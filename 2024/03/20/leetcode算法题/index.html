<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    leetcode算法题 |  
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-leetcode算法题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  leetcode算法题
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2024/03/20/leetcode%E7%AE%97%E6%B3%95%E9%A2%98/" class="article-date">
  <time datetime="2024-03-20T03:06:52.000Z" itemprop="datePublished">2024-03-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">13.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">57 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="leetcode算法题"><a href="#leetcode算法题" class="headerlink" title="leetcode算法题"></a><font color="green">leetcode算法题</font></h1><br>
<br>

<hr>
<a id="more"></a>

<h2 id="1-矩阵"><a href="#1-矩阵" class="headerlink" title="1.矩阵"></a>1.矩阵</h2><h3 id="1-1-54-螺旋矩阵"><a href="#1-1-54-螺旋矩阵" class="headerlink" title="1.1 54.螺旋矩阵"></a>1.1 54.螺旋矩阵</h3><ul>
<li>题目：<br>给定一个包含 m*n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</li>
</ul>
<ul>
<li>思路：<br>设置四个边界，每次遍历完一个方向，就缩小边界，直到边界超过（只是相遇会导致相遇那的元素没有遍历到）。</li>
</ul>
<p>进行循环：<br>1.从左到右，先判断左右边界是否超过，超过则结束，没有超过则从左到右，行为top，走完直到right。然后top++。<br>2.从上到下，先判断上下边界是否超过，超过则结束，没有超过则从上到下，列为right，走完直到bottom。然后right–。<br>3.从右到左，先判断左右边界是否超过，超过则结束，没有超过则从右到左，行为bottom，走完直到left。然后bottom–。<br>4.从下到上，先判断上下边界是否超过，超过则结束，没有超过则从下到上，列为left，走完直到top。然后left++。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> l = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = l - <span class="number">1</span>, top = <span class="number">0</span>, bottom = h - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j &lt;= right; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[top][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">if</span>(top &gt; bottom) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = top; j &lt;= bottom; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[j][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span>(left &gt; right) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = right; j &gt;= left; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[bottom][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            <span class="keyword">if</span>(top &gt; bottom) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = bottom; j &gt;= top; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[j][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-2-289-生命游戏"><a href="#1-2-289-生命游戏" class="headerlink" title="1.2 289.生命游戏"></a>1.2 289.生命游戏</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个包含 m * n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞，或 0 即为 死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<p>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；<br>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；<br>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；<br>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；<br>下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m * n 网格面板 board 的当前状态，返回下一个状态。</p>
<ul>
<li>注意：</li>
</ul>
<ol>
<li>不能普通地边遍历边更新，因为更新会影响后面的判断。</li>
<li>考虑边界问题</li>
</ol>
<ul>
<li>思路：</li>
</ul>
<p>因为不能边遍历边更新(0死1活)，但可以通过新的数来代表状态（2是死变活，3是活变死）。最后再遍历一次，将2变为1，3变为0。</p>
<ol>
<li>遍历每个位置，统计周围活细胞数(考虑边界，考虑变成了2，3的细胞)</li>
<li>通过当前状态和周围活细胞数，判断下一个状态，有变化的位置用2或3表示。</li>
<li>遍历一次，将2变为1，3变为0。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> h,l;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        h = board.size();</span><br><span class="line">        l = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = confirm(board,i,j);</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count &lt; <span class="number">2</span> || count &gt; <span class="number">3</span>) board[i][j] = <span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count==<span class="number">3</span>) board[i][j] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历一次，更新状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">2</span>) board[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">3</span>) board[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计周围活细胞数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">confirm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x=i<span class="number">-1</span>,y=j<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;<span class="number">3</span>;m++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;<span class="number">3</span>;n++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x+m&gt;=<span class="number">0</span> &amp;&amp; x+m&lt;h &amp;&amp; y+n&gt;=<span class="number">0</span> &amp;&amp; y+n&lt;l)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[x+m][y+n]==<span class="number">1</span> || board[x+m][y+n]==<span class="number">3</span>) count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为自己也算进去了，所以判断一下</span></span><br><span class="line">        <span class="keyword">if</span>(board[i][j]==<span class="number">1</span>) count--;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="1-3-48-旋转图像"><a href="#1-3-48-旋转图像" class="headerlink" title="1.3 48.旋转图像"></a>1.3 48.旋转图像</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。且原地旋转。</p>
<ul>
<li>思路：</li>
</ul>
<p>元素翻转后的位置：<br>matrix[i][j] == matrix[j][n-1-i] </p>
<p>可得：<br>matrix[i][j] -&gt; matrix[j][n-1-i] -&gt; matrix[n-1-i][n-1-j] -&gt; matrix[n-1-j][i] -&gt; matrix[i][j]</p>
<ol>
<li>单个位置的旋转。<br>单个位置的旋转，一共会旋转4次，保存一个临时变量，然后依次旋转。</li>
</ol>
<p>考虑要这样旋转几次，因为旋转90度，一次单旋转会改变四个位置的值，因而，只要分别以矩阵左上角1/4的各元素为起始点执行以上旋转操作，即可完整实现矩阵旋转。（n/2）</p>
<p>但当n为奇数时中间不用动，且如果i=n/2,j=n/2的话，会重复旋转，因而只需要让其中一个等于n/2即可。偶数时就不能等于n/2。所以可以用其中一个小于n/2，另一个小于（n+1）/2。（不能是等于n/2，因为偶数时就会重复翻转）</p>
<ol start="2">
<li>水平翻转后，再对角线翻转。</li>
</ol>
<p>数学计算后发现，水平翻转后，再对角线翻转，就是顺时针旋转90度。</p>
<ul>
<li>代码：</li>
</ul>
<ol>
<li><p>单个位置的旋转。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=(n+<span class="number">1</span>)/<span class="number">2</span>;j++)&#123; <span class="comment">//j&lt;=(n+1)/2，保证n为奇数时中间动一次，偶数不用动，且如果i=n/2,j=n/2的话，会重复旋转，因而只需要让其中一个等于n/2即可。偶数时就不能等于n/2</span></span><br><span class="line">                temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n<span class="number">-1</span>-j][i];</span><br><span class="line">                matrix[n<span class="number">-1</span>-j][i] = matrix[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j];</span><br><span class="line">                matrix[n<span class="number">-1</span>-i][n<span class="number">-1</span>-j] = matrix[j][n<span class="number">-1</span>-i];</span><br><span class="line">                matrix[j][n<span class="number">-1</span>-i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>水平翻转后，再对角线翻转。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="comment">// 水平翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="1-4-73-矩阵置零"><a href="#1-4-73-矩阵置零" class="headerlink" title="1.4 73.矩阵置零"></a>1.4 73.矩阵置零</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p>
<ul>
<li>思路：</li>
</ul>
<p>这个题不能用题目2的方法，因为题目2中元素只有0和1，而这个题中元素有多种，所以不能用2和3来表示状态。</p>
<p>将数组的第一行和第一列作为标志位，用来记录该行或该列是否有0。然后遍历数组，如果有0，则将该行和该列的第一个元素置为0。最后再遍历一次数组，元素的行列中如果对应的行标志位或列标志位为0，则将该元素置为0。</p>
<p>但是，第一行和第一列要用来记录标志位，所以要先判断第一行和第一列是否有0，并记录下来。</p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行和第一列中是否有0</span></span><br><span class="line">        <span class="keyword">int</span> flag_col0 = <span class="literal">false</span>, flag_row0 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!matrix[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                flag_col0 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!matrix[<span class="number">0</span>][j]) &#123;</span><br><span class="line">                flag_row0 = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，如果有0，则将该行和该列的第一个元素置为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!matrix[i][j]) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再遍历一次数组，元素的行列中如果对应的行标志位或列标志位（即该行的第一列或该列的第一行）为0，则将该元素置为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!matrix[i][<span class="number">0</span>] || !matrix[<span class="number">0</span>][j]) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后再判断第一行和第一列是否有0，有0则将第一行或列置为0</span></span><br><span class="line">        <span class="keyword">if</span> (flag_col0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag_row0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2.数组"></a>2.数组</h2><h3 id="2-1-704-二分查找"><a href="#2-1-704-二分查找" class="headerlink" title="2.1 704.二分查找"></a>2.1 704.二分查找</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>如：输入：nums = [-1,0,3,5,9,12], target = 9 。 输出：4</p>
<ul>
<li>思路：</li>
</ul>
<p>二分查找，每次取中间值，然后判断中间值和目标值的大小，然后缩小范围。</p>
<p>左闭右闭:创建两个下标left=0和right=mun.size()-1，分别指向数组的第一个元素和最后一个元素。然后不断将中间位置的元素与目标值进行比较，根据比较的结果调整 <code>left = mid+1</code> 和<code>right = mid-1</code> 。</p>
<p>二分查找有易错点：</p>
<ol>
<li>循环条件：left &lt;= right(左闭右闭)还是left &lt; right(左闭右开) </li>
<li>mid的取值：mid = left + (right - left) / 2</li>
<li>判断条件：当target &gt; nums[mid]时，left是mid+1。但当target &lt; nums[mid]时，right是mid-1(左闭右闭)还是mid(左闭右开) 。</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.size()<span class="number">-1</span>; <span class="comment">//左闭右闭</span></span><br><span class="line">        <span class="comment">//int left = 0,right = nums.size(); //左闭右开</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环条件：left &lt;= right(左闭右闭)还是left &lt; right(左闭右开)</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[middle]) right = middle<span class="number">-1</span>; <span class="comment">//right=mid-1(左闭右闭)right=mid(左闭右开)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[middle]) left = middle+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-2-27-移除元素"><a href="#2-2-27-移除元素" class="headerlink" title="2.2 27.移除元素"></a>2.2 27.移除元素</h3><ul>
<li>题目：</li>
</ul>
<p>给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必顫在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>即删除数组中等于val的元素后将数组后面的元素前移，返回新数组的长度。</p>
<ul>
<li>思路：</li>
</ul>
<p>双指针，一个指针用来遍历数组，另一个指针用来记录不等于val的元素。</p>
<ol>
<li>快指针遍历数组</li>
<li>当快指针指向的元素不等于val时，将快指针指向的元素赋值给慢指针指向的元素，然后慢指针+1。（当快指针指向的元素等于val时，慢指针不变，快指针后移，即跳过了val元素）</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> front ,slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(front=<span class="number">0</span>;front &lt;nums.size();front++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(nums[front] == val))&#123; </span><br><span class="line">                nums[slow] = nums[front];</span><br><span class="line">                slow ++; <span class="comment">//当快指针指向的元素不等于val时，将快指针指向的元素赋值给慢指针指向的元素，然后慢指针+1。等于时，慢指针不变，快指针后移，即跳过了val元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2-3-977-有序数组的平方"><a href="#2-3-977-有序数组的平方" class="headerlink" title="2.3 977.有序数组的平方"></a>2.3 977.有序数组的平方</h3><ul>
<li>题目：</li>
</ul>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按 非递减顺序 排序。</p>
<p>如：输入：nums = [-4,-1,0,3,10]。输出：[0,1,9,16,100]</p>
<ul>
<li>思路：</li>
</ul>
<p>因为是平方，所以负数也有可能比正数大，但平方数肯定是从两边最大到中间某个数最小。这样就可以新创一个数组，对原数组用双指针，分别指向两端，然后比较两端的平方大小，大的放在新数组的最后（从小到大），然后大数的指针移动。</p>
<ol>
<li>新建一个数组，用来存放平方后的数。</li>
<li>用双指针，分别指向两端。</li>
<li>比较两端的平方大小，大的放在新数组的最后（从小到大），然后大数的指针移动。</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> k = result.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//p&lt;=q，因为p和q可能会移动到中间,如果p&lt;q，那么p和q会错过中间的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>,q=nums.size()<span class="number">-1</span>;p&lt;=q;)&#123;</span><br><span class="line">            <span class="comment">//p平方大于q的平方,则将p的平方放在result的最后,然后p++</span></span><br><span class="line">            <span class="keyword">if</span>(nums[p]*nums[p] &gt; nums[q]*nums[q])&#123;</span><br><span class="line">                result[k--] = nums[p]*nums[p];</span><br><span class="line">                p++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123; <span class="comment">//p平方小于q的平方,则将q的平方放在result的最后,然后q--</span></span><br><span class="line">                result[k--] = nums[q]*nums[q];</span><br><span class="line">                q--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-209-长度最小的子数组"><a href="#2-4-209-长度最小的子数组" class="headerlink" title="2.4 209.长度最小的子数组"></a>2.4 209.长度最小的子数组</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其和 ≥ target 的长度最小的<strong>连续子数组</strong> [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>如：<br>输入：target = 7, nums = [2,3,1,2,4,3]。输出：2<br>输入：target = 4, nums = [1,4,4]。输出：1</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li><p>暴力解法：遍历数组，i为起始位置，j为结束位置，j内部移动到最后，然后i移动一位直到最后。然后计算i到j的和，如果大于等于target，记录长度，然后找出最小的长度。时间复杂度O(n^2)。</p>
</li>
<li><p>滑动窗口：双指针，i指向起始位置，j指向结束位置。然后<strong>不断移动结束位置</strong>，直到和大于等于target，大于等于后然后判断长度是否是当前最小，是的话保存，然后移动i起始位置，直到和小于target。时间复杂度O(n)。</p>
</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,result=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                <span class="comment">//判断长度是否是当前最小，是的话保存。还要判断result是否为0，为0的话说明是第一次找到大于等于target的长度，要直接赋值</span></span><br><span class="line">                <span class="keyword">if</span>((j-i+<span class="number">1</span>) &lt;result|| !result) result = j-i+<span class="number">1</span>; </span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-5-59-螺旋矩阵II"><a href="#2-5-59-螺旋矩阵II" class="headerlink" title="2.5 59.螺旋矩阵II"></a>2.5 59.螺旋矩阵II</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如：输入：n = 3。输出： [[1,2,3],</span><br><span class="line">                      [8,9,4],</span><br><span class="line">                      [7,6,5]]</span><br></pre></td></tr></table></figure>

<ul>
<li>思路：</li>
</ul>
<p>和螺旋矩阵I一样，设置四个边界，每次遍历完一个方向，就缩小边界，直到边界超过（因为只是相遇的话会导致两个重合的地方的元素没有遍历到。</p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generateMatrix</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">result</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right=n<span class="number">-1</span>, up=<span class="number">0</span>, bottom=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span> result;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++) result[up][i] = node++;</span><br><span class="line">            up++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(up&gt;bottom) <span class="keyword">return</span> result;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=up;i&lt;=bottom;i++) result[i][right] = node++;</span><br><span class="line">            right--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span> result;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right;i&gt;=left;i--) result[bottom][i] = node++;</span><br><span class="line">            bottom--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(up&gt;bottom) <span class="keyword">return</span> result;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom;i&gt;=up;i--) result[i][left] = node++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h2><h3 id="3-1-344-反转字符串"><a href="#3-1-344-反转字符串" class="headerlink" title="3.1 344.反转字符串"></a>3.1 344.反转字符串</h3><ul>
<li>题目：</li>
</ul>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<ul>
<li>思路：</li>
</ul>
<p>双指针，一个指向头，一个指向尾，然后交换两个指针指向的元素。</p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=s.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">char</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            temp= s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-541-反转字符串II"><a href="#3-2-541-反转字符串II" class="headerlink" title="3.2 541.反转字符串II"></a>3.2 541.反转字符串II</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，并将剩余字符保持原样。</p>
<p>如：输入: s = “abcdefg”, k = 2。输出: “bacdfeg”</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>从头开始，i每次移动2k个位置</li>
<li>判断i+k-1是否大于s.size()-1，大于的话，就将i到s.size()-1的字符反转，小于的话，就将i到i+k-1的字符反转。</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseStr</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class="line">            <span class="comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k <span class="number">-1</span>&lt;= s.size()<span class="number">-1</span>) &#123;</span><br><span class="line">                reverse(s.begin() + i, s.begin() + i + k ); <span class="comment">//左闭右开,s.begin() + i + k 指向的是第k个字符的下一个位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span></span><br><span class="line">                reverse(s.begin() + i, s.end());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：reverse函数是左闭右开的，s.end()是指向最后一个元素的下一个位置。</p>
</blockquote>
<h3 id="3-3-151-翻转字符串里的单词"><a href="#3-3-151-翻转字符串里的单词" class="headerlink" title="3.3 151.翻转字符串里的单词"></a>3.3 151.翻转字符串里的单词</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个字符串，逐个翻转字符串中的每个单词。如果有多余的空格，删除。</p>
<p>如：输入：”  the sky is blue  “。输出：”blue is sky the”</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>用双指针，一个指向单词的起始位置，一个指向单词的结束位置。删除多余空格。即遇到空格，就跳过，直到遇到单词，然后将单词放到新的字符串中。（2.2删除元素思路）</li>
<li>翻转整个字符串</li>
<li>star代表一个单词的起始位置。用i遍历字符串，遇到空格就或到达末尾说明遇到了单词并在i在末尾+1（所以for循环中是<code>i &lt;= s.size()</code>）。然后翻转该字符串，并将<code>star = i+1</code>（因为i指向空格，而删除空格函数后只有一个空格，空格后就是下一个单词开始的位置）</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">delet_space</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span>) s[j++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span> (s[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; i &lt; s.size()) s[j++] = s[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.resize(j);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        s = delet_space(s);</span><br><span class="line">        <span class="built_in">std</span>::reverse(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">int</span> star = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>||i==s.size())&#123;</span><br><span class="line">                reverse(s.begin()+star,s.begin()+i);</span><br><span class="line">                star = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4-28-实现strStr"><a href="#3-4-28-实现strStr" class="headerlink" title="3.4 28.实现strStr()"></a>3.4 28.实现strStr()</h3><ul>
<li>题目：</li>
</ul>
<p>实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p>
<p>如：输入: haystack = “hello”, needle = “ll”。输出: 2</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>暴力解法：一个一个进行匹配</li>
<li>KMP算法：通过前缀表，来减少匹配次数。</li>
</ol>
<ul>
<li>KMP算法：</li>
</ul>
<p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong>所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。</p>
<p>简单点来说就是当出现不匹配的字符时，我们要利用已经部分匹配这个有效信息，在已经匹配的字符串中找到尽可能多的相同前缀后缀，然后把要匹配的子字符串的后缀能移动到长字符串已经匹配过字符的前缀(因为后缀和前缀相同的地方可以把前缀移动到后缀的位置处从前后缀不匹配的地方再开始匹配)</p>
<p>kmp实现了遍历的指针不会向后退，而是根据next数组的值来移动，这样就避免了暴力匹配的重复匹配。</p>
<blockquote>
<p>前后缀：前缀是不包括最后一个字符的所有字符，后缀是不包括第一个字符的所有字符。（如abc的前缀是a,ab，后缀是b,bc）<br>前后缀最长公共前后缀：前缀和后缀相同的最长的长度。<br>next数组（前缀表）：next数组是一个数组，存储的是字符串的前缀和后缀的最长公共前后缀的长度。next数组的值是字符串的前缀和后缀的最长公共前后缀的长度，但是是不包括最后一个字符的。</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">needl:a b c a a b c d</span><br><span class="line">next: 0 0 0 1 1 2 3 0</span><br></pre></td></tr></table></figure>
<p>匹配步骤：</p>
<ol>
<li>求出next数组</li>
<li>遍历haystack和needle，当不匹配时，haystack指针不变，needle指针根据next数组移动needle的指针。（这里是next[j-1]，即不匹配字符的前一位的next数组值。也因为j-1，所以判断中要有j&gt;0的判断）</li>
<li>当匹配时，haystack和needle同时后移。直到匹配完成即j==needle.size()，返回i+1-needle.size()。</li>
</ol>
<p><img src="/2024/03/20/leetcode%E7%AE%97%E6%B3%95%E9%A2%98/KMP.gif" alt="kpm"></p>
<ul>
<li>代码：</li>
</ul>
<ol>
<li>求next数组</li>
</ol>
<p>用i和j两个指针，先让next[0] = 0。i从1开始(代表后缀或者说遍历的)，j从0开始(代表前缀，或者说目前匹配了的长度)，</p>
<p>如果needle[i] != needle[j]，则j = next[j-1](因为是j-1所以要判断j&gt;0)，然后再次判断（即让j指向j前面的最大前缀后的一个元素）直到needle[i] == needle[j]或者j==0。如果j==0退出(这一步可以直接跳出循环后赋值)。</p>
<p>如果i,j匹配(next[i] == next[j])，则将j++并让next[i]=j(因为j加1之前是指前缀匹配的最后字符的j也代表了最大公共前后缀的长度，这就是next需要记录的东西)</p>
<p>最后让next[i] = j(因为j此时就是是最大公共前后缀的长度，也是最大公共前缀的最后一个元素的后一位，所以next[i] = j)</p>
<p><img src="/2024/03/20/leetcode%E7%AE%97%E6%B3%95%E9%A2%98/KMP_next.gif" alt="next"></p>
<blockquote>
<p>注：动态图中的数组都整体减了1</p>
</blockquote>
<p>next数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; next,<span class="keyword">const</span> <span class="built_in">string</span>&amp; needle)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>; <span class="comment">//用来记录i元素的最大公共前后缀的长度</span></span><br><span class="line">    next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;needle.size();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(needle[i]!=needle[j]&amp;&amp;j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            j=next[j<span class="number">-1</span>];<span class="comment">//j-1是要回退到的位置，即j-1的前缀的下一个元素（再和i进行比较）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(needle[i]==needle[j])&#123;</span><br><span class="line">           j++; <span class="comment">//比较下一个元素和记录i元素的最大公共前后缀的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>整体代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>; <span class="comment">//一定要初始化</span></span><br><span class="line">        getnext(next,needle);</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;haystack.size();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; needle[j]!=haystack[i])&#123;</span><br><span class="line">                j=next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(needle[j]==haystack[i])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当匹配完成后,j的位置应该在needle的最后一个元素的后一位</span></span><br><span class="line">            <span class="keyword">if</span>(j==needle.size())&#123;</span><br><span class="line">                <span class="keyword">return</span>(i+<span class="number">1</span>-needle.size());<span class="comment">//因为i是从0开始的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; next,<span class="keyword">const</span> <span class="built_in">string</span>&amp; needle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>; <span class="comment">//用来记录i元素的最大公共前后缀的长度</span></span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;needle.size();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(needle[i]!=needle[j]&amp;&amp;j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                j=next[j<span class="number">-1</span>];<span class="comment">//j-1是要回退到的位置，即j-1的前缀的下一个元素（再和i进行比较）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(needle[i]==needle[j])&#123;</span><br><span class="line">               j++; <span class="comment">//比较下一个元素和记录i元素的最大公共前后缀的长度</span></span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-459-重复的子字符串"><a href="#3-5-459-重复的子字符串" class="headerlink" title="3.5 459.重复的子字符串"></a>3.5 459.重复的子字符串</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p>如：输入: “abab”。输出: True</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li><p>暴力解法：就是一个for循环获取 子串的终止位置， 然后判断子串是否能重复构成字符串，又嵌套一个for循环，所以是O(n^2)的时间复杂度。</p>
</li>
<li><p>移动匹配：如果当一个字符串s：abcabc，内部由重复的子串组成，那么s+s：abcabcabcabc，的子串中也一定包含了s，所以s+s中去掉首尾两个字符，如果s在s+s中，那么s一定是由重复的子串组成的。</p>
</li>
<li><p>kmp算法：在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里拿字符串s：abababab 来举例，最长前后缀是abab，不包含的子串是ab，所以abababab中最小重复子串是ab。</p>
</li>
</ol>
<p>为什么呢：设s:abababab首先得保证s是由重复子串组成的，那么s的最长前缀或者后缀（abab）一定缺少了最小重复子串(ab)，又因为通过推算可以得到s[0]s[1] == s[2]s[3],s[2]s[3] == s[4]s[5]，所以s[0]s[1] == s[4]s[5]，所以s是由重复子串组成的。 </p>
<blockquote>
<p>推算：步骤一：因为 这是相等的前缀和后缀，t[0] 与 k[0]相同， t[1] 与 k[1]相同，所以 s[0] 一定和 s[2]相同，s[1] 一定和 s[3]相同，即：，s[0]s[1]与s[2]s[3]相同 。<br>步骤二： 因为在同一个字符串位置，所以 t[2] 与 k[0]相同，t[3] 与 k[1]相同。<br>步骤三： 因为 这是相等的前缀和后缀，t[2] 与 k[2]相同 ，t[3]与k[3] 相同，所以，s[2]一定和s[4]相同，s[3]一定和s[5]相同，即：s[2]s[3] 与 s[4]s[5]相同。<br>步骤四：循环往复。<br>所以字符串s，s[0]s[1]与s[2]s[3]相同， s[2]s[3] 与 s[4]s[5]相同，s[4]s[5] 与 s[6]s[7] 相同。<br>正是因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串</p>
</blockquote>
<p><img src="/2024/03/20/leetcode%E7%AE%97%E6%B3%95%E9%A2%98/small_str.png" alt="最小重复字串"></p>
<p>所以，我们可以通过kmp算法求出next，next的倒数第二位就是最长相等前后缀的长度，让字符串长度减去最长相等前后缀的长度，就是最小重复子串的长度，如果最小重复子串的长度能被整除，那么就是由重复子串组成的。</p>
<ul>
<li>代码：</li>
</ul>
<ol>
<li>移动匹配</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s2 = s+s;</span><br><span class="line">        s2.erase(s2.begin()); s2.erase(s2.end() - <span class="number">1</span>); <span class="comment">// 掐头去尾</span></span><br><span class="line">        <span class="keyword">if</span>(s2.find(s) != <span class="built_in">string</span>::npos) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 查找s是否在s2中，该过程与kmp算法类似</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>kmp算法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">int</span> next[len];</span><br><span class="line">        getnext(s,next);</span><br><span class="line">        <span class="keyword">if</span>(next[len<span class="number">-1</span>] != <span class="number">0</span> &amp;&amp; len%(len-next[len<span class="number">-1</span>])==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//next[len-1] != 0 说明有最长相等前后缀，len%(len-next[len-1])==0 说明能被整除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">int</span> *next)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!=s[j]) j=next[j<span class="number">-1</span>]; <span class="comment">//j-1是要回退到的位置，即j-1的前缀的下一个元素（再和i进行比较）</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j]) j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="4-链表"><a href="#4-链表" class="headerlink" title="4.链表"></a>4.链表</h2><h3 id="4-1-203-移除链表元素"><a href="#4-1-203-移除链表元素" class="headerlink" title="4.1 203.移除链表元素"></a>4.1 203.移除链表元素</h3><ul>
<li>题目：</li>
</ul>
<p>删除链表中等于给定值 val 的所有节点。</p>
<p>如：输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6。输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<ul>
<li>思路：</li>
</ul>
<p>无头节点：</p>
<ol>
<li>判断头节点是否等于val，等于的话，删除头节点，然后头节点指向下一个节点。（循环判断，可能头节点后面还有val）</li>
<li>判断当前节点的下一个节点是否等于val，等于的话，删除下一个节点，然后当前节点的下一个节点指向下下个节点。</li>
</ol>
<p>有头节点：</p>
<ol>
<li>有头节点的话，就不用判断头节点是否等于val，直接从头节点的下一个节点开始判断。（用完后记得返回头节点-&gt;next并删除头节点）</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<p>无头节点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//删除头节点</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span> &amp;&amp; head-&gt;val == val)&#123; <span class="comment">//注意这里是循环判断，可能头节点后面还有val</span></span><br><span class="line">            ListNode *temp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> (temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除非头节点</span></span><br><span class="line">        ListNode *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;next != <span class="literal">NULL</span>)&#123; <span class="comment">//p-&gt;next != NULL，因为可能p=head时head==NULL</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val == val)&#123;</span><br><span class="line">                ListNode *temp = p-&gt;next;</span><br><span class="line">                p-&gt;next = temp-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span>(temp);</span><br><span class="line">            &#125;<span class="keyword">else</span> p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-2-206-反转链表"><a href="#4-2-206-反转链表" class="headerlink" title="4.2 206.反转链表"></a>4.2 206.反转链表</h3><ul>
<li>题目：</li>
</ul>
<p>反转一个单链表。</p>
<p>如：输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL。输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>迭代：用三个指针，一个指向当前节点（cur），一个指向当前节点的前一个节点(pr)，一个指向当前节点的下一个节点(temp)。然后将当前节点的next指向前一个节点(pr)，然后三个指针都后移。</li>
<li>递归：和迭代思路一样，当递归到最后一个节点时（即cur==NULL），返回pr。</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<p>迭代：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pr=<span class="literal">NULL</span>,*temp;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            temp = head-&gt;next; <span class="comment">//保存下一个节点</span></span><br><span class="line">            head-&gt;next = pr; <span class="comment">//当前节点的next指向前一个节点</span></span><br><span class="line">            pr = head; <span class="comment">//pr和head都后移</span></span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>递归：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre,ListNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        ListNode* temp = cur-&gt;next; <span class="comment">//保存下一个节点</span></span><br><span class="line">        cur-&gt;next = pre; <span class="comment">//当前节点的next指向前一个节点</span></span><br><span class="line">        <span class="comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span></span><br><span class="line">        <span class="comment">// pre = cur;</span></span><br><span class="line">        <span class="comment">// cur = temp;</span></span><br><span class="line">        <span class="keyword">return</span> reverse(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 和双指针法初始化是一样的逻辑</span></span><br><span class="line">        <span class="comment">// ListNode* cur = head;</span></span><br><span class="line">        <span class="comment">// ListNode* pre = NULL;</span></span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">NULL</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-3-24-两两交换链表中的节点"><a href="#4-3-24-两两交换链表中的节点" class="headerlink" title="4.3 24.两两交换链表中的节点"></a>4.3 24.两两交换链表中的节点</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>如：输入：1-&gt;2-&gt;3-&gt;4。输出：2-&gt;1-&gt;4-&gt;3</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>创建一个虚拟头节点dummyhead，然后将虚拟头节点指向head，再创建cur指针指向dummyhead</li>
<li>判断cur的下一个节点和下下个节点是否为空，不为空的话。先用保存temp保存cur-&gt;next,然后cur-&gt;next指向cur-&gt;next-&gt;next，temp-&gt;next指向cur-&gt;next-&gt;next,cur-&gt;next-&gt;next指向temp。<br>(比如cur-&gt;1-&gt;2-&gt;3,temp指向1，cur(cur-&gt;next)-&gt;2(cur-&gt;next-&gt;next)，1(temp)-&gt;3(cur-&gt;next-&gt;next)，2(cur-&gt;next)-&gt;1)</li>
</ol>
<p><img src="/2024/03/20/leetcode%E7%AE%97%E6%B3%95%E9%A2%98/24_1.png" alt="24"></p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyhead -&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>&amp;&amp;cur-&gt;next-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            temp-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = temp;</span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-4-19-删除链表的倒数第N个节点"><a href="#4-4-19-删除链表的倒数第N个节点" class="headerlink" title="4.4 19.删除链表的倒数第N个节点"></a>4.4 19.删除链表的倒数第N个节点</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>如：输入：head = [1,2,3,4,5], n = 2。输出：[1,2,3,5]</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>双指针:创建一个虚拟头，再创建两个指针，一个指针先走n+1步（即两个指针中间要间隔n个元素），然后两个指针一起走，当快指针走到末尾（NULL）时，慢指针就是倒数第n个节点的前一个节点。然后删除慢指针的下一个节点。</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummyhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next = head;</span><br><span class="line">        ListNode* fast = dummyhead,*slow=dummyhead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast!=<span class="literal">NULL</span>) fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* temp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-02-07-链表相交"><a href="#4-5-02-07-链表相交" class="headerlink" title="4.5 02.07.链表相交"></a>4.5 02.07.链表相交</h3><ul>
<li>题目：</li>
</ul>
<p>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。</p>
<p>如：输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3。输出：Reference of the node with value = 8（即A中的8和B中的8是同一个节点的地址）</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>两个链表右对齐：先遍历两个链表，得到两个链表的长度，然后让长的链表先走两个链表长度的差值，然后两个链表一起走，当两个节点相等时，就是相交的节点。</li>
</ol>
<p><img src="/2024/03/20/leetcode%E7%AE%97%E6%B3%95%E9%A2%98/02.07.png" alt="02.07"></p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算两个链表的长度</span></span><br><span class="line">        <span class="keyword">int</span> lenA=<span class="number">0</span>,lenB=<span class="number">0</span>;</span><br><span class="line">        ListNode *curA=headA,*curB=headB;</span><br><span class="line">        <span class="keyword">while</span>(curA!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(curB!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//让lenA代表长的链表</span></span><br><span class="line">        <span class="keyword">if</span>(lenB&gt;lenA)&#123;</span><br><span class="line">            swap(lenA,lenB);</span><br><span class="line">            swap (curA,curB);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> gap = lenA-lenB;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//让长的链表先走两个链表长度的差值</span></span><br><span class="line">        <span class="keyword">while</span>(gap--) curA = curA-&gt;next; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curA!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA == curB) <span class="keyword">return</span> curA; <span class="comment">//注意是判断地址是否相等</span></span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-6-142-环形链表II"><a href="#4-6-142-环形链表II" class="headerlink" title="4.6 142.环形链表II"></a>4.6 142.环形链表II</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如：输入：head = [3,2,0,-4], pos = 1（即-4后面指向了2）。输出：返回索引为 1 的链表节点。解释：链表中有一个环，其尾部连接到第二个节点。</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>哈希表：遍历链表，将节点存入哈希表，如果遇到重复的节点，说明有环，返回该节点。</li>
<li>快慢指针：快指针一次走两步，慢指针一次走一步，当快指针追上慢指针时，说明有环。然后让快指针指向头节点，然后快慢指针一起走，当两个指针相遇时，就是环的入口。</li>
</ol>
<blockquote>
<ul>
<li>链表是否有环:fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。</li>
<li>如何找到这个环的入口:假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。那么相遇时： slow指针走过的节点数为:<code> x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数。整理一下得<code>x = z + (n - 1) (y + z) </code>。这个公式的意思是：从头结点到环形入口节点的距离 = 从相遇节点到环形入口节点的距离 + n-1圈的环的长度。所以，当fast指针与slow指针相遇时，让fast指针指向头节点，然后fast指针和slow指针一起走(此时速度一样)，当两个指针相遇时，就是环的入口。</li>
</ul>
</blockquote>
<p><img src="/2024/03/20/leetcode%E7%AE%97%E6%B3%95%E9%A2%98/142_1.png" alt="142_1"></p>
<ul>
<li>代码：</li>
</ul>
<ol>
<li>哈希表：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode *&gt; inset;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inset.find(head)!=<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">            inset.insert(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>快慢指针：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123; <span class="comment">//因为fast指针一次走两步，所以要判断fast和fast-&gt;next</span></span><br><span class="line">            slow = slow-&gt;next; <span class="comment">// 慢指针一次走一步</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next; <span class="comment">// 快指针一次走两步</span></span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123; <span class="comment">// 都一次走一步</span></span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="5-栈和队列"><a href="#5-栈和队列" class="headerlink" title="5.栈和队列"></a>5.栈和队列</h2><h3 id="5-1-232-用栈实现队列"><a href="#5-1-232-用栈实现队列" class="headerlink" title="5.1 232.用栈实现队列"></a>5.1 232.用栈实现队列</h3><ul>
<li>题目：</li>
</ul>
<p>使用两个栈实现队列的下列操作：</p>
<p>void push(int x) 将一个元素放入队列的尾部。<br>int pop() 从队列的头部移除并返回元素。<br>int peek() 返回队列头部的元素。<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false。</p>
<blockquote>
<p>注：stack.pop()是删除栈顶元素（没有返回），stack.top()是返回栈顶元素(返回不会删除)</p>
</blockquote>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>创建两个栈：一个栈（st1）用来存放元素，一个栈(st2)用来输出元素</li>
<li>push时，将元素放入栈st1</li>
<li>pop时，判断栈st2是否为空，为空的话，将栈st1的元素全部放入栈st2，再次判断st2是否为空，然后输出栈st2的栈顶元素</li>
<li>peek时，和pop一样，只是不删除栈顶元素</li>
<li>empty时，判断两个栈是否都为空</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; *st1,*st2;</span><br><span class="line">    MyQueue():st1(<span class="keyword">new</span> <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;),st2(<span class="keyword">new</span> <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st1-&gt;push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出元素时必须得让st2中的元素全部出栈再把st1中的元素放入st2中。不然会出现顺序错误</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st2-&gt;empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st1-&gt;empty()) &#123; <span class="comment">//将st1中的元素全部放入st2中</span></span><br><span class="line">                st2-&gt;push(st1-&gt;top());</span><br><span class="line">                st1-&gt;pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st2-&gt;empty()) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//再次判断st2是否为空</span></span><br><span class="line">        <span class="keyword">int</span> temp = st2-&gt;top(); <span class="comment">//先返回栈顶元素</span></span><br><span class="line">        st2-&gt;pop();<span class="comment">//再删除栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st2-&gt;empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st1-&gt;empty()) &#123;</span><br><span class="line">                st2-&gt;push(st1-&gt;top());</span><br><span class="line">                st1-&gt;pop();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st2-&gt;empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> st2-&gt;top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st1-&gt;empty() &amp;&amp; st2-&gt;empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-2-225-用队列实现栈"><a href="#5-2-225-用队列实现栈" class="headerlink" title="5.2 225.用队列实现栈"></a>5.2 225.用队列实现栈</h3><ul>
<li>题目：</li>
</ul>
<p>使用两个队列实现栈的下列操作：</p>
<p>void push(int x) 将一个元素放入栈顶。<br>int pop() 移除栈顶元素并返回这个元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false。</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>创建两个队列：一个队列（q1）用来存放元素，一个队列(q2)用来辅助输出</li>
<li>push时，将元素放入队列q1</li>
<li>pop时，将队列q1的元素放入队列q2，直到q1中只剩下一个元素，然后输出该元素，再将q2中的元素放入q1</li>
<li>top时，和pop一样，只是不删除栈顶元素</li>
</ol>
<blockquote>
<p>注：queue.front()是返回队列头部元素(不删除)，queue.pop()是删除队列头部元素（没返回）</p>
</blockquote>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;* qe1;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;* qe2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyStack():qe1(<span class="keyword">new</span> <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;),qe2(<span class="keyword">new</span> <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        qe1-&gt;push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(qe1-&gt;empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = qe1-&gt;size()<span class="number">-1</span>; <span class="comment">//这里特别注意不能把size()放在for循环中，因为size()在循环中是动态变化的，并且qe1要留一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">            qe2-&gt;push(qe1-&gt;front());</span><br><span class="line">            qe1-&gt;pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = qe1-&gt;front();</span><br><span class="line">        qe1-&gt;pop();</span><br><span class="line">        <span class="keyword">int</span> len2 = qe2-&gt;size(); <span class="comment">//这里也是一样</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++)&#123;</span><br><span class="line">            qe1-&gt;push(qe2-&gt;front());</span><br><span class="line">            qe2-&gt;pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(qe1-&gt;empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = qe1-&gt;size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">            qe2-&gt;push(qe1-&gt;front());</span><br><span class="line">            qe1-&gt;pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = qe1-&gt;front();</span><br><span class="line">        qe2-&gt;push(qe1-&gt;front()); <span class="comment">//查看了栈顶元素后也要将其放入qe2中，不然会出现顺序错误</span></span><br><span class="line">        qe1-&gt;pop();</span><br><span class="line">        <span class="keyword">int</span> len2 = qe2-&gt;size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++)&#123;</span><br><span class="line">            qe1-&gt;push(qe2-&gt;front());</span><br><span class="line">            qe2-&gt;pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qe1-&gt;empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-3-20-有效的括号"><a href="#5-3-20-有效的括号" class="headerlink" title="5.3 20.有效的括号"></a>5.3 20.有效的括号</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>如：输入: “()[]”。输出: true. 输入: “()[]{}}”. 输出: false,输入: “(({[]}”. 输出: false</p>
<ul>
<li>思路：</li>
</ul>
<p>用栈遍历字符串，遇到左括号就入栈一个右括号，遇到左花括号就入栈一个右花括号，遇到左中括号就入栈一个右中括号，没遇到左括号时就开始判断栈顶元素是否和当前元素相等（<strong>同时也要判断栈是否为空防止左括号少于右括号的情况</strong>），相等就出栈，不相等就返回false。</p>
<ol>
<li>右括号过多（即栈中元素过少）</li>
<li>左括号过多（即栈中元素过多）</li>
<li>匹配不上（栈顶元素不等于右边符号）</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()%<span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果是奇数个括号，直接返回false</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st; <span class="comment">//栈上分配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) st.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;[&#x27;</span>) st.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st.empty()||s[i] != st.top()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈为空(左边符号过少)或者栈顶元素不等于右边符号</span></span><br><span class="line">            <span class="keyword">else</span> st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.empty(); <span class="comment">//栈为空(左边符号过多)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-4-1047-删除字符串中的所有相邻重复项"><a href="#5-4-1047-删除字符串中的所有相邻重复项" class="headerlink" title="5.4 1047.删除字符串中的所有相邻重复项"></a>5.4 1047.删除字符串中的所有相邻重复项</h3><ul>
<li>题目：</li>
</ul>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>如：输入：”abbaca”。输出：”ca”</p>
<ul>
<li>思路：</li>
</ul>
<p>用栈遍历字符串，当栈不为空且栈顶元素等于当前元素时，出栈，否则入栈。</p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.empty()&amp;&amp;st.top() == s[i])&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将栈中元素放入result中</span></span><br><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">            result +=st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为栈是先进后出，所以要反转</span></span><br><span class="line">        reverse(result.begin(),result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-5-150-逆波兰表达式求值"><a href="#5-5-150-逆波兰表达式求值" class="headerlink" title="5.5 150.逆波兰表达式求值"></a>5.5 150.逆波兰表达式求值</h3><ul>
<li>题目：</li>
</ul>
<p>根据 逆波兰表示法，求表达式的值。</p>
<p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>如：输入: [“2”, “1”, “+”, “3”, “*”]。输出: 9 。 解释: ((2 + 1) * 3) = 9</p>
<ul>
<li>思路：</li>
</ul>
<p>用栈遍历字符串，遇到数字就入栈，遇到运算符就出栈两个元素进行运算，然后将结果入栈。</p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 力扣修改了后台测试数据，需要用longlong</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; st; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//遇到运算符就出栈两个元素进行运算</span></span><br><span class="line">            <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> num1 = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> num2 = st.top();</span><br><span class="line">                st.pop();</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span>) st.push(num2 + num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;-&quot;</span>) st.push(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;*&quot;</span>) st.push(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;/&quot;</span>) st.push(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//遇到数字就入栈,stoi是将字符串转换为长整数</span></span><br><span class="line">                st.push(stoll(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = st.top();</span><br><span class="line">        st.pop(); <span class="comment">// 把栈里最后一个元素弹出（其实不弹出也没事）</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-6-239-滑动窗口最大值"><a href="#5-6-239-滑动窗口最大值" class="headerlink" title="5.6 239.滑动窗口最大值"></a>5.6 239.滑动窗口最大值</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<p>如：输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3。输出: [3,3,5,5,6,7]</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>用双端队列deque实现一个单调队列que，队列最左边是最大值，且单调递减</li>
</ol>
<p>单调队列的实现：</p>
<p>void pop(int value): 如果value等于队列最左边的值(此时这是原数组中最左边的要出窗口的值value是否是que的最左边的值，如果是说明原数组中该数要被弹出了)，就弹出队列最左边的值</p>
<p>void push(int value): 如果要入队列的value大于队列最右边的值，就弹出队列最右边的值，直到value小于队列最右边的值（或者队列为空），然后将value放入队列</p>
<p>int front(): 返回队列最左边的值</p>
<ol start="2">
<li>先将前k个元素放入队列，然后从第k个元素开始遍历，每次将窗口最左边的元素弹出（但只有数相等时才会实际弹出），然后将当前元素放入队列，然后将队列最左边的元素放入结果数组中。</li>
</ol>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">滑动窗口的位置                       最大值             队列</span><br><span class="line">[1  3  -1] -3  5  3  6  7           3               [3,-1]      下一次时，因为nums[3-3] ！= que.front()，所以没有弹出</span><br><span class="line">1 [3  -1  -3] 5  3  6  7            3               [3,-1,-3]   下一次时，因为nums[4-3] = que.front()，所以要弹出3</span><br><span class="line">1  3 [-1  -3  5] 3  6  7            5               [5]         (5和-3比较，把-3弹出，再和-1比较，把1弹出)</span><br><span class="line">1  3  -1 [-3  5  3] 6  7            5               [5,3]</span><br><span class="line">1  3  -1  -3 [5  3  6] 7            6               [6]</span><br><span class="line">1  3  -1  -3  5 [3  6  7]           7               [7]</span><br></pre></td></tr></table></figure>

<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span> <span class="comment">//单调队列（从大到小）</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">        <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">        <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!que.empty() &amp;&amp; value == que.front()) &#123;</span><br><span class="line">                que.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">        <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.empty() &amp;&amp; value &gt; que.back()) &#123;</span><br><span class="line">                que.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            que.push_back(value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.front();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123; <span class="comment">// 先将前k的元素放进队列</span></span><br><span class="line">            que.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(que.front()); <span class="comment">// result 记录前k的元素的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            que.pop(nums[i - k]); <span class="comment">// 滑动窗口移除最前面元素</span></span><br><span class="line">            que.push(nums[i]); <span class="comment">// 滑动窗口前加入最后面的元素</span></span><br><span class="line">            result.push_back(que.front()); <span class="comment">// 记录对应的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-7-347-前-K-个高频元素"><a href="#5-7-347-前-K-个高频元素" class="headerlink" title="5.7 347.前 K 个高频元素"></a>5.7 347.前 K 个高频元素</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p>
<p>如：输入: nums = [1,1,1,2,2,3], k = 2。输出: [1,2]</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>用哈希表记录每个元素出现的次数，用优先队列（最小堆）记录前k个高频元素(用小根堆的原因是，当堆的元素个数大于k时，弹出堆顶元素，用小根堆的话，堆顶元素是最小的，弹出后，堆中的元素仍然是前k个高频元素)</li>
<li>遍历哈希表，将元素放入优先队列，当优先队列的元素个数大于k时，将队列的最小元素弹出</li>
</ol>
<ul>
<li>知识</li>
</ul>
<ol>
<li>unordered_map：用来记录元素出现的次数,其底层实现是哈希表，查找时间复杂度是O(1)</li>
<li>priority_queue：优先队列，底层实现是堆，默认是最大堆，这里用的模板是<code>priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,mycomparison&gt;</code>，<strong>表示由pair中的第二个值的最小堆</strong>，pair&lt;int,int&gt;表示元素和出现次数，vector&lt;pair&lt;int,int&gt;&gt;表示存放元素和出现次数的容器，mycomparsion表示比较函数，这里是自定义的比较函数，用来比较pair中的第二个值。</li>
<li>pair：pair&lt;int,int&gt;是一个模板类，用来存放多个不同数据(这里用的int,int)，这里用来存放元素和出现次数</li>
<li>()运算符重载：重载()运算符，使得mycomparison对象可以像函数一样调用，这里是用来比较pair中的第二个值的大小。</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于比较pair中的第二个值的大小</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">mycomparison</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载()运算符，使得mycomparison对象可以像函数一样调用</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要统计元素出现频率</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>; <span class="comment">// map&lt;nums[i],对应出现的次数&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对频率排序</span></span><br><span class="line">        <span class="comment">// 用优先队列定义一个小顶堆（比较方式用自定义的mycomparison），大小为k</span></span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = <span class="built_in">map</span>.begin(); it != <span class="built_in">map</span>.end(); it++) &#123;</span><br><span class="line">            pri_que.push(*it);</span><br><span class="line">            <span class="keyword">if</span> (pri_que.size() &gt; k) &#123; <span class="comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">                pri_que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建保存结果的数组，找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = pri_que.top().first;</span><br><span class="line">            pri_que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-8-226-翻转二叉树"><a href="#5-8-226-翻转二叉树" class="headerlink" title="5.8 226.翻转二叉树"></a>5.8 226.翻转二叉树</h3><ul>
<li>题目：</li>
</ul>
<p>翻转一棵二叉树，即交换每个节点的左右子树。</p>
<p>如：输入：[4,2,7,1,3,6,9]。输出：[4,7,2,9,6,3,1]</p>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>递归：交换左右子树，然后递归左右子树</li>
<li>迭代：用队列，将根节点放入队列，然后遍历队列，每次取出队列的节点，交换左右子树，然后将左右子树放入队列</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);  <span class="comment">// 中</span></span><br><span class="line">        invertTree(root-&gt;left);         <span class="comment">// 左</span></span><br><span class="line">        invertTree(root-&gt;right);        <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">            TreeNode* node = st.top();              <span class="comment">// 中</span></span><br><span class="line">            st.pop();</span><br><span class="line">            swap(node-&gt;left, node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.push(node-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.push(node-&gt;left);     <span class="comment">// 左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-9-101-对称二叉树"><a href="#5-9-101-对称二叉树" class="headerlink" title="5.9 101.对称二叉树"></a>5.9 101.对称二叉树</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>如：输入：[1,2,2,3,4,4,3]。输出：true</p>
<ul>
<li>思路：</li>
</ul>
<p>由最小的单位看起，判断两个左右子树是否对称，首先左子树的左节点和右子树的右节点是否相等，然后左子树的右节点和右子树的左节点是否相等。(左右根，后序)</p>
<p>如果都相等，再递归判断左子树的左节点和右子树的右节点他们的左右子节点，左子树的右节点和右子树的左节点他们的左右子节点。</p>
<p>如果都相等，返回true，否则返回false。</p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">// 此时才做递归，做下一层的判断</span></span><br><span class="line">        <span class="keyword">bool</span> outside = compare(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line">        <span class="keyword">bool</span> inside = compare(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line">        <span class="keyword">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">        <span class="keyword">return</span> isSame;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-10-110-平衡二叉树"><a href="#5-10-110-平衡二叉树" class="headerlink" title="5.10 110.平衡二叉树"></a>5.10 110.平衡二叉树</h3><ul>
<li>题目：</li>
</ul>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。平衡二叉树的定义是：二叉树的每个节点的左右两个子树的高度差的绝对值不超过1。</p>
<p>如：输入：[3,9,20,null,null,15,7]。输出：true</p>
<ul>
<li>思路：</li>
</ul>
<p>当要求解高度时，一般是要让父节点知道字节点的高度，+1然后返回给父节点的父节点。<strong>所以父节点需要知道左右字节点的信息，即要先遍历左右子节点来获取信息，这里就要用到后序遍历（左右中）</strong></p>
<ol>
<li>当节点为空时，返回0（空节点高度为0）</li>
<li>获取左子树的高度，如果左子树高度为-1，说明不是平衡二叉树，返回-1。同理再获取右子树</li>
<li>如果左右子树的高度差的绝对值大于1，返回-1，否则返回左右子树的最大高度+1</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<pre><code class="c++">class Solution &#123;
public:
    // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
    int getHeight(TreeNode* node) &#123;
        if (node == NULL) &#123;
            return 0;
        &#125;
        int leftHeight = getHeight(node-&gt;left);
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(node-&gt;right);
        if (rightHeight == -1) return -1;
        return abs(leftHeight - rightHeight) &gt; 1 ? -1 : 1 + max(leftHeight, rightHeight);
    &#125;
    bool isBalanced(TreeNode* root) &#123;
        return getHeight(root) == -1 ? false : true;
    &#125;
&#125;;</code></pre>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://oyama-mahiro.github.io/2024/03/20/leetcode%E7%AE%97%E6%B3%95%E9%A2%98/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2024/03/13/C-%E5%A4%8D%E4%B9%A0-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">C++复习-基础部分</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "tuYk4qAcyDHqUmYKwnOzB9nI-9Nh9j0Va",
    app_key: "EuYRm7WE36kxYD3nnGAQBK5y",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2024
        <i class="ri-heart-fill heart_icon"></i> nakano-mahiro
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.jpg" alt=""></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">文章</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechatpay.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->


    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
    


<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1975315159&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>