<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言基础-存储类别</title>
    <url>/2020/05/09/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB/</url>
    <content><![CDATA[<h1 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a><font color="green">存储类别</font></h1><p>在理解存储类别前，先要复习一些概念和术语。</p>
<ul>
<li>对象：对于储存在内存中的数据，被储存的每个值都占用一定的物理内存。这样的一块内存成为对象(和面向对象的对象概念不同)</li>
<li>存储期：对象在内存中保留了多长的时间。</li>
<li>标识符用于访问对象，可以用<strong>作用域</strong>和<strong>链接</strong>描述标识符，表明了程序的哪些部分可以使用它。</li>
</ul>
<p>我们先介绍`作用域、链接和储存期的含义，再介绍具体的存储类别</p>
<a id="more"></a>

<h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h2><p>作用域描述程序中可访问标识符的区域。<br>一个C变量的作用域可以是:</p>
<ul>
<li>块作用域：花括号内的代码，if语句或循环所控制的代码</li>
<li>函数作用域：仅用于goto语句的标签。再块中定义但作用域是整个函数</li>
<li>函数原型作用域：从形参定义处到原型声明结束</li>
<li>文件作用域：定义在函数外面，从它的定义到该定义所在的文件的末尾均可见</li>
</ul>
<blockquote>
<p>注意：当一个源代码中包含一个或多个头文件时，会把所有头文件和编译器源代码文件都看成是一个包含信息的单独文件，文件作用域的实际可见范围是整个翻译单元</p>
</blockquote>
<h2 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h2><p>链接指该变量访问范围<br>C变量有3种链接属性：<strong>外部链接，内部链接或无链接</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;具有块作用域、函数作用域和函数原型作用域的变量都是无链接变量<br>&nbsp;&nbsp;&nbsp;&nbsp;文件作用域的变量可以是外部链接和内部链接，<br>&nbsp;&nbsp;&nbsp;&nbsp;内部链接变量比外部链接变量前面多了个static ，内部链接变量只能在翻译单元中使用，外部链接变量可以在多文件程序中使用</p>
<h2 id="3-存储期"><a href="#3-存储期" class="headerlink" title="3.存储期"></a>3.存储期</h2><p>作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。<br>C对象有4种存储期：</p>
<ol>
<li>静态存储期：关键字static，如果对象具有静态储存期，那么它在程序的执行期间一直存在   <font color="red">注意：文件作用域变量都具有静态存储期，但它的static表示的是其链接属性</font></li>
<li>线程存储期: _Thread_local</li>
<li>自动存储期: 通常是块作用域的变量所具有</li>
<li>动态分配存储期： 从声明处到块末尾而不是块头到末尾</li>
</ol>
<h2 id="5种存储类别"><a href="#5种存储类别" class="headerlink" title="5种存储类别"></a>5种存储类别</h2><table>
<thead>
<tr>
<th>存储类别</th>
<th>存储期</th>
<th>作用域</th>
<th>链接</th>
<th>声明方式</th>
</tr>
</thead>
<tbody><tr>
<td>自动(局部变量)</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内</td>
</tr>
<tr>
<td>寄存器</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内，使用关键字<code>register</code></td>
</tr>
<tr>
<td>静态外部链接(全局变量)</td>
<td>静态</td>
<td>文件</td>
<td>外部</td>
<td>所有函数外</td>
</tr>
<tr>
<td>静态内部链接(static全局变量)</td>
<td>静态</td>
<td>文件</td>
<td>内部</td>
<td>所有函数外，翻译单元中，使用关键字<code>static</code></td>
</tr>
<tr>
<td>静态无链接(静态局部变量)</td>
<td>静态</td>
<td>块</td>
<td>无</td>
<td>块内，使用关键字<code>static</code></td>
</tr>
</tbody></table>
<ul>
<li>如果内层块种声明的变量和外层块的变量同名时，优先内层块的变量</li>
<li>寄存器变量储存在寄存器中，所以无法获取其地址</li>
<li>局部静态变量在程序的执行时间一直存在但只能在块内部使用，其值有继承性（就像Java里面的成员变量）</li>
<li>要在外部使用全局变量或在块中使用全局变量或static全局变量。也必须先声明，而且声明前面要加关键字extern</li>
<li>局部变量和静态局部变量在本文件中只能在声明后使用</li>
</ul>
<h3 id="存储类别的初始化"><a href="#存储类别的初始化" class="headerlink" title="存储类别的初始化"></a>存储类别的初始化</h3><ul>
<li>局部变量不会初始化，但其变量值是分配空间范围中的任意值</li>
<li>静态变量如未人为初始化，则自动初始化为0</li>
</ul>
<h3 id="存储类别说明符"><a href="#存储类别说明符" class="headerlink" title="存储类别说明符"></a>存储类别说明符</h3><ul>
<li>auto:声明局部变量，可忽略</li>
<li>register:声明寄存器变量</li>
<li>static:声明静态类型</li>
<li>extern:  声明时调用（全局/static全局） 变量</li>
<li>_Thread_local：声明线程存储期，可以和 static或extern一起使用</li>
</ul>
<hr>
<br>

<h2 id="存储类别与函数"><a href="#存储类别与函数" class="headerlink" title="存储类别与函数"></a>存储类别与函数</h2><p>函数也有存储类别。</p>
<ul>
<li>外部函数<blockquote>
<p>double a(int i)</p>
</blockquote>
</li>
<li>静态函数<blockquote>
<p>static double a(int i)</p>
</blockquote>
</li>
<li>内联函数<blockquote>
<p>extern double a(int i)</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>c</tag>
        <tag>基础</tag>
        <tag>存储类别</tag>
      </tags>
  </entry>
  <entry>
    <title>day11-c数组与指针</title>
    <url>/2023/03/08/day11-c%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="day11-c数组与指针"><a href="#day11-c数组与指针" class="headerlink" title="day11-c数组与指针"></a><font color="green">day11-c数组与指针</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><p>​    字符数组和字符串</p>
<p>​        字符数组：存放的数据是字符数据</p>
<p>​        字符串：由一个或者多个字符组成，在字符串的末尾有一个隐藏的空字符 – ‘\0’</p>
<p>​        char a[50] = “hello”;    </p>
<a id="more"></a>

<h3 id="2-字符串函数："><a href="#2-字符串函数：" class="headerlink" title="2.字符串函数："></a>2.字符串函数：</h3><blockquote>
<p>字符串长度函数 – strlen()<br>字符串连接函数– strcat()<br>字符串拷贝函数 – strcpy()<br>字符串比较函数– strcmp()</p>
</blockquote>
<p><strong>注：<code>int a[10]=&#123;0&#125;</code>相当于把数组a中的所有元素给赋值成’\0’，但是<font color="red">int a[arr]={0}</font>则错误，因为在数组长度为变量时不能同时进行赋值</strong><br><strong>同时也不能把字符串常量赋值给一个字符数组，因为字符数组本身也是个常量 <font color="red">char s[10];s=”abcdefg”</font>是错误的。</strong></p>
<br>
<br>

<hr>
<h2 id="二、指针"><a href="#二、指针" class="headerlink" title="二、指针"></a>二、指针</h2><h3 id="1、指针相关运算符"><a href="#1、指针相关运算符" class="headerlink" title="1、指针相关运算符"></a>1、指针相关运算符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;:获取内容的地址</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">	&amp;a --&gt; 获取到a的地址</span><br><span class="line">    </span><br><span class="line">*：获取地址中的内容</span><br><span class="line">    *(&amp;a) == a == <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、指针变量"><a href="#2、指针变量" class="headerlink" title="2、指针变量"></a>2、指针变量</h3><p>​    指针变量就是用于存放地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; *指针变量名;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">//将a的地址存放在了一个名为p的指针变量中</span></span><br><span class="line">p == &amp;a;</span><br><span class="line">*p = *(&amp;a) == a == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="3、指针变量的赋值"><a href="#3、指针变量的赋值" class="headerlink" title="3、指针变量的赋值"></a>3、指针变量的赋值</h3><p>赋值运算符的左值和右值类型一定要相同</p>
<p>(1)将一个变量的地址赋值给一个具有相同数据类型的指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>(2)将一个已有的指针赋值给一个 具有相同数据类型的指针变量</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *q = p;</span><br><span class="line"></span><br><span class="line">q == p == &amp;a;</span><br></pre></td></tr></table></figure>

<p>(3)将0值赋值给一个指针变量 – 空指针</p>
<p>野指针：定义一个指针，没有明确指向，不能访问野指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>(4)将一个数组的数组名赋值给一个具有相同数据类型的指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a; <span class="comment">// a == &amp;a[0]</span></span><br></pre></td></tr></table></figure>

<p>(5)把一个复合形式的表达式的值赋给一个具有相同数据类型的指针变量</p>
<h3 id="4、指针的运算"><a href="#4、指针的运算" class="headerlink" title="4、指针的运算"></a>4、指针的运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">// &amp;a == 0x2000</span></span><br><span class="line">p+n --&gt; p向高地址位偏移n个元素大小的字节数  <span class="comment">//元素指，该指针指向的内容</span></span><br><span class="line">p-n --&gt; p向低地址位偏移n个元素大小的字节数</span><br><span class="line"></span><br><span class="line">p+n == p+n*<span class="keyword">sizeof</span>(元素类型)  <span class="comment">//在该例中元素类型为int</span></span><br><span class="line">    </span><br><span class="line">注意：指针运算中没有 指针 + 指针、指针 * 指针、 指针 / 指针，因为没有任何实际意义 </span><br><span class="line">    但是有指针 - 指针</span><br><span class="line">    </span><br><span class="line">    指针-指针表示相同类型的两个指针之间相差多少个元素,结果的正负，仅代表地址高低</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">	<span class="keyword">int</span> *q = &amp;b;</span><br><span class="line">	q - p ==  (q-p)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="5、指针和一维数组"><a href="#5、指针和一维数组" class="headerlink" title="5、指针和一维数组"></a>5、指针和一维数组</h3><p>将一个一维数组的数组名赋值给一个具有相同数据类型的指针变量, 我们就可以通过该指针访问数组中所有元素</p>
<blockquote>
<p><strong>注：数组名不能递增递减</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line">*p == a[<span class="number">0</span>];</span><br><span class="line">*(p+<span class="number">1</span>) == a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p++; <span class="comment">// p = p+1; right</span></span><br><span class="line">a++; <span class="comment">// a = a+1; error  数组名不能递增递减</span></span><br><span class="line"></span><br><span class="line">数组a中的第三个元素的表达方式:</span><br><span class="line">	a[<span class="number">2</span>]、 *(p+<span class="number">2</span>)、 *(&amp;a[<span class="number">2</span>])、p[<span class="number">2</span>]、 *(a+<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h3 id="6、指针和二维数组-–-行指针（数组指针）"><a href="#6、指针和二维数组-–-行指针（数组指针）" class="headerlink" title="6、指针和二维数组 – 行指针（数组指针）"></a>6、指针和二维数组 – 行指针（数组指针）</h3><p>​    本质：数组指针是一个指针，存放的内容是地址，指针指向的内容是一个一维数组</p>
<p>​    二维数组的数组名是一个行指针，指向二维数组的首地址，行指针+n相当于地址偏移n行元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//行指针的定义一般形式</span></span><br><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; (*指针变量名)[列数];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line"></span><br><span class="line">*(*(p+<span class="number">1</span>)+<span class="number">2</span>) == 第二行第三个元素</span><br><span class="line">*(*(p+<span class="number">0</span>)+<span class="number">1</span>) == 第一行第二个元素</span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">258</span>;                                                      </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)&amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(++p));</span><br><span class="line">  &#125;</span><br><span class="line">  ````</span><br><span class="line">程序运行结果是  &lt;u&gt;2,1&lt;/u&gt;  </span><br><span class="line"></span><br><span class="line">解：<span class="number">258</span>的<span class="number">16</span>进制为<span class="number">102</span>，按照<span class="keyword">int</span>的存储方式为 <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span>，p指针先到<span class="number">02</span>，因为转移到<span class="keyword">char</span>后+<span class="number">1</span>为前进一个字符，则p指针跳到了<span class="number">01.</span>  </span><br><span class="line"></span><br><span class="line">### <span class="number">2.</span> </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *arr[<span class="number">3</span>]=&#123;a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>]&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<p>程序运行结果是  <u>8</u></p>
<p>解：arr数组里的都是指针，sizeof指向第一个元素即指针，所以大小为8，不是a[0][3]中的12.</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>&emsp;若有以下说明和语句，int c[4][5],(*p)[5];p=c;能正确引用c数组元素的是<u> D</u>.<br>(A) p+1      (B) *(p+3)     　(C) *(p+1)+3   (D) *(p[0]+2) </p>
<p>解：b错误原因是p+3仅代表地址，加个*只能表示p[3].</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>c</tag>
        <tag>指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown笔记-基础</title>
    <url>/2020/04/26/Markdown%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Markdown-概述"><a href="#Markdown-概述" class="headerlink" title="Markdown 概述"></a>Markdown 概述</h1><p>Markdown 是一种轻量级标记语言，与 2004 年创建。<br>后缀为<code>.md</code>或<code>.maekdown</code>，可导出 HTML，Word，pdf 等多种格式文档</p>
<a id="more"></a>

<hr>
<br>

<h1 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h1><h2 id="1-使用-和-标记一级和二级标题"><a href="#1-使用-和-标记一级和二级标题" class="headerlink" title="1.使用=和-标记一级和二级标题"></a>1.使用=和-标记一级和二级标题</h2><blockquote>
<p>这是一级标题<br>==========<br>这是二级标题<br>-—————–</p>
</blockquote>
<h2 id="2-使用-号标记标题"><a href="#2-使用-号标记标题" class="headerlink" title="2.使用#号标记标题"></a>2.使用#号标记标题</h2><blockquote>
<p># 一级标题<br>## 二级标题<br>### 三级标题<br>…<br>###### 六级标题</p>
</blockquote>
<p><strong>注：#后要加空格</strong></p>
<hr>
<br>
<br>

<h1 id="Markdown-段落与字体格式"><a href="#Markdown-段落与字体格式" class="headerlink" title="Markdown 段落与字体格式"></a>Markdown 段落与字体格式</h1><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>1.在段落末尾使用两个以上空格加回车为换行</p>
<p>2.在段落与段落之间留出一个空行为换段落</p>
<h2 id="字体格式"><a href="#字体格式" class="headerlink" title="字体格式"></a>字体格式</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><blockquote>
<p>*斜体文本* &gt; _斜体文本_ &gt; **粗体文本** &gt;__粗体文本__ &gt; ***粗斜体文本*** &gt;___粗斜体文本___</p>
</blockquote>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>&nbsp; 在一行内用三个以上的星号，减号，下划线，在建立一个分割线<br>&nbsp; 注意：行内不能有其他东西</p>
<blockquote>
<p>***<br> -–<br>_ _ _<br>-———–</p>
</blockquote>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a><del>删除线</del></h3><p>&nbsp; 如果要在文字上添加删除线，则在文字两端加上两个波浪线~~</p>
<blockquote>
<p>~~要删除线的文字~~</p>
</blockquote>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>&nbsp; <u>下划线</u>可以通过 HTML 的<code>&lt;u&gt;</code>标签来实现</p>
<blockquote>
<p>&lt;u&gt;带下划线的文本&lt;/u&gt;</p>
</blockquote>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>&nbsp; 在需要脚注<a href="%E6%97%A0%E8%AE%BA%E5%86%99%E4%BB%80%E4%B9%88%E8%84%9A%E6%B3%A8%E5%90%8D%EF%BC%8C%E6%9C%80%E5%90%8E%E9%83%BD%E4%BC%9A%E5%8F%98%E6%88%90%E6%95%B0%E5%AD%97%E6%8E%92%E5%88%97%E6%96%B9%E5%BC%8F">^像这样</a>的文字后写[^脚注名]，并在后面的某个地方用[^要注明的文本]: 内容 来使用脚注。<u>且无论写什么脚注名，最后都会变成数字排列方式</u></p>
<blockquote>
<p>[^脚注名]</p>
<p>[^脚注名]: 脚注内容</p>
</blockquote>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;将选中的文字用灰色背景加重（<code>像这样</code>）,就在文字的两旁加`</p>
<blockquote>
<p>`文字`</p>
</blockquote>
<h3 id="特殊符号失效"><a href="#特殊符号失效" class="headerlink" title="特殊符号失效"></a>特殊符号失效</h3><p>&nbsp; 如果想让特殊符号失效，即打出原有符号样子(如#),则在特殊符号前加反切线\</p>
<blockquote>
<p>\<br> \&lt;\u&gt;…&lt;/u&gt;</p>
</blockquote>
<hr>
<br>
<br>

<h1 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h1><p>&nbsp; Markdown 支持有序列表和无序列表（在标记后面要有空格）</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记</p>
<blockquote>
<p>* 第一项<br>* 第二项<br>* 第三项</p>
<p>+ 第一项<br>+ 第二项<br>+ 第三项</p>
<p>- 第一项<br>- 第二项<br>- 第三项</p>
</blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<br>

<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表使用数字加上<code>.</code>号来表示，如：</p>
<blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
</blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<hr>
<br>
<br>

<h1 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h1><p>Markdown 区块引用时在段落开头使用&gt;号，后面要跟个空格符号</p>
<blockquote>
<p>&gt;区块内文字,效果就是这像一行一样出现阴影</p>
<blockquote>
<p>打多个&gt;还可以还可以内嵌(如这行的&gt;&gt;)</p>
</blockquote>
</blockquote>
<ol>
<li>区块中使用列表的话，就在&gt;后面用列表语法就行<blockquote>
<p>&gt; 1. 第一项<br>&gt; 2. 第二项<br>&gt; 3. 第三项</p>
<p>&gt; + 第一项<br>&gt; + 第二项<br>&gt; + 第三项</p>
</blockquote>
</li>
</ol>
<br>

<ol start="2">
<li>列表中使用区块，则要在&gt;前添加四个空格的缩进</li>
</ol>
<blockquote>
<p>* 第一项<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;区块内容<br>* 第二项</p>
</blockquote>
<p>效果如下：</p>
<ul>
<li>第一项<blockquote>
<p>区块内容</p>
</blockquote>
</li>
<li>第二项</li>
</ul>
<hr>
<br>
<br>

<h1 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h1><ul>
<li>如果是段落上的一个函数或片段的代码可以用反引号(`)将内容包起来</li>
</ul>
<blockquote>
<p>`printf()`函数</p>
</blockquote>
<p><code>printf()</code>函数<br><br></p>
<ul>
<li>如果是代码区块，则使用 4 个空格或者一个制表符(Tab 键)</li>
</ul>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 代码内容</p>
</blockquote>
<pre><code>public static void main(String[] args)&#123;
    System.out.println(&quot;hello,world&quot;)
&#125;</code></pre>
<br>

<ul>
<li>也可以用 ``` …. ``` 来包裹一段代码，还可以在```后面指定一种语言</li>
</ul>
<blockquote>
<p>```java<br>public static void main(String[] args){<br>System.out.println(“hello,world”)<br>}<br>```</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<br>
<br>

<h1 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h1><ul>
<li>普通方式</li>
</ul>
<blockquote>
<p>[链接名称](链接地址)<br>或者&lt;链接地址&gt;</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/3b638180e42c">技术文档书写规范</a></p>
<p><a href="https://www.jianshu.com/p/3b638180e42c">https://www.jianshu.com/p/3b638180e42c</a><br><br></p>
<ul>
<li>高级链接<br>如果链接太长时，可在[连接名称]后面设置一个[标签名],则可在后面的任意位置写[标签名]: 链接<br><strong>注意：<code>[标签名]:</code> 冒号前面以及两个中括号之间[][]不要留空格</strong></li>
</ul>
<blockquote>
<p>[技术文档书写规范][1]<br>[csdn 官网][csdn]</p>
<p>[1]: <a href="https://www.jianshu.com/p/3b638180e42c">https://www.jianshu.com/p/3b638180e42c</a> &gt;[csdn]: <a href="https://www.csdn.net/">https://www.csdn.net/</a></p>
</blockquote>
<p><a href="https://www.jianshu.com/p/3b638180e42c">技术文档书写规范</a><br><a href="https://www.csdn.net/">csdn 官网</a></p>
<hr>
<br>
<br>

<h1 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote>
<p>![alt 属性文本](图片地址)</p>
<p>![alt 属性文本](图片地址 “title 属性文本”)</p>
</blockquote>
<p>alt 为图片加载出错时的代替文本<br>title 为鼠标放在图片上时所显示的文字</p>
<h2 id="图片地址的传入方法"><a href="#图片地址的传入方法" class="headerlink" title="图片地址的传入方法"></a>图片地址的传入方法</h2><ol>
<li>通过图床将图上传到网上后使用图片的链接<blockquote>
<p>![图片加载出错](<a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg">https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http%3A%2F%2Fgss0.baidu.com%2F-4o3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2F810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg</a> “这是 title 属性”)</p>
</blockquote>
</li>
</ol>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587895752391&di=e2f0ba8e2108ab4f04b19700233f121f&imgtype=0&src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg" alt="图片加载出错" title="这是title属性"><br><br></p>
<ol start="2">
<li>将图片存入本地，通过 <a href="https://blog.csdn.net/chudelong1/article/details/90697409">绝对路径/相对路径</a> 来加载图片(相对路径是以当前的 md 文件所在目录为起点)</li>
</ol>
<blockquote>
<p>![图片出不来了](./mdphoto/markdownlearn/0.jpg)</p>
</blockquote>
<p><img src="/2020/04/26/Markdown%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/0.jpg" alt="图片出不来了"></p>
<p>当然，当地址过长时也可以像链接那样将(…)变成变量名</p>
<blockquote>
<p>![图片加载出错][photo 1]</p>
<p>[photo 1]: <a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg">https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http%3A%2F%2Fgss0.baidu.com%2F-4o3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2F810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg</a></p>
</blockquote>
<p><strong><u>注意：如果是想将本地连接的图片通过 hexo 传到远端时，直接使用是无效的,要实现下列步骤</u></strong></p>
<ol>
<li>配置 hexo 根下的<code>_config.yml</code>里面的<code>post_asset_folder:false</code>这个选项设置为<code>true</code>。</li>
<li>git bash 安装插件：<code>npm install https://github.com/7ym0n/hexo-asset-image --save</code> , 安装之后再生成新 md 文件时同目录下会出现同名的文件夹，图片可放进那里</li>
<li>这时再使用上面的语法便能成功</li>
</ol>
<hr>
<br>
<br>

<h1 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h1><p>&nbsp; Markdown 中制作表格用<code>|</code>来分割不同的单元格，用<code>-</code>在分割表头和其它行</p>
<blockquote>
<p>|表头 1|表头 2|表头 3|<br>| :&nbsp;—&nbsp;&nbsp; &nbsp;|:&nbsp;&nbsp; —&nbsp;&nbsp;: |&nbsp;&nbsp;&nbsp;—&nbsp;&nbsp;: |<br>|左对齐|中对齐|右对齐|<br>|左对齐效果|中对齐效果|右对齐效果|</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">表头 1</th>
<th align="center">表头 2</th>
<th align="right">表头 3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">左对齐</td>
<td align="center">中对齐</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td align="left">左对齐效果</td>
<td align="center">中对齐效果</td>
<td align="right">右对齐效果</td>
</tr>
</tbody></table>
<br>
<br>

<p>还能设置表格的对齐方式(默认向左对齐)：</p>
<ul>
<li><strong><code>-:</code></strong> 设置内容和标题栏右对齐</li>
<li><strong><code>:-:</code></strong> 设置内容和标题栏中对齐</li>
<li><strong><code>:-</code></strong> 设置内容和标题栏左对齐</li>
</ul>
<p><strong>注：最右边的<code>|</code>可以省略</strong></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Markdown基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础-递归</title>
    <url>/2020/04/28/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><font color="#7CFC00">基本概念</font></h1><p>C 语言允许函数调用它自己，这种调用的过程称为递归</p>
<a id="more"></a>

<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><blockquote>
<p>栈：一种数据结构，其特点为先进后出</p>
<blockquote>
<p>C 语言在执行代码时会从 main()开始依次将调用的函数放入栈中<br>放完后便将栈中的方法，从栈顶一个个取出并执行</p>
</blockquote>
</blockquote>
<p>如图( 计算 3! )：</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/diguis.jpg" alt="递归原理图"></p>
<p>解释：</p>
<ol>
<li>开始执行，先将<code>main( )</code>函数放入栈底并执行</li>
<li>遇到了<code>fun(3)</code>后把 <code>mian( )</code>函数暂时放在栈中，去调用<code>fun(3)</code>函数</li>
<li>执行<code>fun(3)</code>时又发现调用了<code>fun(2)</code>，又把<code>fun(2)</code>放入栈中去掉<code>fun(1)</code></li>
<li><code>fun(1)</code>时发现没有调用了( 此时<code>fun(1)</code>在栈顶 )，便开始返回，把返回值给了<code>fun(2)</code>，<code>fun(2)</code>也继续下面的语句，返回给了<code>fun(3)</code></li>
<li>最后<code>fun(3)</code>返回给<code>main( )</code>，<code>main( )</code>继续执行下面的语句</li>
</ol>
<p>由此可以看成递归的形成至少需要两个条件：</p>
<ol>
<li>变化的参数</li>
<li>递归终止条件</li>
</ol>
<blockquote>
<p>栈溢出：内存空间是有限的，分配给 C 程序的栈空间也是有限的，如果递归没有结束条件的话就会导致无限的调用，形成栈溢出</p>
</blockquote>
<hr>
<br>
<br>

<h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a><font color="#7CFC00">尾递归</font></h1><p>最简单的递归形式就是把递归调用置于函数的末尾，即正好在 <code>return</code> 语句之前。这种形式的递归被称为 <u>尾递归</u> (如上图所示)，它相当于循环。</p>
<p><strong>如果效果和循环差不多时最好使用循环</strong></p>
<hr>
<br>
<br>

<h1 id="递归的优缺点"><a href="#递归的优缺点" class="headerlink" title="递归的优缺点"></a><font color="#7CFC00">递归的优缺点</font></h1><p>递归的语法易被人理解，但空间成本消耗太大。所以在使用递归时要特别注意，尤其是<font color="red">效率优先</font>的程序</p>
<br>

<blockquote>
<p>注：main( )函数可以调用自己，且两函数间不可以相互调用</p>
</blockquote>
<hr>
<br>
<br>

<h1 id="递归算法实战-汉诺塔问题"><a href="#递归算法实战-汉诺塔问题" class="headerlink" title="递归算法实战-汉诺塔问题"></a><font color="#7CFC00">递归算法实战-汉诺塔问题</font></h1><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p>
<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>
<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1159565693,4014945639&fm=26&gp=0.jpg" alt="汉诺塔"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们倒着的开始，假如要移动 64 个</p>
<ol>
<li>我们要把上面的 63 个移动到 B</li>
<li>把第 64 个移动到 C</li>
<li>把 B 上的 63 个移动到 C</li>
</ol>
<p>那么就会产生问题了：怎么移动那 63 个呢<br>和上面的思路一样</p>
<ol>
<li>我们要把上面的 62 个移动到 B</li>
<li>把第 63 个移动到 C</li>
<li>把 B 上的 62 个移动到 C</li>
</ol>
<p>直到问题变为：怎么移动上面的那 1 个呢，这时我们就会了，移动了 1 个后，我们就会移动 2 个，移动 2 个后，我们就会第 3 个，依次下去，就能把 64 个都移动完了</p>
<p>所以整个过程是</p>
<ol>
<li>我们要把上面的<code>n-1</code>个移动到 B</li>
<li>把第<code>n</code>个移动到 C</li>
<li>把 B 上的<code>n-1</code>个移动到 C</li>
</ol>
<blockquote>
<p>其中移动 n-1 个盘子的操作是递归操作<br>1，3 步分别用了递归</p>
</blockquote>
<p>下面是 java 语言代码实现部分( <del>用 C 表达出来的效果不好啊，还是 java 的看着舒服</del> ，其实基本都是一样的):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        move(A.size(),A,B,C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从这开始看</span></span><br><span class="line">    <span class="comment">//盘子用数字代替，n代表需要移动的盘子数，List是盘子的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当需要移动的盘子数只有1个时，此时这个盘子就是最下面的，其它的都移动到B上(第一步)或者A(第三步)上了了</span></span><br><span class="line">        <span class="comment">// 把A的盘子直接移动到C就行了</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            C.add(A.remove(A.size()-<span class="number">1</span>)); <span class="comment">//注意这里是最下面的盘子数最大</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没到最上面时，则一直重复123步骤</span></span><br><span class="line">        move(n-<span class="number">1</span>,A,C,B); <span class="comment">//对应第一步</span></span><br><span class="line">        C.add(A.remove(A.size()-<span class="number">1</span>));  <span class="comment">//对应第二步</span></span><br><span class="line">        move(n-<span class="number">1</span>,B,A,C);  <span class="comment">//对应第三步</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<br>
<br>

<h1 id="递归总结"><a href="#递归总结" class="headerlink" title="递归总结"></a><font color="#7CFC00">递归总结</font></h1><p>要运用递归的地方都有以下的共同点</p>
<ol>
<li>拥有大量重复的步骤，或者说可将复杂的步骤转换为计算大但容易理解的重复步骤</li>
<li>拥有当达到某种条件时，可返回一个确定值，即遇见某种情况时可向前推导</li>
</ol>
<p>这样便可以将代表条件的变量设为函数参数，把步骤设为函数具体代码</p>
<hr>
<br>
<br>

<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a><font color="#7CFC00">推荐阅读</font></h1><p>知乎-<a href="https://www.zhihu.com/question/24385418">如何理解汉诺塔的递推</a><br><a href="https://leetcode-cn.com/explore/featured/card/recursion-i/">leetcode-递推</a>(有点难度)</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>c</tag>
        <tag>递归</tag>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day13-c指针，函数</title>
    <url>/2023/03/08/day13-c%E6%8C%87%E9%92%88%EF%BC%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="day13-c指针，函数"><a href="#day13-c指针，函数" class="headerlink" title="day13-c指针，函数"></a><font color="green">day13-c指针，函数</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、指针数组"><a href="#1、指针数组" class="headerlink" title="1、指针数组"></a>1、指针数组</h3><p>​    本质：数组</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt;*指针数组名[元素个数];</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> b[<span class="number">50</span>] = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">50</span>] = <span class="string">&quot;qwe&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> *p[<span class="number">3</span>] = &#123;a, b, c&#125;;</span><br><span class="line">	p[<span class="number">0</span>] == a;</span><br><span class="line">	p[<span class="number">2</span>] == b;</span><br><span class="line">	p[<span class="number">3</span>] <span class="comment">//error</span></span><br><span class="line">    *(p[<span class="number">0</span>]) == <span class="string">&#x27;h&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">char</span> **q = p = &amp;a;</span><br><span class="line">	q+<span class="number">1</span> = p+<span class="number">1</span> = &amp;b;</span><br><span class="line">	*q = *p = *(&amp;a) == a;</span><br><span class="line">	**q = *a = <span class="string">&#x27;h&#x27;</span>     </span><br><span class="line">        </span><br><span class="line">    p == &amp;p[<span class="number">0</span>];    </span><br><span class="line">        </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> *p[<span class="number">2</span>] = &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;;</span><br><span class="line">	*(p[<span class="number">0</span>]) == **p == p[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、二级指针"><a href="#2、二级指针" class="headerlink" title="2、二级指针"></a>2、二级指针</h3><p>​     将一级指针的地址称为二级指针</p>
<p>​        int a = 2;</p>
<p>​        int *p = &a;</p>
<p>​        int **q = &p;  //q就是定义的一个二级指针，地址中存放一级指针的值</p>
<h3 id="3、const指针"><a href="#3、const指针" class="headerlink" title="3、const指针"></a>3、const指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//right</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<h3 id="4、void指针"><a href="#4、void指针" class="headerlink" title="4、void指针"></a>4、void指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br><span class="line">p+<span class="number">1</span> <span class="comment">// error  void类型指针在使用时需要类型强转</span></span><br><span class="line">(<span class="keyword">int</span> *)p+<span class="number">1</span> <span class="comment">// 偏移4字节</span></span><br><span class="line">(<span class="keyword">char</span> *)p+<span class="number">1</span> <span class="comment">// 偏移1字节</span></span><br><span class="line"></span><br><span class="line">注意：<span class="keyword">void</span>类型的指针不能使用递增递减运算符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、字符指针和字符串"><a href="#5、字符指针和字符串" class="headerlink" title="5、字符指针和字符串"></a>5、字符指针和字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">6</span>] = <span class="string">&quot;haha&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">&quot;hello&quot;</span>; <span class="comment">//将字符串hello的首地址赋值给指针变量p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *p); <span class="comment">//right</span></span><br><span class="line">*p = <span class="string">&#x27;z&#x27;</span>; <span class="comment">//error hello是一个字符串常量，不能修改里面的字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;asd&quot;</span>); <span class="comment">//error</span></span><br><span class="line"><span class="built_in">strcpy</span>(a, <span class="string">&quot;asd&quot;</span>); <span class="comment">//right	</span></span><br></pre></td></tr></table></figure>



<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><p>概念：函数是一个实现特定功能的代码模块，函数有返回值，也可能没有</p>
<p>​            返回值：函数的结果</p>
<h3 id="1、函数的封装-定义"><a href="#1、函数的封装-定义" class="headerlink" title="1、函数的封装(定义)"></a>1、函数的封装(定义)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">	&lt;数据类型&gt; 函数名(形式参数)</span><br><span class="line">	&#123;</span><br><span class="line">    	功能代码模块;  <span class="comment">//语句块</span></span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">return</span> 表达式; </span><br><span class="line">	&#125;</span><br><span class="line">	数据类型：跟函数返回值的类型一致，如果一个函数没有返回值，则填<span class="keyword">void</span></span><br><span class="line">    函数名：遵循标识符标识符的命名规范，函数命名一般和功能相关。函数名也代表函数的起始地址</span><br><span class="line">    形式参数：形式参数决定了，函数调用时需要传入的实参的个数、类型、顺序，多个形式参数之间用逗号隔开。</span><br><span class="line">    如果函数不需要形式参数，可以省略不写，或者填<span class="keyword">void</span></span><br><span class="line">    <span class="keyword">return</span>：函数结束的标志，后面的表达式的值为函数的结果。如果没有返回值，可以选择不填或者只填<span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="2、函数的调用"><a href="#2、函数的调用" class="headerlink" title="2、函数的调用"></a>2、函数的调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    函数名(实际参数);</span><br><span class="line">	实际参数必须跟形式参数的个数、类型、顺序一致。如果没有形式参数，那么实际参数可以省略</span><br></pre></td></tr></table></figure>

<h3 id="3、函数的声明"><a href="#3、函数的声明" class="headerlink" title="3、函数的声明"></a>3、函数的声明</h3><p>​    在使用函数之前需要对函数进行函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">声明的一般形式：</span><br><span class="line">   &lt;数据类型&gt; 函数名(形式参数); 	</span><br><span class="line"></span><br><span class="line">	函数的声明中变量名是可以省略的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在add.h中声明了#include &lt;stdio.h&gt;后，在其他要用到#include &lt;stdio.h&gt;的函数中可以直接声明#include”add.h”就行。</p>
</blockquote>
<h3 id="4、头文件一般格式"><a href="#4、头文件一般格式" class="headerlink" title="4、头文件一般格式"></a>4、头文件一般格式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ADD_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ADD_H__</span></span><br><span class="line"></span><br><span class="line">头文件声明</span><br><span class="line"></span><br><span class="line">函数声明</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、函数的传参"><a href="#5、函数的传参" class="headerlink" title="5、函数的传参"></a>5、函数的传参</h3><p>(1)赋值传递</p>
<p>&emsp;&emsp;在调用函数时，将普通变量的值直接赋值给形参。因为形式参数和实际参数在内存中存储的地址不同，所以        在函数中无论怎样改变形式参数的值，对实际参数是没有任何影响的</p>
<p>(2)地址传递</p>
<p>&emsp;&emsp;在调用函数时，将普通变量的地址直接赋值给形参。可以通过修改形式参数，间接修改实参的值</p>
<p>(3)全局变量</p>
<p>&emsp;&emsp;因为全局变量的作用域在整个文件中有效，所有在当前文件的任何一个函数中都可以当作参数使用</p>
<h3 id="6、数组传参"><a href="#6、数组传参" class="headerlink" title="6、数组传参"></a>6、数组传参</h3><p>&emsp;&emsp;数组传参需要传入指定数组的首地址，如果该数组是一个整型数组，那么在传入数组首地址的同时，还需要传入数组元素的个数</p>
<hr>
   <br>
   <br>

<h2 id="7、易错点"><a href="#7、易错点" class="headerlink" title="7、易错点"></a>7、易错点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>]=a; <span class="comment">//error</span></span><br><span class="line"><span class="keyword">int</span> *p=a;<span class="comment">//error</span></span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]);<span class="comment">//error一定为8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row=a[<span class="number">1</span>]-a[<span class="number">0</span>];   <span class="comment">//二维数组列数计算，用下一行的地址减去第一行的地址。即使二维数组只有一列也行</span></span><br><span class="line"><span class="keyword">int</span> line=<span class="keyword">sizeof</span>(a)/(row*<span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));​   <span class="comment">//二维数组行数计算</span></span><br></pre></td></tr></table></figure>

<h3 id="指针数组与数组指针的区别"><a href="#指针数组与数组指针的区别" class="headerlink" title="指针数组与数组指针的区别"></a>指针数组与数组指针的区别</h3><p>例：<br>int a[2][3]={1,2,3,4,5,6};<br>int (*p)[3]=a;<br>int *p[2]={a[0],a[1]};</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">指针数组</th>
<th align="center">数组指针</th>
</tr>
</thead>
<tbody><tr>
<td align="center">本质</td>
<td align="center">元素是指针的数组</td>
<td align="center">指向数组的行指针</td>
</tr>
<tr>
<td align="center">形式</td>
<td align="center">int *p[3]={a[0],a[1]};</td>
<td align="center">int (*p)[3]=a;</td>
</tr>
<tr>
<td align="center">p+1</td>
<td align="center">=&amp;p[1]=&amp;a[1]=&amp;&amp;a[1][0]</td>
<td align="center">=&amp;p[1]=&amp;a[1]=&amp;&amp;a[1][0]</td>
</tr>
<tr>
<td align="center">sizeof(p)</td>
<td align="center">整个数组的大小</td>
<td align="center">一定为8(即指针的大小)</td>
</tr>
<tr>
<td align="center">*(p+1)<strong>值一样但形式不一样</strong></td>
<td align="center">p[1]=a[1]=&amp;a[1][0]</td>
<td align="center">=a[1]=&amp;a[1][0]</td>
</tr>
<tr>
<td align="center">sizeof(*p)</td>
<td align="center">一定为8(即指针的大小)</td>
<td align="center">一列的大小</td>
</tr>
<tr>
<td align="center">二级指针x</td>
<td align="center">有二级指针 int **x=p</td>
<td align="center">没有二级指针，<font color="red">不能 int **x=p</font></td>
</tr>
<tr>
<td align="center">**p</td>
<td align="center">=**x=*p[0]=*a[0]=a[0][0]</td>
<td align="center">=*a[0]=a[0][0]</td>
</tr>
</tbody></table>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>指针</tag>
        <tag>c语言</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>day14-c函数</title>
    <url>/2023/03/10/day14-c%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="day14-c函数"><a href="#day14-c函数" class="headerlink" title="day14-c函数"></a><font color="green">day14-c函数</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、函数定义"><a href="#1、函数定义" class="headerlink" title="1、函数定义"></a>1、函数定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; 函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    功能代码;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> 表达式;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数名：也代表函数的首地址</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="2、函数调用"><a href="#2、函数调用" class="headerlink" title="2、函数调用"></a>2、函数调用</h3><p>​    函数名(实际参数);</p>
<p>​    实际参数必须和形参的个数、类型、顺序一致</p>
<h3 id="3、函数声明"><a href="#3、函数声明" class="headerlink" title="3、函数声明"></a>3、函数声明</h3><p>​    &lt;数据类型&gt; 函数名(形式参数);</p>
<h3 id="4、函数的传参"><a href="#4、函数的传参" class="headerlink" title="4、函数的传参"></a>4、函数的传参</h3><p>​    (1)赋值传递</p>
<p>​    (2)地址传递：将数据的地址赋值给形参进行初始化</p>
<p>​    (3)全局变量传参</p>
<h3 id="5、数组传参"><a href="#5、数组传参" class="headerlink" title="5、数组传参"></a>5、数组传参</h3><p>​    (1)整型数组：要传入数组的首地址，还要传入数组的元素个数</p>
<p>​    (2)字符数组：只需要传入数组首地址</p>
<p>练习：定义一个函数，计算二维整型数组的所有元素的和</p>
<h2 id="二、函数和指针"><a href="#二、函数和指针" class="headerlink" title="二、函数和指针"></a>二、函数和指针</h2><h3 id="1、指针函数"><a href="#1、指针函数" class="headerlink" title="1、指针函数"></a>1、指针函数</h3><p>​        如果一个函数的返回值是一个地址值，那么该函数就称为指针函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; *函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    功能代码;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> 地址值; <span class="comment">//合法安全的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2、函数指针"><a href="#2、函数指针" class="headerlink" title="2、函数指针"></a>2、函数指针</h3><p>​    本质：指针，指向一个函数的首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义：</span><br><span class="line">    &lt;数据类型&gt; (*函数指针名)(形式参数);</span><br><span class="line">	数据类型：跟指向的函数的返回值一致</span><br><span class="line">    形式参数：跟指向函数的形参一致</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span> x, <span class="keyword">int</span> y); <span class="comment">//定义了一个函数指针，指向的函数--&gt;返回值为int，参数是两个int类型数据</span></span><br><span class="line">p = add; <span class="comment">//将函数add的首地址赋值给函数指针变量p</span></span><br><span class="line"></span><br><span class="line">调用函数方法：</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//通过函数名+实参 调用函数</span></span><br><span class="line">	(*p)(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//通过访问函数指针内容+实参 调用函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>















<p>​            </p>
<p>​                </p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c语言</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>day12-c指针</title>
    <url>/2023/03/08/day12-c%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="day12-c指针"><a href="#day12-c指针" class="headerlink" title="day12-c指针"></a><font color="green">day12-c指针</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、指针变量的赋值"><a href="#1、指针变量的赋值" class="headerlink" title="1、指针变量的赋值"></a>1、指针变量的赋值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> *q = p;   <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">char</span> *m = <span class="literal">NULL</span>; <span class="comment">//空指针 3</span></span><br><span class="line"><span class="keyword">int</span> *n = b; <span class="comment">// n == &amp;b[0] //4</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>


<h3 id="2、指针变量的运算"><a href="#2、指针变量的运算" class="headerlink" title="2、指针变量的运算"></a>2、指针变量的运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p+n --&gt; 向高地址位偏移n个元素的字节数</span><br><span class="line">p-n --&gt; 向低地址位偏移n个元素的字节数</span><br><span class="line">    </span><br><span class="line">指针-指针：计算两个相同类型的指针之间相差的元素个数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、指针和一维数组"><a href="#3、指针和一维数组" class="headerlink" title="3、指针和一维数组"></a>3、指针和一维数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line">*p == a[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4、指针和二维数组"><a href="#4、指针和二维数组" class="headerlink" title="4、指针和二维数组"></a>4、指针和二维数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">二维数组的数组名也表示整个二维数组的首地址。但是是一个行地址</span><br><span class="line"></span><br><span class="line">    数组指针定义的一般形式：</span><br><span class="line">    	&lt;存储类型&gt; &lt;数据类型&gt; (*数组指针名)[列数];</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	a == &amp;a[<span class="number">0</span>] </span><br><span class="line">	a+<span class="number">1</span> == &amp;a[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line">	*(*(p+<span class="number">1</span>)+<span class="number">1</span>) --&gt; 二维数组中第二行第二个元素</span><br></pre></td></tr></table></figure>

<hr>
<br>
<br>

<h2 id="二、指针"><a href="#二、指针" class="headerlink" title="二、指针"></a>二、指针</h2><h3 id="1、指针数组"><a href="#1、指针数组" class="headerlink" title="1、指针数组"></a>1、指针数组</h3><p>​        数组指针(行指针)：本质是指针，存放地址值，指向的内容是一个一维数组的地址</p>
<p>​        指针数组：本质是数组。如果一个数组中所有元素都是地址，那么该数组称为指针数组</p>
<h3 id="2、指针数组的定义"><a href="#2、指针数组的定义" class="headerlink" title="2、指针数组的定义"></a>2、指针数组的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; *数组名[元素个数];</span><br><span class="line">	例：</span><br><span class="line">    	<span class="keyword">int</span> a, b, c;</span><br><span class="line">		<span class="keyword">int</span> *addr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;</span><br><span class="line">		addr[<span class="number">0</span>] == &amp;a;</span><br><span class="line">		addr[<span class="number">1</span>] == &amp;b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、多级指针–二级指针-难点"><a href="#3、多级指针–二级指针-难点" class="headerlink" title="3、多级指针–二级指针(难点)"></a>3、多级指针–二级指针(<strong>难点</strong>)</h3><p>​    定义一个指针变量，有几个星号就是几级指针</p>
<p>​    二级指针的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; **指针变量名;</span><br><span class="line">例：</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">	<span class="keyword">int</span> **q = &amp;p;</span><br><span class="line">	</span><br><span class="line">	*q == p == &amp;a</span><br><span class="line">	**q == *p == *&amp;a == a == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>注意</strong>：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line"><span class="keyword">int</span> *q[<span class="number">2</span>] = &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;;</span><br><span class="line"></span><br><span class="line">p:数组指针名，p+<span class="number">1</span>偏移一行数据大小</span><br><span class="line">q:指针数组名，q+<span class="number">1</span>偏移一个指针大小</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **x = p; <span class="comment">//error****</span></span><br><span class="line"><span class="keyword">int</span> **x = q;  <span class="comment">//right</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4、const指针"><a href="#4、const指针" class="headerlink" title="4、const指针"></a>4、const指针</h3><p>​    const修饰的变量为只读属性，不能直接修改该变量的值</p>
<p>​    const指针</p>
<p>​    (1)const 数据类型 *指针变量名;</p>
<p>​         数据类型 const *指针变量名;    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//right</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error  *p被修饰为只读</span></span><br></pre></td></tr></table></figure>

<p>​        const修饰是指针指向的内容，不能修改指针指向的数据，但是可以修改指针变量中的地址值</p>
<p>​    </p>
<p>​    (2)数据类型 *  const  指针变量名；   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error p被修饰为只读</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//right</span></span><br></pre></td></tr></table></figure>

<p>​    const修饰的指针变量p，不能修改指针变量的值，但是可以修改指针指向内容的值</p>
<p>（3）const 数据类型 *  const  指针变量名；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error p被修饰为只读</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error *p被修饰为只读</span></span><br></pre></td></tr></table></figure>

<p>​    const同时修饰指针变量和指针指向内容，两者都不能修改</p>
<h3 id="5、void指针"><a href="#5、void指针" class="headerlink" title="5、void指针"></a>5、void指针</h3><p>​        void – 空类型，不确定类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br><span class="line">指针p中可以存放任意类型的地址值</span><br><span class="line">*p = <span class="number">2</span>;  <span class="comment">//error  void指针在使用之前需要将void类型指针强制转换为需要的类型</span></span><br><span class="line">*(<span class="keyword">int</span> *)p = <span class="number">2</span>; <span class="comment">//right</span></span><br></pre></td></tr></table></figure>



<h3 id="6、字符指针和字符串"><a href="#6、字符指针和字符串" class="headerlink" title="6、字符指针和字符串"></a>6、字符指针和字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">50</span>] = &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">&quot;hello&quot;</span>; <span class="comment">//right</span></span><br><span class="line">如果将一个字符串赋值给一个字符指针，相当于把该字符串的首地址赋值给字符指针变量</span><br><span class="line"></span><br><span class="line">注意：如果将一个字符串常量赋值给一个指针变量，那么通过该指针不能修改字符串每一个字符的值</span><br></pre></td></tr></table></figure>


<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>若有以下定义，且0≤i＜4，则不正确的赋值语句是<u>&emsp;B&emsp;</u>.<br>int b[4][6], *p, *q[4];<br>（A）q[i] = b[i];           （B） p = b;<br>（C）p = b[i]               （D） q[i] = &amp;b[0][0];</p>
<p>解：表示b的话要用二次指针来表示二维数组的地址。这样的话*p仅代表所对应的行地址</p>
<p>​    </p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>指针</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>day15-c函数，结构体</title>
    <url>/2023/03/12/day15-c%E5%87%BD%E6%95%B0%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="day15-c函数，结构体"><a href="#day15-c函数，结构体" class="headerlink" title=" day15-c函数，结构体"></a><font color="green"> day15-c函数，结构体</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><hr>
<h3 id="1、指针函数："><a href="#1、指针函数：" class="headerlink" title="1、指针函数："></a>1、指针函数：</h3><p>​    本质：是一个函数，指针函数的返回值是一个地址</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt;* 函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    代码模块;</span><br><span class="line">    <span class="keyword">return</span> 地址量; <span class="comment">//合法地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、函数指针："><a href="#2、函数指针：" class="headerlink" title="2、函数指针："></a>2、函数指针：</h3><p>​    本质：是一个指针，指向一个函数的首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义的一般形式：</span><br><span class="line">    &lt;数据类型&gt; (*函数指针变量名)(参数列表);</span><br><span class="line"></span><br><span class="line">	例：</span><br><span class="line">        <span class="keyword">int</span> (*p)(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">	数据类型：跟指针指向的函数的数据类型一致</span><br><span class="line">	参数列表：跟指针指向的函数的参数列表一致</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">p = add;  <span class="comment">//将函数add的首地址赋值给函数指针变量p</span></span><br><span class="line">(*p)(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//调用add函数传入实参为2和3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><h3 id="1、函数指针数组"><a href="#1、函数指针数组" class="headerlink" title="1、函数指针数组"></a>1、函数指针数组</h3><p>​    本质：是一个数组, 存放的全部都是函数指针类型的数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义的一般形式：</span><br><span class="line">    &lt;数据类型&gt; (*函数指针数组名[元素个数])(参数列表);</span><br><span class="line">	例：</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">		<span class="keyword">int</span> (*arr[<span class="number">2</span>])(<span class="keyword">int</span> x, <span class="keyword">int</span> y) = &#123;add, sub&#125;;</span><br><span class="line">        <span class="comment">//定义了一个名为arr的函数指针数组，数组中最多可以存放两个 int(* )(int, int)类型的数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、递归函数"><a href="#2、递归函数" class="headerlink" title="2、递归函数"></a>2、递归函数</h3><p>​    练习：计算一个正整数的阶乘，用函数封装功能</p>
<p>​    概念：在一个函数中直接或者间接调用函数本身</p>
<p>​    </p>
<p>​    递归函数的特点：</p>
<p>​            1：递推公式</p>
<p>​            2：设置有退出条件</p>
<p>​    优点：能够让代码整体更加简洁</p>
<p>​    缺点：需要消耗大量系统资源</p>
<p>​                必须要设置退出条件</p>
<h2 id="三、结构体"><a href="#三、结构体" class="headerlink" title="三、结构体"></a>三、结构体</h2><p>​    跟数组一样，是用户自定义的一种数据类型</p>
<p>​    结构体中可以存放多个不同数据类型的数据</p>
<h3 id="1、结构体的定义"><a href="#1、结构体的定义" class="headerlink" title="1、结构体的定义"></a>1、结构体的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> 结构体名</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">       数据类型 成员名<span class="number">1</span>;</span><br><span class="line">       数据类型 成员名<span class="number">2</span>;        	</span><br><span class="line">       数据类型 成员名<span class="number">3</span>; </span><br><span class="line">        ......</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	例：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">char</span> name[<span class="number">50</span>]; </span><br><span class="line">            <span class="keyword">int</span>	age;</span><br><span class="line">            <span class="keyword">char</span> sex;</span><br><span class="line">            <span class="keyword">double</span> height;</span><br><span class="line">            <span class="keyword">char</span> address[<span class="number">50</span>];</span><br><span class="line">            <span class="keyword">char</span> hobby[<span class="number">50</span>];</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2、结构体变量"><a href="#2、结构体变量" class="headerlink" title="2、结构体变量"></a>2、结构体变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> 结构体名 结构体变量名;</span></span><br><span class="line">	例：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu2</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、访问结构体成员"><a href="#3、访问结构体成员" class="headerlink" title="3、访问结构体成员"></a>3、访问结构体成员</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    结构体变量名.成员名;  </span><br><span class="line">	stu1.age = <span class="number">18</span>;  <span class="comment">//访问1号学生stu1中的年龄，赋值为18；	</span></span><br></pre></td></tr></table></figure>

<h3 id="4、结构体变量的初始化"><a href="#4、结构体变量的初始化" class="headerlink" title="4、结构体变量的初始化"></a>4、结构体变量的初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 结构体变量名 = &#123;</span>依次给每一个成员赋值&#125;;  <span class="comment">//成员之间用逗号隔开</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu2</span> = &#123;</span><span class="string">&quot;张三&quot;</span>, <span class="number">19</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">182.1</span>, <span class="string">&quot;成都&quot;</span>, <span class="string">&quot;sing and dance&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5、结构体指针"><a href="#5、结构体指针" class="headerlink" title="5、结构体指针"></a>5、结构体指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">p</span> = &amp;<span class="title">stu1</span>;</span></span><br><span class="line">(*p).name       <span class="comment">//stu1中的name成员</span></span><br><span class="line">p-&gt;name == (*p).name</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c语言</tag>
        <tag>函数</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>day17-Linux基础</title>
    <url>/2023/03/14/day17-Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="day17-linux基础"><a href="#day17-linux基础" class="headerlink" title="day17-linux基础"></a><font color="green">day17-linux基础</font></h1><hr>
<h2 id="一、复习补充："><a href="#一、复习补充：" class="headerlink" title="一、复习补充："></a>一、复习补充：</h2><p>缩进：</p>
<p>命令行模式：gg=G</p>
<p>可视化模式：v，上下键选中要对齐的代码，按=</p>
<p>底行模式：set nonumber  不显示行号，set number 显示行号</p>
<a id="more"></a>

<br>
<br>

<hr>
<h2 id="二、tar-归档和释放"><a href="#二、tar-归档和释放" class="headerlink" title="二、tar-归档和释放"></a>二、tar-归档和释放</h2><blockquote>
<p>tar<br>-c   创建归档文件<br>-v   显示归档或释放过程<br>-x   释放归档文件<br>-f   用户指定归档文件的文件名，否则使用默认名称<br>-j   以bzip2方式压缩<br>-z   以gzip方式压缩<br>    tar -czvf  要压缩或归档之后的文件名 目标文件名<br>    tar -xvf   目标文件名</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="三、diff"><a href="#三、diff" class="headerlink" title="三、diff"></a>三、diff</h2><p>比较文件的不同</p>
<br>
<br>

<hr>
<h2 id="四、grep–查询"><a href="#四、grep–查询" class="headerlink" title="四、grep–查询"></a>四、grep–查询</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grep  查询的字符串 查询文件名---查询特定文件的内容</span><br><span class="line">grep  -r 查询的字符串 路径----查询一个路径下所有文件的内容</span><br></pre></td></tr></table></figure>

<p> wc</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wc 文件名： 行数 单词个数 单个字符个数 文件名</span><br><span class="line"> -l：只查看行数</span><br><span class="line"> -w：只查看单词个数（看空格)</span><br><span class="line"> -c：只查看单个字符个数</span><br></pre></td></tr></table></figure>


<br>
<br>

<hr>
<h2 id="五、工具："><a href="#五、工具：" class="headerlink" title="五、工具："></a>五、工具：</h2><p>vi编辑器</p>
<p>gedit编辑器</p>
<p>gcc编译器</p>
<h2 id="1-下载工具："><a href="#1-下载工具：" class="headerlink" title="1.下载工具："></a>1.下载工具：</h2><blockquote>
<p>deb（常用的） —-Debian<br>rpm（小红帽）—-Redhat</p>
</blockquote>
<br>

<h3 id="（1）dpkg工具—-离线下载，没有依赖文件"><a href="#（1）dpkg工具—-离线下载，没有依赖文件" class="headerlink" title="（1）dpkg工具—-离线下载，没有依赖文件"></a>（1）dpkg工具—-离线下载，没有依赖文件</h3><p>sudo—-暂时赋予用户权限，密码初始都为1，但是不显示密码的输入，确保输出按回车就可以了</p>
<p>dpkg都要加sudo</p>
<blockquote>
<p>sudo dpkg -i 安装包—下载<br>sudo dpkg -r 软件名—卸载</p>
</blockquote>
<br>


<h3 id="（2）apt工具—在线下载"><a href="#（2）apt工具—在线下载" class="headerlink" title="（2）apt工具—在线下载"></a>（2）apt工具—在线下载</h3><p>下载：</p>
<blockquote>
<p>sudo apt-get install sl–跑火车<br>sudo apt-get install frozen-bubble–泡泡龙<br>sudo apt-get install cmatrix–代码雨<br>sudo  apt-get install fortune—-名人名言<br>sudo  apt-get install fortunes-zh—-名人名言（中文）<br>sudo  apt-get install lolcat—-有颜色显示<br>fortune | lolcat<br>卸载：sudo apt-get remove 软件名</p>
</blockquote>
<br>

<h3 id="（3）创建共享文件夹："><a href="#（3）创建共享文件夹：" class="headerlink" title="（3）创建共享文件夹："></a>（3）创建共享文件夹：</h3><ol>
<li>选择虚拟机左上菜单的虚拟机选项，点击设置</li>
<li>点击选项，找到共享文件夹，选择总是启用</li>
<li>点击添加，跟着下一步，选择主机（windows）的一个文件作为自己的共享文件夹</li>
<li>点击完成，点击确定，最后在<code>/mnt/hgfs</code>查看有没有</li>
</ol>
<h3 id="（4）网络配置："><a href="#（4）网络配置：" class="headerlink" title="（4）网络配置："></a>（4）网络配置：</h3><p>ping–能不能网络通信</p>
<p>ping +IP地址</p>
<ol>
<li>点击虚拟机菜单的编辑，选择虚拟网络编辑</li>
<li>点击更改设置（如果没有，直接选择桥接模式），选择桥接模式</li>
<li>在桥接模式下选择自己windos网络的描述名字，点击确定</li>
<li>点击虚拟机，选择设置，找到网络适配器，选择自定义模式，选择自己的网络名称(一般为VMnet0)，点击确定</li>
<li>进入linux系统，断开重连网络（重启网络）</li>
</ol>
<p>或者：在终端上输入：</p>
<p>sudo service network-manager restart</p>
<blockquote>
<p>ifconfig—查看linux系统的IP地址<br>ipconfig—查看windows系统的IP地址</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2.用户管理"></a>2.用户管理</h2><p>(1) 超级用户：</p>
<blockquote>
<p>su，开通了所有权限，我们一般不在这里工作，因为一旦删除，找不回来，也容易操作到内核上的东西<br>exit：退出超级用户</p>
</blockquote>
<p>(2)查看</p>
<blockquote>
<p>查看用户—vi /etc/passwd<br>查看用户组–vi /etc/group</p>
</blockquote>
<p>(3)添加用户：</p>
<blockquote>
<p>adduser 新添用户名<br>输入密码，不显示，确保输入按回车<br>su 用户名—-进入该用户</p>
</blockquote>
<p>(4)删除用户<br>deluser 用户名，但是我们一般进入passwd和group这两个文件去删除 <strong>（加sudo）</strong></p>
<p>(5)修改密码：passwd</p>
<br>
<br>

<hr>
<h2 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3.进程管理"></a>3.进程管理</h2><blockquote>
<p>ps   查看前台的进程<br>ps -aux  查看所有进程<br>pstree—以树的形式展示进程<br>top—查看进程（从占用cpu最大开始展示），类似于任务管理器<br>kill -9 进程号   —-杀死进程</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="4-shell的特殊字符"><a href="#4-shell的特殊字符" class="headerlink" title="4.shell的特殊字符"></a>4.shell的特殊字符</h2><p>（1）|—管道</p>
<p>指令1 | 指令2—-把指令1的输出作为指令2的输入</p>
<p>fortune | lolcat</p>
<p>（2）` &emsp; `—命令置换<br>指令1 ` &emsp; `    把命令置换里面的内容作为指令1的参数<br>    echo `ls`</p>
<p>（3）echo–终端的输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo hello    world---会自动缩进空格字符串之间保留一个空格</span><br><span class="line">echo &#x27;hello    world&#x27;---原样输出</span><br><span class="line">echo <span class="string">&quot;hello    world&quot;</span>---原样输出</span><br></pre></td></tr></table></figure>
<p>（4）输入输出重定向</p>
<blockquote>
<p>&gt;:<br>cat &gt;1.c（覆盖输入）<br> &gt;&gt;:<br>cat &gt;&gt;1.c（追加输入）</p>
</blockquote>
<p>注：输入都是读取的键盘输入</p>
<p>（5）通配符：</p>
<ul>
<li>*—匹配所有字符串</li>
<li>{起始..结束}–可以创建起始到结束的文件</li>
<li>touch {1..10}.c—-创建1到10的.c文件</li>
<li>rm 【13579】.c—-删除了1.c 3.c 5.c 7.c 9.c</li>
<li>rm [1-5].c—-删除了1.c2.c3.c4.c5.c</li>
<li>rm [^8].c—-删除除了8.c的文件,也只能通配一个</li>
<li>？—匹配一个字符串<br>rm h？llo.c—删除hello.c hrllo.c</li>
</ul>
<p>（6）其他</p>
<p>shutdown—关机</p>
<p>shutdown -r now—重启</p>
<p>vm上的快照–相当于备份</p>
<br>
<br>

<hr>
<h2 id="5-shell脚本："><a href="#5-shell脚本：" class="headerlink" title="5.shell脚本："></a>5.shell脚本：</h2><p>（1）本质：shell命令的有序集合</p>
<p>解释型语言（python，shell脚本）</p>
<p>不会检查错误，但是会显示出错误，出现错误会继续执行后面的语句</p>
<p>需要一个解释器（shell的是bash）</p>
<p>编译型语言（c语言，c++）</p>
<p>编译会报错，一旦错误会停止进程</p>
<p>（2）怎么去写一个shell脚本：</p>
<ol>
<li><p>创建一个.sh的文件（也可以没有后缀名）</p>
</li>
<li><p>写shell命令</p>
</li>
<li><p>执行:</p>
</li>
</ol>
<p>&emsp;&emsp;&emsp;&emsp;a. 通过bash这个解释器来执行，直接bash+要执行的文件</p>
<p>&emsp;&emsp;&emsp;&emsp;b. 通过chmod给shell文件添加执行权限，然后再执行</p>
<p><strong>注：第一行一般写：<code>#!/bin/bash</code>，我们解释器的路径</strong></p>
<p>练习：复制上一级目录的1.c 2.c到当前目录下，然后把hello world写入1.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> cd ../</span><br><span class="line">  <span class="number">4</span> touch <span class="number">1.</span>c <span class="number">2.</span>c</span><br><span class="line">  <span class="number">5</span> cp [<span class="number">12</span>].c day2</span><br><span class="line">  <span class="number">6</span> echo <span class="string">&quot;hello world&quot;</span> &gt;day2/<span class="number">1.</span>c</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）shell变量</p>
<ul>
<li>自定义变量</li>
</ul>
<p>没有数据类型，默认为字符串类型</p>
<p>赋值不能隔开</p>
<p>变量名=值</p>
<p>没有分号，换行就相当于分号</p>
<p>变量的调用需要加钱$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>位置变量</li>
</ul>
<p>命令行参数的变量，即命令即后面的参数作为变量 从bash后面的那个开始为0</p>
<p>从终端传递参数给shell脚本</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">从$<span class="number">0</span>开始到$<span class="number">9</span>如果要打印<span class="number">9</span>以后的变量需要加&#123;&#125;，例如$&#123;<span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>环境变量</li>
</ul>
<p>计算机定义好了的变量</p>
<p>env可以查看所有环境变量</p>
<p>调用需要加$</p>
<p><strong>注：shell中0是真，1是假</strong></p>
<h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>计算机给一些特殊变量赋予特殊意义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$*--打印的是命令行参数的所有变量，不包括$<span class="number">0</span></span><br><span class="line">$@--打印的是命令行参数的所有变量，不包括$<span class="number">0</span></span><br><span class="line">$#--打印的是命令行参数的个数，不包括$<span class="number">0</span></span><br><span class="line">$?--打印上一次的返回状态（<span class="number">0</span>代表真，<span class="number">1</span>代表假）</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day16-Linux基础</title>
    <url>/2023/03/13/day16-Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="day16-linux基础"><a href="#day16-linux基础" class="headerlink" title="day16-linux基础"></a><font color="green">day16-linux基础</font></h1><hr>
<h2 id="一、嵌入式："><a href="#一、嵌入式：" class="headerlink" title="一、嵌入式："></a>一、嵌入式：</h2><p>以应用为中心，以计算机为基础，软硬件可裁剪，适用于对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统</p>
<a id="more"></a>
<h3 id="1-linux系统："><a href="#1-linux系统：" class="headerlink" title="1.linux系统："></a>1.linux系统：</h3><p>特点：开源、安全性、可移植性</p>
<h3 id="2-linux体系结构："><a href="#2-linux体系结构：" class="headerlink" title="2.linux体系结构："></a>2.linux体系结构：</h3><p>文件结构：最大的为根目录（/），</p>
<blockquote>
<p>home：家目录，给用户工作的目录<br>（~）：权限没有开通完，需要权限需要加sudo<br>dev：设备文件<br>etc：配置文件</p>
</blockquote>
<h3 id="3-vi的配置："><a href="#3-vi的配置：" class="headerlink" title="3.vi的配置："></a>3.vi的配置：</h3><p>vi .vimrc（~下）配置vi的初始化</p>
<blockquote>
<p>boot：启动文件<br>root：权限文件<br>lib：库文件<br>mnt：挂载文件</p>
</blockquote>
<hr>
<br>
<br>

<h2 id="二、shell命令"><a href="#二、shell命令" class="headerlink" title="二、shell命令"></a>二、shell命令</h2><h3 id="1-文件的查看"><a href="#1-文件的查看" class="headerlink" title="1.文件的查看"></a>1.文件的查看</h3><blockquote>
<p>我是谁—whoami<br>我在哪儿—pwd<br>我有什么—-ls</p>
<blockquote>
<p>ls -a—显示所有文件，包括隐藏文件<br>ls -l—显示文件信息</p>
</blockquote>
</blockquote>
<br>

<blockquote>
<p><font color="blue">蓝色</font>：目录文件<br>白色：普通文件<br><font color="green">绿色</font>：可执行文件<br><font color="red">红色</font>：压缩文件<br><font color="#00FFFF">浅蓝</font>：链接文件</p>
</blockquote>
<p>文件的类型：</p>
<p>lsp-bcd</p>
<br>

<h3 id="2-文件的权限："><a href="#2-文件的权限：" class="headerlink" title="2.文件的权限："></a>2.文件的权限：</h3><p>rwxrwxrwx</p>
<p>前三个：用户自己的权限，中间三个，用户组的权限，最后三个，其他用户的权限</p>
<p>ls -R–以遍历的方式查看文件</p>
<br>

<h3 id="3-目录的移动"><a href="#3-目录的移动" class="headerlink" title="3.目录的移动"></a>3.目录的移动</h3><p>我要去哪儿—-cd</p>
<p>cd +路径  (如果直接加文件名，默认从当前路径下去进入)</p>
<p>./—当前路径</p>
<p>../—上一级路径</p>
<p>直接cd，回到家目录（~）<br><br></p>
<h3 id="4-文件的修改"><a href="#4-文件的修改" class="headerlink" title="4.文件的修改"></a>4.文件的修改</h3><blockquote>
<p>mkdir-rmdir：创建-删除目录（里面有文件时不行）<br>rm -r ：（删除目录下所有的文件）<br>touch：创建但不打开文件<br>vi、vim ：打开vim编辑器<br>cat：查看文件内容<br>head：默认查看前十行的内容<br>head -n 文件名：查看文件前n行的内容<br>tail：默认查看后十行的内容<br>tail -n 文件名：查看文件后n行的内容<br>mv：可以充当重命名文件名的作用<br>cp 1.c 2.c：如果没有后面的复制文件，会先创建文件再复制<br>man：查看帮助</p>
</blockquote>
<br>

<hr>
<h2 id="三、编辑器："><a href="#三、编辑器：" class="headerlink" title="三、编辑器："></a>三、编辑器：</h2><p>vi/vim编辑器</p>
<p>vi +文件名—打开这个文件，如果没有这个文件，先去创建再打开</p>
<p>1.命令行模式：yy，nyy，p，dd，ndd，u</p>
<p>2.插入模式：</p>
<blockquote>
<p>i：从光标当前位置开始插入<br>a：追加，从光标下一位开始插入<br>o：从光标下一行开始插入<br>esc：退出插入模式，回到的是命令行模式</p>
</blockquote>
<p>3.底行模式：</p>
<blockquote>
<p>wq，！q，x<br>s/字符串1/字符串2 ：只替换从光标当前所在行的第一个字符串1<br>%s/字符串1/字符串2:替换文件每一行的第一个字符串1<br>%s/字符串1/字符串2/g:替换文件所有的字符串1<br>vsp+文件名：在当前的vi编辑器打开另一个文件<br>ctrl+w—-切换光标的位置<br>退出vsp：wq<br>set mouse = a—让光标跟着鼠标移动<br>set mouse -= a—让光标不跟着鼠标移动<br>gedit编辑器：没有配置，操作起来相对简单一点，类似于word文档</p>
</blockquote>
<br>

<hr>
<h2 id="四、gcc编译器："><a href="#四、gcc编译器：" class="headerlink" title="四、gcc编译器："></a>四、gcc编译器：</h2><blockquote>
<p>四个步骤：<br>1、预处理—处理要用到的头文件和宏定义<br>gcc -E 1.c -o 1.i<br>2、编译—检查代码的错误<br>gcc -S 1.i -o 1.s<br>3、汇编—将文件变成计算机能够识别的二进制文件<br>gcc -c 1.s -o 1.o<br>4、链接—生成执行文件<br>gcc 1.o -o 1</p>
</blockquote>
<p>选项：</p>
<blockquote>
<p>-o：修改执行文件名<br>-Wall：显示所有警告<br>-w：隐藏所有警告</p>
</blockquote>
<br>

<hr>
<h2 id="五、快捷键："><a href="#五、快捷键：" class="headerlink" title="五、快捷键："></a>五、快捷键：</h2><blockquote>
<p>ctrl+l：清屏，翻页，鼠标往上滑还是能看到（clear–但是看不到之前的）<br>ctrl+shift+t：并列打开一个终端（ctrl+shift+n）<br>ctrl+c：结束当前进程回到终端<br>ctrl+z：暂停当前进程回到终端<br>ctrl+空格：切换中英文（可以修改）<br>上下键：翻找历史指令<br>alt+tab：切换终端</p>
</blockquote>
<br>

<hr>
<h2 id="六、文件管理"><a href="#六、文件管理" class="headerlink" title="六、文件管理"></a>六、文件管理</h2><h3 id="1-文件的类型："><a href="#1-文件的类型：" class="headerlink" title="1.文件的类型："></a>1.文件的类型：</h3><p>lsp-bcd</p>
<br>

<h3 id="2-文件的权限：-1"><a href="#2-文件的权限：-1" class="headerlink" title="2.文件的权限："></a>2.文件的权限：</h3><p>rwxrwxrwx</p>
<p>前三个：用户自己的权限，中间三个，用户组的权限，最后三个，其他用户的权限</p>
<br>

<h3 id="3-chmod–修改文件权限"><a href="#3-chmod–修改文件权限" class="headerlink" title="3.chmod–修改文件权限"></a>3.chmod–修改文件权限</h3><p>第一种方式：chmod u+x 文件名—-给当前用户增加执行权限</p>
<p>如果不加u，默认给所有用户加权限</p>
<blockquote>
<p>u–用户自己<br>g—用户组<br>o—其他用户</p>
</blockquote>
<p>第二种方式：chmod 0777 文件名</p>
<br>

<h3 id="4-链接文件–ln"><a href="#4-链接文件–ln" class="headerlink" title="4.链接文件–ln"></a>4.链接文件–ln</h3><p>（1）硬链接：</p>
<p>ln 文件名 硬链接文件名</p>
<p>硬链接如果把本体文件删掉，依旧可以单独使用，类型和原文件一模一样，移动原文件也依旧可以执行</p>
<p>（2）软链接：</p>
<p>ln -s 文件名 软链接文件名 </p>
<p>大大缩小了文件的大小，如果把本体文件删除或者移动，软链接失效</p>
<br>

<h3 id="5-文件的压缩与解压"><a href="#5-文件的压缩与解压" class="headerlink" title="5.文件的压缩与解压"></a>5.文件的压缩与解压</h3><blockquote>
<p>gzip—压缩文件，原文件被替换成压缩之后的文件，，会生成一个.gz的压缩文件，用vi能看到源文件内容，用cat在终端查看乱码<br>gunzip—解压文件<br>bzip2—压缩文件，原文件被替换成压缩之后的文件，，会生成一个.bz2的压缩文件，压缩功能相对于gzip较弱，但是压缩时间缩短<br>bunzip–解压文件<br>xz—压缩文件，原文件被替换成压缩之后的文件，，会生成一个.xz的压缩文件，压缩功能相对于gzip较弱，但是压缩时间缩短<br>unxz–解压文件</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day18-Linux基础,shell脚本</title>
    <url>/2023/03/15/day18-Linux%E5%9F%BA%E7%A1%80,shell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="day18-linux基础-shell脚本"><a href="#day18-linux基础-shell脚本" class="headerlink" title="day18-linux基础,shell脚本"></a><font color="green">day18-linux基础,shell脚本</font></h1><br>
<br>


<hr>
<h2 id="一、变量的四则运算："><a href="#一、变量的四则运算：" class="headerlink" title="一、变量的四则运算："></a>一、变量的四则运算：</h2><a id="more"></a>
<ol>
<li>（（ &emsp; ））</li>
</ol>
<p>不能进行浮点型的运算</p>
<p>调用的时候需要加钱$</p>
<p>可以进型幂数运算</p>
<p>可以进行自加自减</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> a=$(( <span class="number">3</span>**<span class="number">3</span>)) <span class="comment">//3的3次方</span></span><br><span class="line"> <span class="number">4</span> echo $a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>【&emsp;】</li>
</ol>
<p>不能进行浮点型的运算</p>
<p>调用的时候需要加钱$</p>
<p>可以进型幂数运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> a=$[ <span class="number">3</span>+<span class="number">3</span>]</span><br><span class="line"><span class="number">4</span> echo $a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>expr</li>
</ol>
<p>需要命令置换符置换出来结果` &emsp; `</p>
<p>算数之间需要空开</p>
<p>当进行乘法的时候需要用\区分</p>
<p>没有幂数运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=`expr <span class="number">1</span> \* <span class="number">2</span>`</span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>练习：运算出a=3的3次方的值，b=5*7的值，交换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=$((<span class="number">3</span>**<span class="number">3</span>))</span><br><span class="line">  <span class="number">4</span> b=`expr <span class="number">5</span> \* $((<span class="number">4</span>+<span class="number">2</span>))`</span><br><span class="line">  <span class="number">5</span> c=$a</span><br><span class="line">  <span class="number">6</span> a=$b</span><br><span class="line">  <span class="number">7</span> b=$c</span><br><span class="line">  <span class="number">8</span> echo a=$&#123;a&#125;b=$b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="二、shell-语句"><a href="#二、shell-语句" class="headerlink" title="二、shell 语句"></a>二、shell 语句</h2><h3 id="1-解释性语句"><a href="#1-解释性语句" class="headerlink" title="1. 解释性语句"></a>1. 解释性语句</h3><ul>
<li>#注释一行</li>
<li>:&lt;&lt;!注释多行<br>注释的shell语句<br>！</li>
<li>：&lt;&lt;EOF<br>注释的shell语句<br>EOF</li>
</ul>
<h3 id="2-功能性语句"><a href="#2-功能性语句" class="headerlink" title="2.功能性语句"></a>2.功能性语句</h3><h4 id="（1）test"><a href="#（1）test" class="headerlink" title="（1）test"></a>（1）test</h4><p>结构：字符串 整型 文件</p>
<ul>
<li>字符串的比较：</li>
</ul>
<blockquote>
<p>test 字符串1 = 字符串2    —-比较两个字符串是否相等<br>test 字符串1 ！= 字符串2    —-比较两个字符串是否不相等<br>test -z 字符串—判断字符串为不为空<br>test -n 字符串—判断字符串是否不为空</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=<span class="string">&quot;hello&quot;</span></span><br><span class="line">  <span class="number">4</span> b=<span class="string">&quot;hello&quot;</span></span><br><span class="line">  <span class="number">5</span> test $a != $b</span><br><span class="line">  <span class="number">6</span> test -z $a</span><br><span class="line">  <span class="number">7</span> test -n $a</span><br><span class="line">  <span class="number">8</span> echo $?</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>整型的比较</li>
</ul>
<blockquote>
<p>-eq—等于<br>-ne—不等于<br>-gt—大于<br>-lt–小于<br>-ge—大于等于<br>-le—小于等于</p>
</blockquote>
<ul>
<li>文件的比较</li>
</ul>
<blockquote>
<p>-e —判断文件是否存在<br>-f—判断文件是否是普通文件<br>-L—判断文件是否是链接文件<br>-S—判断文件是否是套接字文件<br>-b—判断文件是否是块文件<br>-c—判断文件是否是字符文件<br>-d—判断文件是否是目录文件<br>-p—判断文件是否为管道文件</p>
</blockquote>
<ul>
<li>文件的权限：</li>
</ul>
<blockquote>
<p>-r–判断文件是否有可读权限<br>-w—判断文件是否有可写权限<br>-x—判断文件是否有可执行权限<br>文件1  -nt  文件2–判断文件1是否比文件2新（时间戳）<br>文件1  -ot  文件2–判断文件1是否比文件2旧（时间戳）</p>
</blockquote>
<ul>
<li>逻辑<blockquote>
<p>-o—或<br>-a—与</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> test -d $<span class="number">1</span> -a -f $<span class="number">2</span></span><br><span class="line">  <span class="number">4</span> echo $?</span><br><span class="line">~           </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="（2）read"><a href="#（2）read" class="headerlink" title="（2）read"></a>（2）read</h4><p>把终端上的输入传给参数</p>
<p>read 变量1 变量2 </p>
<p>read -p “提示” 变量名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> read -p <span class="string">&quot;please input tow numbern:&quot;</span> a b</span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line">  <span class="number">5</span> echo $b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>read -t  时间 变量名—限制时间输入</p>
<p>超过时间会自动结束（以秒为单位）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> read -t <span class="number">5</span> a b</span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line">  <span class="number">5</span> echo $b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>read -n –限制输入的个数,超过个数也会自动结束</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> read -n <span class="number">1</span> a b</span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line">  <span class="number">5</span> echo $b</span><br><span class="line">~           </span><br></pre></td></tr></table></figure>

<p>read -s —隐藏输入</p>
<br>

<h3 id="3-shell的控制语句"><a href="#3-shell的控制语句" class="headerlink" title="3. shell的控制语句"></a>3. shell的控制语句</h3><h4 id="（1）if"><a href="#（1）if" class="headerlink" title="（1）if"></a>（1）if</h4><p>第一种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>[]</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">​    shell语句；</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong><font color="red">注意：if和【】之间要隔一个空，表达式和【】也要隔一个空</font></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=<span class="number">56</span></span><br><span class="line">  <span class="number">4</span> b=<span class="number">34</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">if</span> [ $a -gt $b ]</span><br><span class="line">  <span class="number">6</span> then</span><br><span class="line">  <span class="number">7</span>     echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line">  <span class="number">8</span> fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> test语句</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">​    shell语句；</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> a=<span class="number">56</span></span><br><span class="line"><span class="number">4</span> b=<span class="number">34</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">if</span> test $a -gt $b</span><br><span class="line"><span class="number">6</span> then</span><br><span class="line"><span class="number">7</span>     echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="number">8</span> fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>if - elif-else</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> read a b</span><br><span class="line">  <span class="number">4</span> <span class="keyword">if</span> test $a -gt $b</span><br><span class="line">  <span class="number">5</span> then</span><br><span class="line">  <span class="number">6</span>     echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line">  <span class="number">7</span> elif test $a -eq $b</span><br><span class="line">  <span class="number">8</span> then</span><br><span class="line">  <span class="number">9</span>     echo <span class="string">&quot;zhangcheng&quot;</span></span><br><span class="line"> <span class="number">10</span> <span class="keyword">else</span></span><br><span class="line"> <span class="number">11</span>     echo <span class="string">&quot;day3&quot;</span></span><br><span class="line"> <span class="number">12</span> fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>练习：输入一个文件名。判断这个文件是否存在，如果不存在，就创建，判断是否有可写权限，如果有，就把helloworld 写进去，如果没有，赋予可写权限，再写进去，如果存在就写入helloworld</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> read -p <span class="string">&quot;please input a filename:&quot;</span> file</span><br><span class="line"> <span class="number">4</span> <span class="keyword">if</span> test -e $file</span><br><span class="line"> <span class="number">5</span> then</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">if</span> test -w $file</span><br><span class="line"> <span class="number">7</span>     then</span><br><span class="line"> <span class="number">8</span>        echo <span class="string">&quot;hello world&quot;</span>&gt;&gt;$file <span class="comment">//注意别忘了echo</span></span><br><span class="line"> <span class="number">9</span>    <span class="keyword">else</span></span><br><span class="line"><span class="number">10</span>        chmod +w $file</span><br><span class="line"><span class="number">11</span>        echo <span class="string">&quot;hello world&quot;</span>&gt;&gt;$file</span><br><span class="line"><span class="number">12</span>     fi</span><br><span class="line"><span class="number">13</span> <span class="keyword">else</span></span><br><span class="line"><span class="number">14</span>     touch $file</span><br><span class="line"><span class="number">15</span>     echo <span class="string">&quot;hello world&quot;</span>&gt;&gt;$file</span><br><span class="line"><span class="number">16</span> fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 表达式 in</span><br><span class="line"></span><br><span class="line">​           表达式）</span><br><span class="line"></span><br><span class="line">​              shell语句</span><br><span class="line"></span><br><span class="line">​               ；；</span><br><span class="line"></span><br><span class="line">表达式）</span><br><span class="line"></span><br><span class="line">​      shell语句</span><br><span class="line"></span><br><span class="line">​      ；；</span><br><span class="line"></span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">3</span> read a</span><br><span class="line"> <span class="number">4</span> <span class="keyword">case</span>  $a in</span><br><span class="line"> <span class="number">5</span>     <span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>)</span><br><span class="line"> <span class="number">6</span>         echo <span class="string">&quot;星期一&quot;</span></span><br><span class="line"> <span class="number">7</span>         ;;</span><br><span class="line"> <span class="number">8</span>     <span class="number">2</span>)</span><br><span class="line"> <span class="number">9</span>         echo <span class="string">&quot;星期二&quot;</span></span><br><span class="line"><span class="number">10</span>         ;;</span><br><span class="line"><span class="number">11</span>     <span class="number">3</span>)</span><br><span class="line"><span class="number">12</span>         echo <span class="string">&quot;星期三&quot;</span></span><br><span class="line"><span class="number">13</span>         ;;</span><br><span class="line"><span class="number">14</span>     <span class="number">4</span>)</span><br><span class="line"><span class="number">15</span>         echo <span class="string">&quot;星期四&quot;</span></span><br><span class="line"><span class="number">16</span>         ;;</span><br><span class="line"><span class="number">17</span>     <span class="number">5</span>)</span><br><span class="line"><span class="number">18</span>         echo <span class="string">&quot;星期五&quot;</span></span><br><span class="line"><span class="number">19</span>         ;;</span><br><span class="line"><span class="number">20</span>     <span class="number">6</span>)</span><br><span class="line"><span class="number">21</span>         echo <span class="string">&quot;星期六&quot;</span></span><br><span class="line"><span class="number">22</span>         ;;</span><br><span class="line"><span class="number">23</span>     <span class="number">7</span>)</span><br><span class="line"><span class="number">24</span>         echo <span class="string">&quot;星期天&quot;</span></span><br><span class="line"><span class="number">25</span>         ;;</span><br><span class="line">       *)</span><br><span class="line"><span class="number">27</span>         echo <span class="string">&quot;asdads&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">26</span> esac</span><br></pre></td></tr></table></figure>

<p>用【】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read a</span><br><span class="line">  <span class="number">4</span> <span class="keyword">case</span>  $a in</span><br><span class="line">  <span class="number">5</span>     [a-zA-Z])</span><br><span class="line">  <span class="number">6</span>         echo <span class="string">&quot;星期一&quot;</span></span><br><span class="line">  <span class="number">7</span>         ;;</span><br><span class="line">  <span class="number">8</span>     [zbc])</span><br><span class="line">  <span class="number">9</span>         echo <span class="string">&quot;星期二&quot;</span></span><br><span class="line"> <span class="number">10</span>         ;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>练习：模拟一个应用下载</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> read -p <span class="string">&quot;请选择要下载的应用:&quot;</span> app</span><br><span class="line"> <span class="number">4</span> read -p <span class="string">&quot;请确认是否下载y|n|q)&quot;</span> chioce</span><br><span class="line"> <span class="number">5</span> <span class="keyword">case</span> $chioce in</span><br><span class="line"> <span class="number">6</span>     Y|y|yes)</span><br><span class="line"> <span class="number">7</span>         echo <span class="string">&quot;$app正在下载中.....&quot;</span></span><br><span class="line"> <span class="number">8</span>         ;;</span><br><span class="line"> <span class="number">9</span>     N|n|no)</span><br><span class="line"><span class="number">10</span>         echo <span class="string">&quot;取消下载$app&quot;</span></span><br><span class="line"><span class="number">11</span>         ;;</span><br><span class="line"><span class="number">12</span>     *)</span><br><span class="line"><span class="number">13</span>         echo <span class="string">&quot;退出&quot;</span></span><br><span class="line"><span class="number">14</span> esac</span><br><span class="line"><span class="number">15</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="（2）循环语句"><a href="#（2）循环语句" class="headerlink" title="（2）循环语句"></a>（2）循环语句</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 表达式</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">shell语句</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=<span class="number">5</span></span><br><span class="line">  <span class="number">4</span> <span class="keyword">while</span> test $a -gt <span class="number">0</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">  <span class="number">6</span>     ((a--))</span><br><span class="line">  <span class="number">7</span>     echo $a</span><br><span class="line">  <span class="number">8</span> done</span><br></pre></td></tr></table></figure>

<p>死循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">shell语句</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>for循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（（表达式<span class="number">1</span>；表达式<span class="number">2</span>；表达式<span class="number">3</span>））</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">shell语句</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> </span><br><span class="line">  <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++))</span><br><span class="line">  <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line">  <span class="number">7</span>     echo $i</span><br><span class="line">  <span class="number">8</span> done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二种</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 in 单词表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">shell语句</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> </span><br><span class="line">  <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">for</span> i in he li oi asda adsa ada ad</span><br><span class="line">  <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line">  <span class="number">7</span>     echo $i</span><br><span class="line">  <span class="number">8</span> done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>连续的</p>
<p>for 变量 in {起始..结束}</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">for</span> i in &#123;a..z&#125;</span><br><span class="line"> <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">7</span>     echo $i</span><br><span class="line"> <span class="number">8</span> done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>for 变量 in ``</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">for</span> i in `ls`</span><br><span class="line"> <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">7</span>     echo $i</span><br><span class="line"> <span class="number">8</span> done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>练习：求1到100的和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> sum=<span class="number">0</span></span><br><span class="line"> <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;<span class="number">101</span>;i++))</span><br><span class="line"> <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">7</span>     sum=$(($sum+$i))</span><br><span class="line"> <span class="number">8</span> done</span><br><span class="line"> <span class="number">9</span> echo <span class="string">&quot;sum=$sum&quot;</span></span><br><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> sum=<span class="number">0</span></span><br><span class="line"> <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;<span class="number">101</span>;i++))</span><br><span class="line"> <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">7</span>     sum=`expr $sum + $i`</span><br><span class="line"> <span class="number">8</span> done</span><br><span class="line"> <span class="number">9</span> echo <span class="string">&quot;sum=$sum&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="三、shell数组"><a href="#三、shell数组" class="headerlink" title="三、shell数组"></a>三、shell数组</h2><p>shell脚本里面只有一维数组</p>
<p>没有数据类型</p>
<h3 id="1-数组的初始化"><a href="#1-数组的初始化" class="headerlink" title="1. 数组的初始化"></a>1. 数组的初始化</h3><p>数组名=（元素1 元素2 元素3.。。。）</p>
<h3 id="2-数组的赋值："><a href="#2-数组的赋值：" class="headerlink" title="2. 数组的赋值："></a>2. 数组的赋值：</h3><p>数组名【下标】=内容</p>
<h3 id="3-数组的调用："><a href="#3-数组的调用：" class="headerlink" title="3. 数组的调用："></a>3. 数组的调用：</h3><p>${数组名【下标】}</p>
<h3 id="4-数组的遍历："><a href="#4-数组的遍历：" class="headerlink" title="4. 数组的遍历："></a>4. 数组的遍历：</h3><p>循环遍历</p>
<p>${arr[*]}</p>
<p>${arr[@]}</p>
<h3 id="5-求数组的长度："><a href="#5-求数组的长度：" class="headerlink" title="5. 求数组的长度："></a>5. 求数组的长度：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$&#123;<span class="meta">#arr[*]&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> arr=(hello world nihao shijie)</span><br><span class="line"> <span class="number">4</span> arr[<span class="number">0</span>]=<span class="string">&quot;zhangcheng&quot;</span></span><br><span class="line"> <span class="number">5</span> echo $&#123;arr[<span class="number">0</span>]&#125;</span><br><span class="line"> <span class="number">6</span> echo $&#123;arr[@]&#125;</span><br><span class="line"> <span class="number">7</span> echo $&#123;#arr[*]&#125;</span><br><span class="line">                     </span><br></pre></td></tr></table></figure>

<p>练习：</p>
<p>数组的逆序打印（用交换）</p>
<p>shijie nihao world hello</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> arr=(hello world nihao shijie)</span><br><span class="line">  <span class="number">4</span> arr[<span class="number">0</span>]=<span class="string">&quot;zhangcheng&quot;</span></span><br><span class="line">  <span class="number">5</span> echo $&#123;arr[<span class="number">0</span>]&#125;</span><br><span class="line">  <span class="number">6</span> echo $&#123;arr[@]&#125;</span><br><span class="line">  <span class="number">7</span> len=$&#123;#arr[*]&#125;</span><br><span class="line">  <span class="number">8</span> <span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;$len/<span class="number">2</span>;i++))</span><br><span class="line">  <span class="number">9</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">10</span>     temp=$&#123;arr[$i]&#125;</span><br><span class="line"> <span class="number">11</span>     arr[$i]=$&#123;arr[$(($len-$i<span class="number">-1</span>))]&#125;</span><br><span class="line"> <span class="number">12</span>     arr[$(($len-$i<span class="number">-1</span>))]=$temp</span><br><span class="line"> <span class="number">13</span> done</span><br><span class="line"> <span class="number">14</span> </span><br><span class="line"> <span class="number">15</span> echo $&#123;arr[@]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-shell函数"><a href="#4-shell函数" class="headerlink" title="4. shell函数"></a>4. shell函数</h3><p>没有数据类型</p>
<p>没有写形参，但可以传参</p>
<p>只有调用函数之后，函数里面的变量才会生效</p>
<p>函数里面定义的都是全局变量，如果要定义局部变量，加local</p>
<p>（1）函数的一般形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">function 函数名（）</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line"></span><br><span class="line">函数名（）</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）函数的调用，直接函数名</p>
<p>（3）返回值return，可以通过$?来打印函数的返回值,如果有返回值，返回在0~256</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> add()</span><br><span class="line"> <span class="number">4</span> &#123;</span><br><span class="line"> <span class="number">5</span>     a=<span class="number">12</span></span><br><span class="line"> <span class="number">6</span>     <span class="keyword">return</span> $a</span><br><span class="line"> <span class="number">7</span> &#125;</span><br><span class="line"> <span class="number">8</span> add</span><br><span class="line"> <span class="number">9</span> echo $?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（4）函数的传参</p>
<p>函数名 实参1 实参2.。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数体中用$<span class="number">1</span>,$<span class="number">2</span>$<span class="number">3.</span>....来接受传递的实参</span><br><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> add()</span><br><span class="line">  <span class="number">4</span> &#123;</span><br><span class="line">  <span class="number">5</span>     a=<span class="number">12</span></span><br><span class="line">  <span class="number">6</span>     echo $<span class="number">1</span></span><br><span class="line">  <span class="number">7</span>     echo $<span class="number">2</span></span><br><span class="line">  <span class="number">8</span>     echo $<span class="number">3</span></span><br><span class="line">  <span class="number">9</span>     <span class="keyword">return</span> $a</span><br><span class="line"> <span class="number">10</span> &#125;</span><br><span class="line"> <span class="number">11</span> add <span class="number">34</span> <span class="number">56</span> <span class="number">78</span></span><br><span class="line"> <span class="number">12</span> echo $?</span><br></pre></td></tr></table></figure>

<p>练习：写一个求和函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> read m n</span><br><span class="line"> <span class="number">3</span> add()</span><br><span class="line"> <span class="number">4</span> &#123;</span><br><span class="line"> <span class="number">5</span>     sum=<span class="number">0</span></span><br><span class="line"> <span class="number">6</span>     <span class="keyword">for</span>((i=$<span class="number">1</span>;i&lt;=$<span class="number">2</span>;i++))</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">do</span></span><br><span class="line"> <span class="number">8</span>         sum=$(($sum+$i))</span><br><span class="line"> <span class="number">9</span>     done</span><br><span class="line"><span class="number">10</span> &#125;</span><br><span class="line"><span class="number">11</span> add m n</span><br><span class="line"><span class="number">12</span> echo $sum</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="三、c高级："><a href="#三、c高级：" class="headerlink" title="三、c高级："></a>三、c高级：</h2><h3 id="1-指针："><a href="#1-指针：" class="headerlink" title="1. 指针："></a>1. 指针：</h3><p>（1）指针的定义：</p>
<p>存储类型 数据类型 *指针变量名；</p>
<p>（2）指针的初始化：</p>
<p>存储类型 数据类型 *指针变量名=地址；</p>
<p>（3）指针的赋值：</p>
<p>1、把一个已知变量的地址赋值给指针</p>
<p>2、把已知数组首地址赋值给指针</p>
<p>3、把已有同级别指针赋值给指针</p>
<p>4、把NULL赋值给指针</p>
<p>（4）数组指针</p>
<p>本质是一个指针，只是这个指向了每个元素都是一维数组的一维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">10  </span>&#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">int</span> (*p)[<span class="number">3</span>]=a;</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">&quot;a[1][0]=%d\n&quot;</span>,a[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">&quot;*(*(p+1))]=%d\n&quot;</span>,*(*(p+<span class="number">1</span>)));</span><br><span class="line"><span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">&quot;p[1][0]=%d\n&quot;</span>,p[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="number">17</span>     <span class="built_in">printf</span>(<span class="string">&quot;*p[1]=%d\n&quot;</span>,*p[<span class="number">1</span>]);</span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">20</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><font color="red">注意：用指针数组创建的字符串(char *p[]={“hello”,”nihao”,”konnichiwa”})是字符串常量,而用二维字符串数组写的字符串才算变量。</font></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">写博客时有&#123;#的地方必须要放在代码里否则会渲染错误</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
        <tag>Linux基础</tag>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>day22-数据结构和算法简介，顺序表</title>
    <url>/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="day22-数据结构和算法简介，顺序表"><a href="#day22-数据结构和算法简介，顺序表" class="headerlink" title="day22-数据结构和算法简介，顺序表"></a><font color="green">day22-数据结构和算法简介，顺序表</font></h1><h2 id="一、课程大纲"><a href="#一、课程大纲" class="headerlink" title="一、课程大纲"></a>一、课程大纲</h2><ol>
<li>数据结构基础及算法基础+ 顺序表</li>
<li>链表</li>
<li>双向链表、双向循环链表 、栈、队列</li>
<li>树、图</li>
<li>常见的算法</li>
</ol>
<a id="more"></a>
<br>
<br>

<hr>
<h2 id="二、数据结构和算法简介"><a href="#二、数据结构和算法简介" class="headerlink" title="二、数据结构和算法简介"></a>二、数据结构和算法简介</h2><h3 id="1-数据结构基础"><a href="#1-数据结构基础" class="headerlink" title="1.数据结构基础"></a>1.数据结构基础</h3><ol>
<li><p>了解数据的基本概念和术语：</p>
<ul>
<li><p>数据：</p>
<pre><code>  (1)数据即信息的载体，是能够输入到计算机中且能被计算机识别、存储和处理的符号总称。
  (2)数据不仅包括:
 a. 数值型数据：整型、实型、字符型数值型数据
 b. 非数值型数据：图片、视频、声音等</code></pre>
</li>
<li><p>数据项：<br> 数据元素由若干数据项组成，数据项是数据中的最小单位。</p>
<p> 数据由多种数据项组成：</p>
<p> 正比如：我们在讨论一个电影角色等时候，我们讨论的是该角色的姓名、性别、住址、等</p>
<p> 注意：数据项是数据不可分隔的最小组成单位</p>
</li>
<li><p>数据结构（DS）：</p>
<p> (1)可用形式化语言描述，即DS是一个二元组：</p>
<pre><code>       DS =（D,R）其中，D为数据元素的集合，R为D上关系的集合。 </code></pre>
<p> (2)数据结构的逻辑关系</p>
<p> <img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321104451784.png" alt="image-20230321104451784"></p>
</li>
</ul>
<ul>
<li>存储结构：</li>
</ul>
<blockquote>
<p>a. 顺序存储<br>b. 链式存储<br>c. 索引存储<br>d. 散列存储</p>
</blockquote>
<ul>
<li>运算：增、删、改、查、排</li>
</ul>
<p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321105735324.png" alt="image-20230321105735324"></p>
</li>
</ol>
<h3 id="2-算法"><a href="#2-算法" class="headerlink" title="2.算法"></a>2.算法</h3><p>(1)什么是算法？</p>
<pre><code>    1. 算法（Algorithm）是一个有穷规则（或语句、指令）的有序集合。它确定了解决某一问题的一个运算序列。对于问题的初始输入，通过算法有限步的运行，产生一个或多个输出。

    2. 算法的特性：

        (1)  有穷性 —— 算法执行的步骤（或规则）是有限的

        (2)  确定性 —— 每个计算步骤无二义性

        (3)  可行性 —— 每个计算步骤能够在有限的时间内完成

        (4)  输入  —— 算法有零个或多个外部输入

        (5)  输出  —— 算法有一个或多个输出

    3. 算法和程序的区别：

        共同点：二者都是为完成某个任务，或解决某个问题而编制的规则（或语句）的有序集合，这是它们的。
        不同点：
            * 算法与计算机无关，但程序依赖于具体的计算机语言。
            * 算法必须是有穷尽的，但程序可能是无穷尽的。
            * 算法可忽略一些语法细节问题，重点放在解决问题的思路上，但程序必须严格遵循相应语言工具的语法。算法转换成程序后才能在计算机上运行。另外，在设计算法时，一定要考虑它的确定性，即算法的每个步骤都是无二义性的（即一条规则不能有两种以上的解释）

    4. 程序的基本概念：

        1. 可执行的有序二进制指令、存放在磁盘、不占用系统资源（ cpu、内存等）

    5. 算法的优劣：

        消耗时间的多少 ：

        消耗存储空间的多少 ：

        容易理解、容易编程和调试、容易维护。时间复杂度的概念介绍 ：

        问题的规模 ：输入数据量的大小，用n来表示。

        算法的时间复杂度 ：算法消耗时间，它是问题规模的函数 T(n)。

        其中好算法代表了：

            算法对应的程序所耗时间少；

            算法对应的程序所耗存储空间少；

            算法结构性好、易读、易移植和调试等等。

        3. 时间复杂度：算法的时间复杂度定义为算法中可执行语句的频度之和，记为T(n)</code></pre>
<p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321141217272.png" alt="image-20230321141217272"><br><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321141200570.png" alt="image-20230321141200570"></p>
<h3 id="3-数据结构常见的结构"><a href="#3-数据结构常见的结构" class="headerlink" title="3.数据结构常见的结构-"></a>3.数据结构常见的结构-</h3><p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321142133548.png" alt="image-20230321142133548"></p>
<br>
<br>

<hr>
<h2 id="三、数据结构之顺序表"><a href="#三、数据结构之顺序表" class="headerlink" title="三、数据结构之顺序表"></a>三、数据结构之顺序表</h2><ol>
<li>线性表：</li>
</ol>
<p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321144943972.png" alt="image-20230321144943972"></p>
<ol start="2">
<li>线性表特征：</li>
</ol>
<p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321145052751.png" alt="image-20230321145052751"></p>
<ol start="3">
<li>顺序表的代码实现：</li>
</ol>
<p>（1）memset(&emsp;)函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">功能：<span class="built_in">memset</span> - fill memory with a constant byte</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">函数原型：</span><br><span class="line">       <span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">参数说明：</span><br><span class="line">	<span class="keyword">void</span> *s：要清空的目标数组或指针所指空间  buf</span><br><span class="line">	<span class="keyword">int</span> c：给定的填充的数据   <span class="number">0</span> <span class="number">1</span> 等</span><br><span class="line">    <span class="keyword">size_t</span> n： 大小     <span class="keyword">sizeof</span>（buf）；</span><br><span class="line">返回值</span><br><span class="line">	无返回值：</span><br></pre></td></tr></table></figure>



<p>（2）bzero(&emsp;)函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">功能： bzero - write zero-valued bytes</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line">函数原型：</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">参数说明：</span><br><span class="line">	<span class="keyword">void</span> *s：要清空的目标数组或指针所指空间  buf</span><br><span class="line">    <span class="keyword">size_t</span> n： 大小     <span class="keyword">sizeof</span>（buf）；</span><br><span class="line">返回值</span><br><span class="line">	无返回值：</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>（3）printf 变色打印(Linux)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    字背景颜色范围:<span class="number">40</span> - <span class="number">49</span></span><br><span class="line">    <span class="number">40</span>:黑</span><br><span class="line">    <span class="number">41</span>:深红</span><br><span class="line">    <span class="number">42</span>:绿</span><br><span class="line">    <span class="number">43</span>:黄色</span><br><span class="line">    <span class="number">44</span>:蓝色</span><br><span class="line">    <span class="number">45</span>:紫色</span><br><span class="line">    <span class="number">46</span>:深绿</span><br><span class="line">    <span class="number">47</span>:白色</span><br><span class="line">     </span><br><span class="line">    字颜色:<span class="number">30</span> - <span class="number">39</span></span><br><span class="line">    <span class="number">30</span>:黑</span><br><span class="line">    <span class="number">31</span>:红</span><br><span class="line">    <span class="number">32</span>:绿</span><br><span class="line">    <span class="number">33</span>:黄</span><br><span class="line">    <span class="number">34</span>:蓝色</span><br><span class="line">    <span class="number">35</span>:紫色</span><br><span class="line">    <span class="number">36</span>:深绿</span><br><span class="line">    <span class="number">37</span>:白色</span><br><span class="line">    \<span class="number">33</span>[<span class="number">0</span>m 关闭所有属性</span><br><span class="line">    \<span class="number">33</span>[<span class="number">1</span>m 设置高亮度</span><br><span class="line">    \<span class="number">33</span>[<span class="number">4</span>m 下划线</span><br><span class="line">    \<span class="number">33</span>[<span class="number">5</span>m 闪烁</span><br><span class="line">    \<span class="number">33</span>[<span class="number">7</span>m 反显</span><br><span class="line">    \<span class="number">33</span>[<span class="number">8</span>m 消隐</span><br><span class="line">    \<span class="number">33</span>[<span class="number">30</span>m -- \<span class="number">33</span>[<span class="number">37</span>m 设置前景色</span><br><span class="line">    \<span class="number">33</span>[<span class="number">40</span>m -- \<span class="number">33</span>[<span class="number">47</span>m 设置背景色</span><br><span class="line">    \<span class="number">33</span>[nA 光标上移n行</span><br><span class="line">    \<span class="number">33</span>[nB 光标下移n行</span><br><span class="line">    \<span class="number">33</span>[nC 光标右移n行</span><br><span class="line">    \<span class="number">33</span>[nD 光标左移n行</span><br><span class="line">    \<span class="number">33</span>[y;xH设置光标位置</span><br><span class="line">    \<span class="number">33</span>[<span class="number">2</span>J 清屏</span><br><span class="line">    \<span class="number">33</span>[K 清除从光标到行尾的内容</span><br><span class="line">    \<span class="number">33</span>[s 保存光标位置</span><br><span class="line">    \<span class="number">33</span>[u 恢复光标位置</span><br><span class="line">    \<span class="number">33</span>[?<span class="number">25l</span> 隐藏光标</span><br><span class="line">    \<span class="number">33</span>[?<span class="number">25</span>h 显示光标</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;hello world\n&quot;); </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[40;32;5m hello world\033[1m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;\033[40;31;5m hello world\033[0m\n&quot;);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（3）printf 变色打印(Windows)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HANDLE hConsole= GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">    SetConsoleTextAttribute(hConsole,FOREGROUND_RED);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*1. 引入Windows.h头文件。</span></span><br><span class="line"><span class="comment">2. 使用SetConsoleTextAttribute函数设置控制台输出的字体颜色。该函数的第一个参数是控制台输出的句柄，可以使用GetStdHandle函数获取标准输出句柄；第二个参数是字体颜色，可以使用预定义的常量或自定义的颜色值。</span></span><br><span class="line"><span class="comment">   例如，以下代码将控制台输出的字体颜色设置为红色预定义的颜色常量包括：</span></span><br><span class="line"><span class="comment">- FOREGROUND_BLUE：蓝色</span></span><br><span class="line"><span class="comment">- FOREGROUND_GREEN：绿色</span></span><br><span class="line"><span class="comment">- FOREGROUND_RED：红色</span></span><br><span class="line"><span class="comment">- FOREGROUND_INTENSITY：高亮</span></span><br><span class="line"><span class="comment">- BACKGROUND_BLUE：背景色为蓝色</span></span><br><span class="line"><span class="comment">- BACKGROUND_GREEN：背景色为绿色</span></span><br><span class="line"><span class="comment">- BACKGROUND_RED：背景色为红色</span></span><br><span class="line"><span class="comment">- BACKGROUND_INTENSITY：背景色高亮</span></span><br><span class="line"><span class="comment">可以使用位运算符|和&amp;来组合多个颜色常量，</span></span><br><span class="line"><span class="comment">例如：</span></span><br><span class="line"><span class="comment">SetConsoleTextAttribute(hConsole, FOREGROUND_RED | BACKGROUND_GREEN | FOREGROUND_INTENSITY);</span></span><br><span class="line"><span class="comment">该代码将字体颜色设置为红色、背景色设置为绿色、高亮显示。*/</span></span><br></pre></td></tr></table></figure>

<p>（4）线性表c的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造顺序表结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">data_t</span> data[SIZE]; <span class="comment">//保存元素</span></span><br><span class="line">    <span class="keyword">int</span> last;        <span class="comment">//保存尾元素下标</span></span><br><span class="line">&#125;seqlist; </span><br><span class="line"><span class="comment">//创建表头及初始化表</span></span><br><span class="line"><span class="function">seqlist *<span class="title">create_seqlite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    seqlist* head =(seqlist*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(seqlist)); <span class="comment">//创建表头 head </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;last = <span class="number">-1</span>;   <span class="comment">//初始化 last为-1  表示空表</span></span><br><span class="line">    <span class="built_in">memset</span>(head-&gt;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(head-&gt;data)); <span class="comment">//清空 表</span></span><br><span class="line">    <span class="keyword">return</span> head; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求表长</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">get_leng_seqlist</span><span class="params">(seqlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;last+<span class="number">1</span>;  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">seqlist_is_empty</span><span class="params">(seqlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((head-&gt;last == <span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>);  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">seqlist_is_full</span><span class="params">(seqlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((head-&gt;last+<span class="number">1</span> == SIZE)?<span class="number">1</span>:<span class="number">0</span>);  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_by_pos_seqlist</span><span class="params">(seqlist* head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) perr_exit(<span class="string">&quot;insert_by_pos_seqlist:&quot;</span>);  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_full(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; head-&gt;last+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//挪位置</span></span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i=head-&gt;last+<span class="number">1</span>; i&gt;pos; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;data[i] = head-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    head-&gt;data[pos] = value;</span><br><span class="line">    <span class="comment">//更新 last </span></span><br><span class="line">        head-&gt;last++; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置 查询</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">find_by_pos_seqlist</span><span class="params">(seqlist *head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_empty(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt;head-&gt;last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;data[pos]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按值 查询</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_by_data_seqlist</span><span class="params">(seqlist *head, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_empty(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;= head-&gt;last; i++) <span class="comment">// 0-5 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;data[i] == val)</span><br><span class="line">            <span class="keyword">return</span> i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置 修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change_by_pos_seqlist</span><span class="params">(seqlist* head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_empty(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt;head-&gt;last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    head-&gt;data[pos] = new_val; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置 删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_by_pos_seqlist</span><span class="params">(seqlist *head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;;  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_empty(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; head-&gt;last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//挪位置 并覆盖删除</span></span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i=pos; i&lt;head-&gt;last; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;data[i] = head-&gt;data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新 last </span></span><br><span class="line">        head-&gt;last--; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_seqlist</span><span class="params">(seqlist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==head) <span class="keyword">return</span> ;</span><br><span class="line">    head-&gt;last = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">destory_seqlist</span><span class="params">(seqlist **head)</span> <span class="comment">// 为什么要用2级指针 看 3_getmem_point.c</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(*head);</span><br><span class="line">    *head = <span class="literal">NULL</span>; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印看结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prn</span><span class="params">(seqlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[40;32;5m\033[1m\n&quot;</span>);   <span class="comment">//开启打印颜色</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> len = get_leng_seqlist(head); </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, head-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\033[40;32;5m\033[0m\n&quot;</span>);   <span class="comment">//关闭打印颜色</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误打印</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    seqlist* head = create_seqlite();</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert_by_pos_seqlist(head, i, i+<span class="number">1</span>); <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    prn(head); </span><br><span class="line">    change_by_pos_seqlist(head, <span class="number">4</span>, <span class="number">666</span>);</span><br><span class="line">    prn(head); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find_by_data_seqlist(head, <span class="number">666</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete_by_pos_seqlist(head, <span class="number">5</span>); </span><br><span class="line">    prn(head); </span><br><span class="line">clear_seqlist(head); </span><br><span class="line">    destory_seqlist(&amp;head);  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<br>
<br>

<hr>
<h2 id="四、指针，函数和空间的关系"><a href="#四、指针，函数和空间的关系" class="headerlink" title="四、指针，函数和空间的关系"></a>四、指针，函数和空间的关系</h2><p>总的来说，就是指针在作为函数的参数进行传参的时候是用的是值传参。也就是说指针之间的传参只是在函数中得到了主函数指针的样本，两个不同的指针指向了同一个地址。<br>先来看一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *create（）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *p=（<span class="keyword">int</span> *）<span class="built_in">malloc</span>（<span class="keyword">sizeof</span>（<span class="keyword">int</span>））；</span><br><span class="line">    <span class="keyword">return</span> p；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> destory(<span class="keyword">int</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">free</span>(p);</span><br><span class="line">     P=<span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = create();</span><br><span class="line">    destory(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这一段代码有个问题，就是在destory()中创建一个指针，这个指针指向的是和main()中的p指针指向的同一个空间。在释放了空间后，destory()中的指针空了，但是mian()中的指针还在，并且因为空间被释放了所以变成了野指针。</p>
<p>再来看另一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">&#125;st; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmem</span><span class="params">(<span class="keyword">int</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *s = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmem_2</span><span class="params">(<span class="keyword">int</span> **s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *s = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *(<span class="keyword">int</span> *)*s = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st *p = (st*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="comment">//getmem(p-&gt;a); //指针变量名 不能改变实参</span></span><br><span class="line">    getmem_2(&amp;(p-&gt;a)); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(p-&gt;a)); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>getmem()函数是错误的，因为是在getmem()函数中创建了一个指针，然后让该指针指向了一个开辟的空间，但是主函数的指针并没有指向该空间而处于未初始化的状态。</p>
<p>要想用主函数里的指针开辟空间，就要在函数中用到二级指针来传递主函数指针的地址</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>day19-c函数，结构体</title>
    <url>/2023/03/17/day19-c%E5%87%BD%E6%95%B0%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="day19-c函数，结构体"><a href="#day19-c函数，结构体" class="headerlink" title="day19-c函数，结构体"></a><font color="green">day19-c函数，结构体</font></h1><br>
<br>

<hr>
<h2 id="一、函数："><a href="#一、函数：" class="headerlink" title="一、函数："></a>一、函数：</h2><p>完成特定功能的程序模块</p>
<a id="more"></a>

<h3 id="1-函数的分类："><a href="#1-函数的分类：" class="headerlink" title="1. 函数的分类："></a>1. 函数的分类：</h3><p>库函数，给用户直接调用的函数（调用时要加对应的头文件）</p>
<p>自定义函数：用户自己写的函数</p>
<h3 id="2-怎么去写一个函数："><a href="#2-怎么去写一个函数：" class="headerlink" title="2. 怎么去写一个函数："></a>2. 怎么去写一个函数：</h3><p>（1）函数的声明：定义在头文件下，主函数上，提前告诉计算机，我后面有这个，要给这个函数开辟空间，如果函数的功能写在主函数前面，可以不要声明</p>
<p>一般形式：存储类型 数据类型 函数名（数据类型 形参1，数据类型 形参2.。。。）；（一定要加分号）</p>
<p>（2）函数的功能：</p>
<blockquote>
<p>存储类型 数据类型 函数名（数据类型 形参1，数据类型 形参2.。。。）<br>{<br>功能模块；<br>返回值；返回值可以没有，根据功能来定，如果有返回值，返回值的数据类型要和函数的数据类型保持一致<br>}</p>
</blockquote>
<p>（3）函数的调用</p>
<p>函数名（实参1，实参2.。。。）</p>
<p>实参的数据类型和个数和顺序要和形参保持一致</p>
<h3 id="3-函数的传参："><a href="#3-函数的传参：" class="headerlink" title="3. 函数的传参："></a>3. 函数的传参：</h3><ul>
<li>值传递：</li>
<li>地址传递–地址具有唯一性</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> t;</span><br><span class="line"><span class="number">11</span>     t=*a;</span><br><span class="line"><span class="number">12</span>     *a=*b;</span><br><span class="line"><span class="number">13</span>     *b=t;</span><br><span class="line"><span class="number">14</span>     </span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">17 </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">int</span> x=<span class="number">12</span>,y=<span class="number">34</span>;</span><br><span class="line"><span class="number">19</span>     swap(&amp;x,&amp;y);</span><br><span class="line"><span class="number">20</span>     <span class="built_in">printf</span>(<span class="string">&quot;x=%d----y=%d\n&quot;</span>,x,y);</span><br><span class="line"><span class="number">21</span>     </span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">23</span> &#125;   </span><br></pre></td></tr></table></figure>

<ul>
<li>数组传递–数组传数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="number">9</span> <span class="function"><span class="keyword">char</span> *<span class="title">mystrcat</span><span class="params">(<span class="keyword">char</span> p[<span class="number">32</span>],<span class="keyword">char</span> q[<span class="number">32</span>])</span></span>;<span class="comment">//函数的声明</span></span><br><span class="line"><span class="number">10</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">11 </span>&#123;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">char</span> a[<span class="number">32</span>]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="number">13</span>     <span class="keyword">char</span> b[<span class="number">32</span>]=<span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="number">14</span>     <span class="built_in">puts</span>(mystrcat(a,b));<span class="comment">//函数的调用</span></span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">17</span> &#125;</span><br><span class="line"><span class="number">18</span> <span class="function"><span class="keyword">char</span> *<span class="title">mystrcat</span><span class="params">(<span class="keyword">char</span> p[<span class="number">32</span>],<span class="keyword">char</span> q[<span class="number">32</span>])</span><span class="comment">//函数的功能</span></span></span><br><span class="line"><span class="function">19 </span>&#123;</span><br><span class="line"><span class="number">20</span>     <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">int</span> len=<span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="number">22</span>     <span class="keyword">for</span>(i=<span class="number">0</span>;p[i];i++)</span><br><span class="line"><span class="number">23</span>     &#123;</span><br><span class="line"><span class="number">24</span>         p[len]=q[i];</span><br><span class="line"><span class="number">25</span>         len++;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span>     <span class="keyword">return</span> p;</span><br><span class="line"><span class="number">28</span> &#125;</span><br><span class="line"><span class="number">29</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-指针函数"><a href="#4-指针函数" class="headerlink" title="4.指针函数"></a>4.指针函数</h3><p>本质是一个函数，特殊之处返回值必定是一个地址</p>
<p>一般形式：存储类型 数据类型 *函数名（数据类型 形参1，数据类型 形参2.。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mystrcat</span><span class="params">(<span class="keyword">char</span> p[<span class="number">32</span>],<span class="keyword">char</span> q[<span class="number">32</span>])</span><span class="comment">//函数的功能</span></span></span><br><span class="line"><span class="function"> 19 </span>&#123;</span><br><span class="line"> <span class="number">20</span>     <span class="keyword">int</span> i;</span><br><span class="line"> <span class="number">21</span>     <span class="keyword">int</span> len=<span class="built_in">strlen</span>(p);</span><br><span class="line"> <span class="number">22</span>     <span class="keyword">for</span>(i=<span class="number">0</span>;p[i];i++)</span><br><span class="line"> <span class="number">23</span>     &#123;</span><br><span class="line"> <span class="number">24</span>         p[len]=q[i];</span><br><span class="line"> <span class="number">25</span>         len++;</span><br><span class="line"> <span class="number">26</span>     &#125;</span><br><span class="line"> <span class="number">27</span>     <span class="keyword">return</span> p;</span><br><span class="line"> <span class="number">28</span> &#125;</span><br><span class="line"> <span class="number">29</span> </span><br></pre></td></tr></table></figure>

<h3 id="5-函数指针："><a href="#5-函数指针：" class="headerlink" title="5.函数指针："></a>5.函数指针：</h3><p>本质是一个函数，只是这个指针指向的是函数的入口地址，就是函数名</p>
<p>一般形式：存储类型 数据类型 （*指针变量名）（数据类型 形参1，数据类型 形参2.。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> t;</span><br><span class="line"><span class="number">11</span>     t=*a;</span><br><span class="line"><span class="number">12</span>     *a=*b;</span><br><span class="line"><span class="number">13</span>     *b=t;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function">17 </span>&#123;   </span><br><span class="line"><span class="number">18</span>     <span class="keyword">return</span> *a + *b;</span><br><span class="line"><span class="number">19</span> &#125;   </span><br><span class="line"><span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">21 </span>&#123;</span><br><span class="line"><span class="number">22</span>     <span class="keyword">int</span> x=<span class="number">12</span>,y=<span class="number">34</span>;</span><br><span class="line"><span class="number">23</span>     <span class="keyword">int</span> (*p)(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)=swap; <span class="comment">//把swap赋给p函数指针</span></span><br><span class="line"><span class="number">24</span>     p(&amp;x,&amp;y);<span class="comment">//调用p</span></span><br><span class="line"><span class="number">25</span>     p=add;</span><br><span class="line"><span class="number">26</span>     <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,p(&amp;x,&amp;y));</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">29</span> &#125;</span><br></pre></td></tr></table></figure>




<h3 id="6-函数指针数组"><a href="#6-函数指针数组" class="headerlink" title="6. 函数指针数组"></a>6. 函数指针数组</h3><p>本质是一个数组，只是这个数组里面放的是指向函数的指针</p>
<p>一般形式：存储类型 数据类型 （*数组名【下标】）（数据类型 形参1，数据类型 形参2.。。。）</p>
<p>例如：int （*p【3】）（int ，int）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*===============================================</span></span><br><span class="line"><span class="comment">*   文件名称：jisuan.c</span></span><br><span class="line"><span class="comment">*   创 建 者：  张城   </span></span><br><span class="line"><span class="comment">*   创建日期：2023年03月16日</span></span><br><span class="line"><span class="comment">*   描    述：</span></span><br><span class="line"><span class="comment">================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jian</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cheng</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chu</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> (*p[<span class="number">4</span>])(<span class="keyword">int</span> a,<span class="keyword">int</span> b)=&#123;add,jian,cheng,chu&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>,&amp;i,&amp;c,&amp;j);</span><br><span class="line">    <span class="keyword">switch</span>(c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">0</span>](i,j));<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">1</span>](i,j));<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">2</span>](i,j));<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">3</span>](i,j));<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="7-函数的多文件封装"><a href="#7-函数的多文件封装" class="headerlink" title="7. 函数的多文件封装"></a>7. 函数的多文件封装</h3><p>（1）头文件–可以放库头文件和所有功能函数的声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __JISUAN_H__---防止头文件重复包含</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> __JISUAN_H__</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;--库头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;--函数的声明</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jian</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cheng</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chu</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>（2）功能文件–自定义的头文件和所有功能函数代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;jisuan.h&quot;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">return</span> a+b;</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span> <span class="function"><span class="keyword">int</span> <span class="title">jian</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">13 </span>&#123;</span><br><span class="line"><span class="number">14</span>     <span class="keyword">return</span> a-b;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">cheng</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">17 </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">return</span> a*b;</span><br><span class="line"><span class="number">19</span> &#125;</span><br><span class="line"><span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">chu</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">21 </span>&#123;</span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> a/b;</span><br><span class="line"><span class="number">23</span> &#125;</span><br><span class="line"><span class="number">24</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>（3）主函数文件—自定义头文件和函数的调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;jisuan.h&quot;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">  9 </span>&#123;</span><br><span class="line"> <span class="number">10</span>     <span class="keyword">int</span> x=<span class="number">12</span>,y=<span class="number">34</span>;</span><br><span class="line"> <span class="number">11</span>     <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,add(x,y));</span><br><span class="line"> <span class="number">12</span> </span><br><span class="line"> <span class="number">13</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">14</span> &#125;</span><br><span class="line">编译：至少编译两个.c文件，头文件默认在当前目录下去找</span><br><span class="line">    调用外部头文件：-I</span><br></pre></td></tr></table></figure>


<h3 id="8-递归函数："><a href="#8-递归函数：" class="headerlink" title="8. 递归函数："></a>8. 递归函数：</h3><p>直接或间接调用函数本身的函数</p>
<p>两个条件：调用自己，要有结束标志</p>
<p>每次调用自己都会给函数开辟空间，所以每次调用的变量都被会保留在当前函数内，没有到结束标志回归不会被释放</p>
<p>循环能做的，递归函数都能做，但是递归函数能做的，循环不一定能做，所以我们能用循环就用循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line"><span class="number">11</span>     &#123;</span><br><span class="line"><span class="number">12</span>        <span class="keyword">return</span> n+add(n<span class="number">-1</span>);</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">17 </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">int</span> n;</span><br><span class="line"><span class="number">19</span>     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="number">20</span>     <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,add(n));</span><br><span class="line"><span class="number">21</span> </span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">23</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-回调函数"><a href="#9-回调函数" class="headerlink" title="9. 回调函数"></a>9. 回调函数</h3><p>把一个函数作为一个参数，用函数指针来接受的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">return</span> a+b;</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span> <span class="function"><span class="keyword">int</span> <span class="title">gohome</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> (*p)())</span></span></span><br><span class="line"><span class="function">13 </span>&#123;</span><br><span class="line"><span class="number">14</span>     <span class="keyword">return</span> p(a,b);</span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">18 </span>&#123;</span><br><span class="line"><span class="number">19</span>     <span class="keyword">int</span> x=<span class="number">12</span>,y=<span class="number">34</span>;</span><br><span class="line"><span class="number">20</span>     <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,gohome(x,y,callback));</span><br><span class="line"><span class="number">21</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">22</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-动态开辟空间函数"><a href="#10-动态开辟空间函数" class="headerlink" title="10. 动态开辟空间函数"></a>10. 动态开辟空间函数</h3><p>malloc</p>
<p>在堆区开辟空间，需要我们手动开辟，<strong>也需要我们手动释放</strong></p>
<p>头文件：#include &lt;stdlib.h&gt;</p>
<p>函数原型：void *malloc(size_t size);</p>
<p>参数：size：需要开辟空间的大小</p>
<p>返回值：开辟成功返回开辟的首地址，失败返回NULL</p>
<p>释放空间地址：</p>
<p>void free(void *ptr);</p>
<p>参数：ptr：要释放的首地址</p>
<p><strong>释放的是开辟的空间地址，而我们的指针还在，此时没有指向，变成野指针，需要给它赋值为NULL</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">10 </span>&#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="number">12</span>     <span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line"><span class="number">13</span>     &#123;</span><br><span class="line"><span class="number">14</span>         <span class="built_in">printf</span>(<span class="string">&quot;create error\n&quot;</span>);</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span>     *p=<span class="number">12</span>;</span><br><span class="line"><span class="number">17</span>     <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>,*p);</span><br><span class="line"><span class="number">18</span>     <span class="built_in">free</span>(p);</span><br><span class="line"><span class="number">19</span>     p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">21</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">22</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="二、关键字："><a href="#二、关键字：" class="headerlink" title="二、关键字："></a>二、关键字：</h2><h3 id="1-const–变量常量化"><a href="#1-const–变量常量化" class="headerlink" title="1. const–变量常量化"></a>1. const–变量常量化</h3><p>const修饰指针：</p>
<p>int const *p=&amp;a—-p的内容不能改</p>
<p>int *const p=&amp;a;—-p的指向不能改</p>
<h3 id="2-typedef—重命名"><a href="#2-typedef—重命名" class="headerlink" title="2. typedef—重命名"></a>2. typedef—重命名</h3><p>已知数据类型的重命名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="keyword">typedef</span> <span class="keyword">int</span> A;</span><br><span class="line">  <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 10 </span>&#123;</span><br><span class="line"> <span class="number">11</span>     A a=<span class="number">12</span>;</span><br><span class="line"> <span class="number">12</span>     <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);    </span><br><span class="line"> <span class="number">13</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">14</span> &#125; </span><br><span class="line">~     </span><br></pre></td></tr></table></figure>

<h3 id="3-define—-宏定义"><a href="#3-define—-宏定义" class="headerlink" title="3. define—-宏定义"></a>3. define—-宏定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="meta">#<span class="meta-keyword">define</span> A char *</span></span><br><span class="line">  <span class="number">9</span> <span class="keyword">typedef</span>  <span class="keyword">char</span> * B;</span><br><span class="line"> <span class="number">10</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 11 </span>&#123;</span><br><span class="line"> <span class="number">12</span>     A a,b; <span class="comment">//这样定义后会发现b是char类型而不是char*</span></span><br><span class="line"> <span class="number">13</span>     B c,d; <span class="comment">// a=8,b=1,c=8,d=8</span></span><br><span class="line"> <span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">&quot;a=%ld\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"> <span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">&quot;b=%ld\n&quot;</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line"> <span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">&quot;c=%ld\n&quot;</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line"> <span class="number">17</span>     <span class="built_in">printf</span>(<span class="string">&quot;d=%ld\n&quot;</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line"> <span class="number">18</span>     </span><br><span class="line"> <span class="number">19</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">20</span> &#125; </span><br></pre></td></tr></table></figure>

<p>练习：利用宏定义求出两个数之间的最大值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="meta">#<span class="meta-keyword">define</span> MAX (5&gt;3)?5:3</span></span><br><span class="line">  <span class="number">9</span> <span class="keyword">typedef</span>  <span class="keyword">char</span> * B; </span><br><span class="line"> <span class="number">10</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 11 </span>&#123;   </span><br><span class="line"> <span class="number">12</span>     <span class="built_in">printf</span>(<span class="string">&quot;MAX=%d\n&quot;</span>,MAX);</span><br><span class="line"> <span class="number">13</span>     </span><br><span class="line"> <span class="number">14</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">15</span> &#125;   </span><br><span class="line">~     </span><br></pre></td></tr></table></figure>

<h3 id="4-static—静态区域存储"><a href="#4-static—静态区域存储" class="headerlink" title="4. static—静态区域存储"></a>4. static—静态区域存储</h3><blockquote>
<p>修饰全局变量，限制作用域<br>修饰局部变量，延长声明周期（只会被初始化一次）<br>修饰函数，限制作用域</p>
</blockquote>
<h3 id="5-extern—调用外部文件变量"><a href="#5-extern—调用外部文件变量" class="headerlink" title="5. extern—调用外部文件变量"></a>5. extern—调用外部文件变量</h3><p>只能调用全局变量</p>
<blockquote>
<p>定义: int extern a;</p>
</blockquote>
<p>编译的时候要和调用的文件一起编译</p>
<h3 id="6-struct—结构体"><a href="#6-struct—结构体" class="headerlink" title="6. struct—结构体"></a>6. struct—结构体</h3><p>本质还是一个数据类型，只是里面可以放很多成员，这些成员数据类型可以一样，也可以不一样，可以是已知的数据类型，也可以是构造类型</p>
<p>一般形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct 结构体名&#123;</span><br><span class="line">数据类型 成员1；</span><br><span class="line">数据类型 成员2；</span><br><span class="line">......</span><br><span class="line">&#125;；--分号不能省略</span><br></pre></td></tr></table></figure>
<p>结构体的初始化：（按照顺序初始化）</p>
<p>全局变量初始化：在头文件下，主函数上，就是在构造完这个结构体立马定义一个变量</p>
<p>局部变量初始化，在主函数里面定义一个结构体变量</p>
<p>结构体的成员的调用：变量名.成员</p>
<p>结构体的赋值：</p>
<p>1、结构体赋结构体</p>
<p>2、每个成员单独赋值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="number">9</span> <span class="class"><span class="keyword">struct</span> <span class="title">zc</span>&#123;</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> age;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"><span class="number">12</span>     <span class="keyword">char</span> sex[<span class="number">32</span>];</span><br><span class="line"><span class="number">13</span> &#125;a=&#123;<span class="number">18</span>,<span class="string">&quot;zhangcheng&quot;</span>,<span class="string">&quot;man&quot;</span>&#125;;<span class="comment">//全局变量初始化</span></span><br><span class="line"><span class="number">14</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">15 </span>&#123;   </span><br><span class="line"><span class="number">16</span>     <span class="class"><span class="keyword">struct</span> <span class="title">zc</span> <span class="title">b</span>=&#123;</span><span class="number">20</span>,<span class="string">&quot;cheng&quot;</span>,<span class="string">&quot;man&quot;</span>&#125;;<span class="comment">//局部变量初始化</span></span><br><span class="line"><span class="number">17</span>     <span class="class"><span class="keyword">struct</span> <span class="title">zc</span> <span class="title">c</span>;</span></span><br><span class="line"><span class="number">18</span>     c.age=<span class="number">22</span>;</span><br><span class="line"><span class="number">19</span>     <span class="built_in">strcpy</span>(c.name,<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line"><span class="number">20</span>     <span class="built_in">strcpy</span>(c.sex,<span class="string">&quot;women&quot;</span>);</span><br><span class="line"><span class="number">21</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.age=%d\n&quot;</span>,a.age);<span class="comment">//成员的调用</span></span><br><span class="line"><span class="number">22</span>     <span class="built_in">printf</span>(<span class="string">&quot;b.age=%d\n&quot;</span>,b.age);</span><br><span class="line"><span class="number">23</span>     <span class="built_in">printf</span>(<span class="string">&quot;c.sex=%s\n&quot;</span>,c.sex);</span><br><span class="line"><span class="number">24</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">25</span> &#125;</span><br><span class="line">     </span><br></pre></td></tr></table></figure>


<ul>
<li>结构体的大小：</li>
</ul>
<p>规则：</p>
<p>&emsp;&emsp;如果是64位操作系统默认按照8byte对齐，但是如果最大的数据类型小于8byte，就按照最大数据类型大小对齐（就是最大成员数据类型的倍数）</p>
<p>&emsp;&emsp;如果是32位操作系统默认按照4byte对齐，但是如果最大的数据类型小于4byte，就按照最大数据类型大小对齐（就是最大成员数据类型的倍数）</p>
<p>&emsp;&emsp;如果对齐字节能够放下后面的成员，就会在当前字节放</p>
<p>&emsp;&emsp;并且存储遵循偶数存储原则</p>
<blockquote>
<p>例：<br>struct temp{char a；short b;char c;int d}<br>结构体大小为12字节。因为以里面最大的int开辟空间为4字节<br>第一个4字节有<code>a,b</code>,因为偶数原则，a占1，b占3，4<br>第二个4字节有<code>c</code>，占1<br>第三个4字节有<code>d</code>占1，2，3，4</p>
</blockquote>
<blockquote>
<p>static 修饰的不占空间</p>
</blockquote>
<ul>
<li>空类 占1个字节 （占位符）</li>
<li>成员函数、静态成员、友元函数 占 0字节 </li>
<li>虚函数占 4字节 （虚函数表占4字节）</li>
<li>非静态成员 满足字节序对齐 </li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>函数</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>day20-c特殊类型和gbd,makefile</title>
    <url>/2023/03/17/day20-c%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E5%92%8Cgbd-makefile/</url>
    <content><![CDATA[<h1 id="day20-linux基础和c"><a href="#day20-linux基础和c" class="headerlink" title="day20-linux基础和c"></a><font color="green">day20-linux基础和c</font></h1><br>
<br>

<hr>
<h2 id="一、结构体："><a href="#一、结构体：" class="headerlink" title="一、结构体："></a>一、结构体：</h2><a id="more"></a>

<h3 id="1-结构体的嵌套："><a href="#1-结构体的嵌套：" class="headerlink" title="1. 结构体的嵌套："></a>1. 结构体的嵌套：</h3><p>结构体里面再放结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">  <span class="number">9</span>     <span class="keyword">int</span> age;</span><br><span class="line"> <span class="number">10</span>     <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"> <span class="number">11</span>     <span class="keyword">int</span> id;</span><br><span class="line"> <span class="number">12</span> &#125;STU;</span><br><span class="line"> <span class="number">13</span> </span><br><span class="line"> <span class="number">14</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tea</span>&#123;</span></span><br><span class="line"> <span class="number">15</span>     <span class="keyword">int</span> age;</span><br><span class="line"> <span class="number">16</span>     <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"> <span class="number">17</span>     <span class="keyword">char</span> sex[<span class="number">32</span>];</span><br><span class="line"> <span class="number">18</span>     STU zc;</span><br><span class="line"> <span class="number">19</span> &#125;TEA;</span><br><span class="line"> <span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 21 </span>&#123;   </span><br><span class="line"> <span class="number">22</span>     STU a=&#123;<span class="number">12</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">45</span>&#125;;</span><br><span class="line"> <span class="number">23</span>     TEA b=&#123;<span class="number">30</span>,<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;man&quot;</span>,a&#125;;</span><br><span class="line"> <span class="number">24</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.age=%d\n&quot;</span>,a.age);</span><br><span class="line"> <span class="number">25</span>     <span class="built_in">printf</span>(<span class="string">&quot;b.zc.age=%d\n&quot;</span>,b.zc.age);</span><br><span class="line"> <span class="number">26</span> </span><br><span class="line"> <span class="number">27</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">28</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-结构体指针"><a href="#2-结构体指针" class="headerlink" title="2. 结构体指针"></a>2. 结构体指针</h3><p>本质是一个指针，只是这个指针指向了一个结构体</p>
<p>一般形式：struct 结构提名 * 指针变量名；</p>
<p>初始化：struct 结构提名 * 指针变量名=结构体地址；</p>
<p>指针访问结构体内容：</p>
<p>两种方式：</p>
<p>1、（*p）.成员—用的少</p>
<p>2、p-&gt;成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">21 </span>&#123;   </span><br><span class="line"><span class="number">22</span>     STU a=&#123;<span class="number">12</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">45</span>&#125;;</span><br><span class="line"><span class="number">23</span>     STU *p=&amp;a;<span class="comment">//初始化</span></span><br><span class="line"><span class="number">24</span>     <span class="built_in">printf</span>(<span class="string">&quot;(*p).age=%d\n&quot;</span>,(*p).age);</span><br><span class="line"><span class="number">25</span>     <span class="built_in">printf</span>(<span class="string">&quot;p-&gt;age=%d\n&quot;</span>,p-&gt;age);</span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">28</span> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-结构体数组："><a href="#3-结构体数组：" class="headerlink" title="3. 结构体数组："></a>3. 结构体数组：</h3><p>本质是一个数组，只是这个数组里面的元素都是结构体</p>
<p>一般形式：struct 结构提名 数组名【下标】；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 21 </span>&#123;   </span><br><span class="line"> <span class="number">22</span>     STU a=&#123;<span class="number">12</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">45</span>&#125;;</span><br><span class="line"> <span class="number">23</span>     STU b=&#123;<span class="number">13</span>,<span class="string">&quot;lisi&quot;</span>,<span class="number">47</span>&#125;;</span><br><span class="line"> <span class="number">24</span>     STU c=&#123;<span class="number">15</span>,<span class="string">&quot;wangwu&quot;</span>,<span class="number">50</span>&#125;;</span><br><span class="line"> <span class="number">25</span>     STU s[<span class="number">3</span>]=&#123;a,b,c&#125;;<span class="comment">//初始化</span></span><br><span class="line"> <span class="number">26</span>     <span class="built_in">printf</span>(<span class="string">&quot;s[1].name=%s\n&quot;</span>,s[<span class="number">1</span>].name);</span><br><span class="line"> <span class="number">27</span>     </span><br><span class="line"> <span class="number">28</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">29</span> &#125; </span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="二、共用体—union"><a href="#二、共用体—union" class="headerlink" title="二、共用体—union"></a>二、共用体—union</h2><p>也叫联合体</p>
<p>成员们一起用一片空间地址</p>
<p>共用体不允许初始化</p>
<p>STU a={12,”zhangsan”,45};//错误</p>
<p>赋值只能成员赋值，而且每次只能赋值一个，前面赋值的都会被覆盖</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="number">9</span> <span class="keyword">typedef</span> <span class="keyword">union</span> stu&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> age;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"><span class="number">12</span>     <span class="keyword">int</span> id;</span><br><span class="line"><span class="number">13</span> &#125;STU;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">16 </span>&#123;   </span><br><span class="line"><span class="number">17</span>     STU a;</span><br><span class="line"><span class="number">18</span>     a.age=<span class="number">12</span>;</span><br><span class="line"><span class="number">19</span>     <span class="built_in">strcpy</span>(a.name,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"><span class="number">20</span>     a.id=<span class="number">45</span>;</span><br><span class="line"><span class="number">21</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.age=%d\n&quot;</span>,a.age); <span class="comment">//a.age=45</span></span><br><span class="line"><span class="number">22</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.name=%s\n&quot;</span>,a.name); <span class="comment">//a.name=-</span></span><br><span class="line"><span class="number">23</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.id=%d\n&quot;</span>,a.id); <span class="comment">//a.id=45</span></span><br><span class="line"><span class="number">24</span>     </span><br><span class="line"><span class="number">25</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">26</span> &#125; </span><br></pre></td></tr></table></figure>

<p>共用体的大小：</p>
<p>也要遵循结构体大小的规则，但是只会给最大成员开辟对应的空间地址</p>
<br>
<br>

<hr>
<h2 id="三、枚举型–enum"><a href="#三、枚举型–enum" class="headerlink" title="三、枚举型–enum"></a>三、枚举型–enum</h2><p>成员没有初始化，从0开始往后赋值</p>
<p>如果有成员赋值，成员后面依次递增+1</p>
<p>enum里面的成员都是常量，不能修改它们的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">10 </span>&#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">enum</span> &#123;A,E,B=<span class="number">2</span>,C,D=<span class="number">8</span>,F&#125;;</span><br><span class="line"><span class="number">12</span>     <span class="built_in">printf</span>(<span class="string">&quot;A=%d\n&quot;</span>,A);<span class="comment">//0</span></span><br><span class="line"><span class="number">13</span>     <span class="built_in">printf</span>(<span class="string">&quot;E=%d\n&quot;</span>,E);<span class="comment">//1</span></span><br><span class="line"><span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">&quot;B=%d\n&quot;</span>,B);<span class="comment">//2</span></span><br><span class="line"><span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">&quot;C=%d\n&quot;</span>,C);<span class="comment">//3</span></span><br><span class="line"><span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">&quot;F=%d\n&quot;</span>,F);<span class="comment">//9</span></span><br><span class="line"><span class="number">17</span>     </span><br><span class="line"><span class="number">18</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">19</span> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="四、gdb调试工具："><a href="#四、gdb调试工具：" class="headerlink" title="四、gdb调试工具："></a>四、gdb调试工具：</h2><p>帮助我们找出代码的问题</p>
<p>gcc -g 编译的文件名，会生成一个a.out的执行文件，这个执行文件就可以调试</p>
<p>gdb 执行文件名</p>
<blockquote>
<p>r—运行我们的程序<br>l—查看我们的程序代码<br>b—设置断点，让程序跑到我们断点的那一行<br>c–继续运行我们的程序，直到下一个断点，如果没有直接运行完<br>p+变量===查看变量的值<br>n—按行运行，但是不进入函数<br>s—按行运行，会进入函数<br>delete—删除所有断点<br>q—退出dgb调试</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="五、makefile"><a href="#五、makefile" class="headerlink" title="五、makefile"></a>五、makefile</h2><p>makefile是一个文件，里面放的是编译的规则，可以管理多个文件</p>
<p>make是一个工具，用来解析我们的makefile</p>
<p>make会根据文件的时间戳进行编译，如果文件的时间戳没有改变，不会编译该文件，节省大量的编译时间</p>
<p>makefile的逻辑：</p>
<p>目标文件：依赖文件</p>
<p>​     （tab）编译语句</p>
<p>目标文件就是我们最终会生成的文件，要生成这个文件，会去找生成它需要的文件，就叫依赖文件，如果这个依赖文件有需要其他文件来生成，继续找它的依赖文件，直到不需要为止</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> app:<span class="built_in">list</span>.o main.o</span><br><span class="line"> <span class="number">2</span>     gcc  <span class="built_in">list</span>.o main.o -o app</span><br><span class="line"> <span class="number">3</span> <span class="built_in">list</span>.o:<span class="built_in">list</span>.c</span><br><span class="line"> <span class="number">4</span>     gcc -c <span class="built_in">list</span>.c -o <span class="built_in">list</span>.o</span><br><span class="line"> <span class="number">5</span> main.o:main.c</span><br><span class="line"> <span class="number">6</span>     gcc -c main.c -o main.o</span><br><span class="line"> <span class="number">7</span> clean:</span><br><span class="line"> <span class="number">8</span>     rm main.o <span class="built_in">list</span>.o app </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>make clean  删除生成的文件（执行clean后面的语句）</p>
<p>make，默认解析当前目录下的makefile或者Makefile</p>
<p>make -f 指定的makefile</p>
<p>调用外部头文件-I 加头文件的路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> app:<span class="built_in">list</span>.o main.o</span><br><span class="line"> <span class="number">2</span>     gcc  <span class="built_in">list</span>.o main.o -I ./include -o app</span><br><span class="line"> <span class="number">3</span> <span class="built_in">list</span>.o:<span class="built_in">list</span>.c</span><br><span class="line"> <span class="number">4</span>     gcc -c <span class="built_in">list</span>.c -I ./include -o <span class="built_in">list</span>.o</span><br><span class="line"> <span class="number">5</span> main.o:main.c</span><br><span class="line"> <span class="number">6</span>     gcc -c main.c -I ./include -o main.o</span><br><span class="line"> <span class="number">7</span> clean:</span><br><span class="line"> <span class="number">8</span>     rm main.o <span class="built_in">list</span>.o app </span><br></pre></td></tr></table></figure>

<h3 id="makefile的变量"><a href="#makefile的变量" class="headerlink" title="makefile的变量"></a>makefile的变量</h3><p>变量的赋值：</p>
<ul>
<li>=：给当前变量赋值，但是如果后面有新的赋值，把新的赋值给变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">2</span> b=$(a)</span><br><span class="line">  <span class="number">3</span> a=<span class="number">34</span></span><br><span class="line">  <span class="number">4</span> all:</span><br><span class="line">  <span class="number">5</span>     @echo $(b)</span><br><span class="line">b=<span class="number">34</span></span><br></pre></td></tr></table></figure>

<ul>
<li>:=—立即赋值,和平时的赋值一样，后面新的赋值不会改变当前值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">2</span> b:=$(a)</span><br><span class="line">  <span class="number">3</span> a=<span class="number">34</span></span><br><span class="line">  <span class="number">4</span> all:</span><br><span class="line">  <span class="number">5</span>     @echo $(b)</span><br><span class="line">      b=<span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>？=—询问赋值,询问前面有没有赋值，如果有，此次赋值无效</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">2</span> b:=$(a)</span><br><span class="line">  <span class="number">3</span> a?=<span class="number">34</span></span><br><span class="line">  <span class="number">4</span> all:</span><br><span class="line">  <span class="number">5</span>     @echo $(b)</span><br><span class="line">  <span class="number">6</span>     echo $(a)</span><br><span class="line">a=<span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>+=：追加赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">2</span> b:=$(a)</span><br><span class="line">  <span class="number">3</span> a+=hello</span><br><span class="line">  <span class="number">4</span> all:</span><br><span class="line">  <span class="number">5</span>     @echo $(b)</span><br><span class="line">  <span class="number">6</span>     echo $(a)</span><br><span class="line">a=<span class="number">12</span> hello</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在语句前加@隐藏显示语句</p>
</blockquote>
<p>利用变量写makefile：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> TARGET=app <span class="comment">//相当于代替</span></span><br><span class="line">  <span class="number">2</span> OBJS=<span class="built_in">list</span>.o main.o </span><br><span class="line">  <span class="number">3</span> CC=gcc</span><br><span class="line">  <span class="number">4</span> OBJS2=<span class="built_in">list</span>.c</span><br><span class="line">  <span class="number">5</span> OBJS3=main.c</span><br><span class="line">  <span class="number">6</span> PATH=-I ./include</span><br><span class="line">  <span class="number">7</span> </span><br><span class="line">  <span class="number">8</span> $(TARGET):$(OBJS)</span><br><span class="line">  <span class="number">9</span>     $(CC)  $(OBJS) $(PATH) -o $(TARGET)</span><br><span class="line"> <span class="number">10</span> <span class="built_in">list</span>.o:$(OBJS2)</span><br><span class="line"> <span class="number">11</span>     $(CC) -c $(OBJS2) $(PATH) -o <span class="built_in">list</span>.o</span><br><span class="line"> <span class="number">12</span> main.o:$(OBJS3)</span><br><span class="line"> <span class="number">13</span>     $(CC) -c $(OBJS3) $(PATH) -o main.o</span><br><span class="line"> <span class="number">14</span> clean:</span><br><span class="line"> <span class="number">15</span>     rm $(OBJS) $(TARGET) </span><br><span class="line">~                            </span><br></pre></td></tr></table></figure>

<p>特殊的变量：</p>
<blockquote>
<p>$@—目标文件<br>$^—所有依赖文件<br>$&lt;:第一个依赖文件<br>通配符：%</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TARGET=app</span><br><span class="line"> <span class="number">2</span> OBJS=<span class="built_in">list</span>.o main.o</span><br><span class="line"> <span class="number">3</span> CC=gcc</span><br><span class="line"> <span class="number">4</span> OBJS2=<span class="built_in">list</span>.c</span><br><span class="line"> <span class="number">5</span> OBJS3=main.c</span><br><span class="line"> <span class="number">6</span> path=-I ./include</span><br><span class="line"> <span class="number">7</span> $(TARGET):$(OBJS)</span><br><span class="line"> <span class="number">8</span>     $(CC)  $^ $(path) -o $@</span><br><span class="line"> <span class="number">9</span> %.o:%.c</span><br><span class="line"><span class="number">10</span>     $(CC) -c $^ $(path) -o $@</span><br><span class="line"><span class="number">11</span> clean:</span><br><span class="line"><span class="number">12</span>     rm $(TARGET) $(OBJS)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>c语言</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>结构体</tag>
        <tag>gbd</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>day23-链表</title>
    <url>/2023/03/23/day23-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="day23-链表"><a href="#day23-链表" class="headerlink" title="day23-链表"></a><font color="green">day23-链表</font></h1><h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><p>链表是一种常见的数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。</p>
<p>链表可以分为单向链表和双向链表两种类型。在单向链表中，每个节点只包含一个指向下一个节点的指针，而在双向链表中，每个节点同时包含指向上一个节点和下一个节点的指针。</p>
<p>相比于数组，链表的一个重要优势是可以动态地增加和删除节点，而不需要移动整个数据结构中的其他元素。但是，链表的访问效率较低，因为需要遍历整个链表才能找到所需节点。</p>
<a id="more"></a>
<br>
<br>

<hr>
<h2 id="二、链表图解"><a href="#二、链表图解" class="headerlink" title="二、链表图解"></a>二、链表图解</h2><h3 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h3><p><img src="/2023/03/23/day23-%E9%93%BE%E8%A1%A8/lianbiao.jpg" alt="链表"></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><img src="/2023/03/23/day23-%E9%93%BE%E8%A1%A8/charu.jpg" alt="链表"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="/2023/03/23/day23-%E9%93%BE%E8%A1%A8/shanchu.jpg" alt="链表"></p>
<br>
<br>

<hr>
<h2 id="三、链表的代码实现"><a href="#三、链表的代码实现" class="headerlink" title="三、链表的代码实现"></a>三、链表的代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linklist.h&quot;</span></span></span><br><span class="line"><span class="comment">//创建链表的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">data_t</span> data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">next</span>;</span> <span class="comment">//next 域</span></span><br><span class="line">&#125;linklist; </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表头节点</span></span><br><span class="line"><span class="function">linklist* <span class="title">create_linklist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    linklist* head = (linklist*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;data = <span class="number">-1</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linklist_is_empty</span><span class="params">(linklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((head-&gt;next == <span class="literal">NULL</span>) ?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求有效节点个数(求长度)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num_linklist</span><span class="params">(linklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    linklist *p = head-&gt;next; <span class="comment">//定义p指针指向第一个有效节点</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)  <span class="comment">//循环遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        num++;              <span class="comment">//统计节点数</span></span><br><span class="line">        p = p-&gt;next;        <span class="comment">//p指针向后偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_head_linklist</span><span class="params">(linklist* head, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备new 节点</span></span><br><span class="line">    linklist *<span class="keyword">new</span>  = (linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = val; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//头插法 插入</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = head-&gt;next; </span><br><span class="line">    head-&gt;next = <span class="keyword">new</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_by_pos_linklist</span><span class="params">(linklist *head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_linklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备new 节点 和p 指针 </span></span><br><span class="line">    linklist* p = head; </span><br><span class="line">    linklist* <span class="keyword">new</span> = (linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = val;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将p 找到pos-1的位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="comment">//将新节点插入pos 位置</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next   = <span class="keyword">new</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change_by_pos_linklist</span><span class="params">(linklist*head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(linklist_is_empty(head)== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_linklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    linklist* p = head-&gt;next; </span><br><span class="line">    <span class="comment">//找到pos 位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--)  </span><br><span class="line">        p   = p-&gt;next;</span><br><span class="line">    p-&gt;data = new_val;  <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//按位置查询</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">find_by_pos_linklist</span><span class="params">(linklist*head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(linklist_is_empty(head)== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_linklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    linklist* p = head-&gt;next; </span><br><span class="line">    <span class="comment">//找到pos 位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--)  </span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;data; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_by_pos_linklist</span><span class="params">(linklist* head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(linklist_is_empty(head)== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_linklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备p 指向pos-1， q 指向要删除的pos 节点</span></span><br><span class="line">    linklist* p = head;</span><br><span class="line">    linklist* q = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//找到pos -1位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--) </span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    p-&gt;next = q-&gt;next; </span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="built_in">free</span>(q); </span><br><span class="line">    q = <span class="literal">NULL</span>; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印有效节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(linklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span>;</span><br><span class="line">    linklist *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-4d&quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clear_linklist</span><span class="params">(linklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    linklist *p = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    linklist* q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next; <span class="comment">//q 偏移</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;  <span class="comment">//p 向后偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">destory_linklist</span><span class="params">(linklist** head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(*head);</span><br><span class="line">    head = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命令行模式下：gg=GG 自动缩进</span></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="四、单向循环链表"><a href="#四、单向循环链表" class="headerlink" title="四、单向循环链表"></a>四、单向循环链表</h2><p>即把链表代码中表示的最后一位的NULL都改为head就行。</p>
<br>
<br>

<hr>
<h2 id="五、双向链表"><a href="#五、双向链表" class="headerlink" title="五、双向链表"></a>五、双向链表</h2><p>双向链表的主要不同点便是</p>
<ol>
<li>头插法插入时要判断后面是否是NULL，按位置插入和删除时要判断是否是尾部</li>
<li>插入的顺序主要分四部：(先右后左，先赋值给new再把原数据指向new)<blockquote>
<p>new-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;piror=new;<br>new-&gt;prior=p;<br>p-&gt;next=new;</p>
</blockquote>
</li>
</ol>
<p>下面是双向链表的c的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dlinklist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表头节点</span></span><br><span class="line"><span class="function">dlinklist* <span class="title">create_dlinklist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dlinklist* head = (dlinklist*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dlinklist));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;data = <span class="number">-1</span>;</span><br><span class="line">    head-&gt;prior = head-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//head-&gt;prior = NULL; </span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlinklist_is_empty</span><span class="params">(dlinklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((head-&gt;next == head-&gt;prior) ?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求有效节点个数(求长度)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num_dlinklist</span><span class="params">(dlinklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    dlinklist *p = head-&gt;next; <span class="comment">//定义p指针指向第一个有效节点</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)  <span class="comment">//循环遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        num++;              <span class="comment">//统计节点数</span></span><br><span class="line">        p = p-&gt;next;        <span class="comment">//p指针向后偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_head_dlinklist</span><span class="params">(dlinklist* head, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备new 节点</span></span><br><span class="line">    dlinklist *<span class="keyword">new</span>  = (dlinklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dlinklist));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = val; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//头插法 插入</span></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next   == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = head-&gt;next;</span><br><span class="line">        <span class="keyword">new</span>-&gt;prior = head;</span><br><span class="line">        head-&gt;next = <span class="keyword">new</span>; </span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prior = <span class="keyword">new</span>; </span><br><span class="line">        <span class="keyword">new</span>-&gt;prior = head;</span><br><span class="line">        head-&gt;next = <span class="keyword">new</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印有效节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(dlinklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span>;</span><br><span class="line">    dlinklist *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-4d&quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_by_pos_dlinklist</span><span class="params">(dlinklist *head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_dlinklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备new 节点 和p 指针 </span></span><br><span class="line">    dlinklist* p = head; </span><br><span class="line">    dlinklist* <span class="keyword">new</span> = (dlinklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dlinklist));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = val;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将p 找到pos-1的位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="comment">//将新节点插入pos 位置</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>) <span class="comment">//尾插</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">        <span class="keyword">new</span>-&gt;prior = p;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;prior = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;prior = p;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_by_pos_dlinklist</span><span class="params">(dlinklist* head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dlinklist_is_empty(head)== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_dlinklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备p 指向pos-1， q 指向要删除的pos 节点</span></span><br><span class="line">    dlinklist* p = head;</span><br><span class="line">    dlinklist* q = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//找到pos -1位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--) <span class="comment">// pos -1</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    <span class="comment">//q = p-&gt;next ; </span></span><br><span class="line">    <span class="comment">//if(q-&gt;next == NULL) //尾删</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next-&gt;next == <span class="literal">NULL</span>) <span class="comment">//尾删</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        q = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        q-&gt;next-&gt;prior = p; </span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        q = <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>day24-栈与队列</title>
    <url>/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="day24-栈与队列"><a href="#day24-栈与队列" class="headerlink" title="day24-栈与队列"></a><font color="green">day24-栈与队列</font></h1><h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>&emsp;&emsp;栈和队列是两种常见的数据结构。它们都是线性结构，但它们的操作方式不同。栈是一种后进先出（LIFO）的数据结构，即最后进入的元素最先被访问。而队列是一种先进先出（FIFO）的数据结构，即最先进入的元素最先被访问。</p>
<p>&emsp;&emsp;在具体实现时，栈和队列也有所不同。栈只在一端进行插入和删除操作，这一端称为栈顶。而队列则在两端进行插入和删除操作，分别称为队头和队尾。</p>
<a id="more"></a>
<h3 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2. 实现方式"></a>2. 实现方式</h3><p>栈和队列的实现方式有很多种，这里我提供一些常见的实现方式。</p>
<p>栈的实现方式：</p>
<ol>
<li>用数组来模拟栈，用top变量表示栈顶元素的下标，用push()方法向栈顶添加元素，用pop()方法弹出栈顶元素。</li>
<li>用链表来模拟栈，用head指针表示栈顶元素，用push()方法向栈顶添加元素，用pop()方法弹出栈顶元素。</li>
<li>用双端队列（deque）来模拟栈，用append()方法向栈顶添加元素，用pop()方法弹出栈顶元素。</li>
</ol>
<p>队列的实现方式：</p>
<ol>
<li>用数组来模拟队列，用front和rear变量分别表示队头和队尾的下标，用push()方法向队尾添加元素，用pop()方法弹出队头元素。为了节省空间，常用循环队列来存放数据。循环队列的核心在于<code>求余%</code></li>
<li>用链表来模拟队列，用head和tail指针分别表示队头和队尾元素，用push()方法向队尾添加元素，用pop()方法弹出队头元素。</li>
<li>用两个栈来模拟队列，一个栈作为输入栈，一个栈作为输出栈。当需要弹出队头元素时，如果输出栈为空，则将输入栈中的所有元素依次弹出并压入输出栈中；否则直接从输出栈中弹出。</li>
</ol>
<blockquote>
<p>注：队列可以分为两种模式：</p>
<blockquote>
<ol>
<li>front存第一个数据，rear指向最后一个数据的下一个位置。数据是从0开始存的。</li>
<li>fornt指向第一个数据的上一个位置，rear存最后一个数据。数据是从1开始存的。</li>
</ol>
</blockquote>
</blockquote>
<h3 id="3-结构图解"><a href="#3-结构图解" class="headerlink" title="3. 结构图解"></a>3. 结构图解</h3><h4 id="栈的实现图解"><a href="#栈的实现图解" class="headerlink" title="栈的实现图解"></a>栈的实现图解</h4><ol>
<li>数组栈</li>
</ol>
<p><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/zhan.jpg" alt="数组栈"></p>
<ol start="2">
<li>链表栈   </li>
</ol>
<p>入栈<br><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/jinzhan_lian.gif" alt="链表入栈">  </p>
<p>出栈<br><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/chuzhan_lian.gif" alt="链表入栈"></p>
<h4 id="队列的实现图解"><a href="#队列的实现图解" class="headerlink" title="队列的实现图解"></a>队列的实现图解</h4><ol>
<li>数组队列(用的1的模式)</li>
</ol>
<p><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/duilie_shuzu.jpg" alt="数组队列">  </p>
<ol start="2">
<li>链表队列</li>
</ol>
<p><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/duilie_lianbiao.jpg" alt="数组队列"></p>
<br>
<br>

<hr>
<h2 id="二、栈与队列的c语言实现"><a href="#二、栈与队列的c语言实现" class="headerlink" title="二、栈与队列的c语言实现"></a>二、栈与队列的c语言实现</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造顺序栈类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">data_t</span> data[SIZE];<span class="comment">//顺序栈</span></span><br><span class="line">	<span class="keyword">int</span> top;<span class="comment">//保存栈顶元素的下标</span></span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空栈</span></span><br><span class="line"><span class="function"><span class="built_in">stack</span> *<span class="title">createSeqstack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span> *sq = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));<span class="comment">//给顺序栈开空间</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">memset</span>(sq-&gt;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(sq-&gt;data));<span class="comment">//清空顺序栈</span></span><br><span class="line">	sq-&gt;top = <span class="number">-1</span>;<span class="comment">//说明栈中无元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqstack_is_empty</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ((sq-&gt;top == <span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqstack_is_full</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ((sq-&gt;top == SIZE<span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求栈中元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLengthStack</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sq == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> (sq-&gt;top+<span class="number">1</span>);</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pushStack</span><span class="params">(<span class="built_in">stack</span> *sq, <span class="keyword">data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(seqstack_is_full(sq))<span class="comment">//判满</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	sq-&gt;data[sq-&gt;top+<span class="number">1</span>] = data;</span><br><span class="line">	sq-&gt;top++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">popStack</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sq == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(seqstack_is_empty(sq))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">data_t</span> data = sq-&gt;data[sq-&gt;top];<span class="comment">//data变量保存栈顶元素的值</span></span><br><span class="line">	sq-&gt;top--;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印栈中元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(seqstack_is_empty(sq))</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=sq-&gt;top;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sq-&gt;data[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>
<br>

<h3 id="链表栈"><a href="#链表栈" class="headerlink" title="链表栈"></a>链表栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造链式栈节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">data_t</span> data;<span class="comment">//节点的数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span><span class="comment">//保存下一个节点的地址</span></span><br><span class="line">&#125;lstack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空链式栈</span></span><br><span class="line"><span class="function">lstack *<span class="title">createLstack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lstack *top = (lstack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lstack));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	top-&gt;data = <span class="number">-1</span>;</span><br><span class="line">	top-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstack_is_empty</span><span class="params">(lstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ((top-&gt;next == <span class="literal">NULL</span>)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求栈中节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLengthLstack</span><span class="params">(lstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	lstack *p = top-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pushLstack</span><span class="params">(lstack *top, <span class="keyword">data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	lstack *<span class="keyword">new</span> = (lstack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lstack));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;data = data;</span><br><span class="line">	<span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将 new节点插入到栈顶位置，即  pos=0 位置处</span></span><br><span class="line">	<span class="keyword">new</span>-&gt;next = top-&gt;next;</span><br><span class="line">	top-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">popLstack</span><span class="params">(lstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(lstack_is_empty(top))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	lstack *p = top-&gt;next;<span class="comment">//p指针保存的是栈顶元素的地址</span></span><br><span class="line">	<span class="keyword">data_t</span> data = p-&gt;data;<span class="comment">//data变量保存的是栈顶节点的值</span></span><br><span class="line">	top-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印栈中各个节点的data值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfLstack</span><span class="params">(lstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(lstack_is_empty(top))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	lstack *p = top-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>
<br>

<h3 id="数组队列-求余思想"><a href="#数组队列-求余思想" class="headerlink" title="数组队列(求余思想)"></a>数组队列(求余思想)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">data_t</span> data[SIZE];</span><br><span class="line">	<span class="keyword">int</span> front; <span class="comment">//对头元素的位置</span></span><br><span class="line">	<span class="keyword">int</span> rear; <span class="comment">//队尾元素的下一个位置</span></span><br><span class="line">&#125;squeue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="function">squeue *<span class="title">createSqueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	squeue *sq = (squeue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(squeue));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(sq-&gt;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(sq-&gt;data));</span><br><span class="line"></span><br><span class="line">	sq-&gt;front = sq-&gt;rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squeue_is_empty</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ((sq-&gt;front == sq-&gt;rear)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squeue_is_full</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (sq-&gt;front == (sq-&gt;rear+<span class="number">1</span>)%SIZE )?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squeue_length</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	int num= 0;</span></span><br><span class="line"><span class="comment">	int temp = sq-&gt;front;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	while(temp != sq-&gt;rear)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		num++;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">		temp = (temp+1)%SIZE;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	return num;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">return</span> (sq-&gt;rear  + SIZE  -  sq-&gt;front)%SIZE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队, 在队尾进行入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squeue_in</span><span class="params">(squeue *sq, <span class="keyword">data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(sq-&gt;rear != <span class="number">0</span> &amp;&amp; sq-&gt;rear%(SIZE<span class="number">-1</span>)==<span class="number">0</span>)</span><br><span class="line">		sq-&gt;rear = (sq-&gt;rear+<span class="number">1</span>)%SIZE;</span><br><span class="line"></span><br><span class="line">	sq-&gt;data[sq-&gt;rear] = data;</span><br><span class="line"></span><br><span class="line">	sq-&gt;rear = (sq-&gt;rear+<span class="number">1</span>)%SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">squeue_out</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(squeue_is_empty(sq) == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">data_t</span> data = sq-&gt;data[sq-&gt;front];</span><br><span class="line"></span><br><span class="line">	sq-&gt;front = (sq-&gt;front+<span class="number">1</span>)%SIZE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispalySqueue</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> temp = sq-&gt;front;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(temp != sq-&gt;rear)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sq-&gt;data[temp]);</span><br><span class="line">	</span><br><span class="line">		temp = (temp+<span class="number">1</span>)%SIZE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<br>
<br>
<br>

<h3 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">data_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;linklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	linklist *front; <span class="comment">//指向对头元素的前一个位置</span></span><br><span class="line">	linklist *rear; <span class="comment">//指向队尾元素的位置</span></span><br><span class="line">&#125;lqueue;</span><br><span class="line"></span><br><span class="line"><span class="function">lqueue *<span class="title">createLqueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lqueue *lq = (lqueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lqueue));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	lq-&gt;front = (linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist)); <span class="comment">//返回头结点的地址</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq-&gt;front)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	lq-&gt;rear = lq-&gt;front;</span><br><span class="line"></span><br><span class="line">	lq-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> lq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lqueue_is_empty</span><span class="params">(lqueue *lq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (lq-&gt;front == lq-&gt;rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lqueue_length</span><span class="params">(lqueue *lq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	linklist *p = lq-&gt;front-&gt;next; <span class="comment">//p指向第一个有效结点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lqueue_in</span><span class="params">(lqueue *lq, <span class="keyword">data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	linklist *<span class="keyword">new</span> = (linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span>-&gt;data = data;</span><br><span class="line">	<span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	lq-&gt;rear-&gt;next = <span class="keyword">new</span>; </span><br><span class="line"></span><br><span class="line">	lq-&gt;rear = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">lqueue_out</span><span class="params">(lqueue *lq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lqueue_is_empty(lq))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	linklist *p = lq-&gt;front-&gt;next; <span class="comment">//指向对头元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">data_t</span> data = p-&gt;data;</span><br><span class="line"></span><br><span class="line">	lq-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lq-&gt;front-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">		lq-&gt;front == lq-&gt;rear;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayLqueue</span><span class="params">(lqueue *lq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	linklist *p = lq-&gt;front-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line"></span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>栈，队列</tag>
      </tags>
  </entry>
  <entry>
    <title>day25-二叉树</title>
    <url>/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="day25-树"><a href="#day25-树" class="headerlink" title="day25-树"></a><font color="green">day25-树</font></h1><h2 id="一、树的概念"><a href="#一、树的概念" class="headerlink" title="一、树的概念"></a>一、树的概念</h2><h3 id="1-树形结构的形式化"><a href="#1-树形结构的形式化" class="headerlink" title="1. 树形结构的形式化"></a>1. 树形结构的形式化</h3><h4 id="1-1-序偶"><a href="#1-1-序偶" class="headerlink" title="1.1 序偶"></a>1.1 序偶</h4><p>定义：设有两个元素x和y，由x和y构成的序偶记为&lt;x,y&gt;。  </p>
<blockquote>
<p>序偶可以描述有先后顺序要求的一对元素之间的关系，顺序很重要&lt;x,y&gt; $\not =$ &lt;y,x&gt;  </p>
</blockquote>
<h4 id="1-2-树的直接定义"><a href="#1-2-树的直接定义" class="headerlink" title="1.2 树的直接定义"></a>1.2 树的直接定义</h4><p>&emsp;&emsp;树是包括n（n$\geq$0）个元素的集合D，R是D中元素的序偶集合，若D为空，R也为空，此时为空树，否则R满足以下要求：</p>
<ul>
<li>有且仅有一个结点a $\in$ D，不存在任何节点v $\in$ D,v $\not =$ a，使得&lt;v,a&gt; $\in$ R,该结点为树的根。<font color="blue">如果树不为空，则树的根节点是唯一的</font></li>
<li>对于除根结点a以外任一结点u $\in$ D而言，都有且仅有一个结点 v $\in$ D，v $\not =$ u，使得&lt;v,u&gt; $\in$ R成立。<font color="blue">根节点没有前驱，其他结点均有唯一前驱</font></li>
</ul>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AE%9A%E4%B9%89.jpg" alt="树的直接定义"></p>
<a id="more"></a>
<h4 id="1-3-树的递归定义"><a href="#1-3-树的递归定义" class="headerlink" title="1.3 树的递归定义"></a>1.3 树的递归定义</h4><p>&emsp;&emsp;树是包括n个结点的有限集T，若n=0，则该数为空树；否则为非空树，在该非空树中，有且仅有一个特定的称为根的结点（r），其余结点(T-{r})划分成m(m$\geq$0)个互不相交的子集 $ T_1,T_2,…T_m $,其中，每个子集 $T_i$都是树，也称为树根节点r的子树。</p>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89.jpg" alt="树的递归定义"></p>
<h3 id="2-树的基本术语"><a href="#2-树的基本术语" class="headerlink" title="2. 树的基本术语"></a>2. 树的基本术语</h3><p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD1.jpg" alt="树的基本术语"></p>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD4.jpg" alt="树的基本术语"></p>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD5.jpg" alt="树的基本术语"></p>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD6.jpg" alt="树的基本术语"></p>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD7.jpg" alt="树的基本术语"></p>
<p>森林：树的集合，0棵或多棵不相交的树组成森林</p>
 <br>
 <br>

<hr>
<h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p> &emsp;&emsp;定义:二叉树是结点的有限集合，该集合或者为空集，或者是由一个根和两个互不相交的、称为该根的左子树和右子树的二叉树组成。</p>
<ul>
<li>二叉树要分左右顺序</li>
<li>二叉树的每个结点最多只能有2棵子树</li>
</ul>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ol>
<li>性质1：二叉树的第i（i $\geq$ 1）层上至多有 $2^{i-1}$ 个结点。（数学归纳法证明）</li>
<li>性质2：高度为h的二叉树上至多有 $2^h-1$ 个结点</li>
<li>性质3：包含n个节点的二叉树的高度最矮为 $log_2(n+1)$(向上取整) ,最高为n</li>
<li>任一棵二叉树中,若叶节点数量为 $n_0$ ,度为2的节点数量为 $n_2$ ,则有 $n_0=n_2+1$ </li>
</ol>
<h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3><ul>
<li><p>满二叉树:所有结点饱和  </p>
</li>
<li><p>完全二叉树:只有最下面两层结点的度可以小于2,且最下一层的叶节点均依次集中在靠左的位置上,<font color="blue">即除了最后一层结点其它结点都是满的,最后一层可以满也可以只有一个结点,但度为1的结点的子结点必须在左边</font></p>
<blockquote>
<p>设有n个节点的完全二叉树,按照从上到下,从左到右依次编号0-n-1. 则:</p>
<ol>
<li>i&gt;0,则该结点的双亲编号为(i-1)/2向下取整</li>
<li>若2i+1 &lt; n,则该节点的左孩子编号为2i+1,否则该节点无左孩子 </li>
<li>若2i+2 &lt; n,则该节点的右孩子编号为2i+2,否则该节点无右孩子</li>
</ol>
</blockquote>
</li>
<li><p>扩充二叉树:除叶子节点外,其余节点的度必须为2</p>
</li>
</ul>
<h3 id="二叉树ADT"><a href="#二叉树ADT" class="headerlink" title="二叉树ADT"></a>二叉树ADT</h3><ol>
<li>数组存储<br>用完全二叉树的顺序方式存储倒数组对应下标中. 不是完全二叉树就通过添加空结点改造成完全二叉树<br>缺点:可能会存在较大的空间浪费</li>
<li>链表存储<br>创建一个节点的结构体,其中包含该点数据,和该点的左子节点和右子节点<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BtBode</span>&#123;</span></span><br><span class="line">  ElemType element;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span> *<span class="title">lChild</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span> *<span class="title">rChild</span>;</span></span><br><span class="line">  <span class="comment">//struct btNode *parent</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">binarytree</span>&#123;</span></span><br><span class="line">  BtNode *root;</span><br><span class="line">&#125;Binary Tree;</span><br></pre></td></tr></table></figure>
<img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E8%A1%A8.jpg" alt="二叉树ADT"></li>
</ol>
<p>扩展:在链表结点中增加一个parent指针,令它指向该节点的双亲结点,就可以实现二叉树的双向链表结构</p>
<h3 id="二叉树的基本运算"><a href="#二叉树的基本运算" class="headerlink" title="二叉树的基本运算"></a>二叉树的基本运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造一棵空二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">(BinaryTree *bt)</span></span>&#123;</span><br><span class="line">  bt-&gt;root=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新节点,该节点的数据为x,ln和m为该节点的左右孩子</span></span><br><span class="line"><span class="function">BtNode* <span class="title">NewNode</span><span class="params">(ElemType x,BtNode *ln,BtNode *m)</span></span>&#123;</span><br><span class="line">  BtNode *p=(BtNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Btnode));</span><br><span class="line">  p-&gt;element=x;</span><br><span class="line">  p-&gt;lChild=ln;</span><br><span class="line">  p-&gt;rChild=m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给空的二叉树赋值x,并返回true,如果不是空的二叉树返回false</span></span><br><span class="line"><span class="function">BOOL <span class="title">Root</span><span class="params">(Binary Tree *bt,ElemType x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(bt-&gt;root)&#123;</span><br><span class="line">    x=&amp;bt-&gt;root-&gt;element;<span class="comment">//将root节点的数值的地址赋给x</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造二叉树bt,根节点的值为e,left和right为根的左右子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeTree</span><span class="params">(BinaryTree *bt,ElemType e,BinaryTree *left,BinaryTree *right)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(bt-&gt;root||left==right) <span class="keyword">return</span>; <span class="comment">//判断bt是否为空树以及左子树和右子树是否相同</span></span><br><span class="line">  bt-&gt;root=NewNode(e,left-&gt;root,right-&gt;root);</span><br><span class="line">  left-&gt;root=right-&gt;root=<span class="literal">NULL</span>; <span class="comment">//左右子树的root已经失去作用,置为NULL.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>day26-图</title>
    <url>/2023/04/01/day26-%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="day26-图"><a href="#day26-图" class="headerlink" title="day26-图"></a><font color="green">day26-图</font></h1>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>day27.5-静态库，动态库</title>
    <url>/2023/04/05/day27-5-%E9%9D%99%E6%80%81%E5%BA%93%EF%BC%8C%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<h1 id="day27-5-静态库，动态库"><a href="#day27-5-静态库，动态库" class="headerlink" title="day27.5-静态库，动态库"></a><font color="green">day27.5-静态库，动态库</font></h1><hr>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>c语言程序编译的步骤（源文件到可执行文件的编译）：</p>
<blockquote>
<p>预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接</p>
</blockquote>
<a id="more"></a>

<p>预处理：是使用预编译器cpp进行处理.c源文件和.h头文件，最终生成一个.i的文件。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line">或</span><br><span class="line">cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure>
<p>编译：是将<code>预处理</code>完的文件进行一系列的词法分析、语法分析、语义分析及优化，最后生成 .s 汇编代码文件。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>
<p>汇编：将汇编代码转变成机器可以执行的指令， 每一条汇编代码几乎都对应着一条机器指令。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o 或者 as hello.s -o hello.o</span><br></pre></td></tr></table></figure>

<p>链接：链接的作用就是我们这篇文章的重点，就是将我们编译出来的<code>目标文件</code>和我们代码所用到的<code>库文件</code>一起打包成一个<code>可执行文件</code>的过程。例如hello.c中的打印函数printf，这个函数不是凭空出现的，在链接的过程中就要连同对应库文件一起打包，最终可执行文件才能正常运行。</p>
<p><img src="/2023/04/05/day27-5-%E9%9D%99%E6%80%81%E5%BA%93%EF%BC%8C%E5%8A%A8%E6%80%81%E5%BA%93/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg" alt="编译"></p>
<br>
<br>

<hr>
<h2 id="二、静态库与动态库概念"><a href="#二、静态库与动态库概念" class="headerlink" title="二、静态库与动态库概念"></a>二、静态库与动态库概念</h2><h3 id="2-1-C头文件的编译"><a href="#2-1-C头文件的编译" class="headerlink" title="2.1 C头文件的编译"></a>2.1 C头文件的编译</h3><p>对于&lt;&gt;文件，gcc会在系统预设包含文件目录(如/usr/include)中搜寻相应的文件</p>
<blockquote>
<p> cpp-v：查看默认搜索头文件路径<br>对于””文件，gcc会首先当前目录中搜寻头文件，如没有则需要在编译选项中使用<code>-I 头文件所在目录</code> 到指定的目录下寻找头文件</p>
</blockquote>
<h3 id="2-2-库的概念"><a href="#2-2-库的概念" class="headerlink" title="2.2 库的概念"></a>2.2 库的概念</h3><ul>
<li><p>库函数：由某些组织或机构提供的，应用程序员可以直接调用。如Printf等</p>
</li>
<li><p>库：若干个函数的可执行代码，打包为库文件，提供了系统调用和c库的基本函数。</p>
</li>
<li><p>静态库：把需要的.c文件做出一个.a库文件，gcc编译时直接编译进可执行文件中。就只需要链接这个库文件。会让可执行文件变大。而且如果库文件更新了，可执行文件就需要重新编译</p>
</li>
<li><p>动态库：把需要的.c文件做出一个.so库文件，动态库中的代码是可执行文件在运行中加载执行的，gcc编译时不会编译进可执行的文件中。而是留好了记号，库文件更新了，可执行文件不用重新编译。</p>
</li>
</ul>
<br>
<br>

<hr>
<h2 id="三、静态库和动态库的使用"><a href="#三、静态库和动态库的使用" class="headerlink" title="三、静态库和动态库的使用"></a>三、静态库和动态库的使用</h2><h3 id="3-1-静态库"><a href="#3-1-静态库" class="headerlink" title="3.1 静态库"></a>3.1 静态库</h3><ul>
<li><p>生成静态库：</p>
<blockquote>
<ol>
<li>把库函数所属的.c文件编译成.o文件</li>
<li>用ar命令归档，生成文件libmyc.a。<code>ar -rc &lt;生成的档案文件名&gt; &lt;.o文件名列表&gt;</code>(一般取名是  <code>lib+名字+.a</code>)</li>
</ol>
</blockquote>
</li>
<li><p>使用静态库<br>假设头文件在includes目录中，生成的libmymath.a库在libs中</p>
<blockquote>
<ol>
<li>编译头文件：<code>gcc -c -I ./includes</code></li>
<li>链接静态库：<code>gcc -o main.o -L ./libs -lmymath</code> (链接库的名字时只需要<code>-l+名字</code>，不用加前面的lib)</li>
</ol>
</blockquote>
</li>
<li><p>用makefile实现</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ALL := main                          <span class="comment"># := 是递归赋值，即使变量已经被赋值了还能赋值</span></span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -Wall -g -I ./includes/    <span class="comment">#wall：显示所有警告信息 -g：编译时生成调试信息 “-I ./includes/”表示将当前目录下的“includes”文件夹添加到头文件搜索路径中</span></span><br><span class="line">LDFLAGS := -L ./libs -lmamath        <span class="comment">#-L ./libs -lymamath”。其中，“-L ./libs”表示将当前目录下的“libs”文件夹添加到链接库搜索路径中，“-lymamath”表示链接名为“libymamath.so”的库文件。</span></span><br><span class="line">SRC := $(wildcard *.c)               <span class="comment">#用“wildcard”函获取当前目录下的所有.c文件</span></span><br><span class="line">OBJ := $(patsubst %.c, %.o , $(SRC)) <span class="comment">#用“patsubst”函数将变量SRC中的每个文件名中的“.c”替换为“.o”</span></span><br><span class="line">$(ALL) : $(OBJ)</span><br><span class="line">    $(CC) -o <span class="variable">$@</span> $^ $(LDFLAGS)        <span class="comment">#$@”表示规则的目标文件，“$^”表示规则的所有依赖文件。</span></span><br><span class="line">%.o : %.c</span><br><span class="line">    $(CC) -c $&lt; $(CFLAGS)            <span class="comment">#编译所有的C源文件，生成对应的目标文件,其中$&lt;表示的是第一个依赖文件，也就是当前正在被编译的c源文件</span></span><br><span class="line">clean:</span><br><span class="line">    rm main *.o</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-动态库"><a href="#3-2-动态库" class="headerlink" title="3.2 动态库"></a>3.2 动态库</h3></li>
<li><p>动态库的封装</p>
</li>
</ul>
<blockquote>
<p>对要封装的.c文件（假设是mymath.c）使用指令：<code>gcc -o libmymath.so -shared -fPIC mymath.c</code></p>
</blockquote>
<ul>
<li>动态库的使用</li>
</ul>
<blockquote>
<p>编译：和静态库差不多，编译头文件：<code>gcc -c -I ./includes</code><br>再编译动态库：<code>gcc -o main.o -L ./libs -lmymath</code>(记得去掉打头的lib和结尾的.so)<br>运行：先把编译的库的目录加入到环境变量中（设库目录是./libs）：<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./libs</code>(将./libs追加到环境变量的后面)。再启动执行文件</p>
</blockquote>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>c，封装</tag>
      </tags>
  </entry>
  <entry>
    <title>day29-网络编程简介</title>
    <url>/2023/04/10/day29-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="day29-网络编程简介"><a href="#day29-网络编程简介" class="headerlink" title="day29-网络编程简介"></a><font color="green">day29-网络编程简介</font></h1><a id="more"></a>

<h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1-共享内存"><a href="#1-共享内存" class="headerlink" title="1. 共享内存"></a>1. 共享内存</h3><h4 id="1-1-共享内存通信流程"><a href="#1-1-共享内存通信流程" class="headerlink" title="1.1 共享内存通信流程"></a>1.1 共享内存通信流程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、生成key值</span></span><br><span class="line"><span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;a&#x27;</span>);  </span><br><span class="line"><span class="comment">//2、创建共享内存</span></span><br><span class="line"><span class="keyword">int</span> shmid = shmget(key, <span class="number">512</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line"><span class="comment">//3、内存映射</span></span><br><span class="line"><span class="keyword">void</span> *buf = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//4、数据读写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5、取消映射</span></span><br><span class="line">shmdt(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6、删除共享内存</span></span><br><span class="line">shmctl(shmid, IPC_RMID， <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>



<h3 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h3><h5 id="2-1-消息队列的执行过程"><a href="#2-1-消息队列的执行过程" class="headerlink" title="2.1 消息队列的执行过程"></a>2.1 消息队列的执行过程</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建消息队列</span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line">		参数：</span><br><span class="line">            key：</span><br><span class="line">            	ftok得到的key值或者 IPC_PRIVATE(创建私有的消息队列)</span><br><span class="line">            msgflg：</span><br><span class="line">            	IPC_CREAT | <span class="number">0664</span></span><br><span class="line">		返回值：</span><br><span class="line">            成功返回消息队列id，失败返回<span class="number">-1</span>；</span><br><span class="line">    </span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>; </span><br><span class="line">		参数：</span><br><span class="line">            smqid：</span><br><span class="line">            	创建或者打开消息队列得到的id号</span><br><span class="line">            msgp：</span><br><span class="line">            	是一个结构体指针，类型为<span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> *， 表示为发送消息结构体的首地址</span></span><br><span class="line"><span class="class">            <span class="title">msgsz</span>：</span></span><br><span class="line"><span class="class">            	消息正文内容的大小</span></span><br><span class="line"><span class="class">            <span class="title">msgflg</span>：</span></span><br><span class="line"><span class="class">            	0:</span>阻塞方式发送</span><br><span class="line">                IPC_NOWAIT：以非阻塞方式发送</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">               <span class="keyword">long</span> mtype;       <span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">               <span class="keyword">char</span> mtext[<span class="number">1</span>];    <span class="comment">/* message data */</span></span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">	 例：</span><br><span class="line">         <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>   //定义消息结构体</span></span><br><span class="line"><span class="class">         &#123;</span></span><br><span class="line">             <span class="keyword">long</span> mtype;</span><br><span class="line">             <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">         &#125;MSG;</span><br><span class="line"></span><br><span class="line">         <span class="meta">#<span class="meta-keyword">define</span> LEN (sizeof(MSG)-sizeof(long))  <span class="comment">//计算消息正文内容大小</span></span></span><br><span class="line"></span><br><span class="line">		 MSG msg;  <span class="comment">//定义消息结构体变量</span></span><br><span class="line">		 <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">			msg.mtype = <span class="number">100</span>;  <span class="comment">//封装消息类型</span></span><br><span class="line">		 	fgets(msg.mtext, <span class="number">1024</span>, <span class="built_in">stdin</span>);  <span class="comment">//输入消息正文</span></span><br><span class="line">		 	msg.mtext[<span class="built_in">strlen</span>(msg.mtext)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">         	msgsnd(id, &amp;msg， LEN, <span class="number">0</span>);  <span class="comment">//发送消息</span></span><br><span class="line">         &#125;   	</span><br><span class="line"><span class="comment">//接收消息</span></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line">		参数：</span><br><span class="line">            msgtyp：接收消息的类型</span><br><span class="line">    </span><br><span class="line"><span class="comment">//删除消息队列</span></span><br><span class="line">msgctl()            </span><br><span class="line">    </span><br></pre></td></tr></table></figure>





<h3 id="3-信号灯集"><a href="#3-信号灯集" class="headerlink" title="3. 信号灯集"></a>3. 信号灯集</h3><h5 id="3-1-相关接口函数"><a href="#3-1-相关接口函数" class="headerlink" title="3.1 相关接口函数"></a>3.1 相关接口函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建信号灯集</span></span><br><span class="line"><span class="keyword">int</span> semid = semget()    </span><br><span class="line"><span class="comment">//初始化信号灯集</span></span><br><span class="line"><span class="keyword">union</span> semun un;</span><br><span class="line">un.val = <span class="number">1</span>;</span><br><span class="line">semctl(semid, <span class="number">0</span>, SETVAL, un);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//PV操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">buf.sem_num = <span class="number">0</span>;  <span class="comment">//操作的信号灯的编号</span></span><br><span class="line">buf.sem_op = <span class="number">1</span>;   <span class="comment">//设置为V操作</span></span><br><span class="line">buf.sem_flag = IPC_NOWAIT; </span><br><span class="line">semop(semid, &amp;buf, <span class="number">1</span>); <span class="comment">//对信号灯集中第一个信号量进行V操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除信号灯集</span></span><br><span class="line">semctl(semid， <span class="number">0</span>, IPC_RMID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="二、网络编程"><a href="#二、网络编程" class="headerlink" title="二、网络编程"></a>二、网络编程</h2><h3 id="1-性能指标"><a href="#1-性能指标" class="headerlink" title="1. 性能指标"></a>1. 性能指标</h3><p>计算机网络的性能指标是用来衡量网络的质量和效率的一些量化的标准。根据1和2，常用的性能指标有以下几种：</p>
<ul>
<li>速率：连接在计算机网络上的主机在数字信道上传送数据的速率，单位是b/s（比特每秒）。</li>
<li>带宽：网络通信线路传送数据的能力，表示在单位时间内网络中某信道所能通过的“最高数据率”，单位也是b/s。</li>
<li>吞吐量：单位时间内通过网络的数据量，受网络的带宽或网络的额定速率的限制，单位也是b/s。</li>
<li>时延：数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，单位是s（秒）。时延由以下几个部分组成：<ul>
<li>发送时延：从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间，取决于数据长度和发送速率。</li>
<li>传播时延：电磁波在信道中需要传播一定的距离而花费的时间，取决于电磁波传播速度和链路长度。</li>
<li>处理时延：主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。</li>
<li>排队时延：分组在路由器输入输出队列中排队等待处理所经历的时延，取决于网络中当时的通信量。</li>
</ul>
</li>
<li>时延带宽积：链路的时延带宽积又称为以比特为单位的链路长度，表示该链路上可以容纳的比特数，单位是bit。</li>
<li>往返时间RTT：往返时间表示从发送方发送数据开始，到发送方收到来自接收方的确认（接收方接收到数据之后立即发送确认），总共经历的时间，只考虑信道上的传播时延。</li>
<li>利用率：利用率指出某信道有百分之几的时间是被利用的（有数据通过），分为信道利用率和网络利用率。信道利用率并非越高越好，当某信道的利用率增大时，该信道引起的时延也就迅速增加</li>
</ul>
<p><img src="/2023/04/10/day29-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/xinneng.jpg" alt="xinneng"></p>
<h3 id="2-网络协议模型"><a href="#2-网络协议模型" class="headerlink" title="2. 网络协议模型"></a>2. 网络协议模型</h3><h5 id="OSI七层协议模型-理论化的模型"><a href="#OSI七层协议模型-理论化的模型" class="headerlink" title="OSI七层协议模型(理论化的模型)"></a>OSI七层协议模型(理论化的模型)</h5><p>*应用层：解决通过应用进程的交互来说实现特定网络应用的问题</p>
<p>表示层：信息加密、解密，数据格式转换等操作</p>
<p>会话层：建立通信节点</p>
<p>*传输层：自下而上第一个提供完成端到端服务，解决进程之间基于网络的通信问题</p>
<p>*网络层：路由寻址(ip)  ip：在网络中唯一标识一台主机，解决分组在多个网络上传输的问题</p>
<p>*数据链路层：将物理层接收到的数据，进行帧格式的打包，纠错处理。解决分组在一个网络上的传输问题</p>
<p>*物理层：屏蔽物理硬件差异，光电信号的转换。用来解决使用何种信号来传输比特的问题。</p>
<p>物、数、网、传、会、表、应</p>
<h5 id="网络设备和OSE关系"><a href="#网络设备和OSE关系" class="headerlink" title="网络设备和OSE关系"></a>网络设备和OSE关系</h5><p>路由器的最高功能层是网络层3<br>交换器的最高功能层是数据链路层2<br>集线器的最高功能层是物理层1</p>
<h5 id="TCP-IP四层协议模型"><a href="#TCP-IP四层协议模型" class="headerlink" title="TCP/IP四层协议模型"></a>TCP/IP四层协议模型</h5><p>应用层:http(超文本传输协议)、FTP（文件传输协议）、DNS（域名解析，享受无连接服务）、NFS(网络挂载协议)、SSH（远程登录协议）</p>
<p>传输层：TCP协议、UDP协议，数据包为TCP报文段或UDP用户数据报</p>
<p>网络层：IP协议，数据包为IP数据报。提供的是无连接不可靠的数据报服务。</p>
<p>物理与网络接口层：以太网协议、PPP(拨号协议)、令牌环网、ARP(ip-&gt;mac)、RARP（mac-&gt;ip)，TCP/IP协议并没有在这层规定东西是为了可以互联全世界各种不同的网络接口。数据包为比特流</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tcp协议和udp协议</span><br><span class="line">    共同点：都是传输层的通信协议</span><br><span class="line">	不同点：</span><br><span class="line">    	tcp：面向连接，保证数据安全、可靠、不失序的一种通信协议</span><br><span class="line">    		应用场景：</span><br><span class="line">    			登录相关程序、重要文件</span><br><span class="line">    	udp：无连接，是一种不安全、不可靠的一种通信协议</span><br><span class="line">    		应用场景：</span><br><span class="line">    			流媒体软件、大型的音视频传输    </span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/10/day29-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/tcpip.jpg" alt="tcpip"></p>
<h3 id="3-网络编程预备知识"><a href="#3-网络编程预备知识" class="headerlink" title="3. 网络编程预备知识"></a>3. 网络编程预备知识</h3><h5 id="2-1-IP地址"><a href="#2-1-IP地址" class="headerlink" title="2.1 IP地址"></a>2.1 IP地址</h5><p>​    IP地址在网络中唯一标识一台主机</p>
<p>​    IPV4：32bit 4字节数据</p>
<p>​            点分十进制：”1.1.1.0”</p>
<p>​            二进制：00000001 00000001 00000001 00000000</p>
<p>​    IPV6：128bit</p>
<p>​    MAC：48bit全球唯一标识</p>
<p>​        ARP： ip –&gt; MAC</p>
<p>​        RARP: MAC –&gt; ip</p>
<h5 id="2-2-PORT端口号"><a href="#2-2-PORT端口号" class="headerlink" title="2.2 PORT端口号"></a>2.2 PORT端口号</h5><p>​    一个端口号对应一个进程</p>
<p>​    端口号：2字节，是一个short类型的正整数</p>
<p>​    端口号取值范围：0 ~ 65535</p>
<p>​        0不能使用</p>
<pre><code>     1~1023：系统端口，不能使用</code></pre>
<p>​        1024~5000：一般应用程序</p>
<p>​        5001~65535:系统预留自定义端口</p>
<h5 id="2-3-套接字-–socket"><a href="#2-3-套接字-–socket" class="headerlink" title="2.3 套接字 –socket"></a>2.3 套接字 –socket</h5><p>​    进程间通信的机制之一</p>
<p>​    本质：是一个特殊的文件描述符，是一个按顺序分配的最小的非负整数</p>
<h3 id="2-4-三次握手和四次挥手"><a href="#2-4-三次握手和四次挥手" class="headerlink" title="2.4 三次握手和四次挥手"></a>2.4 三次握手和四次挥手</h3><p>TCP的三次握手和四次挥手实质就是TCP通信的连接和断开。</p>
<p>三次握手：为了对每次发送的数据量进行跟踪与协商，确保数据段的发送和接收同步，根据所接收到的数据量而确认数据发送、接收完毕后何时撤消联系，并建立虚连接。</p>
<p>四次挥手：即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。</p>
<p><img src="/2023/04/10/day29-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/huishou.jpg" alt="huishou"></p>
<h4 id="2-4-1-三次握手"><a href="#2-4-1-三次握手" class="headerlink" title="2.4.1 三次握手"></a>2.4.1 三次握手</h4><p>TCP协议位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略。</p>
<h5 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h5><blockquote>
<p>第1次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；</p>
<p>第2次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了；</p>
<p>第3次握手：客户端再回传一个带有ACK标志的数据包，表示我知道了，握手结束。</p>
<p>其中：SYN标志位数置1，表示建立TCP连接；ACK标志表示验证字段。</p>
</blockquote>
<h5 id="三次握手详细说明"><a href="#三次握手详细说明" class="headerlink" title="三次握手详细说明"></a>三次握手详细说明</h5><ol>
<li><p>客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）；</p>
</li>
<li><p>服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接；</p>
</li>
<li><p>客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）。</p>
</li>
</ol>
<h4 id="2-4-2-四次挥手"><a href="#2-4-2-四次挥手" class="headerlink" title="2.4.2 四次挥手"></a>2.4.2 四次挥手</h4><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<h5 id="四次挥手​​​​​​​过程："><a href="#四次挥手​​​​​​​过程：" class="headerlink" title="四次挥手​​​​​​​过程："></a>四次挥手​​​​​​​过程：</h5><blockquote>
<p>第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；</p>
<p>第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；</p>
<p>第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；</p>
<p>第4次挥手：客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手。</p>
</blockquote>
<p>其中：FIN标志位数置1，表示断开TCP连接。</p>
<h5 id="四次挥手详细说明"><a href="#四次挥手详细说明" class="headerlink" title="四次挥手详细说明"></a>四次挥手详细说明</h5><ol>
<li><p>客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）；</p>
</li>
<li><p>服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y由服务端随机生成）；</p>
</li>
<li><p>服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输到A的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号。（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）；</p>
</li>
<li><p>客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h为客户端随机生成）<br>至此TCP断开的4次挥手过程完毕。</p>
</li>
</ol>
<h4 id="2-4-3-相关状态名词"><a href="#2-4-3-相关状态名词" class="headerlink" title="2.4.3 相关状态名词"></a>2.4.3 相关状态名词</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">LISTEN：等待从任何远端TCP 和端口的连接请求。</span><br><span class="line"> </span><br><span class="line">SYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。</span><br><span class="line"> </span><br><span class="line">SYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。</span><br><span class="line"> </span><br><span class="line">ESTABLISHED：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。</span><br><span class="line"> </span><br><span class="line">FIN_WAIT_1：等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。</span><br><span class="line"> </span><br><span class="line">FIN_WAIT_2：等待远端TCP 的连接终止请求。</span><br><span class="line"> </span><br><span class="line">CLOSE_WAIT：等待本地用户的连接终止请求。</span><br><span class="line"> </span><br><span class="line">CLOSING：等待远端TCP 的连接终止请求确认。</span><br><span class="line"> </span><br><span class="line">LAST_ACK：等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）</span><br><span class="line"> </span><br><span class="line">TIME_WAIT：等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认。</span><br><span class="line">TIME_WAIT 两个存在的理由：</span><br><span class="line">          1.可靠的实现tcp全双工连接的终止；</span><br><span class="line">          2.允许老的重复分节在网络中消逝。</span><br><span class="line"> </span><br><span class="line">CLOSED：不在连接状态（这是为方便描述假想的状态，实际不存在）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>day33-c++运算符重载</title>
    <url>/2023/04/21/day33-c++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="day33-c-运算符重载"><a href="#day33-c-运算符重载" class="headerlink" title="day33-c++运算符重载"></a><font color="green">day33-c++运算符重载</font></h1><!--mroe-->

<h2 id="一、什么是运算符重载"><a href="#一、什么是运算符重载" class="headerlink" title="一、什么是运算符重载"></a>一、什么是运算符重载</h2><p>运算符重载是一种特殊的函数重载，它允许我们为自定义的类或结构定义新的运算符含义，从而实现不同类型数据之间的操作。例如，我们可以重载加号运算符（+）来实现两个复数或者两个矩阵的相加。</p>
<p>运算符重载的本质是定义一个函数，并告诉c++编译器，当遇到该运算符时就调用此函数来执行相应的操作。这个函数叫做运算符重载函数，它可以是类的成员函数，也可以是类的友元函数。</p>
<p>C++编译器会根据操作数的类型来判断是否要调用操作符重载函数。如果操作数是用户自定义的类型，且存在一个匹配的操作符重载函数，那么就会调用这个函数。如果操作数是内置的类型，或者不存在一个匹配的操作符重载函数，那么就会使用操作符的原始含义。</p>
<h2 id="二、为什么要运算符重载"><a href="#二、为什么要运算符重载" class="headerlink" title="二、为什么要运算符重载"></a>二、为什么要运算符重载</h2><p>运算符重载的目的是为了提高代码的可读性和简洁性，让我们可以用自然的方式表达自定义类型之间的操作。例如，如果我们定义了一个分数类Fraction，我们可以通过重载加号运算符来实现两个分数对象的相加，而不需要调用一个特定的函数。</p>
<h2 id="三、运算符重载形式"><a href="#三、运算符重载形式" class="headerlink" title="三、运算符重载形式"></a>三、运算符重载形式</h2><p>运算符重载函数的一般形式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 <span class="keyword">operator</span> 运算符 (参数列表) &#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，operator是关键字，它与要重载的运算符一起构成函数名。返回值类型和参数列表根据不同的运算符和需求而定。</p>
<p>根据参数个数的不同，我们可以将运算符分为一元运算符和二元运算符。一元运算符只有一个参数，二元运算符有两个参数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一元运算符 - 的重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>- () &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(-real, -imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元运算符 + 的重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex&amp; c) &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(real + c.real, imag + c.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据定义位置的不同，我们可以将运算符分为类内重载和类外重载。</p>
<ul>
<li>类内重载：将运算符重载函数作为类的成员函数，这样可以直接访问类的私有成员。类内重载的函数通常只有一个参数，表示运算符的右操作数，左操作数默认为调用该函数的对象。</li>
<li>类外重载：将运算符重载函数作为类的友元函数或普通函数，这样需要显式地传递运算符的左右操作数。类外重载的函数通常有两个参数，分别表示运算符的左右操作数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line"><span class="comment">// 类内重载 + 运算符</span></span><br><span class="line">Point <span class="keyword">operator</span>+ (<span class="keyword">const</span> Point&amp; p) &#123;</span><br><span class="line"><span class="keyword">return</span> Point(x + p.x, y + p.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> Point <span class="keyword">operator</span>- (<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外重载 - 运算符</span></span><br><span class="line">Point <span class="keyword">operator</span>- (<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2) &#123;</span><br><span class="line"><span class="keyword">return</span> Point(p1.x - p2.x, p1.y - p2.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，当要操作类中私有成员时就用类内重载或者友员函数重载。当操作公用的成员时就能用类外普通函数重载。</p>
<h2 id="四、运算符重载的分类"><a href="#四、运算符重载的分类" class="headerlink" title="四、运算符重载的分类"></a>四、运算符重载的分类</h2><p>根据运算符操作数的个数，可以将运算符分为一元运算符和二元运算符。</p>
<ul>
<li>一元运算符：只有一个操作数，例如 +、-、*、&amp;、!、++、– 等。一元运算符可以作为前置或后置形式使用，例如 ++a 或 a++。一元运算符重载时，如果是类内重载，则不需要参数；如果是类外重载，则需要一个参数。</li>
<li>二元运算符：有两个操作数，例如 +、-、*、/、%、==、!=、&lt;、&gt; 等。二元运算符重载时，如果是类内重载，则需要一个参数；如果是类外重载，则需要两个参数。</li>
</ul>
<p>另外，还有一些特殊的运算符，例如 ()、[]、-&gt; 等，它们也可以进行重载，但必须作为类的成员函数进行类内重载。</p>
<p>自增分为前自增和后自增，这两个在语法上有一定的区别（后置++的参数要多个占位符<code>int</code>）,输入和输出重载返回值和参数有<code>ostream &amp;</code> 和 <code>istream &amp;</code>。</p>
<p><strong>当返回值是对象时需要用引用返回防止空间浪费</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point&amp; <span class="keyword">operator</span>+ (<span class="keyword">const</span> Point&amp; p) &#123;     <span class="comment">//类内实现操作符重载</span></span><br><span class="line">        Point* temp = <span class="keyword">new</span> Point(x + p.x, y + p.y);</span><br><span class="line">        <span class="keyword">return</span> *temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面这种返回引用有个问题，这样返回对象会造成一定的空间浪费，因为你需要在堆上分配一个临时对象，然后在栈上分配一个临时对象的拷贝。而且，临时对象的生命周期是由它所绑定的引用决定的，因为你返回了一个临时对象的引用，所以它的生命周期会延长到引用的生命周期结束为止，你还需要手动释放堆上的临时对象。</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2) &#123;<span class="comment">//类外友联实现操作符重载</span></span><br><span class="line">        <span class="keyword">return</span> Point(p1.x + p2.x, p1.y + p2.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这样返回不会造成空间浪费，当函数结束后临时对象会自动销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>++ (Point&amp; p1, <span class="keyword">int</span>)&#123; <span class="comment">//后置++</span></span><br><span class="line">        <span class="keyword">return</span> Point(p1.x++,p1.y++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span>++ (Point&amp; p1)&#123; <span class="comment">//前置++</span></span><br><span class="line">        <span class="keyword">return</span> Point(++p1.x,++p1.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Point &amp;p) &#123; <span class="comment">//输入重载</span></span><br><span class="line">        os &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,y=&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Point &amp;p) &#123;  <span class="comment">//输出重载</span></span><br><span class="line">        is &gt;&gt; p.x &gt;&gt; p.y;</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//括号重载，不能用友员函数写</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;x +=a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y +=b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">a</span><span class="params">(<span class="number">12</span>,<span class="number">13</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cin</span>  &gt;&gt; a ;</span><br><span class="line">    <span class="function">Point <span class="title">b</span><span class="params">(<span class="number">14</span>,<span class="number">15</span>)</span></span>;</span><br><span class="line">    Point c=b+(a++);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a;</span><br><span class="line">    a(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;c:&quot;</span>&lt;&lt;c;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//14 15</span></span><br><span class="line"><span class="comment">//a:x=15,y=16</span></span><br><span class="line"><span class="comment">//c:x=28,y=30</span></span><br><span class="line"><span class="comment">//a:x=16,y=18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//14 15</span></span><br><span class="line"><span class="comment">//a:x=15,y=16</span></span><br><span class="line"><span class="comment">//c:x=28,y=30</span></span><br><span class="line"><span class="comment">//a:x=16,y=18</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>重载运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>day34-c++模板</title>
    <url>/2023/04/24/day34-c-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="day34-c-模板"><a href="#day34-c-模板" class="headerlink" title="day34-c++模板"></a><font color="green">day34-c++模板</font></h1><!--mroe-->

<h2 id="一、c-模板简介"><a href="#一、c-模板简介" class="headerlink" title="一、c++模板简介"></a>一、c++模板简介</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><p>模板的概念是，我们可以定义一个函数或类的框架，但是不指定具体的数据类型，而是用一个占位符（如T）来表示。当我们使用模板时，编译器会根据我们传入的实际类型，生成对应的函数或类的代码。这样，我们就可以避免重复编写相同逻辑的代码，提高代码的复用性和可维护性。</p>
<h3 id="1-2-模板的作用"><a href="#1-2-模板的作用" class="headerlink" title="1.2 模板的作用"></a>1.2 模板的作用</h3><p>它可以让我们实现泛型编程（generic programming），即编写与数据类型无关的代码。泛型编程的优点是，它可以提高代码的效率和灵活性，减少错误和冗余，增加代码的可读性和可扩展性。例如，我们可以使用模板来实现一个通用的排序函数，它可以对任何类型的数组进行排序，而不需要为每种类型都写一个专门的排序函数。</p>
<h3 id="1-3-模板的使用场景"><a href="#1-3-模板的使用场景" class="headerlink" title="1.3 模板的使用场景"></a>1.3 模板的使用场景</h3><p>当我们需要对不同类型的数据进行相同或类似的操作时，我们可以考虑使用模板。例如，我们可以使用模板来实现一些常用的数据结构（如链表，栈，队列等），它们可以存储任何类型的数据。我们也可以使用模板来实现一些算法（如排序，查找，最大值等），它们可以处理任何类型的数据。</p>
<h3 id="1-4-模板的分类"><a href="#1-4-模板的分类" class="headerlink" title="1.4 模板的分类"></a>1.4 模板的分类</h3><p>模板的分类有两种：函数模板和类模板。 函数模板是指定义一个通用的函数，它可以根据不同的参数类型生成不同的函数代码。类模板是指定义一个通用的类，它可以根据不同的参数类型生成不同的类代码。函数模板和类模板都可以有多个参数类型，也可以有默认参数类型。函数模板和类模板都遵循一些语法规则，例如，在定义和使用模板时都要加上template关键字，在使用模板时都要加上尖括号（&lt;&gt;）来指定参数类型等。</p>
<br>
<br>

<hr>
<h2 id="二、c-模板定义"><a href="#二、c-模板定义" class="headerlink" title="二、c++模板定义"></a>二、c++模板定义</h2><p>模板的定义使用了关键字template，后面跟一个或多个模板参数，用尖括号&lt;&gt;括起来。模板参数可以是类型参数，也可以是非类型参数，如整数或枚举常量。例如，下面是一个简单的模板函数的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义函数模板add</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;   <span class="comment">//声明类型可以用typename也可以用class</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//根据实参类型自动匹配类型T为int</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add(<span class="number">3.14</span>,<span class="number">2.2</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> d = add(<span class="number">3.8</span>,<span class="number">2.9</span>); <span class="comment">//根据返回值类型适配类型T为double还是int</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;add(3,2.9)&lt;&lt;endl; //编译错误，有两种类型int和double,无法匹配类型T</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>,<span class="number">2.9</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//显示指定T为int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="三、c-模板使用"><a href="#三、c-模板使用" class="headerlink" title="三、c++模板使用"></a>三、c++模板使用</h2><p>多参数时可以设置为 template &lt;typename T，int x&gt;,下面是用模板类创建的数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">int</span> len&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Array(T val);</span><br><span class="line">    ~Array();</span><br><span class="line">    <span class="function">T <span class="title">getval</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> )</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setval</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ,<span class="keyword">const</span> T)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">int</span> len&gt;</span><br><span class="line">Array&lt;T,len&gt;::Array(T val) &#123;</span><br><span class="line">    buffer = <span class="keyword">new</span> T[len];</span><br><span class="line">    assert(buffer != <span class="literal">NULL</span>);  <span class="comment">//assert是一个宏定义，不是函数1。它用于检查程序中的条件是否为真。如果条件为假，程序会终止运行，并输出错误信息，包括断言的表达式，源文件名和行号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        buffer[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">int</span> len&gt;</span><br><span class="line">Array&lt;T,len&gt;::~Array() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">int</span> len&gt;</span><br><span class="line">T Array&lt;T,len&gt;::getval(<span class="keyword">const</span> <span class="keyword">int</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> buffer[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">int</span> len&gt;</span><br><span class="line"><span class="keyword">void</span> Array&lt;T,len&gt;::setval(<span class="keyword">const</span> <span class="keyword">int</span> pos,<span class="keyword">const</span> T val) &#123;</span><br><span class="line">    buffer[pos] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Array&lt;int , 10&gt; a(0);</span><br><span class="line">    a.setval(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    a.setval(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; a.getval(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; a.getval(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="四、c-友员模板函数"><a href="#四、c-友员模板函数" class="headerlink" title="四、c++友员模板函数"></a>四、c++友员模板函数</h2><p>友员模板函数是将模板函数声明为类的友员函数的一种方法。友员模板函数可以访问类的私有成员和保护成员，同时也可以根据不同的类型参数生成不同的函数实例。友员模板函数可以实现一些特定的功能，例如重载运算符，比较不同类型的对象，或者实现多态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个模板类 Complex，表示复数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T real; <span class="comment">// 实部</span></span><br><span class="line">    T imag; <span class="comment">// 虚部</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数，可以用两个参数或一个参数初始化</span></span><br><span class="line">    Complex(T r = <span class="number">0</span>, T i = <span class="number">0</span>) : real(r), imag(i) &#123;&#125;</span><br><span class="line"><span class="comment">// 获取实部的值</span></span><br><span class="line">    <span class="function">T <span class="title">getReal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> real; &#125;</span><br><span class="line"><span class="comment">// 获取虚部的值</span></span><br><span class="line">    <span class="function">T <span class="title">getImag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> imag; &#125;</span><br><span class="line"><span class="comment">// 定义一个友员模板函数，用于实现+的操作符重载</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> Complex&lt;U&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&lt;U&gt;&amp; a, <span class="keyword">const</span> Complex&lt;U&gt;&amp; b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友员模板函数的实现，返回两个复数相加的结果</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">Complex&lt;U&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&lt;U&gt;&amp; a, <span class="keyword">const</span> Complex&lt;U&gt;&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> Complex&lt;U&gt;(a.getReal() + b.getReal(), a.getImag() + b.getImag());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建两个 int 类型的复数对象</span></span><br><span class="line">    <span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex&lt;<span class="keyword">int</span>&gt; <span class="title">c2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="comment">// 使用+操作符重载，输出两个复数相加的结果</span></span><br><span class="line">    Complex&lt;<span class="keyword">int</span>&gt; c3 = c1 + c2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c3.getReal() &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c3.getImag() &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 + 6i</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再来个例子；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个非类型参数化的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T x, U y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C(<span class="keyword">const</span> T&amp; d) : data(d) &#123;&#125;</span><br><span class="line"><span class="comment">// 说明一个非类型参数化的函数模板为友员，并在非类型参数前加上typename关键字</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(U x, V y)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个非类型参数化的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">C&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">// 调用友员函数时，指定非类型参数的类型</span></span><br><span class="line">show&lt;C&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;(c, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>day35-c++类继承</title>
    <url>/2023/04/25/day35-c-%E7%B1%BB%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="day35-c-类继承"><a href="#day35-c-类继承" class="headerlink" title="day35-c++类继承"></a><font color="green">day35-c++类继承</font></h1><!--mroe-->

<h2 id="一、c-继承概念"><a href="#一、c-继承概念" class="headerlink" title="一、c++继承概念"></a>一、c++继承概念</h2><p>C++继承是面向对象程序设计中的一个重要概念，它允许我们根据一个已有的类来创建一个新的类，从而实现代码的重用和扩展。C++支持三种继承方式：公有继承、保护继承和私有继承，它们影响了基类和派生类之间成员的访问权限。C++还支持多继承，即一个派生类可以有多个基类，继承了它们的特性。在多继承中，有时会出现菱形继承的情况，即多个基类继承自同一个祖先类，导致派生类拥有重复的祖先类成员。为了解决这个问题，C++引入了虚继承和虚基类的概念，使得派生类只保留一份祖先类成员。</p>
<p>友员函数可以继承。</p>
<br>
<br>

<hr>
<h2 id="二、c-继承基础语法"><a href="#二、c-继承基础语法" class="headerlink" title="二、c++继承基础语法"></a>二、c++继承基础语法</h2><p>C++继承语法的一般形式是：</p>
<blockquote>
<p>class 派生类名 : 继承方式 基类名 {<br>&emsp;&emsp;派生类的成员<br>}</p>
</blockquote>
<p>&emsp;&emsp;其中，继承方式可以是public（公有）、protected（保护）或private（私有）三种之一，用来指定基类的成员在派生类中的访问权限。<br>&emsp;&emsp;如果不指定继承方式，默认为private。</p>
<blockquote>
<p>&emsp;&emsp;public是将基类的公有成员和保护成员继承给子类，且权限不变<br>&emsp;&emsp;protected是将基类的公有成员和保护成员继承给子类，并且权限变为protected，不能在外部访问。Protected继承也保持了父类和子类之间的is-a(继承，子类是父类的一种特殊情况)关系，但是这种关系对外部不可见。<br>&emsp;&emsp;private是将基类的共有成员和保护成员继承给子类，并且权限变为private。Private继承破坏了父类和子类之间的is-a关系，即子类不是一种特殊的父类。Private继承相当于把父类作为一个组件嵌入到子类中，实现了has-a(组合，一个类包含另一个类的对象)关系。</p>
</blockquote>
<p>&emsp;&emsp;例如，下面的代码定义了一个基类Animal和一个派生类Dog，Dog继承了Animal的所有成员，并增加了自己的成员函数bark()。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal is eating.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal is sleeping.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dog is barking.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这样，我们就可以通过Dog类的对象来调用Animal类的成员函数，以及Dog类自己的成员函数，如下：</span></span><br><span class="line">Dog d;</span><br><span class="line">d.eat(); <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">d.sleep(); <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">d.bark(); <span class="comment">// 调用派生类的成员函数</span></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="三、c-继承的构造和析构顺序"><a href="#三、c-继承的构造和析构顺序" class="headerlink" title="三、c++继承的构造和析构顺序"></a>三、c++继承的构造和析构顺序</h2><p>当创建一个派生类的对象时，会先调用基类的构造函数，然后再调用派生类的构造函数。如果基类有多个，那么会按照声明的顺序从左到右依次调用基类的构造函数。如果基类或派生类有成员对象，那么会在调用自身的构造函数之前先调用成员对象的构造函数。如果基类的构造函数有参数，那么需要在派生类的初始化列表中显式地传递参数给基类的构造函数。</p>
<p>其次，我们来看看析构函数的调用顺序。当销毁一个派生类的对象时，会先调用派生类的析构函数，然后再调用基类的析构函数。如果基类有多个，那么会按照声明的顺序从右到左依次调用基类的析构函数。如果基类或派生类有成员对象，那么会在调用自身的析构函数之后再调用成员对象的析构函数。</p>
<p><img src="/2023/04/25/day35-c-%E7%B1%BB%E7%BB%A7%E6%89%BF/gouzhao.png" alt="gouzhao"></p>
<br>
<br>

<hr>
<h2 id="四、c-继承的赋值"><a href="#四、c-继承的赋值" class="headerlink" title="四、c++继承的赋值"></a>四、c++继承的赋值</h2><ul>
<li>派生类的对象可以赋值给基类的对象，但是会发生对象切割，即派生类特有的成员会被忽略。</li>
<li>基类的对象不能赋值给派生类的对象，因为基类的对象可能缺少派生类需要的成员。</li>
<li>派生类的指针或引用可以赋值给基类的指针或引用，这样可以实现多态，即通过基类的指针或引用调用派生类的虚函数。</li>
<li>基类的指针或引用不能赋值给派生类的指针或引用，除非使用强制类型转换，但是这样做可能会导致运行时错误。</li>
</ul>
<br>
<br>

<hr>
<h2 id="五、c-继承的重名问题"><a href="#五、c-继承的重名问题" class="headerlink" title="五、c++继承的重名问题"></a>五、c++继承的重名问题</h2><p>在c++中，继承是一种实现代码复用和多态的重要机制。继承允许一个类（子类）从另一个类（父类）继承成员变量和成员函数，从而实现对父类的扩展和修改。但是，如果子类和父类中有同名的成员，那么就会出现重名问题，也就是说，子类中的同名成员会隐藏父类中的同名成员，导致访问冲突和歧义。</p>
<p>为了解决这个问题，c++提供了以下几种方法：</p>
<ul>
<li>使用作用域限定符（::）来指定访问哪个类中的同名成员。例如，如果子类A继承了父类B，并且都有一个同名的函数f()，那么可以通过A::f()来调用子类中的f()，或者通过B::f()来调用父类中的f()。</li>
<li>使用虚函数（virtual）来实现多态。虚函数是一种特殊的成员函数，它可以被子类重写（override），从而实现不同的行为。如果子类和父类中都有一个同名的虚函数f()，那么当通过父类指针或引用来调用f()时，会根据对象的实际类型来动态绑定（dynamic binding），调用相应的子类或父类中的f()。这样就可以避免歧义，并且提高了代码的灵活性和可维护性。</li>
<li>使用using声明（using declaration）来引入父类中的同名成员到子类的作用域中。这样可以使得子类和父类中的同名成员都可以被访问，而不需要使用作用域限定符。例如，如果子类A继承了父类B，并且都有一个同名的变量x，那么可以在子类A中使用using B::x;来引入父类中的x到子类的作用域中。这样就可以通过x来访问子类或父类中的x。</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>day36-c++多态</title>
    <url>/2023/04/26/day36-c-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="day36-c-多态"><a href="#day36-c-多态" class="headerlink" title="day36-c++多态"></a><font color="green">day36-c++多态</font></h1><!--mroe-->

<h2 id="一、多态概念"><a href="#一、多态概念" class="headerlink" title="一、多态概念"></a>一、多态概念</h2><p>&emsp;&emsp;C++多态是一种程序设计思想，它允许使用一个统一的接口来操作不同的对象。多态的好处是可以提高代码的可扩展性和复用性，减少重复的代码和冗余的判断。C++中实现多态的方式有两种：静态多态和动态多态。</p>
<p>&emsp;&emsp;静态多态是在编译时就确定了函数的调用，它主要依靠函数重载和运算符重载来实现。函数重载是指在同一作用域中，可以有多个同名但参数不同的函数，编译器根据函数的参数类型和个数来选择合适的函数。运算符重载是指可以为自定义的类型重新定义运算符的含义，使得运算符可以用于不同的对象。</p>
<p>&emsp;&emsp;动态多态是在运行时才确定了函数的调用，它主要依靠虚函数和继承来实现。虚函数是在基类中使用关键字virtual声明的函数，在派生类中可以重新定义该函数的行为。继承是指一个类可以从另一个类继承其成员变量和成员函数，形成类之间的层次关系。当基类的指针或引用指向派生类的对象时，通过该指针或引用调用虚函数，会根据对象的实际类型来执行相应的函数，这就是动态多态。</p>
<br>
<br>

<hr>
<h2 id="二、虚继承"><a href="#二、虚继承" class="headerlink" title="二、虚继承"></a>二、虚继承</h2><p>&emsp;&emsp;C++虚继承是一种特殊的继承方式，它可以解决多重继承中的菱形继承问题。菱形继承是指一个类继承了两个或多个具有相同基类的类，导致最终的派生类拥有多份基类的数据成员和成员函数。这样会造成数据冗余和二义性，影响程序的正确性和效率。</p>
<p>&emsp;&emsp;为了避免菱形继承的问题，C++引入了虚继承的概念。虚继承是指在继承关系中，使用virtual关键字修饰某个或某些基类，使得这些基类在派生类中只存在一份拷贝。这样，最终的派生类就不会出现重复的基类成员，也不会有二义性的调用。</p>
<p>&emsp;&emsp;虚继承的实现原理是通过虚基表和虚基指针来实现的。虚基表是一个存储了虚基类地址的表，每个虚基类都有一个虚基表。虚基指针是一个指向虚基表的指针，每个含有虚基类的派生类都有一个或多个虚基指针。当派生类对象访问虚基类成员时，就会通过虚基指针和虚基表找到对应的虚基类地址，然后再访问其成员。</p>
<p>下面是一个简单的例子，演示了类的虚继承的用法和效果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">A(<span class="keyword">int</span> x) : a(x) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类B，虚继承A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">B(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : A(x), b(y) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类C，虚继承A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">C(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : A(x), c(y) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类D，继承B和C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">D(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> w) : A(x), B(x, y), C(x, z), d(w) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">D <span class="title">obj</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// 创建D对象</span></span><br><span class="line">obj.show(); <span class="comment">// 调用D的show函数</span></span><br><span class="line">obj.B::show(); <span class="comment">// 调用B的show函数</span></span><br><span class="line">obj.C::show(); <span class="comment">// 调用C的show函数</span></span><br><span class="line">obj.A::show(); <span class="comment">// 调用A的show函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">d = 4</span><br><span class="line">b = 2</span><br><span class="line">c = 3</span><br><span class="line">a = 1</span><br></pre></td></tr></table></figure>

<p>可以看到，D对象只有一份A对象的拷贝，而不是两份。这就是虚继承的作用。</p>
<br>
<br>

<hr>
<h2 id="三、虚函数"><a href="#三、虚函数" class="headerlink" title="三、虚函数"></a>三、虚函数</h2><p>&emsp;&emsp;c++中，多态是通过虚函数来实现的。虚函数是在基类中用virtual关键字声明的成员函数，它可以在派生类中被重写（override）或重载（overload）。</p>
<p>&emsp;&emsp;当我们用一个基类指针或引用指向一个派生类对象时(向上隐式转换，即派生类转换为父类，舍弃虚函数以外的派生类独有成员)，如果调用的是虚函数，那么会根据指针或引用所指向的对象的实际类型来决定调用哪个版本的虚函数，这就是多态的表现形式。**<font color="blue">也就是说，接口只是一个形式，只有在运行时当把调用了接口的派生类给基类指针或者引用时，接口才有具体的形式。</font>**</p>
<p>例如，假设有一个基类Animal和两个派生类Cat和Dog，它们都有一个虚函数speak()，分别输出“喵喵”和“汪汪”。如果我们定义了一个Animal指针p，并让它分别指向一个Cat对象和一个Dog对象，那么当我们调用p-&gt;speak()时，就会根据p所指向的对象的类型来输出不同的声音：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="comment">// 虚函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Animal speaks&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写虚函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Meow&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; <span class="comment">// 重写虚函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Woof&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal* p = <span class="literal">nullptr</span>; <span class="comment">// 基类指针</span></span><br><span class="line">    Cat c; <span class="comment">// Cat对象</span></span><br><span class="line">    Dog d; <span class="comment">// Dog对象</span></span><br><span class="line">    p = &amp;c; <span class="comment">// 指向Cat对象</span></span><br><span class="line">    p-&gt;speak(); <span class="comment">// 调用Cat的speak()，输出Meow</span></span><br><span class="line">    p = &amp;d; <span class="comment">// 指向Dog对象</span></span><br><span class="line">    p-&gt;speak(); <span class="comment">// 调用Dog的speak()，输出Woof</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虚函数的限制：</p>
<ul>
<li>非类的成员函数不能定义为虚函数</li>
<li>虚函数不能是静态函数。静态函数属于类，而不属于对象，它不受对象类型的影响，因此不能被重写。</li>
<li>虚函数不能是构造函数。构造函数用于初始化对象，它在创建对象时就确定了对象的类型，因此不能被重写。但析构函数可以定义为虚函数。</li>
<li>虚函数不能是内联函数。内联函数在编译时就被替换为函数体，它不会产生函数调用的开销，但也失去了多态的特性，因此不能被重写。</li>
<li>虚函数不能是友元函数。友元函数不属于类的成员，它可以访问类的私有和保护成员，但它不受对象类型的影响，因此不能被重写。</li>
</ul>
</blockquote>
<p>析构函数一般要写成虚函数，不写的话当基类指针或引用指向派生类，在销毁时只会销毁基类而不会销毁派生类。当析构函数加上虚函数后销毁时就会都被销毁。</p>
<br>
<br>

<hr>
<h2 id="四、覆盖、重载和隐藏"><a href="#四、覆盖、重载和隐藏" class="headerlink" title="四、覆盖、重载和隐藏"></a>四、覆盖、重载和隐藏</h2><ol>
<li>覆盖</li>
</ol>
<p>覆盖（override）：指子类重新实现了父类中的虚函数，函数名、参数列表、返回类型必须与父类中的虚函数完全相同，覆盖后，在使用基类指针或引用调用虚函数时，将调用子类的实现。</p>
<p>覆盖是为了实现多态，让派生类可以根据自己的特性来修改基类中的虚函数行为，提高代码的灵活性和扩展性。</p>
<p>覆盖（override）的特征：</p>
<ul>
<li>只能用于虚函数</li>
<li>函数名、参数列表、返回类型必须与父类中的虚函数完全相同</li>
<li>在使用基类指针或引用调用虚函数时，将调用子类的实现</li>
<li>用于实现运行时多态性</li>
</ul>
<ol start="2">
<li>重载</li>
</ol>
<p>重载（overload）：指在同一个作用域内，函数名相同，但是参数列表不同的函数。在使用函数时，根据参数的类型、数量或顺序来选择正确的函数。重载不要求函数是虚函数。</p>
<p>重载是为了让同一个函数名可以根据不同的参数类型或个数来执行不同的操作，提高代码的简洁性和可读性。</p>
<p>重载（overload）的特征：</p>
<ul>
<li>函数名相同，但是参数列表不同的函数</li>
<li>在同一个作用域内定义</li>
<li>参数的类型、数量或顺序不同</li>
<li>返回类型可以相同也可以不同</li>
<li>不要求函数是虚函数</li>
<li>根据参数的类型、数量或顺序来选择正确的函数</li>
<li>编译器在编译时根据函数的参数类型来确定函数调用</li>
</ul>
<ol start="3">
<li>隐藏</li>
</ol>
<p>隐藏（hide）：指子类中的成员函数和父类中的成员函数同名，但参数列表不同，或者不是虚函数。在使用子类对象调用该函数时，将调用子类中的函数而不是父类中的函数。父类的同名函数被隐藏了，但不是被覆盖。</p>
<p>隐藏是为了避免派生类和基类中的同名函数发生混淆或冲突，提高代码的安全性和稳定性。</p>
<p>隐藏（hide）的特征：</p>
<ul>
<li>子类中的成员函数和父类中的成员函数同名，但参数列表不同，或者不是虚函数</li>
<li>在使用子类对象调用该函数时，将调用子类中的函数而不是父类中的函数</li>
<li>父类的同名函数被隐藏了，但不是被覆盖</li>
<li>在编译时根据调用的对象类型来确定函数调用</li>
</ul>
<ol start="4">
<li>之间的区别</li>
</ol>
<blockquote>
<ul>
<li>定义方式不同：覆盖是在子类中重新实现父类的虚函数，重载是在同一个作用域中定义多个同名函数，但是参数列表不同，隐藏是在子类中定义与父类同名但参数列表不同的非虚函数。</li>
<li>参数列表不同：覆盖要求完全相同，重载要求函数名相同且参数列表不同，而隐藏则要求函数名相同但参数列表不同。</li>
<li>是否是虚函数：覆盖只能用于虚函数，重载不要求函数是虚函数，而隐藏是在子类中定义非虚函数。</li>
<li>实现机制不同：覆盖是在编译时动态绑定的，而重载和隐藏是在编译时静态绑定的。</li>
<li>调用方式不同：覆盖是在使用基类指针或引用调用虚函数时，将调用子类的实现，而重载和隐藏是在编译时根据调用的对象类型来确定函数调用。</li>
</ul>
</blockquote>
<p>当然，这三种特性也有一些注意事项和限制：</p>
<ul>
<li>重载时要避免歧义和二义性，即不能让编译器无法判断应该调用哪个重载函数。</li>
<li>覆盖时要遵循里氏替换原则，即不能让派生类中的覆盖函数违反基类中虚函数的契约或预期。</li>
<li>隐藏时要注意作用域和指针类型，即不能让基类指针或引用调用到派生类中隐藏的函数或反之。</li>
</ul>
<br>
<br>

<hr>
<h2 id="五、抽象类"><a href="#五、抽象类" class="headerlink" title="五、抽象类"></a>五、抽象类</h2><p>C++ 抽象类是一种不能实例化的类，它包含了一个或多个纯虚函数，用来表示一种通用的概念或接口。纯虚函数是没有实现的虚函数，它们必须在派生类中被重写，否则派生类也不能实例化。抽象类的作用是为其他类提供一个可以继承的基类，从而实现多态性和代码复用。不能创建抽象类的对象。</p>
<p>纯虚函数的定义如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">virtual &lt;返回值&gt; &lt;函数名&gt;() = 0;//有纯虚数的类就是抽象类</span><br></pre></td></tr></table></figure>
<p>下面是一个抽象类的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个抽象类 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 纯虚函数，用 = 0 表示</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 普通成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">width = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">height = h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> width;</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个派生类 Rectangle，继承自 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 重写纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> width * height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个派生类 Triangle，继承自 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>:</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 重写纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> width * height / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主函数中使用抽象类和派生类</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 不能创建抽象类的对象</span></span><br><span class="line"><span class="comment">// Shape s; // 编译错误</span></span><br><span class="line"><span class="comment">// 可以创建指向抽象类的指针或引用</span></span><br><span class="line">Shape* p;</span><br><span class="line"><span class="comment">// 可以创建派生类的对象</span></span><br><span class="line">Rectangle r;</span><br><span class="line">Triangle t;</span><br><span class="line"><span class="comment">// 可以通过指针或引用调用纯虚函数</span></span><br><span class="line">p = &amp;r; <span class="comment">// 指向 Rectangle 对象</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rectangle area: &quot;</span> &lt;&lt; p-&gt;getArea() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 多态调用</span></span><br><span class="line">p = &amp;t; <span class="comment">// 指向 Triangle 对象</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Triangle area: &quot;</span> &lt;&lt; p-&gt;getArea() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 多态调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<br>
<br>

<hr>
<h2 id="六、限制构造"><a href="#六、限制构造" class="headerlink" title="六、限制构造"></a>六、限制构造</h2><p>c++限制构造是一种编程技术，用于防止类的对象被随意创建或复制。c++限制构造的目的是保证类的封装性和一致性，以及避免资源的浪费和泄露。c++限制构造的方法有以下几种：</p>
<ul>
<li>将构造函数或拷贝构造函数声明为私有或受保护的，这样只有类的成员函数或友元函数才能访问它们。</li>
<li>将构造函数或拷贝构造函数声明为删除的，这样编译器会报错，如果试图调用它们。</li>
<li>将构造函数或拷贝构造函数声明为纯虚的，这样类就变成了抽象类，不能创建对象。</li>
<li>将构造函数或拷贝构造函数定义为内联的，并在类内部抛出异常，这样运行时会发生错误，如果试图调用它们。</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>day37-c++异常，智能指针</title>
    <url>/2023/04/27/day37-c-%E5%BC%82%E5%B8%B8%EF%BC%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="day37-c-异常，智能指针"><a href="#day37-c-异常，智能指针" class="headerlink" title="day37-c++异常，智能指针"></a><font color="green">day37-c++异常，智能指针</font></h1><!--mroe-->

<h2 id="一、c-异常"><a href="#一、c-异常" class="headerlink" title="一、c++异常"></a>一、c++异常</h2><h3 id="1-异常简介"><a href="#1-异常简介" class="headerlink" title="1. 异常简介"></a>1. 异常简介</h3><p>C++异常是一种在程序运行过程中发生的意外或错误情况，例如除以零、数组越界、内存不足等。当异常发生时，程序的正常执行流程会被中断，转而执行一段专门用于处理异常的代码，称为异常处理器。异常处理器可以恢复程序的状态，继续执行后续的代码，或者终止程序并报告错误信息。</p>
<p>C++提供了一套异常处理机制，包括以下几个关键字：</p>
<ul>
<li>throw：用于抛出一个异常，可以是任意类型的表达式，例如<code>throw 0</code>; <code>throw &quot;error&quot;</code>; <code>throw std::runtime_error(&quot;invalid input&quot;)</code>;</li>
<li>try：用于定义一个可能抛出异常的代码块，例如<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span> / <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (...) &#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;division by zero\n&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>catch：用于捕获一个特定类型或所有类型的异常，并执行相应的处理代码，您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的,一般来说，throw什么类型的异常则要用同类型的catch参数来捕捉。例如<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( b == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (a/b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        z = division(x, y);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; z &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于我们抛出了一个类型为 const char* 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。</span></span><br></pre></td></tr></table></figure>
可以一个try用多个catch来捕捉，只不过前面的捕捉范围要比后面的小。</li>
<li>noexcept：用于指定一个函数是否保证不抛出异常，例如void foo() noexcept; void bar() noexcept(false);</li>
</ul>
<h3 id="2-异常规则"><a href="#2-异常规则" class="headerlink" title="2.异常规则"></a>2.异常规则</h3><ul>
<li><p>throw抛出的异常类型与catch抓取的异常类型要一致；</p>
</li>
<li><p>throw抛出的异常类型可以是子类对象，catch可以是父类对象；</p>
</li>
<li><p>catch块的参数推荐采用地址传递而不是值传递，不仅可以提高效率，还可以利用对象的多态性。另外，派生类的异常捕获要放到父类异常扑获的前面，否则，派生类的异常无法被扑获；</p>
</li>
<li><p>如果使用catch参数中，使用基类捕获派生类对象，一定要使用传递引用的方式，例如catch (exception &amp;e)；</p>
</li>
<li><p>异常是通过抛出对象而引发的，该对象的类型决定了应该激活哪个处理代码；</p>
</li>
<li><p>被选中的处理代码是调用链中与该对象类型匹配且离抛出异常位置最近的那一个；</p>
</li>
<li><p>在try的语句块内声明的变量在外部是不可以访问的，即使是在catch子句内也不可以访问；</p>
</li>
<li><p>栈展开会沿着嵌套函数的调用链不断查找，直到找到了已抛出的异常匹配的catch子句。如果抛出的异常一直没有函数捕获(catch)，则会一直上传到c++运行系统那里，导致整个程序的终止。</p>
</li>
</ul>
<h3 id="3-c-类"><a href="#3-c-类" class="headerlink" title="3. c++类"></a>3. c++类</h3><p>下面是c++类中常见的异常：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Exception</code></td>
<td>基本异常类，用作其他异常类的基类。</td>
</tr>
<tr>
<td><code>LogicError</code></td>
<td>逻辑错误的异常，由程序逻辑引起。</td>
</tr>
<tr>
<td><code>RuntimeError</code></td>
<td>运行时错误的异常，通常由运行时环境引起。</td>
</tr>
<tr>
<td><code>OutOfBoundsException</code></td>
<td>超出边界的异常，用于数组或容器访问超出范围。</td>
</tr>
<tr>
<td><code>NullPointerException</code></td>
<td>空指针异常，当使用空指针时抛出。</td>
</tr>
<tr>
<td><code>InvalidArgumentException</code></td>
<td>无效参数异常，当传递无效参数给函数或方法时抛出。</td>
</tr>
<tr>
<td><code>FileException</code></td>
<td>文件异常，当文件操作失败时抛出。</td>
</tr>
<tr>
<td><code>NetworkException</code></td>
<td>网络异常，当网络操作失败时抛出。</td>
</tr>
</tbody></table>
<h3 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4. 自定义异常"></a>4. 自定义异常</h3><p>您可以通过继承和重载 exception 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常类，继承自std::exception基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，使用传入的错误消息初始化异常对象</span></span><br><span class="line">    MyException(<span class="keyword">const</span> <span class="keyword">char</span>* message) : m_message(message) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写what()函数，返回错误消息</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span>  <span class="comment">//noexcept关键字表示该函数不会引发异常。override关键字用于告诉编译器，what()函数是对基类std::exception中的虚函数进行重写。这样做可以帮助确保函数签名与基类中声明的虚函数相匹配。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* m_message;  <span class="comment">// 错误消息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义除数为零异常类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DivideByZeroException</span> :</span> <span class="keyword">public</span> MyException</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，调用基类构造函数并传入错误消息</span></span><br><span class="line">    DivideByZeroException() : MyException(<span class="string">&quot;除数不能为零！&quot;</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义索引越界异常类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexOutOfBoundsException</span> :</span> <span class="keyword">public</span> MyException</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，调用基类构造函数并传入错误消息</span></span><br><span class="line">    IndexOutOfBoundsException() : MyException(<span class="string">&quot;索引越界！&quot;</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> DivideByZeroException();  <span class="comment">// 抛出除数为零异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> IndexOutOfBoundsException();  <span class="comment">// 抛出索引越界异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> MyException&amp; ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;捕获到异常: &quot;</span> &lt;&lt; ex.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="二、转换函数"><a href="#二、转换函数" class="headerlink" title="二、转换函数"></a>二、转换函数</h2><p>c++转换函数是一种特殊的成员函数，它可以将一个类的对象转换为另一种类型的值。转换函数的一般形式如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">operator 类型名()</span><br><span class="line">&#123;</span><br><span class="line">    // 转换操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，operator是关键字，类型名是要转换的目标类型，没有参数和返回类型。转换函数必须定义在类的内部，不能是静态的或常量的。转换函数可以被显式或隐式地调用，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subclass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">subclass</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subclass</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    subclass(<span class="keyword">int</span> x):x(x),Base(x)&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span> &lt;&lt;(ostream &amp;out, <span class="keyword">const</span> subclass &amp;obj)&#123;</span><br><span class="line">        out &lt;&lt; obj.x;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Base::<span class="keyword">operator</span> <span class="title">subclass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">subclass <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Base <span class="title">b</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码有两个注意点。一个是b=a是调用了Base的转换函数，实际b是个Base的int成员。</p>
<p>另一个是a=6过程中，a是一个subclass的对象，而不是一个基本类型的变量。当你给a赋值为6时，实际上是调用了subclass的构造函数，创建了一个新的subclass对象，并用它替换了原来的a。</p>
<p>C++标准库中提供了一些用于类型转换的标准转换函数。这些函数可以方便地进行常见的类型转换操作。以下是几个常用的标准转换函数：</p>
<ul>
<li><p><code>static_cast</code>: 用于执行静态类型转换，将一个表达式转换为指定类型。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> result = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(num);  <span class="comment">// 将整数 num 转换为双精度浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;num);  <span class="comment">// 将指向整数 num 的指针转换为 void* 类型</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>dynamic_cast</code>: 用于执行动态类型转换，在类层次结构中进行多态类型的转换。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> Derived();</span><br><span class="line">Derived* derivedPtr = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(basePtr);  <span class="comment">// 将基类指针转换为派生类指针</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>const_cast</code>: 用于移除变量的 <code>const</code> 修饰符或 <code>volatile</code> 修饰符。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* ptr = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;num);  <span class="comment">// 移除 num 的 const 修饰符，ptr 可以修改 num 的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = num;</span><br><span class="line"><span class="keyword">int</span>&amp; ref2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(ref);  <span class="comment">// 移除 ref 的 const 修饰符，ref2 可以修改 num 的值</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>reinterpret_cast</code>: 用于执行底层的重新解释转换。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span>* charPtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;num);  <span class="comment">// 将整数 num 的地址转换为字符指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* intPtr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(charPtr);  <span class="comment">// 将字符指针转换为整数指针</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<br>
<br>

<hr>
<h2 id="三、智能指针"><a href="#三、智能指针" class="headerlink" title="三、智能指针"></a>三、智能指针</h2><p>C++ 智能指针是一种能够自动管理动态分配内存的对象，它可以避免手动调用 new 和 delete 导致的内存泄漏或异常安全问题。C++ 标准库提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr 和 weak_ptr。</p>
<blockquote>
<ul>
<li>auto_ptr 已经被废弃，不建议使用。</li>
<li>unique_ptr是一种独占式的智能指针，它保证同一时间只有一个unique_ptr对象可以指向某个内存资源。当unique_ptr对象被销毁时，它会自动释放所指向的内存资源。unique_ptr不能被复制或赋值，只能通过移动语义来转移所有权。unique_ptr可以指向单个对象或者数组，也可以自定义删除器来处理特殊的资源释放方式。</li>
<li>shared_ptr是一种共享式的智能指针，它允许多个shared_ptr对象指向同一个内存资源。每个shared_ptr对象都有一个引用计数，表示有多少个shared_ptr对象共享该资源。当某个shared_ptr对象被销毁时，它会减少引用计数，当引用计数变为0时，才会释放所指向的内存资源。shared_ptr也可以指向单个对象或者数组，也可以自定义删除器。shared_ptr还可以和weak_ptr配合使用，避免循环引用导致的内存泄漏。</li>
<li>weak_ptr 是一种不影响引用计数的智能指针，它可以从一个 shared_ptr 或另一个 weak_ptr 构造，它用于观察对象是否还存在，而不延长其生命周期。</li>
</ul>
</blockquote>
<p>智能指针的使用可以简化 C++ 的内存管理，提高代码的可读性和安全性。</p>
<p><code>unique_ptr</code> 语法格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; ptr;  <span class="comment">// 创建一个名为 ptr 的 unique_ptr，指向类型为 T 的对象，初始为空指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> T(args...))</span></span>;  <span class="comment">// 创建一个 unique_ptr，同时进行对象的动态内存分配和初始化</span></span><br><span class="line"></span><br><span class="line">ptr.reset();  <span class="comment">// 释放 ptr 指向的对象，并将 ptr 重置为空指针</span></span><br><span class="line"></span><br><span class="line">T* rawPtr = ptr.get();  <span class="comment">// 获取 ptr 内部存储的原始指针</span></span><br><span class="line"></span><br><span class="line">ptr.release();  <span class="comment">// 释放 ptr 的所有权，返回内部存储的原始指针，并将 ptr 重置为空指针</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>shared_ptr</code> 语法格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; ptr;  <span class="comment">// 创建一个名为 ptr 的 shared_ptr，指向类型为 T 的对象，初始为空指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> T(args...))</span></span>;  <span class="comment">// 创建一个 shared_ptr，同时进行对象的动态内存分配和初始化</span></span><br><span class="line"></span><br><span class="line">ptr.reset();  <span class="comment">// 释放 ptr 指向的对象，并将 ptr 重置为空指针</span></span><br><span class="line"></span><br><span class="line">T* rawPtr = ptr.get();  <span class="comment">// 获取 ptr 内部存储的原始指针</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; ptr2 = ptr;  <span class="comment">// 使用复制构造函数创建一个新的 shared_ptr，与 ptr 共享对象所有权，引用计数增加</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; ptr3 = <span class="built_in">std</span>::make_shared&lt;T&gt;(args...);  <span class="comment">// 使用 make_shared 创建 shared_ptr，更高效的分配内存</span></span><br><span class="line"></span><br><span class="line">ptr.use_count();  <span class="comment">// 返回与 ptr 共享对象所有权的 shared_ptr 的数量</span></span><br><span class="line"></span><br><span class="line">ptr.reset();  <span class="comment">// 释放 ptr 指向的对象，并将 ptr 重置为空指针，引用计数减少，当引用计数为零时，对象被销毁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面是shared_ptr的示例代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor called!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~MyClass() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor called!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Some function called!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; <span class="title">sharedPtr1</span><span class="params">(<span class="keyword">new</span> MyClass())</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; sharedPtr2 = sharedPtr1;  <span class="comment">// 复制构造函数增加引用计数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; sharedPtr3 = sharedPtr1;  <span class="comment">// 引用计数增加到3</span></span><br><span class="line"></span><br><span class="line">    sharedPtr1-&gt;SomeFunction();</span><br><span class="line">    sharedPtr2-&gt;SomeFunction();</span><br><span class="line">    sharedPtr3-&gt;SomeFunction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有 shared_ptr 离开作用域后，拥有的对象会自动被销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>异常</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>day38-c++类库</title>
    <url>/2023/04/28/day38-c-%E7%B1%BB%E5%BA%93/</url>
    <content><![CDATA[<h1 id="day38-c-类库"><a href="#day38-c-类库" class="headerlink" title="day38-c++类库"></a><font color="green">day38-c++类库</font></h1><!--mroe-->

<h2 id="一、STL简介"><a href="#一、STL简介" class="headerlink" title="一、STL简介"></a>一、STL简介</h2><p>标准模板库 STL（Standard Template Library），是 C++ 标准库的一部分，不需要单独安装，只需要#include 头文件。</p>
<p>STL六大部件：</p>
<ul>
<li>容器（Containers）</li>
<li>分配器（Allocators）</li>
<li>算法（Algorithm）</li>
<li>迭代器（Iterators）</li>
<li>适配器（Adapters）</li>
<li>仿函数（Functors）</li>
</ul>
<p>库类函数很多，这里就只拿vector进行演示，更多的函数请查询相关库。</p>
<h2 id="二、vector"><a href="#二、vector" class="headerlink" title="二、vector"></a>二、vector</h2><p>vector（矢量），是一种「变长数组」，即“自动改变数组长度的数组”。</p>
<p>值得一提的是，vector可以用来以邻接表的方式储存图，非常友好，非常简洁。</p>
<p>要使用vector，需要添加头文件：<code>#include &lt;vector&gt;</code></p>
<ol>
<li>vector的定义</li>
</ol>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">vector&lt;类型名&gt; 变量名;</span><br><span class="line">vector&lt;int&gt; array[SZIE]; //二维变长数组</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">vector&lt;int&gt; name;</span><br><span class="line">vector&lt;double&gt; name;</span><br><span class="line">vector&lt;char&gt; name;</span><br><span class="line">vector&lt;struct node&gt; name;</span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; name;//注意：&gt; &gt;之间要加空格</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>vector容器内元素的访问</li>
</ol>
<ul>
<li><p>通过下标访问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    vi.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;vi[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过迭代器访问：<br>迭代器（iterator）可以理解为指针：</p>
</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">vector&lt;类型名&gt;::iterator 变量名;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//v.begin()返回v的首元素地址</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=v.begin();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;it[i]&lt;&lt;<span class="string">&quot; &quot;</span>;  <span class="comment">//it[i]也可以写成it.at(i)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是一些常见的与<code>std::vector</code>相关的函数及其参数：</p>
<ol>
<li><code>push_back(const T&amp; value)</code>: 在vector的末尾添加一个值为<code>value</code>的元素。</li>
<li><code>pop_back()</code>: 删除vector的末尾元素。</li>
<li><code>size() const</code>: 返回vector中元素的个数。</li>
<li><code>empty() const</code>: 检查vector是否为空，如果为空则返回true，否则返回false。</li>
<li><code>clear()</code>: 清空vector，删除所有元素。</li>
<li><code>insert(iterator position, const T&amp; value)</code>: 在迭代器<code>position</code>指定的位置插入一个值为<code>value</code>的元素。</li>
<li><code>erase(iterator position)</code>: 删除迭代器<code>position</code>指定位置的元素。</li>
<li><code>resize(size_type count)</code>: 调整vector的大小为<code>count</code>，可以增加或减少元素的个数。</li>
<li><code>reserve(size_type count)</code>: 设置vector的容量为至少<code>count</code>，即预留一定的空间。</li>
<li><code>at(size_type pos)</code>: 访问索引为<code>pos</code>的元素，返回引用。</li>
<li><code>front() const</code>: 返回vector的第一个元素的引用。</li>
<li><code>back() const</code>: 返回vector的最后一个元素的引用。</li>
<li><code>begin()</code>: 返回指向vector第一个元素的迭代器。</li>
<li><code>end()</code>: 返回指向vector末尾（最后一个元素的下一个位置）的迭代器。</li>
</ol>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>day39-QT简介</title>
    <url>/2023/05/04/day39-QT%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="day39-QT简介"><a href="#day39-QT简介" class="headerlink" title="day39-QT简介"></a><font color="green">day39-QT简介</font></h1><!--mroe-->

<h2 id="一、QT简介"><a href="#一、QT简介" class="headerlink" title="一、QT简介"></a>一、QT简介</h2><p>&emsp;&emsp;QT是一个跨平台的应用程序开发框架，它可以用来创建图形用户界面（GUI）和非GUI应用程序。QT的特点是使用C++作为编程语言，提供了一套丰富的类库和工具，以及一种元对象系统（MOC），可以实现信号和槽机制，以及动态类型转换等功能。</p>
<p>&emsp;&emsp;QT的优势在于它提供了一致的编程接口和体验，无论是在不同的操作系统或者不同的设备上，都可以使用相同的代码和工具来创建应用程序。QT还提供了许多高级的功能和组件，例如网络、数据库、多媒体、XML、OpenGL等。此外，QT还支持多种编程语言，除了C++之外，还有Python、Ruby、Java等。QT还有一个活跃的社区和开源许可，使得开发者可以方便地获取技术支持和资源。</p>
<br>
<br>

<hr>
<h2 id="二、QT项目结构"><a href="#二、QT项目结构" class="headerlink" title="二、QT项目结构"></a>二、QT项目结构</h2><p>一般来说，一个QT项目由以下几个部分组成：</p>
<ul>
<li>.pro文件：这是一个项目配置文件，它定义了项目的基本信息，如项目名称、版本、目标平台、源文件列表、头文件列表、资源文件列表、依赖库等。.pro文件是由qmake工具解析的，qmake可以根据.pro文件生成相应平台的构建文件，如Makefile或Visual Studio工程文件。</li>
<li>源文件：这是项目的核心部分，它包含了项目的业务逻辑和算法实现，通常以.cpp为扩展名。源文件中可以包含QT的宏和关键字，如Q_OBJECT、signals、slots等，这些宏和关键字可以被moc工具识别和处理，moc可以根据源文件生成元对象代码，这些代码实现了QT的对象模型和信号槽机制。</li>
<li>头文件：这是项目的接口部分，它声明了项目中使用的类、函数、变量等，通常以.h为扩展名。头文件中也可以包含QT的宏和关键字，如Q_OBJECT、signals、slots等，这些宏和关键字同样可以被moc工具识别和处理，moc可以根据头文件生成元对象代码。</li>
<li>资源文件：这是项目的外观部分，它包含了项目中使用的图标、图片、音频、视频等非代码资源，通常以.qrc为扩展名。资源文件是由rcc工具解析的，rcc可以根据资源文件生成二进制资源代码，这些代码可以被嵌入到可执行文件中，或者作为外部文件分发。</li>
<li>界面文件：这是项目的视觉部分，它定义了项目中使用的窗口、控件、布局等图形用户界面元素，通常以.ui为扩展名。界面文件是由uic工具解析的，uic可以根据界面文件生成界面代码，这些代码可以被包含到源文件中，或者作为单独的头文件使用。</li>
</ul>
<p>通常创建的qt项目工程里有如下文件：</p>
<blockquote>
<p>pro：指导生成makefile<br>widget.h：窗体类的定义<br>widget.cpp：类中成员函数<br>main.cpp:主函数  功能: 定义窗体对象 显示窗体 进入事件循环<br>widget.ui(xml): ui文件 uic工具将ui文件转换成c++代码 -&gt; ui_widget.h</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="三、QT函数结构"><a href="#三、QT函数结构" class="headerlink" title="三、QT函数结构"></a>三、QT函数结构</h2><h3 id="3-1-main-cpp"><a href="#3-1-main-cpp" class="headerlink" title="3.1 main.cpp"></a>3.1 main.cpp</h3><p>main.cpp 是主函数文件，内部主要包含应用程序的入口函数，也就是 main() 函数。Qt 界面程序中的 main() 函数也有固定的格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;<span class="comment">//事件循环对象</span></span><br><span class="line">    <span class="comment">//函数主体</span></span><br><span class="line">    widget w;<span class="comment">//窗体对象，调用构造函数</span></span><br><span class="line">    w.show();<span class="comment">//显示界面</span></span><br><span class="line">    <span class="comment">//~函数主体</span></span><br><span class="line">    <span class="keyword">return</span> a.exec();<span class="comment">//事件循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中a.exec的功能如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">while(1)&#123;</span><br><span class="line">    1.阻塞休眠等待事件发生</span><br><span class="line">    2.当事件发生后通过事件处理器处理事件（虚函数）</span><br><span class="line">        a.标准事件：事件处理器直接处理</span><br><span class="line">        b.非标准事件：事件处理器不知道怎么处理-&gt;emit信号 用户:关联信号与槽函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-widget-h"><a href="#3-2-widget-h" class="headerlink" title="3.2 widget.h"></a>3.2 widget.h</h3><p>widget.h是界面的头文件，里面主要包含了widget的命名空间，基类QWidget和widget结构体。<br>下面是一般的widget格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//名字空间</span></span><br><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span><span class="comment">//声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> QWidget <span class="comment">//界面类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT <span class="comment">//支持元对象编译器moc,即支持信号与槽</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;<span class="comment">//构造函数</span></span><br><span class="line">    ~Widget();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">signals:<span class="comment">//自定义信号</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MySignal</span><span class="params">(QString)</span></span>;</span><br><span class="line"><span class="keyword">private</span> slots:<span class="comment">//槽函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_btnClose_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_btnInsert_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTitle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on_btnWin_clicked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MySlot</span><span class="params">(QString)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::Widget *ui;<span class="comment">//对象指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<blockquote>
<p>注：如果要用到ui编辑则需要把widget声明在ui里，并且在ui里面的拖动的对象都要通过 <code>ui-&gt;对象名</code> 来调用</p>
</blockquote>
<h3 id="3-3-widget-cpp"><a href="#3-3-widget-cpp" class="headerlink" title="3.3 widget.cpp"></a>3.3 widget.cpp</h3><p>widget.cpp里面是界面的主要内容，包括构造析构函数，成员和槽函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ui_widget.h&quot;</span> <span class="comment">//uic工具在编译时将widget.ui转换成c++代码</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) : <span class="comment">//构造函数的定义</span></span><br><span class="line">    QWidget(parent),<span class="comment">//给基类的构造函数传递实参:parent</span></span><br><span class="line">    ui(<span class="keyword">new</span> Ui::Widget) <span class="comment">//ui = new Ui::Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);<span class="comment">//界面布局</span></span><br><span class="line"></span><br><span class="line">    connect(ui-&gt;btnTitle,SIGNAL(clicked(<span class="keyword">bool</span>)),<span class="keyword">this</span>,SLOT(setTitle()));<span class="comment">//关联信号与槽  btnTitle -&gt; clicked() -&gt; Widget -&gt;setTitle()</span></span><br><span class="line">    connect(<span class="keyword">this</span>,SIGNAL(MySignal(QString)),<span class="keyword">this</span>,SLOT(MySlot(QString)));<span class="comment">//关联自定义信号和自定义槽函数</span></span><br><span class="line"></span><br><span class="line">    ui-&gt;lineEdit-&gt;setText(<span class="string">&quot;aaaaaaaaaa&quot;</span>);<span class="comment">//设置文本</span></span><br><span class="line">    qDebug() &lt;&lt; ui-&gt;lineEdit-&gt;text();<span class="comment">//获取文本</span></span><br><span class="line"></span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;Widget&quot;</span>;<span class="comment">//跟踪打印</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()<span class="comment">//析构函数的定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.信号与槽关联： 右键组件 -&gt; 转到槽 -&gt; 信号</span></span><br><span class="line">                <span class="comment">//适合: 标准信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_btnClose_clicked</span><span class="params">()</span><span class="comment">//btnClose -&gt; clicked 信号 -&gt; widget -&gt; on_btnClose_clicked()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot;on_btnClose_clicked。。。。。&quot;</span>;<span class="comment">//跟踪打印</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;close();<span class="comment">//关窗口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.信号与槽关联： 通过命名规则关联，其实和第一种本质一样</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_btnInsert_clicked</span><span class="params">()</span><span class="comment">//命名规则：on_对象指针名_信号名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    QString str;</span><br><span class="line">    str.<span class="built_in">sprintf</span>(<span class="string">&quot;i=%d&quot;</span>,++i);</span><br><span class="line"></span><br><span class="line">    ui-&gt;btnInsert-&gt;setText(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.信号与槽关联： 通过 +/-关联</span></span><br><span class="line">    <span class="comment">//适合：信号和槽都是标准的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.通用的信号与槽函数的关联方式：</span></span><br><span class="line">    <span class="comment">//connect</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::setTitle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowTitle(<span class="string">&quot;MyWin&quot;</span>);<span class="comment">//修改窗体标题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_btnWin_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    QString str;</span><br><span class="line">    str.<span class="built_in">sprintf</span>(<span class="string">&quot;i=%d&quot;</span>,++i);</span><br><span class="line"></span><br><span class="line">    ui-&gt;btnWin-&gt;setText(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//emit 自定义信号(str) -&gt; 自定义槽函数 -&gt; 显示为窗口标题</span></span><br><span class="line">    <span class="function">emit <span class="title">MySignal</span><span class="params">(str)</span></span>;<span class="comment">//触发自定义信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::MySlot</span><span class="params">(QString msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowTitle(msg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>自己设置的信号要用emit触发。</p>
</blockquote>
<h2 id="四、QT内存管理"><a href="#四、QT内存管理" class="headerlink" title="四、QT内存管理"></a>四、QT内存管理</h2><ul>
<li><p>自动存储管理：Qt中的大多数对象是使用自动存储管理的，这意味着它们的内存管理是由C++的自动变量和栈来处理的。当对象超出其作用域时，它们的内存会自动释放。</p>
</li>
<li><p>动态存储管理：有时候需要在堆上分配对象，并手动管理它们的内存。Qt提供了两个主要的机制来进行动态内存管理：new 和 delete 运算符。可以使用 new 在堆上分配一个对象，并使用 delete 来释放它。注意，在使用 new 创建对象后，必须手动调用 delete 来释放它，以避免内存泄漏。另外，Qt还提供了 deleteLater() 函数，可以在稍后的时间点安全地删除对象。</p>
</li>
<li><p>父子关系：Qt中的对象可以通过指定父对象来建立层次关系。当父对象被销毁时，它会自动销毁其所有的子对象。这种机制简化了内存管理，因为你只需要删除父对象，而不需要手动删除所有的子对象。</p>
</li>
<li><p>智能指针：Qt还提供了一些智能指针类，如 QSharedPointer 和 QScopedPointer，用于帮助管理对象的生命周期。这些智能指针类能够自动跟踪对象的引用计数，并在不再需要时自动释放对象。</p>
</li>
</ul>
<br>
<br>

<hr>
<h2 id="五、QT信号与槽简介"><a href="#五、QT信号与槽简介" class="headerlink" title="五、QT信号与槽简介"></a>五、QT信号与槽简介</h2><p>&emsp;&emsp;Qt信号与槽是一种对象间通信的机制，可以让一个对象在发生某种事件时，通知另一个对象执行相应的操作。信号与槽机制是Qt的核心特性，也是Qt与其他框架最大的不同之处。</p>
<p>&emsp;&emsp;信号是由对象发出的，表示某种状态的改变或者用户的操作。槽是用来响应信号的函数，可以是任何能和信号关联的成员函数或者普通函数。信号和槽可以通过QObject::connect()函数进行连接，指定发送对象、发送的信号、接收对象和接收的槽。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连接QPushButton的clicked信号和QLabel的setText槽</span></span><br><span class="line">connect(button, SIGNAL(clicked()), label, SLOT(setText(<span class="string">&quot;Hello World&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>信号和槽有以下特点：</p>
<ul>
<li>信号和槽可以包含任意数量和类型的参数，只要参数类型可以进行隐式转换（类型匹配，信号参数的个数大于等于槽函数参数个数）或者注册到元对象系统。</li>
<li>信号和槽必须使用void关键字声明，不能有返回值。</li>
<li>信号和槽可以使用public、protected或者private修饰符，但是一般建议使用public或者protected。</li>
<li>信号和槽可以使用Q_OBJECT宏声明在任何继承自QObject的类中，也可以使用Q_SIGNALS和Q_SLOTS宏声明在任何类中。</li>
<li>一个信号可以连接到多个槽，一个槽也可以连接到多个信号。当信号发出时，连接到它的所有槽都会按照连接顺序依次执行。</li>
<li>一个信号可以连接到另一个信号，这样当第一个信号发出时，会自动触发第二个信号。</li>
<li>一个对象可以断开和另一个对象的所有连接，也可以断开特定的连接。断开连接可以使用QObject::disconnect()函数实现。</li>
</ul>
<p>信号与槽相连接的几种方法：</p>
<ol>
<li>右键组件-&gt;转到槽-&gt;选择信号-&gt;确定（命名规则：on_对象指针名_信号名）</li>
<li>直接命名方式</li>
<li>+/-</li>
<li>connect(发送信号的对象，信号，接收信号的对象，槽函数)</li>
</ol>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>day41-ARM指令</title>
    <url>/2023/05/17/day41-ARM%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="day41-ARM指令"><a href="#day41-ARM指令" class="headerlink" title="day41-ARM指令"></a><font color="green">day41-ARM指令</font></h1><!--mroe-->

<h2 id="一、基本指令"><a href="#一、基本指令" class="headerlink" title="一、基本指令"></a>一、基本指令</h2><ol>
<li><p>搬移指令：这类指令主要用于在寄存器之间复制数据，或者把立即数值复制到寄存器。</p>
<ul>
<li><p><code>MOV</code>: 这个指令将第二个操作数的值复制到第一个操作数（一个寄存器）。例如，<code>MOV r0, r1</code>将把r1寄存器的值复制到r0寄存器。</p>
</li>
<li><p><code>MVN</code>: 这个指令将第二个操作数的值取反然后复制到第一个操作数（一个寄存器）。例如，<code>MVN r0, r1</code>将把r1寄存器的值取反，然后将结果复制到r0寄存器。</p>
</li>
</ul>
</li>
<li><p>逻辑指令：这类指令用于执行逻辑运算，如AND、OR、NOT和XOR。</p>
<ul>
<li><code>CMP</code> (Compare): 这个指令用于比较两个操作数的值。它将第一个操作数和第二个操作数相减，然后设置条件代码标志，但不保存结果。例如，<code>CMP r0, r1</code>会比较r0和r1的值。如果r0大于r1，那么会设置大于标志；如果r0等于r1，那么会设置等于标志；如果r0小于r1，那么会设置小于标志。</li>
</ul>
</li>
</ol>
<blockquote>
<p><code>CMP</code>主要用于改变程序的状态寄存器（CPSR），包括以下几个标志：</p>
<p>（1）<strong>Z（零标志）</strong>：如果两个操作数相等，即它们相减的结果为0，那么零标志就会被设置。</p>
<p>（2）<strong>N（负标志）</strong>：如果第一个操作数小于第二个操作数，那么结果会是负数，此时负标志会被设置。</p>
<p>（3）<strong>C（进位标志）</strong>：如果在无符号比较中，第一个操作数小于第二个操作数，进位标志会被设置。</p>
<p>（4）<strong>V（溢出标志）</strong>：如果在有符号比较中发生溢出，溢出标志会被设置。</p>
<p>在<code>CMP</code>指令后通常会跟随一个条件跳转指令，如<code>BNE</code>（如果上一个比较操作的结果不为零，则跳转），<code>BLT</code>（如果上一个比较操作的结果为负，则跳转）等，这些指令根据CPSR中的标志来决定是否跳转。</p>
</blockquote>
<ul>
<li><p><code>AND</code>: 这个指令将第一个和第二个操作数进行位与运算，然后将结果存入第一个操作数。例如，<code>AND r0, r1</code>将r0和r1的每一位进行与运算，然后将结果存入r0。</p>
</li>
<li><p><code>ORR</code>: 这个指令将第一个和第二个操作数进行位或运算，然后将结果存入第一个操作数。例如，<code>ORR r0, r1</code>将r0和r1的每一位进行或运算，然后将结果存入r0。</p>
</li>
<li><p><code>EOR</code>: 这个指令将第一个和第二个操作数进行异或运算，然后将结果存入第一个操作数。例如，<code>EOR r0, r1</code>将r0和r1的每一位进行异或运算，然后将结果存入r0。</p>
</li>
<li><p><code>BIC</code>: 这个指令将第一个操作数和第二个操作数的反码进行位与运算，然后将结果存入第一个操作数。例如，<code>BIC r0, r1</code>将r0和r1的反码进行与运算，然后将结果存入r0。</p>
</li>
<li><p><code>TST</code>: 这个指令用于测试两个操作数的位模式。它将第一个操作数和第二个操作数进行位与运算，然后设置条件代码标志，但不保存结果。例如，TST r0, r1会将r0和r1进行位与运算。如果结果为0，那么会设置零标志；否则，不设置零标志。</p>
</li>
</ul>
<ol start="3">
<li><p>位移指令：这类指令主要用于在位级别上移动寄存器的值。</p>
<ul>
<li><p><code>LSL</code>: 逻辑左移。这个指令将第一个操作数的值左移第二个操作数指定的位数，空出的位用0填充。例如，<code>LSL r0, r1, #2</code>将把r1寄存器的值左移2位，然后将结果存入r0寄存器。</p>
</li>
<li><p><code>LSR</code>: 逻辑右移。这个指令将第一个操作数的值右移第二个操作数指定的位数，空出的位用0填充。例如，<code>LSR r0, r1, #2</code>将把r1寄存器的值右移2位，然后将结果存入r0寄存器。</p>
</li>
<li><p><code>ROR</code>: 循环右移。这个指令将第一个操作数的值右移第二个操作数指定的位数，从尾部移出的位被插入到头部。例如，ROR r0, r1, #2将把r1寄存器的值右移2位，然后将结果存入r0寄存器。</p>
</li>
<li><p><code>RRX</code>: 带扩展的循环右移。这个指令将第一个操作数的值右移一位，将进位标志放入最高有效位，并将最低有效位放入进位标志。例如，RRX r0, r1将把r1寄存器的值右移一位，然后将结果存入r0寄存器。</p>
</li>
</ul>
</li>
<li><p>加载/存储指令：这些指令用于在存储器和寄存器之间传输数据。最常见的有<code>LDR</code>（Load Register）和<code>STR</code>（Store Register）。</p>
<blockquote>
<p>ldr r1,=srcBuf @将标准srcBuf的地址加载到寄存器r1。</p>
</blockquote>
<ul>
<li><code>LDR</code>：从内存中加载数据到寄存器。例如，<code>LDR r0, [r1]</code>将从r1寄存器指向的内存地址加载数据到r0寄存器。也就是r0 = *r1</li>
<li><code>STR</code>：将寄存器中的数据存储到内存。例如，<code>STR r0, [r1]</code>将把r0寄存器中的数据存储到r1寄存器指向的内存地址。 *r1 = r0</li>
<li></li>
</ul>
</li>
<li><p>批量操作指令：这些指令允许你一次对多个寄存器进行操作。常见的有<code>LDM</code>（Load Multiple）和<code>STM</code>（Store Multiple）。</p>
<ul>
<li><code>LDM</code>：从内存中加载多个寄存器。例如，<code>LDMIA r0!, &#123;r1-r3&#125;</code>会从r0寄存器指向的地址开始连续加载r1, r2, r3这三个寄存器，并且在加载后自动增加r0的值。</li>
<li><code>STM</code>：将多个寄存器的值存储到内存中。例如，<code>STMIA r0!, &#123;r1-r3&#125;</code>会将r1, r2, r3这三个寄存器的值连续存储到r0寄存器指向的地址开始的内存位置，并且在存储后自动增加r0的值。</li>
</ul>
</li>
<li><p>堆栈指令：堆栈是一种特殊的数据结构，后入先出（LIFO）。ARM汇编中，通常使用<code>PUSH</code>和<code>POP</code>指令操作堆栈。</p>
<ul>
<li><code>PUSH</code>：将一个或多个寄存器的值压入堆栈。例如，<code>PUSH &#123;r0, lr&#125;</code>会将r0寄存器和链接寄存器lr的值压入堆栈。</li>
<li><code>POP</code>：从堆栈中弹出一个或多个值到寄存器。例如，<code>POP &#123;r0, lr&#125;</code>会将堆栈的顶部两个值弹出，分别存入r0寄存器和链接寄存器lr。</li>
<li><code>STMFD</code>用于函数调用的过程中保存和恢复寄存器的状态。<code>STMFD sp!, &#123;r0-r3, lr&#125;</code>将把r0至r3和lr这些寄存器的值连续存储到栈（由栈指针sp指向的内存）中，并且在存储后自动减小sp的值（因为在ARM中，栈是向下增长的）；</li>
<li><code>LDMFD</code>用于函数调用的过程中保存和恢复寄存器的状态。<code>LDMFD sp!, &#123;r0-r3, pc&#125;</code>则从栈中加载r0至r3和程序计数器pc的值，并且在加载后自动增加sp的值。</li>
</ul>
</li>
<li><p>软中断指令：<code>SWI</code>（Software Interrupt）指令用于触发软件中断。这通常用于调用操作系统的服务。</p>
<ul>
<li><code>SWI</code>：后面跟一个立即数，表示中断号。例如，<code>SWI 0x123456</code>会触发中断号为0x123456的软件中断。</li>
</ul>
</li>
</ol>
<ol start="8">
<li>LDMFD/STMFD：这是<code>LDM</code>和<code>STM</code>的特殊形式，通常用于函数调用的过程中保存和恢复寄存器的状态。例如，<code>STMFD sp!, &#123;r0-r3, lr&#125;</code>将把r0至r3和lr这些寄存器的值连续存储到栈（由栈指针sp指向的内存）中，并且在存储后自动减小sp的值（因为在ARM中，栈是向下增长的）；<code>LDMFD sp!, &#123;r0-r3, pc&#125;</code>则从栈中加载r0至r3和程序计数器pc的值，并且在加载后自动增加sp的值。</li>
</ol>
<br>
<br>

<hr>
<h2 id="二、异常"><a href="#二、异常" class="headerlink" title="二、异常"></a>二、异常</h2><h3 id="2-1-异常简介"><a href="#2-1-异常简介" class="headerlink" title="2.1 异常简介"></a>2.1 异常简介</h3><p>ARM的异常是指任何改变程序正常执行流程的条件或系统事件。</p>
<p>ARM架构将异常分为两大类：同步异常和异步异常。</p>
<ul>
<li>同步异常是由当前执行的指令引起的，例如未定义指令，数据终止，或者系统调用等。</li>
<li>异步异常是由外部事件引起的，例如中断或者调试请求等。</li>
</ul>
<p>当发生异常时，处理器会停止当前执行的代码，跳转到一个专门处理该异常的代码段，称为<strong>异常处理程序</strong>。每种异常类型都有自己的<strong>异常向量表</strong>。</p>
<p>ARM架构还引入了不同的<strong>特权级别</strong>和<strong>异常级别</strong>来控制软件对系统和处理器资源的访问权限。</p>
<ul>
<li>特权级别决定了软件实体可以看到和控制哪些处理器资源。</li>
<li>异常级别表示当前处理器处于哪种特权级别。只有在发生异常或者从异常返回时，当前的特权级别才会改变。<h3 id="2-2-异常向量表"><a href="#2-2-异常向量表" class="headerlink" title="2.2 异常向量表"></a>2.2 异常向量表</h3><ul>
<li>ARM的异常向量表是一个存储<strong>异常处理程序地址</strong>的内存区域。</li>
</ul>
</li>
<li>每个<strong>异常级别</strong>（EL3，EL2，EL1）都有自己的向量表。</li>
<li>向量表中的每个条目包含一个要执行的指令，通常是一个跳转到完整异常处理程序的分支指令。</li>
<li>向量表中的每个条目占16个指令（在ARMv7-A和AArch32中，每个条目只占4个字节）。<ul>
<li>向量表的基地址由<strong>向量基址寄存器</strong>（VBAR_EL3，VBAR_EL2和VBAR_EL1）给出。</li>
</ul>
</li>
<li>每个条目相对于基地址有一个固定的偏移量。</li>
<li>向量表有16个条目，每个条目占128字节（32个指令）。<ul>
<li>使用哪个条目取决于以下几个因素：</li>
</ul>
</li>
<li>异常类型（SError，FIQ，IRQ或同步）</li>
<li>如果在同一异常级别发生异常，要使用的栈指针（SP0或SPn）</li>
<li>如果在较低异常级别发生异常，下一较低级别的执行状态（AArch64或AArch32）</li>
</ul>
<p><img src="/2023/05/17/day41-ARM%E6%8C%87%E4%BB%A4/error.png" alt="异常向量表"></p>
<blockquote>
<p>异常指定了优先级和固定的服务顺序:</p>
<ul>
<li>Reset（复位）</li>
<li>Data Abort（数据中止）</li>
<li>FIQ（快中断）</li>
<li>IRQ（中断）</li>
<li>Prefetch About（预取中止）</li>
<li>SWI（软中断）</li>
<li>Undefined instruction（未定义指令）</li>
</ul>
</blockquote>
<h3 id="2-3-异常过程"><a href="#2-3-异常过程" class="headerlink" title="2.3 异常过程"></a>2.3 异常过程</h3><ul>
<li>ARM的异常处理过程是通过一个称为<strong>向量表</strong>的内存区域来控制的。<ul>
<li>向量表通常位于内存映射的底部，从0x0到0x1c。</li>
<li>每种异常类型在向量表中分配一个字，该字包含一个分支指令或者一个异常处理程序的地址。</li>
</ul>
</li>
</ul>
<p>用一个”Undefined Instruction”异常作为示例：</p>
<ol>
<li><p>当执行到无效的指令时，会引发一个”Undefined Instruction”异常。</p>
</li>
<li><p>ARM核心首先会停止当前指令的执行，并将异常指令的地址+4（如果在ARM状态下）或者+2（如果在Thumb状态下）保存到LR中。</p>
</li>
<li><p>接着，ARM核心会将CPSR的值保存到SPSR中，切换到Undefined模式，并更新CPSR的值以反映新的状态。这包括将模式位设置为Undefined模式，禁用一些或所有中断，并设置适当的指令集。</p>
</li>
<li><p>然后，ARM核心会将PC寄存器设置为”Undefined Instruction”异常向量的地址（通常是0x00000004），并开始执行位于该地址的异常处理程序。</p>
</li>
<li><p>在开始执行异常处理程序前，会使用STMFD SP!, {R0-R12, LR}指令将当前的寄存器状态保存到堆栈中。</p>
</li>
<li><p>异常处理程序执行完毕后，会使用LDMFD SP!, {R0-R12, PC}^指令从堆栈中恢复之前保存的寄存器状态。</p>
</li>
<li><p>最后，异常处理程序通过将SPSR的值复制回CPSR，并将LR的值复制回PC，从而恢复到异常发生前的状态，并继续执行下一个指令。</p>
</li>
</ol>
<p>下面是ASM的异常标准格式：<br>.word 是汇编语言中的一个伪指令，它用于在内存中存储一个固定大小的数据。在大多数汇编语言中，.word 通常用于存储一个整数或者一个地址。(一般是存储过大的立即数)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    .global  delay1s </span><br><span class="line">    .text     </span><br><span class="line">    .global _start</span><br><span class="line">_start:</span><br><span class="line">		b		reset                        @0x00</span><br><span class="line">		ldr		pc,_undefined_instruction  @0x04</span><br><span class="line">		ldr		pc,_software_interrupt     </span><br><span class="line">		ldr		pc,_prefetch_abort</span><br><span class="line">		ldr		pc,_data_abort</span><br><span class="line">		ldr		pc,_not_used</span><br><span class="line">		ldr		pc,_irq</span><br><span class="line">		ldr		pc,_fiq</span><br><span class="line"></span><br><span class="line">_undefined_instruction: .word  _undefined_instruction</span><br><span class="line">_software_interrupt:	.word  _software_interrupt</span><br><span class="line">_prefetch_abort:		.word  _prefetch_abort</span><br><span class="line">_data_abort:			.word  _data_abort</span><br><span class="line">_not_used:				.word  _not_used</span><br><span class="line">_irq:					.word  _irq </span><br><span class="line">_fiq:					.word  _fiq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reset: </span><br><span class="line">	ldr	r0,&#x3D;0x40008000      @设置异常向量表的起始地址为0x40008000，也就是开始位置</span><br><span class="line">	mcr	p15,0,r0,c12,c0,0		@ Vector Base Address Register  修改异常向量表的起始地址</span><br><span class="line"></span><br><span class="line">init_stack:</span><br><span class="line">	ldr		r0,stacktop         &#x2F;*这样做的目的是使得每个模式都有自己的独立堆栈空间，这样当处理器在不同模式之间切换时，每个模式的堆栈上下文都能被保留，从而避免了上下文切换时的混乱。*&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;********svc mode stack********&#x2F;</span><br><span class="line">		mov		sp,r0</span><br><span class="line">		sub		r0,#128*4          &#x2F;*512 byte  for irq mode of stack*&#x2F;</span><br><span class="line">	&#x2F;****irq mode stack**&#x2F;</span><br><span class="line">		msr		cpsr,#0xd2</span><br><span class="line">		mov		sp,r0</span><br><span class="line">		sub		r0,#128*4          &#x2F;*512 byte  for irq mode of stack*&#x2F;</span><br><span class="line">	&#x2F;***fiq mode stack***&#x2F;</span><br><span class="line">		msr 	cpsr,#0xd1</span><br><span class="line">		mov		sp,r0</span><br><span class="line">		sub		r0,#0</span><br><span class="line">	&#x2F;***abort mode stack***&#x2F;</span><br><span class="line">		msr		cpsr,#0xd7</span><br><span class="line">		mov		sp,r0</span><br><span class="line">		sub		r0,#0</span><br><span class="line">	&#x2F;***undefine mode stack***&#x2F;</span><br><span class="line">		msr		cpsr,#0xdb</span><br><span class="line">		mov		sp,r0</span><br><span class="line">		sub		r0,#0</span><br><span class="line">   &#x2F;*** sys mode and usr mode stack ***&#x2F;</span><br><span class="line">		msr		cpsr,#0x10</span><br><span class="line">		mov		sp,r0             &#x2F;*1024 byte  for user mode of stack*&#x2F;</span><br><span class="line"></span><br><span class="line">		b		main    &#x2F;*跳转到c的main函数*&#x2F;</span><br><span class="line"></span><br><span class="line">delay1s:</span><br><span class="line">     ldr      r4,&#x3D;0x1ffffff   </span><br><span class="line">delay1s_loop:</span><br><span class="line">     sub    r4,r4,#1</span><br><span class="line">     cmp   r4,#0         </span><br><span class="line">     bne    delay1s_loop</span><br><span class="line">     mov   pc,lr	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	.align	4</span><br><span class="line"></span><br><span class="line">	&#x2F;****  swi_interrupt handler  ****&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stacktop:    .word 		stack+4*512</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line"></span><br><span class="line">stack:	</span><br><span class="line">  .space  4*512</span><br><span class="line">.end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="三、汇编和c的混合编写"><a href="#三、汇编和c的混合编写" class="headerlink" title="三、汇编和c的混合编写"></a>三、汇编和c的混合编写</h2><h3 id="3-1-内联汇编"><a href="#3-1-内联汇编" class="headerlink" title="3.1 内联汇编"></a>3.1 内联汇编</h3><p>在C语言中，可以使用<code>asm</code>关键字将汇编代码嵌入到C代码中。这种方式被称为内联汇编。一个简单的例子如下(汇编用的ARM)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    __asm__(<span class="string">&quot;add %0, %1, %2&quot;</span></span><br><span class="line">            : <span class="string">&quot;=r&quot;</span> (result)</span><br><span class="line">            : <span class="string">&quot;r&quot;</span> (a), <span class="string">&quot;r&quot;</span> (b)</span><br><span class="line">            );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = add(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The result is %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这个例子中，__asm__关键字后面的字符串是我们插入的汇编代码。&quot;add %0, %1, %2&quot;是一条ARM加法指令，它将%1和%2的值相加，然后将结果存储在%0中。%0、%1和%2是我们用来引用C变量的占位符，它们在后面的冒号后的列表中定义。=r、r和r是约束，它们告诉编译器result、a和b都应该在通用寄存器中。</span></span><br></pre></td></tr></table></figure>


<h3 id="3-2-联合编译"><a href="#3-2-联合编译" class="headerlink" title="3.2 联合编译"></a>3.2 联合编译</h3><p>在汇编代码中跳转到C的main函数，这种情况通常发生在引导加载器或者内核代码中。</p>
<p>这种需要用到相关makefile和lds脚本。</p>
<p>这里提供点亮led灯的两个makefile和lds(linux下)：</p>
<p>makefile：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">all:</span><br><span class="line">	arm-none-linux-gnueabi-gcc -fno-builtin -nostdinc -c -o start.o start.s</span><br><span class="line">	arm-none-linux-gnueabi-gcc -fno-builtin -nostdinc -c -o main.o main.c</span><br><span class="line">	arm-none-linux-gnueabi-ld start.o main.o -Tmap.lds -o led.elf</span><br><span class="line">	arm-none-linux-gnueabi-objcopy -O binary led.elf led.bin</span><br><span class="line">	arm-none-linux-gnueabi-objdump -D led.elf &gt; led.dis</span><br><span class="line">clean:</span><br><span class="line">	rm -rf *.bak *.o *.elf *.dis *.bin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>lds:</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">/*linux下的连接脚本模板*/</span><br><span class="line">OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;) /*指定输出可执行文件是elf格式，32位ARM指令，小端*/</span><br><span class="line">OUTPUT_ARCH(arm)  /*指定输出可执行文件的平台(arm平台)*/</span><br><span class="line">ENTRY(_start)     /*指定连接之后第一条指令的地址为_start*/</span><br><span class="line">SECTIONS  /*指定连接之后的代码段(.text) 数据段(.data) .bss段如何摆放*/</span><br><span class="line">&#123;</span><br><span class="line">	. = 0x40008000; /*指定链接的起始地址 从0x40008000地址开始摆放*/</span><br><span class="line">	. = ALIGN(4);   /*指令对齐(4字节对齐)*/</span><br><span class="line">	.text      :    /*代码段开始*/</span><br><span class="line">	&#123;</span><br><span class="line">		start.o(.text)  /*0x40008000地址放start.o对应的start.s的第一条指令*/</span><br><span class="line">		*(.text)        /* *：其他的*.o文件系统自动安排位置*/</span><br><span class="line">	&#125;</span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">    .data :         /*数据段开始*/</span><br><span class="line">	&#123; *(.data) &#125;    /*数据段也让系统自动分配*/</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .bss :</span><br><span class="line">     &#123; *(.bss) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-外部函数声明"><a href="#3-3-外部函数声明" class="headerlink" title="3.3 外部函数声明"></a>3.3 外部函数声明</h3><p>假设你有一个名为<code>add.s</code>的汇编文件，其中定义了一个加法函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.global add</span><br><span class="line">add:</span><br><span class="line">    add r0, r1, r2</span><br><span class="line">    bx lr</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，你可以在你的C代码中使用外部函数声明来调用这个汇编函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = add(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The result is %d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>day42-ARM引脚、串口</title>
    <url>/2023/05/22/day42-ARM%E5%BC%95%E8%84%9A%E3%80%81%E4%B8%B2%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="day42-ARM引脚、串口"><a href="#day42-ARM引脚、串口" class="headerlink" title="day42-ARM引脚、串口"></a><font color="green">day42-ARM引脚、串口</font></h1><!--mroe-->

<h2 id="一、ARM引脚控制"><a href="#一、ARM引脚控制" class="headerlink" title="一、ARM引脚控制"></a>一、ARM引脚控制</h2><p>在裸机编程中，想要控制引脚就需要配置该引脚相应的寄存器</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>串口</tag>
      </tags>
  </entry>
  <entry>
    <title>day43-系统移植简介</title>
    <url>/2023/05/25/day43-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="day43-系统移植简介"><a href="#day43-系统移植简介" class="headerlink" title="day43-系统移植简介"></a><font color="green">day43-系统移植简介</font></h1><!--mroe-->
<h2 id="一、系统移植简介"><a href="#一、系统移植简介" class="headerlink" title="一、系统移植简介"></a>一、系统移植简介</h2><p>&emsp;&emsp;系统移植是将一个程序或操作系统从一个硬件平台转移到另一个硬件平台的过程。这个过程可能涉及到修改源代码，以使其能够在新的硬件平台上运行，或者使用交叉编译的技术，将源代码编译成在新硬件平台上运行的可执行文件。</p>
<br>
<br>

<hr>
<h2 id="二、嵌入式linux系统"><a href="#二、嵌入式linux系统" class="headerlink" title="二、嵌入式linux系统"></a>二、嵌入式linux系统</h2><p>&emsp;&emsp;Linux系统由多个主要部分组成，包括：</p>
<ol>
<li><p>引导程序（BootLoader）：BootLoader是用于初始化硬件设备、建立内存空间的映射图，然后将系统的控制权交给操作系统内核的一段小程序。它负责在启动时加载内核到内存中，并传递给它控制权。常见的引导程序包括GRUB、LILO等。</p>
</li>
<li><p>内核（Kernel）：内核是操作系统的核心部分，它负责管理系统的硬件资源，并提供上层应用程序调用的接口服务程序。Linux内核包括了设备驱动、进程和内存管理、文件系统等。</p>
</li>
<li><p>设备树（Device Tree, DTB）：在嵌入式Linux系统中，设备树是一个数据结构，用于描述硬件设备的信息，例如设备的物理地址、设备的类型、设备的配置等。设备树可以让内核知道系统中存在哪些设备，这些设备如何配置，以及它们如何相互连接。</p>
</li>
<li><p>根文件系统（rootfs）：根文件系统是Linux系统启动后，用户可以直接操作的部分。它包含操作系统需要的各种文件和目录，例如/bin、/etc、/lib、/usr等。根文件系统可以是只读的（如在嵌入式系统或LiveCD中），也可以是可写的。</p>
</li>
</ol>
<p>&emsp;&emsp;在Linux系统启动过程中，BootLoader首先被执行，它初始化硬件，并加载内核和设备树到内存中，然后将控制权交给内核。内核开始运行，并使用设备树信息来理解硬件配置。然后，内核挂载根文件系统，系统进入用户空间，开始执行init进程，最后用户可以开始使用系统。</p>
<br>
<br>

<hr>
<h2 id="三、交叉编译"><a href="#三、交叉编译" class="headerlink" title="三、交叉编译"></a>三、交叉编译</h2><p>&emsp;&emsp;交叉编译是在一种系统平台（称为主机）上生成另一种系统平台（称为目标）上运行的可执行代码的过程。例如，你可能在一台运行Linux的x86架构的电脑（主机）上编译一份用于在ARM架构的设备（目标）上运行的程序。</p>
<p>&emsp;&emsp;交叉编译器（Cross Compiler）是实现交叉编译的关键工具，它能够产生能在不同硬件或操作系统平台上运行的二进制文件。常见的交叉编译工具有GCC、Clang等。</p>
<p>&emsp;&emsp;这里用的是arm-linuxg-gcc编译器</p>
<br>
<br>

<hr>
<h2 id="四、环境搭建（连接）"><a href="#四、环境搭建（连接）" class="headerlink" title="四、环境搭建（连接）"></a>四、环境搭建（连接）</h2><p>交叉开发环境的硬件组成主要由以下几大部分：</p>
<blockquote>
<ol>
<li>开发主机</li>
<li>目标机（开发板）</li>
<li>二者的链接介质，常用的主要有3中方式：（1）串口线 （2）USB线 （3）网线</li>
</ol>
</blockquote>
<p>对应的硬件介质，还必须要有相应的软件“介质”支持：</p>
<blockquote>
<ol>
<li>对于串口，通常用的有串口调试助手，putty工具等，工具很多，功能都差不多，会用一两款就可以；</li>
<li>对于USB线，当然必须要有USB的驱动才可以，一般芯片公司会提供，比如对于三星的芯片，USB下载主要由DNW软件来完成；</li>
<li>对于网线，则必须要有网络协议支持才可以，常用的服务主要<code>tftp</code>和<code>nfs</code></li>
</ol>
</blockquote>
<p>利用网线将windows，虚拟机，板子连接起来：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">(1) 设置虚拟机ip：</span><br><span class="line">    1. 编辑 -&gt; 虚拟网络编辑器（桥接模式） -&gt; VMnet0 桥接到（选连板子的网卡，就是连接到网口的那个网卡）</span><br><span class="line">    2. 虚拟机 -&gt; 设置 -&gt; 网卡适配器  -&gt; 自定义 (选 VMnet0)</span><br><span class="line">    3. 点ubuntu右上角网络图标 -&gt; 右键选编辑连接 -&gt; 全删掉 -&gt; 添加（改新连接名称为board）-&gt; IPV4 设置 -&gt; 方法（选手动） -&gt; 点添加 设置为 192.168.9.120 255.255.255.0 192.168.9.1 并保存退出</span><br><span class="line">    4. 断开网络再连接，ifconfig测试，ping主机</span><br><span class="line"></span><br><span class="line">(2) 设置windows的ip：</span><br><span class="line">    打开windows网络与共享中心--&gt;本地连接--&gt;属性--&gt;IPV4地址配置--&gt;配置IP；192.168.9.100</span><br><span class="line"></span><br><span class="line">(3) 设置板子ip：</span><br><span class="line">      set ipaddr 192.168.9.233		  //设置【目标机】开发板的ip地址；</span><br><span class="line">			set serverip 192.168.9.120		//设置【开发主机】ubuntu的ip地址；</span><br><span class="line">			set gatewayip 192.168.9.1		  //设置网关</span><br><span class="line">			set netmask 255.255.255.0		  //设置子网掩码</span><br><span class="line">			saveenv							          //保存环境变量到emmc中；</span><br><span class="line">板子命令：</span><br><span class="line">printenv（pri）： 输出当前环境信息；</span><br><span class="line">setenv（set）：设置环境变量；</span><br><span class="line">saveenv（save）：保存环境变量； </span><br><span class="line">ping ：是否能ping通虚拟机     </span><br></pre></td></tr></table></figure>
<p><strong>上面是板子直连的情况，如果是在同一个局域网下的，就按局域网的ip进行连接，即更改板子的设置，注意板子的ip绝不能被占用</strong></p>
<h3 id="4-1-tftp服务"><a href="#4-1-tftp服务" class="headerlink" title="4.1 tftp服务"></a>4.1 tftp服务</h3><p>&emsp;&emsp;主要用于实现文件的下载，比如开发调试的过程中，主要用<code>tftp</code>把要测试的bootloader、kernel和文件系统直接下载到内存中运行，而不需要预先烧录到Flash芯片中，一方面，在测试的过程中，往往需要频繁的下载，如果每次把这些要测试的文件都烧录到Flash中然后再运行也可以，但是缺点是：过程比较麻烦，而且Flash的擦写次数是由限的；另外一方面：测试的目的就是把这些目标文件加载到内存中直接运行就可以了，而<code>tftp</code>就刚好能够实现这样的功能，因此，更没有必要把这些文件都烧录到Flash中去。</p>
<p>tftp建立：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">(1) 虚拟机建立tftp：</span><br><span class="line">    0.检查是否安装过tftp</span><br><span class="line">			sudo apt-cache policy tftpd-hpa</span><br><span class="line">			</span><br><span class="line">		1. 安装tftp服务器：</span><br><span class="line">			sudo apt-get install tftpd-hpa tftp-hpa</span><br><span class="line">			注意：虚拟机需要连外网，也就是能够ping www.baidu.com </span><br><span class="line">		2. 配置tftp服务器：</span><br><span class="line">			sudo vim /etc/default/tftpd-hpa</span><br><span class="line">			TFTP_USERNAME=&quot;tftp&quot;				    #用户的使用命令；</span><br><span class="line">			TFTP_DIRECTORY=&quot;/tftpboot&quot;			#共享文件的路径；</span><br><span class="line">			TFTP_ADDRESS=&quot;0.0.0.0:69&quot;			  #服务器的ip地址和端口号；</span><br><span class="line">			TFTP_OPTIONS=&quot;-l -c -s&quot;</span><br><span class="line">			根文件系统下面创建目录tftpboot,修改共享文件的权限（文件夹和文件的权限都要修改）</span><br><span class="line">				sudo chmod 0777 /tftpboot</span><br><span class="line">		3. 启动tftp服务器</span><br><span class="line">				sudo service tftpd-hpa restart	//重启</span><br><span class="line">		4. 将需要传输的文件存储在共享目录中(/tftpboot)</span><br><span class="line">				</span><br><span class="line">		5. 测试是否成功安装</span><br><span class="line">				tftp 127.0.0.1    </span><br><span class="line">				tftp&gt;get &lt;filename&gt;    </span><br><span class="line">				tftp&gt;q</span><br><span class="line">(2) 板子建立tftp</span><br><span class="line">    1. 把day1的镜像目录下的uImage，exynos4412-fs4412.dtb，ramdisk.img拷贝到/tftpboot目录下</span><br><span class="line">			tftp 41000000 uImage				//下载内核</span><br><span class="line">			tftp 42000000 exynos4412-fs4412.dtb	//下载设备树</span><br><span class="line">			tftp 43000000 ramdisk.img			//下载根文件系统</span><br><span class="line">			bootm 41000000 	43000000 		 42000000</span><br><span class="line">			      内核地址	 根文件系统地址	设备树地址</span><br><span class="line">			注意：地址顺序不能出错；	  </span><br><span class="line">				  </span><br><span class="line">			一次性配置：</span><br><span class="line">			set bootcmd tftp 41000000 uImage<span class="tag">\<span class="name">;</span></span> tftp 42000000 exynos4412-fs4412.dtb<span class="tag">\<span class="name">;</span></span> tftp 43000000 ramdisk.img<span class="tag">\<span class="name">;</span></span> bootm 41000000 43000000 42000000 </span><br><span class="line"></span><br><span class="line">      save</span><br><span class="line">(3) 交叉编译器安装：</span><br><span class="line">    1. 将gcc-4.6.4.tar.xz 拷贝到虚拟机的某一个目录中</span><br><span class="line">			cp gcc-4.6.4.tar.xz ~/workspace/fs4412	</span><br><span class="line">		2. 进入到所对应的目录中，解压gcc-4.6.4.tar.xz</span><br><span class="line">			cd ~/workspace/fs4412 </span><br><span class="line">			tar -xvf gcc-4.6.4.tar.xz</span><br><span class="line">		3. 进入到gcc-4.6.4目录中，通过pwd查看绝对路径；</span><br><span class="line">			cd gcc-4.6.4/bin</span><br><span class="line">			pwd   === &gt; /home/farsight/workspace/fs4412/gcc-4.6.4/bin</span><br><span class="line">		4. 修改PATH的值；</span><br><span class="line">			进入到/etc/bash.bashrc,在文件的最前面添加</span><br><span class="line">			sudo vim /etc/bash.bashrc</span><br><span class="line">			export PATH=<span class="formula">$PATH:/home/farsight/workspace/fs4412/gcc-4.6.4/bin</span></span><br><span class="line"><span class="formula">		5. 重启；</span></span><br><span class="line"><span class="formula">			source /etc/bash.bashrc</span></span><br><span class="line"><span class="formula">		</span></span><br><span class="line"><span class="formula">		6. 测试：</span></span><br><span class="line"><span class="formula">			a.生成可执行文件：arm-none-linux-guneabi-gcc 1.c</span></span><br><span class="line"><span class="formula">			b.拷贝执行文件到下载目录: cp a.out /tftpboot</span></span><br><span class="line"><span class="formula">			c.在板子上使用tftp下载a.out到板子上： tftp -g -r a.out 192.168.9.120 （注：板子和Ubuntu必须在同一网段）</span></span><br><span class="line"><span class="formula">				注：使用tftp上传文件到服务器 tftp -p -r a.out 192.168.9.120</span></span><br><span class="line"><span class="formula">			d.修改a.out权限：chmod 777 a.out</span></span><br><span class="line"><span class="formula">			e.执行a.out: ./a.out</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-nfs服务"><a href="#4-2-nfs服务" class="headerlink" title="4.2 nfs服务"></a>4.2 nfs服务</h3><p>&emsp;&emsp;主要用于实现网络文件的挂载，实际上是实现网络文件的共享，在开发的过程中，通常在系统移植的最后一步会制作文件系统，那么这是可以把制作好的文件系统放置在我们开发主机PC的相应位置，开发板通过nfs服务进行挂载，从而测试我们制作的文件系统是否正确，在整个过程中并不需要把文件系统烧录到Flash中去，而且挂载是自动进行挂载的，bootload启动后，kernel运行起来后会根据我们设置的启动参数进行自动挂载，因此，对于开发测试来讲，这种方式非常的方便，能够提高开发效率。(和共享文件差不多)</p>
<p>nfs建立：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">(1)虚拟机</span><br><span class="line">	  0. 查看是否安装过nfs服务器：</span><br><span class="line">			sudo apt-cache policy nfs-kernel-server</span><br><span class="line">		1. 安装nfs服务器</span><br><span class="line">			sudo apt-get install nfs-kernel-server</span><br><span class="line">		2. 配置nfs服务器</span><br><span class="line">			1) 拷贝day1镜像目录下的根文件系统rootfs.tar.xz到开发主机中的一个目录（例如/source/nfs）</span><br><span class="line">				cp rootfs.tar.xz /source/nfs</span><br><span class="line">			2) 进入到rootfs.tar.xz所对应的目录中</span><br><span class="line">				cd /source/nfs</span><br><span class="line">			3) 解压根文件系统</span><br><span class="line">				tar -xvf rootfs.tar.xz</span><br><span class="line">			4) 进入到rootfs目录，使用pwd确定所对应的绝对路径</span><br><span class="line">				cd rootfs</span><br><span class="line">				pwd  ----&gt; /source/nfs/rootfs   就是用来挂载的共享路径；</span><br><span class="line">				</span><br><span class="line">			5) 修改nfs配置文件 sudo vim  /etc/exports </span><br><span class="line">				在文件的尾部添加代码：</span><br><span class="line">				/source/nfs/rootfs  *(rw,sync,no_root_squash,no_subtree_check)</span><br><span class="line">				注意：路径需要和根文件系统的实际路径一致；</span><br><span class="line"></span><br><span class="line">		3. 启动nfs服务器：</span><br><span class="line">			sudo service nfs-kernel-server restart</span><br><span class="line">				</span><br><span class="line">		4. 测试是否配置成功 </span><br><span class="line">			sudo mount -t nfs localhost:/source/nfs/rootfs/  /mnt/  //测试nfs服务是否安装成功。</span><br><span class="line"></span><br><span class="line">			ls /mnt/  （如果其中的内容和/nfs/rootfs中一致。 表示有挂载成功）</span><br><span class="line"></span><br><span class="line">			sudo umount /mnt   //解除挂载</span><br><span class="line">	</span><br><span class="line">(2) 设置板子nfs:</span><br><span class="line">			1. 设置启动参数：</span><br><span class="line">				set bootcmd tftp 41000000 uImage<span class="tag">\<span class="name">;</span></span> tftp 42000000 exynos4412-fs4412.dtb<span class="tag">\<span class="name">;</span></span> bootm 41000000 - 42000000</span><br><span class="line">				set bootargs root=/dev/nfs nfsroot=192.168.12.123:/source/nfs/rootfs rw console=ttySAC2,115200 init=/linuxrc ip=192.168.12.31 clk_ignore_unused=true</span><br><span class="line">				set bootargs root=/dev/nfs nfsroot=192.168.12.123:/source/nfs/rootfs rw console=ttySAC2,115200 init=/linuxrc ip=192.168.12.31 clk_ignore_unused=true</span><br><span class="line">									ubuntuIP              			                                 开发板IP</span><br><span class="line">				saveenv</span><br><span class="line">				</span><br><span class="line">			2、开发板重新启动: 开发板自动进入 下面界面</span><br><span class="line">				[root@farsight ]#   --- 成功</span><br><span class="line">				</span><br><span class="line">				把文件放入虚拟机中Linux的共享目录/source/nfs/rootfs中，开发板中自然会出现这个文件</span><br><span class="line">				在虚拟机中 cp  a.out  /source/nfs/rootfs</span><br><span class="line">				开发板中出现下面界面：</span><br><span class="line">				[root@farsight ]# ls</span><br><span class="line">				1.c      bin      etc      linuxrc  proc     sbin     tmp      var</span><br><span class="line">				a.out    dev      lib      mnt      root     sys      usr</span><br><span class="line">				</span><br><span class="line">		【问题解决】</span><br><span class="line">			5、nfs本机测试没问题，但是挂载到开发板失败</span><br><span class="line">			</span><br><span class="line">				方法一：如果ubuntu是18.04</span><br><span class="line">					/*Ubuntu 18.04 nfs 默认为协议3和协议4，但是 我的uboot 默认启动的是协议2的形式</span><br><span class="line">					如:  /srv/homes    hostname1(rw,sync,no_subtree_check)</span><br><span class="line">					若想要求 nfs 支持协议2，就在/etc/default/nfs-kernel-server末尾加一句：</span><br><span class="line">					RPCNFSDOPTS=&quot;--nfs-version 2,3,4 --debug --syslog&quot;</span><br><span class="line">					*/</span><br><span class="line">				方法二：如果ubuntu是20.04</span><br><span class="line">					1）把nfs配置文件备份</span><br><span class="line">						sudo mv /etc/default/nfs-kernel-server  /etc/default/nfs-kernel-server.back</span><br><span class="line">					2) 替换nfs配置文件</span><br><span class="line">						把day1镜像目录下的nfs-kernel-server拷贝到/etc/default目录下</span><br><span class="line">							sudo cp nfs-kernel-server  /etc/default</span><br><span class="line">					3) 重启nfs服务</span><br><span class="line">						sudo service nfs-kernel-server restart</span><br><span class="line">					4) 重新挂载到开发板</span><br></pre></td></tr></table></figure>

<h3 id="4-3-将系统存储到emmc中"><a href="#4-3-将系统存储到emmc中" class="headerlink" title="4.3 将系统存储到emmc中"></a>4.3 将系统存储到emmc中</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在sd卡中烧录对应u-boot</span><br><span class="line">		a)	拷贝第一天/镜像文件/ramdisk.img拷贝到虚拟机/tftpboot目录下</span><br><span class="line">		b)	烧写内核镜像到EMMC上</span><br><span class="line">		# tftp 41000000 uImage</span><br><span class="line">		# movi  write  kernel  41000000</span><br><span class="line"></span><br><span class="line">		c)	烧写设备树文件到EMMC上</span><br><span class="line">		# tftp  41000000 exynos4412-fs4412.dtb</span><br><span class="line">		# movi  write  dtb  41000000</span><br><span class="line"></span><br><span class="line">		d)	烧写文件系统镜像到EMMC上</span><br><span class="line">		# tftp  41000000  ramdisk.img</span><br><span class="line">		#movi  write  rootfs  41000000  3000000</span><br><span class="line"></span><br><span class="line">		e)	设置启动参数</span><br><span class="line">		# set bootcmd movi read kernel 41000000<span class="tag">\<span class="name">;</span></span>movi read dtb 42000000<span class="tag">\<span class="name">;</span></span>movi read rootfs 43000000 3000000<span class="tag">\<span class="name">;</span></span>bootm 41000000 43000000 42000000</span><br><span class="line">		# set bootargs</span><br><span class="line">		# saveenv</span><br><span class="line"></span><br><span class="line">		f)	重新启动开发板，u-boot自动加载、执行内核</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ARM</tag>
        <tag>系统移植</tag>
      </tags>
  </entry>
  <entry>
    <title>day44-系统移植bootloader</title>
    <url>/2023/05/30/day44-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8Dbootloader/</url>
    <content><![CDATA[<h1 id="day44-系统移植bootloader"><a href="#day44-系统移植bootloader" class="headerlink" title="day44-系统移植bootloader"></a><font color="green">day44-系统移植bootloader</font></h1><!--mroe-->

<h2 id="一、bootloader简介"><a href="#一、bootloader简介" class="headerlink" title="一、bootloader简介"></a>一、bootloader简介</h2><p>&emsp;&emsp;就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境，他就是所谓的引导加载程序（Boot Loader）。</p>
<p>&emsp;&emsp;BootLoader的任务是引导操作系统，所谓引导操作系统，就是启动内核，让内核运行就是把内核加载到内存RAM中去运行，那先问两个问题：第一个问题，是谁把内核搬到内存中去运行？第二个问题：我们说的内存是SDRAM，大家都知道，这种内存和SRAM不同，最大的不同就是SRAM只要系统上电就可以运行，而SDRAM需要软件进行初始化才能运行，那么在把内核搬运到内存运行之前必须要先初始化内存吧，那么内存是由谁来初始化的呢？其实这两件事情都是由bootloader来干的，目的是为内核的运行准备好软硬件环境，没有bootloadr我们的系统当然不能跑起来。</p>
<p>&emsp;&emsp;BootLoader种类众多，其中u-boot使用较为广泛</p>
<blockquote>
<p>① 开放源码；<br>② 支持多种嵌入式操作系统内核，如Linux、NetBSD， VxWorks， QNX， RTEMS， ARTOS， LynxOS；<br>③ 支持多个处理器系列，如PowerPC、ARM、x86、MIPS、XScale；<br>④ 较高的可靠性和稳定性；<br>⑤ 高度灵活的功能设置，适合U-Boot调试、操作系统不同引导要求、产品发布等；<br>⑥ 丰富的设备驱动源码，如串口、以太网、SDRAM、FLASH、LCD、NVRAM、EEPROM、RTC、键盘等；<br>⑦ 较为丰富的开发调试文档与强大的网络技术支持；</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="二、-u-boot"><a href="#二、-u-boot" class="headerlink" title="二、 u-boot"></a>二、 u-boot</h2><h3 id="2-1-u-boot结构"><a href="#2-1-u-boot结构" class="headerlink" title="2.1 u-boot结构"></a>2.1 u-boot结构</h3><table>
<thead>
<tr>
<th>Directory</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>API</code></td>
<td>存储U-Boot提供的接口函数</td>
</tr>
<tr>
<td><code>arch</code></td>
<td>与体系结构相关的代码，是核心文件夹</td>
</tr>
<tr>
<td><code>board</code></td>
<td>基于不同具体开发板的自定义代码</td>
</tr>
<tr>
<td><code>common</code></td>
<td>通用代码，涵盖所有方面，以处理命令行为主</td>
</tr>
<tr>
<td><code>disk</code></td>
<td>与分区相关的代码</td>
</tr>
<tr>
<td><code>doc</code></td>
<td>常见特性和问题描述的文档</td>
</tr>
<tr>
<td><code>drivers</code></td>
<td>常用设备驱动程序，每种类型的设备驱动程序都占用一个子目录</td>
</tr>
<tr>
<td><code>fs</code></td>
<td>文件系统，支持嵌入式开发常用的文件系统（CRAMFS，EXT2，EXT3，JFFS2等）</td>
</tr>
<tr>
<td><code>include</code></td>
<td>定义了全局需要的头文件</td>
</tr>
<tr>
<td><code>lib</code></td>
<td>通用库文件</td>
</tr>
<tr>
<td><code>net</code></td>
<td>网络相关代码，小型协议栈</td>
</tr>
<tr>
<td><code>post</code></td>
<td>上电自检</td>
</tr>
<tr>
<td><code>tools</code></td>
<td>辅助工具，用于编译和检查uboot目标文件</td>
</tr>
</tbody></table>
<h3 id="2-2-u-boot命令"><a href="#2-2-u-boot命令" class="headerlink" title="2.2 u-boot命令"></a>2.2 u-boot命令</h3><p><code>pri</code>:显示<br><code>set</code>:设置<br><code>save</code>:保存<br><code>tftp</code>:下载<br><code>loadb</code>:kermit协议下载二进制<br><code>movi</code>:emmc写入/读取<br><code>boot</code>：启动</p>
<p><code>bootcmd</code>：启动命令<br><code>bootargs</code>:启动参数</p>
<h3 id="2-3-u-boot工作模式"><a href="#2-3-u-boot工作模式" class="headerlink" title="2.3 u-boot工作模式"></a>2.3 u-boot工作模式</h3><p>&emsp;&emsp;U-Boot的工作模式有启动加载模式和下载模式。启动加载模式是Bootloader的正常工作模式，嵌入式产品发布时，Bootloader必须工作在这种模式下，Bootloader将嵌入式操作系统从FLASH中加载到SDRAM中运行，整个过程是自动的。下载模式就是Bootloader通过某些通信手段将内核映像或根文件系统映像等从PC机中下载到目标板的SDRAM中运行，用户可以利用Bootloader提供的一些令接口来完成自己想要的操作，这种模式主要用于测试和开发。</p>
<br>
<br>

<hr>
<h2 id="三、-启动流程"><a href="#三、-启动流程" class="headerlink" title="三、 启动流程"></a>三、 启动流程</h2><p>启动模式包含：自启动和交互模式，正常使用是自启动模式。</p>
<p>&emsp;&emsp;大多数BootLoader都分为stage1和stage2两大部分，U-boot也不例外。依赖于cpu体系结构的代码（如设备初始化代码等）通常都放在stage1且可以用汇编语言来实现，而stage2则通常用C语言来实现，这样可以实现复杂的功能，而且有更好的可读性和移植性。</p>
<ol>
<li>stage1（start.s代码结构）</li>
</ol>
<p>U-boot的stage1代码通常放在start.s文件中，它用汇编语言写成，其主要代码部分如下：</p>
<ul>
<li>定义入口。由于一个可执行的image必须有一个入口点，并且只能有一个全局入口，通常这个入口放在rom（Flash）的0x0地址，因此，必须通知编译器以使其知道这个入口，该工作可通过修改连接器脚本来完成。</li>
<li>设置异常向量，设置SVC模式，关闭MMU Cache</li>
<li>设置CPU的速度、时钟频率及中断控制寄存器。</li>
<li>初始化内存控制器 。</li>
<li>将rom中的程序复制到ram中。</li>
<li>初始化堆栈 。</li>
<li>转到ram中执行，该工作可使用指令ldrpc来完成。</li>
</ul>
<ol start="2">
<li>stage2（C语言代码部分）</li>
</ol>
<p>lib_arm/board.c中的start armboot是C语言开始的函数，也是整个启动代码中C语言的主函数，同时还是整个u-boot（armboot）的主函数，该函数主要完成如下操作：</p>
<ul>
<li>调用一系列的初始化函数。</li>
<li>初始化flash设备。</li>
<li>初始化系统内存分配函数。</li>
<li>如果目标系统拥有nand设备，则初始化nand设备。</li>
<li>如果目标系统有显示设备，则初始化该类设备。</li>
<li>初始化相关网络设备，填写ip，c地址等。</li>
<li>进入命令循环（即整个boot的工作循环），接受用户从串口输入的命令，然后进行相应的工作。</li>
</ul>
<br>
<br>

<hr>
<h2 id="四、u-boot移植"><a href="#四、u-boot移植" class="headerlink" title="四、u-boot移植"></a>四、u-boot移植</h2><h3 id="已配置好的："><a href="#已配置好的：" class="headerlink" title="已配置好的："></a>已配置好的：</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">0、注释配置文件中的中文设置, 在下面三行加#</span><br><span class="line">	# sudo vim ~/.bashrc</span><br><span class="line">	#export LANG=LANG=&quot;zh_CN.utf-8&quot;</span><br><span class="line">	#export LANGUAGE=&quot;zh_CN:zh:en_US:en&quot;</span><br><span class="line">	#export LC_ALL=&quot;zh_CN.utf-8&quot;</span><br><span class="line"></span><br><span class="line">1、解压day2中的u-boot-2013.01-fs4412.tar.bz2</span><br><span class="line">	tar -xvf u-boot-2013.01-fs4412.tar.xz</span><br><span class="line"></span><br><span class="line">2、拷贝day2下的build.sh到解压的目录下，替换原有的目录</span><br><span class="line"></span><br><span class="line">3、进入u-boot-2013.01-fs4412，执行build.sh</span><br><span class="line">	./build.sh</span><br><span class="line">注： 如果Flash不是三星的，则需要根据FS4412兼容高版本eMMC.pdf更改emmc配置</span><br><span class="line"></span><br><span class="line">4、验证u-boot.bin</span><br><span class="line">	1) 将生成的u-boot-fs4412.bin文件拷贝到tftp共享目录中；</span><br><span class="line">			cp u-boot-fs4412.bin /tftpboot</span><br><span class="line">	2) 通过sd方式将生产uboot烧写到mmc中；</span><br><span class="line">			将拨码开关拨到sd启动方式，启动开发板进入到交互模式：</span><br><span class="line">			tftp 41000000 u-boot-fs4412.bin</span><br><span class="line">			movi write u-boot 41000000</span><br><span class="line">			将拨码开关拨到emmc启动方式，观察现象,启动成功</span><br></pre></td></tr></table></figure>

<h3 id="未配置好的"><a href="#未配置好的" class="headerlink" title="未配置好的"></a>未配置好的</h3><ol>
<li>boot中的<code>makefile</code>中搜索<code>CROSS_COMPILE</code>指定架构(如arm)和交叉编译工具链（如arm-none-linux-gnueabi）</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ARM</tag>
        <tag>系统移植</tag>
        <tag>bootloader</tag>
      </tags>
  </entry>
  <entry>
    <title>day45-系统移植内核</title>
    <url>/2023/06/01/day45-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<h1 id="day45-系统移植内核"><a href="#day45-系统移植内核" class="headerlink" title="day45-系统移植内核"></a><font color="green">day45-系统移植内核</font></h1><!--mroe-->

<h2 id="一、内核简介"><a href="#一、内核简介" class="headerlink" title="一、内核简介"></a>一、内核简介</h2><p>Linux内核是Linux操作系统的核心部分，负责处理系统的主要操作，如硬件抽象、进程调度、内存管理，以及提供一个稳定、安全的环境来运行应用程序。从技术上来看，内核其实是硬件和软件之间的连接层，我们也可以称之为中间层。</p>
<h3 id="1-1-内核实现策略"><a href="#1-1-内核实现策略" class="headerlink" title="1.1 内核实现策略"></a>1.1 内核实现策略</h3><ul>
<li><p>宏内核<br>内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸(裁剪)。Linux内核就是基于这个策略实现的</p>
</li>
<li><p>微内核<br>最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。</p>
</li>
</ul>
<h3 id="1-2-内核的核心模块"><a href="#1-2-内核的核心模块" class="headerlink" title="1.2 内核的核心模块"></a>1.2 内核的核心模块</h3><h4 id="1-2-1-进程的管理"><a href="#1-2-1-进程的管理" class="headerlink" title="1.2.1 进程的管理"></a>1.2.1 进程的管理</h4><p>Linux操作系统中的进程管理是内核的核心功能之一。以下是一些关键的概念和特性：</p>
<h5 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h5><ul>
<li><strong>进程</strong>：被视为执行环境的实例，包括程序代码、相关的数据、寄存器的状态、程序计数器、堆和栈等。</li>
<li><strong>线程</strong>：进程中的一个执行单元，共享进程的资源，有自己独立的执行序列。Linux内核通过轻量级进程（LWP）实现线程。</li>
</ul>
<h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><p>进程可能处于以下状态之一：</p>
<ul>
<li>运行（正在CPU上执行或准备好运行但在等待CPU变得可用）</li>
<li>等待/睡眠（等待某些条件成立或等待资源可用）</li>
<li>停止（例如，当收到SIGSTOP信号或者正在被调试）</li>
<li>僵尸（进程已经终止，但父进程还没有收集到它的终止状态）</li>
</ul>
<h5 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h5><p>内核的调度器负责决定哪个进程应该获得CPU的使用权。Linux使用优先级和调度策略来决定进程的执行顺序。</p>
<p>以下是Linux进程调度的一些重要概念：</p>
<blockquote>
<p>(1)调度器和调度策略：</p>
<p>Linux内核中有一个调度器组件，负责管理和调度所有的进程。调度器根据一定的策略来决定下一个要运行的进程。</p>
<p>Linux支持多种调度策略，包括：</p>
<p>SCHED_FIFO：实时调度策略，先进先出。对于具有相同优先级的进程，最早到达的进程首先获得处理器，一直运行直到自愿放弃或者更高优先级的进程就绪。</p>
<p>SCHED_RR：实时调度策略，循环执行。这是一种为具有相同优先级的进程设计的公平策略，当一个进程耗尽了它的时间片，调度器将选择下一个进程执行。</p>
<p>SCHED_OTHER：普通的非实时调度策略，这是默认的调度策略，采用的是CFS（Completely Fair Scheduler）调度算法。</p>
<p>(2)优先级：</p>
<p>Linux的每个进程都有一个相关联的优先级，决定了它在和其他进程竞争CPU时的地位。实时进程有静态优先级范围，普通进程有动态优先级范围。实时进程的优先级总是高于普通进程。</p>
<p>(3)时间片：</p>
<p>在Linux系统中，每个进程被赋予一个时间片，即进程可以运行的时间长度。时间片用完后，进程将被调度出CPU，然后调度器选择另一个进程运行。</p>
<p>(4)上下文切换：</p>
<p>当调度器决定替换当前正在运行的进程时，它执行一个被称为”上下文切换”的操作。这包括保存当前进程的状态，然后加载新进程的状态。这是一个开销相对较大的操作，因为它涉及到CPU寄存器和内存映射等状态信息的保存和加载。</p>
</blockquote>
<h5 id="进程创建与结束"><a href="#进程创建与结束" class="headerlink" title="进程创建与结束"></a>进程创建与结束</h5><p>进程通过系统调用<code>fork()</code>创建。进程结束通常是因为它完成了其工作或者因为收到一个终止信号。</p>
<h5 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h5><p>Linux提供了多种进程间通信（IPC）机制，包括管道、信号、消息队列、共享内存、信号量等。</p>
<h5 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h5><p>每个进程都有一个相关联的用户ID，用于确定它的权限。</p>
<br>

<h4 id="1-2-2-内存管理"><a href="#1-2-2-内存管理" class="headerlink" title="1.2.2 内存管理"></a>1.2.2 内存管理</h4><p>Linux内存管理是一个非常重要的部分，涉及到多个关键的概念和组件。</p>
<h5 id="物理与虚拟内存"><a href="#物理与虚拟内存" class="headerlink" title="物理与虚拟内存"></a>物理与虚拟内存</h5><ul>
<li><strong>物理内存</strong>：指的是实际的RAM。</li>
<li><strong>虚拟内存</strong>：它允许计算机看似拥有比实际更多的RAM，通过使用硬盘空间作为额外的内存。</li>
</ul>
<h5 id="分页和分段"><a href="#分页和分段" class="headerlink" title="分页和分段"></a>分页和分段</h5><ul>
<li><strong>分页</strong>：操作系统将虚拟内存划分为大小固定的块，称为页面。物理内存也被划分为大小固定的块，称为页帧。</li>
<li><strong>分段</strong>：是将内存划分为大小可变的块。</li>
</ul>
<h5 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h5><ul>
<li>当所有的物理内存都被使用时，操作系统需要决定哪些页面应被移出内存，为新的页面腾出空间。这个决定是由页面置换算法（page replacement algorithm）来做的。</li>
</ul>
<h5 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h5><ul>
<li><strong>静态内存分配</strong>：在程序编译时由编译器自动完成。</li>
<li><strong>自动内存分配（栈内存分配）</strong>：在程序运行时由编译器自动完成。</li>
<li><strong>动态内存分配（堆内存分配）</strong>：由程序员显式调用malloc，calloc等函数完成。</li>
</ul>
<h5 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h5><ul>
<li><strong>内存映射</strong>（Memory Mapping）是一种能让程序直接访问物理内存的方法。</li>
</ul>
<h5 id="Swap空间"><a href="#Swap空间" class="headerlink" title="Swap空间"></a>Swap空间</h5><ul>
<li><strong>Swap空间</strong>是硬盘上的一块区域，被操作系统用作虚拟内存。当物理内存不足时，操作系统可以将一部分数据（页面）移出物理内存，存放到Swap空间，从而释放出物理内存供其他用途使用。</li>
</ul>
<br>

<h4 id="1-2-3-文件系统"><a href="#1-2-3-文件系统" class="headerlink" title="1.2.3 文件系统"></a>1.2.3 文件系统</h4><h5 id="文件系统类型"><a href="#文件系统类型" class="headerlink" title="文件系统类型"></a>文件系统类型</h5><p>Linux支持多种文件系统类型，包括但不限于以下几种：</p>
<ul>
<li><strong>ext2/ext3/ext4</strong>：Linux的传统文件系统，ext4是最新版本，提供了许多改进和新功能。</li>
<li><strong>XFS</strong>：一种高性能的日志文件系统，适合处理大文件和大存储设备。</li>
<li><strong>Btrfs</strong>：一个现代的、具有许多高级功能的文件系统，如检查点、快照和动态空间分配。</li>
<li><strong>FAT32/NTFS</strong>：由Microsoft开发，主要在Windows系统中使用，但Linux也提供了对它们的支持。</li>
</ul>
<h5 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h5><p>Linux文件系统遵循一种统一的目录结构，所有内容都从根目录<code>/</code>开始。以下是一些重要的目录：</p>
<ul>
<li>**/**：根目录，所有的文件和目录都从这里开始。</li>
<li><strong>/home</strong>：用户的主目录，每个用户在这里都有一个自己的目录。</li>
<li><strong>/etc</strong>：系统配置文件的存储位置。</li>
<li><strong>/var</strong>：经常变化的文件，如日志文件和邮件队列等。</li>
<li><strong>/bin</strong> 和 <strong>/sbin</strong>：二进制可执行文件的存储位置，如常用的命令和系统程序。</li>
<li><strong>/lib</strong>：库文件的存储位置。</li>
</ul>
<h5 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h5><p>每个文件都有一个相关的inode，它存储了文件的元数据，如文件大小、创建时间、修改时间、所有者和权限等。inode号是文件在文件系统中的唯一标识。</p>
<h5 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h5><p>Linux支持两种类型的文件链接：</p>
<ul>
<li><strong>硬链接</strong>：指向文件的inode的直接引用。所有的硬链接都指向同一个inode，因此看起来就像是同一个文件。</li>
<li><strong>软链接（符号链接）</strong>：指向文件路径的引用，类似于Windows中的快捷方式。</li>
</ul>
<h5 id="挂载和卸载"><a href="#挂载和卸载" class="headerlink" title="挂载和卸载"></a>挂载和卸载</h5><p>在Linux中，设备（如硬盘分区或USB驱动器）必须先挂载到文件系统的某个点（称为挂载点），然后才能访问其中的文件。同样，设备可以从文件系统卸载，此后就无法访问其内容。</p>
<br>

<h4 id="1-2-4-设备驱动"><a href="#1-2-4-设备驱动" class="headerlink" title="1.2.4 设备驱动"></a>1.2.4 设备驱动</h4><p>设备驱动是一段可以让操作系统和硬件设备进行交互的程序。下面是一些关于Linux设备驱动的主要概念：</p>
<h5 id="设备驱动的类型"><a href="#设备驱动的类型" class="headerlink" title="设备驱动的类型"></a>设备驱动的类型</h5><p>Linux中的设备驱动主要可以分为以下三种类型：</p>
<ul>
<li><strong>字符设备驱动</strong>：用于控制字符设备，这些设备以字符为单位进行数据传输，例如键盘和鼠标。</li>
<li><strong>块设备驱动</strong>：用于控制块设备，这些设备以数据块为单位进行数据传输，例如硬盘和光驱。</li>
<li><strong>网络设备驱动</strong>：用于控制网络设备，例如网络适配器和路由器。</li>
</ul>
<h5 id="加载和卸载设备驱动"><a href="#加载和卸载设备驱动" class="headerlink" title="加载和卸载设备驱动"></a>加载和卸载设备驱动</h5><p>在Linux中，设备驱动可以动态地加载和卸载。可以使用<code>insmod</code>命令来加载设备驱动，使用<code>rmmod</code>命令来卸载设备驱动。</p>
<h5 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h5><p>Linux将所有的设备视为文件，设备文件通常位于<code>/dev</code>目录中。设备文件可以是字符设备文件或块设备文件，可以通过读写这些设备文件来控制硬件设备。</p>
<h5 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h5><p><code>udev</code>是Linux 2.6内核和更高版本的一个设备管理工具，它可以动态地创建和管理设备节点，使设备管理更加灵活。</p>
<h5 id="驱动模块"><a href="#驱动模块" class="headerlink" title="驱动模块"></a>驱动模块</h5><p>驱动模块是包含设备驱动函数的程序，它们可以在运行时动态地加载和卸载。这使得Linux内核可以保持小型和高效，同时也能支持大量不同类型的硬件设备。</p>
<h5 id="编写设备驱动"><a href="#编写设备驱动" class="headerlink" title="编写设备驱动"></a>编写设备驱动</h5><p>编写设备驱动是一个复杂的任务，需要深入理解硬件设备的工作原理以及Linux内核的工作机制。驱动程序需要在内核空间运行，因此它们必须遵循特定的编程规则和约定。</p>
<br>

<h4 id="1-2-5-网络栈"><a href="#1-2-5-网络栈" class="headerlink" title="1.2.5 网络栈"></a>1.2.5 网络栈</h4><p>Linux网络栈是一个实现了TCP/IP网络协议的软件栈。以下是一些重要的概念：</p>
<h5 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h5><p>TCP/IP模型由四层构成：应用层、传输层、网络层和链路层。每一层都负责处理特定的任务，并为上一层提供服务。</p>
<h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><p>网络栈包括一组协议，这些协议定义了数据在网络中的传输方式。其中最重要的两个协议是TCP（传输控制协议）和IP（互联网协议）。</p>
<h5 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h5><p>Socket API用于创建和管理网络连接。通过socket，应用程序可以发送和接收数据。</p>
<h5 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h5><p>网络设备是用于发送和接收数据包的硬件设备。在Linux中，每个网络设备都由一个设备驱动程序来管理。</p>
<h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><p>路由是决定数据包从源地址到目的地址所走的路径的过程。路由表是用于存储路由信息的数据结构。</p>
<h5 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h5><p>网络安全包括一系列用于保护网络连接和数据的技术。其中包括防火墙（用于阻止未授权的网络访问）和IPSec（一种用于加密IP数据包的协议）。</p>
<h5 id="网络调试工具"><a href="#网络调试工具" class="headerlink" title="网络调试工具"></a>网络调试工具</h5><p>Linux提供了多种用于调试网络问题的工具，如ping（用于测试网络连通性），traceroute（用于跟踪数据包的路由路径），netstat（用于显示网络状态）等等。</p>
<br>
<br>

<hr>
<h2 id="二、内核移植"><a href="#二、内核移植" class="headerlink" title="二、内核移植"></a>二、内核移植</h2><ol>
<li>准备内核源代码</li>
<li>makefile编辑交叉编译环境</li>
<li>make exynos_defconfig默认配置，配置文件放在 arch/arm/configs下</li>
<li>make menuconfig图形界面配置内核</li>
<li>make uImage编译内核</li>
<li>make dtbs编译设备树</li>
<li>按照需求在设备树中添加设备和配置内核，再重新编译</li>
</ol>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">内核移植：</span><br><span class="line"></span><br><span class="line">一、 内核准备：</span><br><span class="line"></span><br><span class="line">1. 内核源代码准备</span><br><span class="line">	1）官网下载Linux内核源代码</span><br><span class="line">	2）找供应商要（得到Linux内核源代码：linux-3.14.tar.xz）</span><br><span class="line"></span><br><span class="line">2. 拷贝源代码到工作目录：</span><br><span class="line">	cp linux-3.14.tar.xz </span><br><span class="line">3. 进入Linux内核源代码所在目录，解压Linux内核源代码</span><br><span class="line">	cd </span><br><span class="line">	tar xf linux-3.14.tar.xz</span><br><span class="line">4. 进入到源代码目录中</span><br><span class="line">	cd linux-3.14</span><br><span class="line">	</span><br><span class="line">二、 内核编译：	</span><br><span class="line">5. 修改编译平台和交叉编译环境</span><br><span class="line">	进入Makefile文件，修改参数：</span><br><span class="line">	修改：</span><br><span class="line"> 199 ARCH		?= <span class="formula">$(SUBARCH)</span></span><br><span class="line"><span class="formula"> 200 CROSS_COMPILE	?= $</span>(CONFIG_CROSS_COMPILE:&quot;<span class="comment">%&quot;=%)</span></span><br><span class="line">	为：</span><br><span class="line"> 199 ARCH            ?= arm</span><br><span class="line"> 200 CROSS_COMPILE   ?= arm-none-linux-gnueabi-</span><br><span class="line"></span><br><span class="line">6. 导入默认配置，配置文件放在 arch/arm/configs下</span><br><span class="line">	make exynos_defconfig</span><br><span class="line">7. 配置内核</span><br><span class="line">	make menuconfig</span><br><span class="line">	正常执行，会弹出一个菜单选项，我们可以去选择需要配置的内核；</span><br><span class="line">	注意：</span><br><span class="line">	(如果在编译的时候出现了下面的错误，则说明图形界面库没有安装，需要安装库</span><br><span class="line">		sudo apt-get install exuberant-ctags</span><br><span class="line">		sudo apt-get install libncurses5-dev</span><br><span class="line">	)</span><br><span class="line"> *** Unable to find the ncurses libraries or the</span><br><span class="line"> *** required header files.</span><br><span class="line"> *** &#x27;make menuconfig&#x27; requires the ncurses libraries.</span><br><span class="line"> *** </span><br><span class="line"> *** Install ncurses (ncurses-devel) and try again.</span><br><span class="line"> *** </span><br><span class="line">make[1]: *** [scripts/kconfig/dochecklxdialog] Error 1</span><br><span class="line">make: *** [menuconfig] Error 2</span><br><span class="line">第二种：</span><br><span class="line">farsight@ubuntu:~/fs4412/1905/linux-3.14<span class="formula">$ make menuconfig</span></span><br><span class="line"><span class="formula">scripts/kconfig/mconf Kconfig</span></span><br><span class="line"><span class="formula">Your display is too small to run Menuconfig!</span></span><br><span class="line"><span class="formula">It must be at least 19 lines by 80 columns.</span></span><br><span class="line"><span class="formula">make[1]: *** [menuconfig] Error 1</span></span><br><span class="line"><span class="formula">make: *** [menuconfig] Error 2</span></span><br><span class="line"><span class="formula"></span></span><br><span class="line"><span class="formula">表示终端太小，全屏显示就可以解决</span></span><br><span class="line"><span class="formula"></span></span><br><span class="line"><span class="formula">	正常执行菜单选项，选择串口信息：</span></span><br><span class="line"><span class="formula">	/* 将串口选择为 2  */</span></span><br><span class="line"><span class="formula">	System Type  ---&gt;</span></span><br><span class="line"><span class="formula">		(2) S3C UART to use for low-level messages</span></span><br><span class="line"><span class="formula">	</span></span><br><span class="line"><span class="formula">8. 编译内核</span></span><br><span class="line"><span class="formula">	make uImage</span></span><br><span class="line"><span class="formula">	编译成功会生成一个经过压缩后的镜像文件uImage，其生成的文件路径为：arch/arm/boot/uImage</span></span><br><span class="line"><span class="formula">	注意：(如果在编译的时候出现了下面的错误，则说明缺少mkimage工具，</span></span><br><span class="line"><span class="formula">	需将第一天工具中的mkimage拷贝到ubuntu的/usr/bin目录下)</span></span><br><span class="line"><span class="formula">&quot;mkimage&quot; command not found - U-Boot images will not be built</span></span><br><span class="line"><span class="formula">make[1]: *** [arch/arm/boot/uImage] Error 1</span></span><br><span class="line"><span class="formula">make: *** [uImage] Error 2</span></span><br><span class="line"><span class="formula"></span></span><br><span class="line"><span class="formula">三、设备树编译：</span></span><br><span class="line"><span class="formula">9. 修改设备树文件</span></span><br><span class="line"><span class="formula">	参考板origen的设备数文件为参考：</span></span><br><span class="line"><span class="formula">	cp arch/arm/boot/dts/exynos4412-origen.dts arch/arm/boot/dts/exynos4412-fs4412.dts</span></span><br><span class="line"><span class="formula">10. 修改Makefile，添加编译项：</span></span><br><span class="line"><span class="formula">	vim arch/arm/boot/dts/Makefile</span></span><br><span class="line"><span class="formula">	在</span></span><br><span class="line"><span class="formula">		exynos4412-origen.dtb <span class="tag">\</span></span></span><br><span class="line"><span class="formula">	下添加如下内容</span></span><br><span class="line"><span class="formula">		exynos4412-fs4412.dtb <span class="tag">\</span></span></span><br><span class="line"><span class="formula">11. 编译设备树文件：</span></span><br><span class="line"><span class="formula">	make dtbs</span></span><br><span class="line"><span class="formula">	</span></span><br><span class="line"><span class="formula">12. 拷贝编译的内核和设备树到tftp共享文件中</span></span><br><span class="line"><span class="formula">	cp arch/arm/boot/uImage /tftpboot</span></span><br><span class="line"><span class="formula">	cp arch/arm/boot/dts/exynos4412-fs4412.dtb /tftpboot</span></span><br><span class="line"><span class="formula">	</span></span><br><span class="line"><span class="formula">四、调试内核和设备树；</span></span><br><span class="line"><span class="formula">采用tftp下载内核和设备树，nfs挂载根文件系统</span></span><br><span class="line"><span class="formula">	set tftp 41000000 uImage<span class="tag">\<span class="name">;</span></span> tftp 42000000 exynos4412-fs4412.dtb<span class="tag">\<span class="name">;</span></span> bootm 41000000 - 42000000</span></span><br><span class="line"><span class="formula">	set bootargs root=/dev/nfs nfsroot=192.168.9.120:/source/nfs/rootfs rw clk_ignore_unused console=ttySAC2,115200 init=/linuxrc ip=192.168.9.233</span></span><br><span class="line"><span class="formula">	saveenv</span></span><br><span class="line"><span class="formula">掉电重启板子  //会看到内核信息输出。 但后面有报错，正常 （因为网卡等还没移植，nfs挂载肯定失败）</span></span><br><span class="line"><span class="formula"></span></span><br><span class="line"><span class="formula"></span></span><br><span class="line"><span class="formula">【网卡驱动的移植】 </span></span><br><span class="line"><span class="formula">1. 修改设备树文件</span></span><br><span class="line"><span class="formula"></span></span><br><span class="line"><span class="formula">添加：linux-3.14/arch/arm/boot/dts/exynos4412-fs4412.dts</span></span><br><span class="line"><span class="formula">srom-cs1@5000000 &#123;</span></span><br><span class="line"><span class="formula">		compatible = &quot;simple-bus&quot;;</span></span><br><span class="line"><span class="formula">		#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="formula">		#size-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="formula">		reg = &lt;0x5000000 0x1000000&gt;;</span></span><br><span class="line"><span class="formula">		ranges;</span></span><br><span class="line"><span class="formula"></span></span><br><span class="line"><span class="formula">		ethernet@5000000 &#123;</span></span><br><span class="line"><span class="formula">			compatible = &quot;davicom,dm9000&quot;;</span></span><br><span class="line"><span class="formula">			reg = &lt;0x5000000 0x2 0x5000004 0x2&gt;;</span></span><br><span class="line"><span class="formula">			interrupt-parent = &lt;&amp;gpx0&gt;;</span></span><br><span class="line"><span class="formula">			interrupts = &lt;6 4&gt;;</span></span><br><span class="line"><span class="formula">			davicom,no-eeprom;</span></span><br><span class="line"><span class="formula">			mac-address = [00 0a 2d a6 55 a2];</span></span><br><span class="line"><span class="formula">		&#125;;</span></span><br><span class="line"><span class="formula">	&#125;;</span></span><br><span class="line"><span class="formula"></span></span><br><span class="line"><span class="formula">添加设备编译参数</span></span><br><span class="line"><span class="formula">make menuconfig</span></span><br><span class="line"><span class="formula">[*] Networking support  ---&gt;    //配置支持TCP/IP</span></span><br><span class="line"><span class="formula">	Networking options  ---&gt;</span></span><br><span class="line"><span class="formula">		&lt;*&gt; Packet socket</span></span><br><span class="line"><span class="formula">		&lt;*&gt;Unix domain sockets </span></span><br><span class="line"><span class="formula">		[*] TCP/IP networking</span></span><br><span class="line"><span class="formula">		[*]   IP: kernel level autoconfiguration</span></span><br><span class="line"><span class="formula">Device Drivers  ---&gt;   //配置支持DM9000网卡驱动</span></span><br><span class="line"><span class="formula">	[*] Network device support  ---&gt;</span></span><br><span class="line"><span class="formula">		[*]   Ethernet driver support (NEW)  ---&gt;</span></span><br><span class="line"><span class="formula">			&lt;*&gt;   DM9000 support</span></span><br><span class="line"><span class="formula">File systems  ---&gt;  //配置支持网络文件系统NFS</span></span><br><span class="line"><span class="formula">	[*] Network File Systems (NEW)  ---&gt;</span></span><br><span class="line"><span class="formula">		&lt;*&gt;   NFS client support</span></span><br><span class="line"><span class="formula">		[*]     NFS client support for NFS version 2</span></span><br><span class="line"><span class="formula">		[*]     NFS client support for NFS version 3</span></span><br><span class="line"><span class="formula">		[*]       NFS client support for the NFSv3 ACL protocol extension</span></span><br><span class="line"><span class="formula">		[*]   Root file system on NFS</span></span><br><span class="line"><span class="formula"></span></span><br><span class="line"><span class="formula">		</span></span><br><span class="line"><span class="formula">重新编译内核和设备树</span></span><br><span class="line"><span class="formula">	make uImage</span></span><br><span class="line"><span class="formula">	make dtbs</span></span><br><span class="line"><span class="formula">将编译好的内核和设备树拷贝到tftp共享目录中</span></span><br><span class="line"><span class="formula">	cp arch/arm/boot/uImage /tftpboot</span></span><br><span class="line"><span class="formula">	cp arch/arm/boot/dts/exynos4412-fs4412.dtb /tftpboot</span></span><br><span class="line"><span class="formula">采用tftp下载内核和设备树，nfs挂载根文件系统</span></span><br><span class="line"><span class="formula">	set tftp 41000000 uImage<span class="tag">\<span class="name">;</span></span> tftp 42000000 exynos4412-fs4412.dtb<span class="tag">\<span class="name">;</span></span> bootm 41000000 - 42000000</span></span><br><span class="line"><span class="formula">	set bootargs root=/dev/nfs nfsroot=192.168.1.190:/source/nfs/rootfs rw clk_ignore_unused console=ttySAC2,115200 init=/linuxrc ip=192.168.1.191</span></span><br><span class="line"><span class="formula"></span></span><br><span class="line"><span class="formula">如果挂载失败：修改文件drivers/clk/clk.c  </span></span><br><span class="line"><span class="formula">	修改static bool clk_ignore_unused; 为：static bool clk_ignore_unused = true;    //忽略时钟</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ARM</tag>
        <tag>系统移植</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>day46-系统移植根文件</title>
    <url>/2023/06/01/day46-%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E6%A0%B9%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="day46-系统移植根文件"><a href="#day46-系统移植根文件" class="headerlink" title="day46-系统移植根文件"></a><font color="green">day46-系统移植根文件</font></h1><!--mroe-->]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ARM</tag>
        <tag>系统移植</tag>
        <tag>根文件</tag>
      </tags>
  </entry>
  <entry>
    <title>day48-设备驱动</title>
    <url>/2023/06/02/day48-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h1 id="day48-设备驱动"><a href="#day48-设备驱动" class="headerlink" title="day48-设备驱动"></a><font color="green">day48-设备驱动</font></h1><!--mroe-->

<h2 id="一、设备驱动简介"><a href="#一、设备驱动简介" class="headerlink" title="一、设备驱动简介"></a>一、设备驱动简介</h2><p>&emsp;&emsp;Linux的设备驱动是一种软件层，它可以让应用程序和硬件设备之间进行通信，同时隐藏设备的工作细节。Linux的设备驱动可以分为三种基本类型：<code>字符设备驱动</code>，<code>块设备驱动</code>和<code>网络设备驱动</code>。</p>
<blockquote>
<ul>
<li>字符设备驱动是一种可以按字节以串行顺序依次访问的设备，如键盘，鼠标等。</li>
<li>块设备驱动是一种可以用任意顺序进行访问，以块为单位进行操作的设备，如硬盘，软驱等。</li>
<li>网络设备驱动是一种负责发送和接收数据报文的设备，如网卡等。</li>
</ul>
</blockquote>
<p>除了这三种基本类型，Linux还定义了一些独特的驱动体系结构，如TTY驱动，IIC驱动，USB驱动，PCI驱动，LCD驱动等。</p>
<p>&emsp;&emsp;Linux的设备驱动可以以两种方式存在：编译进内核或者作为模块加载进内核。编译进内核的设备驱动会在启动内核时就被激活，而模块方式的设备驱动会在需要时才被加载进内核空间。Linux的设备驱动都按照操作系统给出的独立于设备的接口而设计，应用程序可以使用统一的系统调用接口来访问各个设备。</p>
<p>&emsp;&emsp;Linux的设备驱动模型包含设备 (device)、总线 (bus)、类 (class)和驱动 (driver)，它们之间相互关联。其中设备 (device)和驱动 (driver)通过总线 (bus)绑定在一起。Linux内核中，分别用 bus_type 、 device_driver 和 device 结构来描述总线、驱动和设备。每个设备都有一个对应的<code>设备文件</code>（又名：设备节点），用户程序通过这个文件来使用驱动程序操作设备。每个设备文件都有一个<code>主从设备号</code>来标识其类型和编号，并且有一个 inode 结构来管理其属性和操作函数指针。除了读写设备文件外，用户程序还可以通过 ioctl 接口来配置和修改特定的设备属性。</p>
<p><img src="/2023/06/02/day48-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E9%A9%B1%E5%8A%A8%E7%BB%93%E6%9E%84.png" alt="驱动"></p>
<br>
<br>

<hr>
<h2 id="二、字符设备编程"><a href="#二、字符设备编程" class="headerlink" title="二、字符设备编程"></a>二、字符设备编程</h2><h3 id="2-1-设备号表示方式"><a href="#2-1-设备号表示方式" class="headerlink" title="2.1 设备号表示方式"></a>2.1 设备号表示方式</h3><p>设备号的类型为dev_t,该类型在<code>&lt;linux/types.h&gt;</code>中定义。</p>
<p>在内核版本2.6.0中，dev_t是32位，其中高12位用于表示主设备号，其余20位用于表示次设备号。</p>
<p><img src="/2023/06/02/day48-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/%E8%AE%BE%E5%A4%87%E5%8F%B7.png" alt="驱动"></p>
<p>对于主次设备号，可以使用<code>&lt;linux/kdev_t.h&gt;</code>的宏来获取dev_t类型的主次设备号，也可以用其中的宏来生产一个dev_t</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MAJOR(<span class="keyword">dev_t</span> dev); <span class="comment">//用于获取设备的主设备号</span></span><br><span class="line">MINOR(<span class="keyword">dev_t</span> dev); <span class="comment">//用于获取设备的次设备号</span></span><br><span class="line">MKDEV(<span class="keyword">int</span> major, <span class="keyword">int</span> minor); <span class="comment">//根据所给的主次设备号生成dev_t</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-字符设备主次设备号分配和释放"><a href="#2-2-字符设备主次设备号分配和释放" class="headerlink" title="2.2 字符设备主次设备号分配和释放"></a>2.2 字符设备主次设备号分配和释放</h3><p>内核中要创建一个设备，首先需要分配设备号，分配的设备号可以手动分配，也可以自动分配。<br>用于分配设备号的函数在<code>&lt;linux/fs.h&gt;</code>中。</p>
<ul>
<li>静态分配<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> first, <span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//first：</span></span><br><span class="line"><span class="comment">//要分配的设备编号的范围起始值。</span></span><br><span class="line"><span class="comment">//count：</span></span><br><span class="line"><span class="comment">//是要分配的设备号数量。</span></span><br><span class="line"><span class="comment">//name：</span></span><br><span class="line"><span class="comment">//和该设备关联的名字。</span></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//设备分配成功时，该函数返回0，失败时返回负的错误码。</span></span><br></pre></td></tr></table></figure></li>
<li>动态分配</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span>* dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> firstminor, <span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dev:</span></span><br><span class="line"><span class="comment">// dev用于保存输出的设备号。</span></span><br><span class="line"><span class="comment">// firstminor:</span></span><br><span class="line"><span class="comment">// 该参数是次设备号的分配范围起始值。</span></span><br><span class="line"><span class="comment">// count:</span></span><br><span class="line"><span class="comment">// 该参数是要分配次设备号数量。</span></span><br><span class="line"><span class="comment">// name:</span></span><br><span class="line"><span class="comment">// 和该设备关联的名字。</span></span><br><span class="line"><span class="comment">// 返回值:</span></span><br><span class="line"><span class="comment">// 设备分配成功时，该函数返回0，失败时返回负的错误码。</span></span><br></pre></td></tr></table></figure>

<p>分配成功后，可以通过指令<code>cat /proc/devices | grep &lt;设备名字&gt;</code>来查看。</p>
<ul>
<li>释放设备号<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregister_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dev</span></span><br><span class="line"><span class="comment">// 该参数为需要释放的设备号</span></span><br><span class="line"><span class="comment">// count</span></span><br><span class="line"><span class="comment">// 该参数为需要释放的设备数量</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-3-和字符设备相关的重要数据结构以及函数"><a href="#2-3-和字符设备相关的重要数据结构以及函数" class="headerlink" title="2.3 和字符设备相关的重要数据结构以及函数"></a>2.3 和字符设备相关的重要数据结构以及函数</h3><ul>
<li>cdev<br>cdev表示了一个字符设备，其中最重要的是成员是ops，我们字符设备所能实现的功能都需要依靠这个这个。用户在调用相关函数时最终会通过这个ops指向我们所实现的各种函数中。其中的owner表示了模块的所属，一般都初始化为宏<code>THIS_MODULE</code>。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内核版本：5.4.0-1071-raspi</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">//所属模块</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span><span class="comment">//文件操作</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">dev_t</span> dev;<span class="comment">//设备号</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>初始化一个字符设备和注销字符设备时会用到如下几种函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化一个cdev结构体，并和file_operations绑定</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *, <span class="keyword">const</span> struct file_operations *)</span></span>;</span><br><span class="line"><span class="comment">//分配一个cdev结构体</span></span><br><span class="line"><span class="function">struct cdev *<span class="title">cdev_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//添加一个字符设备到内核，在添加之前，第二个参数设备号需要已经被注册过，第三个参数是分配的范围，以所给的设备号，初始几个设备。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *, <span class="keyword">dev_t</span>, <span class="keyword">unsigned</span>)</span></span>;</span><br><span class="line"><span class="comment">//cdev_del必须和cdev_add配合使用，cdev_del用于删除一个字符设备。在卸载驱动时要删除已经添加了的字符设备。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_del</span><span class="params">(struct cdev *)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>struct file_operations</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内核版本：5.4.0-1071-raspi</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">	<span class="keyword">int</span> (*iopoll)(struct kiocb *kiocb, <span class="keyword">bool</span> spin);</span><br><span class="line">	<span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">	<span class="keyword">int</span> (*iterate_shared) (struct file *, struct dir_context *);</span><br><span class="line">	<span class="keyword">__poll_t</span> (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line">	<span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">	<span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_supported_flags;</span><br><span class="line">	<span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">	<span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">	<span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">	<span class="comment">//。。。省略</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该结构用来表明设备的文件操作，用户应用的文件操作(open,write,read,close等操作)最终会通过调用该结构中的函数指针来调用我们自己定义相关操作函数。设备不支持的调用可以设置为NULL；<br>该结构中的struct module *owner;是指向拥有该结构体模块的指针，一般该成员会被初始化为<code>&lt;linux/module.h&gt;</code>中的宏<code>THIS_MODULE</code>。<br>其中常用的操作有open，write，read，llseek,unlocked_ioctl等。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ARM</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>day47-驱动简介</title>
    <url>/2023/06/01/day47-%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="day47-驱动简介"><a href="#day47-驱动简介" class="headerlink" title="day47-驱动简介"></a><font color="green">day47-驱动简介</font></h1><!--mroe-->

<h2 id="一、驱动简介"><a href="#一、驱动简介" class="headerlink" title="一、驱动简介"></a>一、驱动简介</h2><p>&emsp;&emsp;在Linux中，驱动是一种特殊的程序，它允许操作系统与硬件设备进行交互。驱动程序通常在内核空间运行，这是因为它们需要执行一些只能在内核空间进行的操作，如直接访问硬件或使用特权指令。</p>
<p>&emsp;&emsp;在Linux中，驱动程序通常被实现为内核模块。内核模块是一种可在运行时加载或卸载的代码，它们不是内核的固定部分，这提供了更大的灵活性。例如，如果你添加了一个新的硬件设备，只需要加载相应的驱动模块就可以使用它，而不需要重新编译整个内核。</p>
<br>
<br>

<hr>
<h2 id="二、驱动模块"><a href="#二、驱动模块" class="headerlink" title="二、驱动模块"></a>二、驱动模块</h2><p>&emsp;&emsp;在Linux系统中，驱动程序通常被设计成<code>内核模块</code>的形式。一个内核模块是内核的一部分，它在系统启动时并不立即加载。只有在需要时，模块才会被动态加载到内核中；不再需要时，它们可以被卸载。这种机制提供了很大的灵活性和效率。</p>
<p>&emsp;&emsp;驱动模块，就是作为内核模块的设备驱动。它们是用来管理和控制硬件设备的程序。例如，你的系统可能有一个用于管理你的网络接口卡的驱动模块，当你的系统启动时，这个模块会被加载到内核中，以便系统可以使用网络接口卡。</p>
<p>模块和应用程序的区别：<br>|            | 应用程序           | 内核模块                     |<br>| ———- | —————— | —————————- |<br>| 运行空间   | 用户空间           | 内核空间                     |<br>| 访问权限   | 有限               | 完全                         |<br>| 功能       | 执行特定任务       | 扩展内核功能                 |<br>| 依赖       | 操作系统API        | 内核API                      |<br>| 加载和卸载 | 通过用户启动和结束 | 可在系统运行时动态加载和卸载 |<br>| 错误处理   | 可以捕获并处理错误 | 错误可能导致整个系统崩溃     |</p>
<h3 id="2-1-驱动模块编程"><a href="#2-1-驱动模块编程" class="headerlink" title="2.1 驱动模块编程"></a>2.1 驱动模块编程</h3><h4 id="模块形式"><a href="#模块形式" class="headerlink" title="模块形式"></a>模块形式</h4><p>驱动模块编程需要两个东西：.c和makefile<br> .c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">&quot;ZhangSan&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">module_param(name, charp, <span class="number">0</span>);</span><br><span class="line">module_param(age, <span class="keyword">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 加载函数与卸载函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mymod_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">&quot;Mymod init ok!\n&quot;</span>);</span><br><span class="line">	printk(<span class="string">&quot;name = %s, age = %d\n&quot;</span>, name, age);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mymod_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	printk(<span class="string">&quot;Mymod exit ok!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 声明加载与卸载函数</span></span><br><span class="line">module_init(mymod_init);</span><br><span class="line">module_exit(mymod_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 模块信息</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);      <span class="comment">//许可证</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;LiuJ&quot;</span>);      <span class="comment">//作者</span></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A sample test module!&quot;</span>);  <span class="comment">//描述</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>makefile:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KERNEL_DIR = /home/hqyj/Liuj/230301/linux-3.14   <span class="comment">#内核源码路径</span></span><br><span class="line">CUR_DIR = <span class="variable">$(<span class="built_in">shell</span> pwd)</span>   <span class="comment">#当前路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(KERNELRELEASE)</span>, )</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(CUR_DIR)</span> modules 用内核源码的makefile进行编译</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C <span class="variable">$(KERNEL_DIR)</span> M=<span class="variable">$(CUR_DIR)</span> clean</span><br><span class="line"></span><br><span class="line"><span class="section">install: </span></span><br><span class="line">	cp *.ko /source/nfs/rootfs    <span class="comment">#将编译生成的.ko模块文件复制到指定的目录。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">obj-m = module.o</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获得的.ko通过nfs挂载到板子上，通过指令进行加载和卸载：</p>
<blockquote>
<p>lsmod：显示已加载模块<br>insmod *.ko：加载模块<br>rmmod *：卸载模块</p>
</blockquote>
<h4 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h4><p>头文件下面使用下面的函数：</p>
<blockquote>
<p>module_param(参数名,类型,权限);</p>
</blockquote>
<p>在板子上加载时要输入对应参数：</p>
<blockquote>
<p>insmod 模块 参数1=val1 参数2=val2</p>
</blockquote>
<h4 id="模块符号"><a href="#模块符号" class="headerlink" title="模块符号"></a>模块符号</h4><p>EXPORT_SYMBOL(符号)</p>
<p>在Linux内核编程中，通常情况下一个内核模块不能直接访问另一个内核模块中定义的函数或者变量。但有时候，一个内核模块需要使用另一个内核模块提供的功能。为了实现这个目的，内核提供了EXPORT_SYMBOL和EXPORT_SYMBOL_GPL两个宏来导出函数或变量。</p>
<p>当一个内核模块使用EXPORT_SYMBOL或EXPORT_SYMBOL_GPL宏导出一个函数或变量时，其他的内核模块就可以使用extern关键字来声明并使用这个函数或变量。例如：</p>
<pre><code class="c">// 在module1中
void module1_func(void) &#123;
    // ...
&#125;

EXPORT_SYMBOL(module1_func);



// 在module2中
extern void module1_func(void);

void module2_func(void) &#123;
    module1_func();
&#125;

</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ARM</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式学习-Linux基础</title>
    <url>/2023/02/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一、linux系统基础"><a href="#一、linux系统基础" class="headerlink" title="一、linux系统基础"></a><font color="green">一、linux系统基础</font></h1><h2 id="1、linux和windows"><a href="#1、linux和windows" class="headerlink" title="1、linux和windows"></a>1、linux和windows</h2><p>​    linux：开源、免费、安全性高、稳定性强、可移植性高</p>
<a id="more"></a>

<h2 id="2、linux操作系统的基本使用"><a href="#2、linux操作系统的基本使用" class="headerlink" title="2、linux操作系统的基本使用"></a>2、linux操作系统的基本使用</h2><h3 id="0-、linux的文件的系统结构"><a href="#0-、linux的文件的系统结构" class="headerlink" title="(0)、linux的文件的系统结构"></a>(0)、linux的文件的系统结构</h3><blockquote>
<ul>
<li>windows：所有文件有分盘(C,D,E,F….)，每个盘中都有子文件或者子目录，对文件存放没有要求，可以放在任意位置</li>
<li>linux：没有分盘，只有一个大的目录–根目录（’/‘），根目录下的文件夹每一个都有其固定作用</li>
<li>bin：存放二进制文件或者可执行程序</li>
<li>dev：存放设备文件</li>
<li>etc：系统相关的配置文件</li>
<li>home：用户目录，用户所有操作都在该目录下进行     /home/hqyj 可以用符号(~)表示</li>
</ul>
</blockquote>
<br>
<br>

<hr>
<h3 id="1-、基本的shell命令"><a href="#1-、基本的shell命令" class="headerlink" title="(1)、基本的shell命令"></a>(1)、基本的shell命令</h3><p>​        shell本质：命令行解释器，将用户输入的特定指令转换为系统能够识别的语言</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    绝对路径：从根目录出发所表示的一个路径</span><br><span class="line">    相对路径：相对于用户当前位置所表示的一个路径</span><br><span class="line"></span><br><span class="line">pwd:显示当前用户在文件系统中的绝对路径</span><br><span class="line">    用法：</span><br><span class="line">    	pwd + 回车</span><br><span class="line">ls:显示当前用户所在路径下的所有文件(不包含隐藏文件)</span><br><span class="line">    用法：</span><br><span class="line">    	ls + 回车</span><br><span class="line">ls -a：显示当前用户所在路径下的所有文件(包含隐藏文件)</span><br><span class="line">    <span class="string">&#x27;.&#x27;</span> == 用户当前目录</span><br><span class="line">    &#x27;..&#x27; == 当前目录的上一级目录</span><br><span class="line">    </span><br><span class="line">ls -l:显示当前用户所在路径下的所有文件的详细信息</span><br><span class="line">    - rw- rw- r--</span><br><span class="line">    第一位代表文件类型：</span><br><span class="line">    	<span class="string">&#x27;-&#x27;</span> :普通文件</span><br><span class="line">    	<span class="string">&#x27;d&#x27;</span> :目录文件</span><br><span class="line">    	<span class="string">&#x27;c&#x27;</span> :字符设备文件</span><br><span class="line">    	<span class="string">&#x27;b&#x27;</span> :块设备文件</span><br><span class="line">    	<span class="string">&#x27;p&#x27;</span> :管道文件</span><br><span class="line">    	<span class="string">&#x27;l&#x27;</span> :符号链接文件</span><br><span class="line">    	<span class="string">&#x27;s&#x27;</span> :套接字文件</span><br><span class="line">            不同操作系统下支持使用的文件类型不同</span><br><span class="line">    	</span><br><span class="line">    后<span class="number">9</span>位代表文件存取权限</span><br><span class="line">         rw-rw-r--  == <span class="number">110</span> <span class="number">110</span> <span class="number">100</span> == <span class="number">0664</span></span><br><span class="line">         权限的前<span class="number">3</span>位表示用户自己的使用权限，如果当前位上没有对应权限用<span class="string">&#x27;-&#x27;</span>表示                      </span><br><span class="line">		 权限的中间<span class="number">3</span>位代表用户组的使用权限        </span><br><span class="line">         权限的最后<span class="number">3</span>位代表其他用户的使用权限</span><br><span class="line">         r -- 具有读权限  w -- 具有写权限  x -- 具有可执行权限</span><br><span class="line">    改变文件权限的命令入下:</span><br><span class="line">         chmod [-R]  xyz  文件或目录</span><br><span class="line">         -R ： 以递归方式进行修改，比如修改某个目录下所有文件的属性。</span><br><span class="line"></span><br><span class="line">cd: 目录跳转	</span><br><span class="line">    用法：</span><br><span class="line">    	cd + 指定路径    </span><br><span class="line"></span><br><span class="line">touch:以不打开的方式创建一个文件，如果文件存在，则修改时间戳</span><br><span class="line">    用法：</span><br><span class="line">    	touch + 文件名</span><br><span class="line">    </span><br><span class="line">rm:删除指定文件</span><br><span class="line">    用法：</span><br><span class="line">    	rm + 文件名</span><br><span class="line">    </span><br><span class="line">cat：显示文件内容</span><br><span class="line">    用法：</span><br><span class="line">    	cat + 文件名</span><br><span class="line">    </span><br><span class="line">cp: 复制文件</span><br><span class="line">    用法：</span><br><span class="line">    	cp + 源文件名 + 路径名</span><br><span class="line">    	cp + 源文件名 + 目标文件名</span><br><span class="line">mv：移动文件</span><br><span class="line">    用法：</span><br><span class="line">    	mv + 源文件名 + 路径名</span><br><span class="line">    	mv + 源文件名 + 目标文件名    </span><br><span class="line"></span><br><span class="line">mkdir: 创建目录</span><br><span class="line">    用法：</span><br><span class="line">    	mkdir + 目录名</span><br><span class="line">    </span><br><span class="line">rmdir: 删除指定目录(空目录)   </span><br><span class="line">    用法：</span><br><span class="line">    	rmdir + 目录名</span><br><span class="line">    </span><br><span class="line">  	删除非空目录：rm -r 目录名</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">clear:清屏    ctrl + l快捷方式也可以清屏</span><br><span class="line">Tab: 命令补全</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h3 id="2-、vim编辑器"><a href="#2-、vim编辑器" class="headerlink" title="(2)、vim编辑器"></a>(2)、vim编辑器</h3><p>shell命令：vi 或者 vim + 文件名  </p>
<p>如果文件不存在，则会先创建再进行编辑</p>
<h4 id="vim编辑器中的三种工作模式："><a href="#vim编辑器中的三种工作模式：" class="headerlink" title="vim编辑器中的三种工作模式："></a>vim编辑器中的三种工作模式：</h4><p>​命令行模式：用户在进入编辑器后默认处于的工作模式</p>
<p>​        在命令行模式下不能直接输入数据，但是可以对文本进行复制、粘贴、剪切、撤销等操作：</p>
<p>​            在命令行模式下输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ngg: 光标跳到某一行首</span><br><span class="line"></span><br><span class="line">nyy：将光标以及光标以下的n行数据进行复制</span><br><span class="line"></span><br><span class="line">ndd：将光标以及光标以下的n行数据进行剪切或删除</span><br><span class="line"></span><br><span class="line">p：将复制或者剪切的内容粘贴到光标的下一行</span><br><span class="line"></span><br><span class="line">u：撤回到上一步操作</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>：当前行首</span><br><span class="line"></span><br><span class="line">$：当前行尾</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    编辑模式：可以对文本进行编辑操作</p>
<p>​        在命令行模式下输入：a, i, o都可以进入编辑模式</p>
<p>​        按Esc退回到命令行模式</p>
<p>​    </p>
<p>​    底行模式：对文本进行保存、退出等操作</p>
<p>​        在命令行模式下输入冒号进入底行模式</p>
<p>​            在底行模式下输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">w：保存文件</span><br><span class="line">q：退出文件</span><br><span class="line">wq：保存并且退出</span><br><span class="line">q！：强制不保存退出</span><br><span class="line">x：保存并且退出</span><br></pre></td></tr></table></figure>

<br>

<h4 id="vim文本查找和替换"><a href="#vim文本查找和替换" class="headerlink" title="vim文本查找和替换"></a>vim文本查找和替换</h4><p>在一般模式下，可以执行以下命令。</p>
<ol>
<li>查找<br>pattern  从光标开始处向文件尾搜索pattern，后按下n或N</li>
</ol>
<p>注意：</p>
<blockquote>
<p>n    在同一个方向重复上一次搜索命令<br>N    在反方向重复上一次搜索命令</p>
</blockquote>
<p>注意：<br>在/pattern之前先跳到第一行则进行全文件搜索。</p>
<ol start="2">
<li>替换<blockquote>
<p>:%s/p1/p2/g   //将文件中所有的p1均用p2替换<br>:%s/p1/p2/gc  //替换时需要确认<br>“s“ 全称：substitute替换；<br>“g“ 全称：global全局；<br>“c“ 全称：confirm，确认</p>
</blockquote>
</li>
</ol>
<h3 id="3-、gcc编译工具"><a href="#3-、gcc编译工具" class="headerlink" title="(3)、gcc编译工具"></a>(3)、gcc编译工具</h3><p>​    shell指令：</p>
<p>​        gcc + c文件名</p>
<p>​        编译成功之后会在当前目录下产生一个名为a.out的二进制可执行程序</p>
<p>​            </p>
<p>​       gcc c文件名 -o 新的二进制可执行文件名</p>
<p>​    </p>
<h3 id="4-、执行程序"><a href="#4-、执行程序" class="headerlink" title="(4)、执行程序"></a>(4)、执行程序</h3><p>​    shell命令：</p>
<p>​        ./可执行的二进制文件名</p>
<p>​        </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>day27-文件与系统IO</title>
    <url>/2023/04/01/day27-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9FIO/</url>
    <content><![CDATA[<h1 id="day27-文件与系统IO"><a href="#day27-文件与系统IO" class="headerlink" title="day27-文件与系统IO"></a><font color="green">day27-文件与系统IO</font></h1><h2 id="一、IO概念"><a href="#一、IO概念" class="headerlink" title="一、IO概念"></a>一、IO概念</h2><h3 id="1-标准IO和文件IO的区别："><a href="#1-标准IO和文件IO的区别：" class="headerlink" title="1. 标准IO和文件IO的区别："></a>1. 标准IO和文件IO的区别：</h3><blockquote>
<ol>
<li>标准IO是c库函数，文件IO是系统调用接口</li>
<li>标准IO自带缓冲区，文件IO没有缓冲</li>
<li>标准IO是文件IO的基础上封装出来的API接口</li>
</ol>
</blockquote>
<a id="more"></a>

<table>
<thead>
<tr>
<th></th>
<th>文件io</th>
<th>标准io</th>
</tr>
</thead>
<tbody><tr>
<td>缓冲</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>高低级</td>
<td>linux系统io、低级io</td>
<td>高级io</td>
</tr>
<tr>
<td>操作对象</td>
<td>文件描述符</td>
<td>流</td>
</tr>
<tr>
<td>能否打开设备文件</td>
<td>可以</td>
<td>不可以</td>
</tr>
<tr>
<td>API</td>
<td>open，close，read，write，sleek</td>
<td>fopen，fclose，fread，fwrite，fseek</td>
</tr>
</tbody></table>
<h3 id="2-缓冲区："><a href="#2-缓冲区：" class="headerlink" title="2. 缓冲区："></a>2. 缓冲区：</h3><p>&emsp;&emsp;缓冲区是内存空间的一部分，在内存中预留了一定的存储空间，用来暂时保存输入和输出等I/O操作的一些数据，这些预留的空间就叫做缓冲区。缓冲区是为了减少cpu对磁盘的读写次数，从内存（即缓冲区）中读取数据来加快运行速度</p>
<ol>
<li><p>全缓冲：当缓冲区满了或者特定的情况下才会刷新，最经典的是对磁盘文件的读写</p>
</li>
<li><p>行缓冲：当缓冲区中有了换行\n就会刷新，经典的有标准输入（stdin）输出（stdout）流</p>
</li>
<li><p>无缓冲：任何东西进入缓冲区马上被刷新走，经典的有标准错误输出流（stderr）</p>
</li>
</ol>
<p>默认：程序结束会刷新缓冲区</p>
<h3 id="3-流"><a href="#3-流" class="headerlink" title="3. 流"></a>3. 流</h3><p>&emsp;&emsp;在C语言中，将在不同的输入/输出设备之间进行传递的数据抽象为“流”。C中有三种标准流：标准输入流<code>stdin</code>，标准输出流<code>stdout</code>，标准错误流<code>stderr</code><br>&emsp;&emsp;流实际上就是一个字节序列，输入函数的字节序列被称为输入流，输出函数的字节序列称为输出流。<br>&emsp;&emsp;根据数据形式，输入输出流可以分为<code>文本流</code>（字符流）和<code>二进制流</code>。</p>
<blockquote>
<p>文本流和二进制流：</p>
<ul>
<li>文本文件：（又称ASCII文件）该文件中一个字符占用一个字节，存储单元中存放单个字符对应的ASCII 码。在文本流中输入输出的数据是字符或字符串，可以被修改；</li>
<li>二进制文件：二进制文件是存储在内存的数据的映像，也称映像文件。二进制流中输入输出是一系列二进制的0、1代码，不能以任何方式修改。</li>
</ul>
</blockquote>
<h3 id="4-文件"><a href="#4-文件" class="headerlink" title="4. 文件"></a>4. 文件</h3><p>&emsp;&emsp;C语言使用的文件系统为：<code>缓冲文件系统</code>（标准I/O）和<code>非缓冲文件系统</code>（系统I/O）。其中ANSIC标准采用“缓冲文件系统”处理文件。</p>
<p>&emsp;&emsp;文件指针：<br>在C语言中，所有文件操作必须依靠指针完成，通常用fopen（）为文件变量进行赋值。标准输入输出流，标准错误流都是文件指针类型的，可以给文件指针变量进行赋值。</p>
<blockquote>
<p>FILE *变量名</p>
</blockquote>
<h3 id="5-文件描述符"><a href="#5-文件描述符" class="headerlink" title="5. 文件描述符"></a>5. 文件描述符</h3><p>&emsp;&emsp;文件描述符：就是内核为了高效管理已被打开的文件所创的索引，是一个非负整数（通常为0-1023），所有执行I/O操作的系统调用都是通过文件描述符来实现。并规定系统刚启动时0是标准输入，1是标准输出，2是标准错误。如果打开新的文件，那么它的文件描述符会是3。<font color="blue">简单理解文件描述符就是一个数值的下标，下标的内容就是指向打开文件的指针。</font><br><br><br>&emsp;&emsp;实际上关于文件描述符，Linux内核维护了3个数据结构： </p>
<ul>
<li>进程级的文件描述符表</li>
<li>系统级的打开文件描述符表</li>
<li>文件系统的i-node表</li>
</ul>
<h4 id="5-1-进程级的文件描述表"><a href="#5-1-进程级的文件描述表" class="headerlink" title="5.1 进程级的文件描述表"></a>5.1 进程级的文件描述表</h4><p>&emsp;&emsp;一个Linux进程启动后，会在内核空间创建一个PCB控制块（PCB是进程控制块的缩写，包含了如进程的状态、程序计数器、堆栈指针、打开的文件列表、进程优先级等。主要用于进程之间切换时，对该进程的PCB进行保存和恢复状态），PCB内部有个 记录当前进程所有可用的文件描述符 的文件描述符表，除了这张表，系统还要维护另外两张表：打开文件描述表和i-node表</p>
<h4 id="5-2-系统级的打开文件描述表"><a href="#5-2-系统级的打开文件描述表" class="headerlink" title="5.2 系统级的打开文件描述表"></a>5.2 系统级的打开文件描述表</h4><ul>
<li>当前文件的偏移量</li>
<li>打开文件时的标识（open()里的falgs参数）</li>
<li>文件的访问模式（mode）</li>
<li>与信号驱动相关的设置</li>
<li>对该文件i-node对象的引用，即i-node指针</li>
</ul>
<h4 id="5-3-文件系统的i-node表"><a href="#5-3-文件系统的i-node表" class="headerlink" title="5.3 文件系统的i-node表"></a>5.3 文件系统的i-node表</h4><ul>
<li>文件类型（例如：常规文件，套接字或FIFO）和访问权限</li>
<li>一个指针，指向该文件所持有的锁链表（即对文件的锁定）</li>
<li>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳</li>
</ul>
<br>

<p>这三个表之间的关系如下图：<br><img src="/2023/04/01/day27-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9FIO/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.jpg" alt="文件描述符"></p>
<ul>
<li><p>在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的。</p>
</li>
<li><p>进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</p>
</li>
<li><p>进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况。 </p>
</li>
<li><p>*这就说明：同一个进程的不同文件描述符可以指向同一个文件；不同进程可以拥有相同的文件描述符；不同进程的同一个文件描述符可以指向不同的文件（一般也是这样，除了 0、1、2 这三个特殊的文件）；不同进程的不同文件描述符也可以指向同一个文件。**</p>
<br>
<br>

<hr>
</li>
</ul>
<h2 id="二、I-O函数"><a href="#二、I-O函数" class="headerlink" title="二、I/O函数"></a>二、I/O函数</h2><h3 id="1-更改缓冲区类型：setvbuf"><a href="#1-更改缓冲区类型：setvbuf" class="headerlink" title="1. 更改缓冲区类型：setvbuf"></a>1. 更改缓冲区类型：setvbuf</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int setvbuf(FILE *stream, char *buf, int mode, size_t size);</span><br><span class="line">功能：可以更改缓冲区类型（缓冲区可以人为指定）</span><br><span class="line">头文件：不需要特定头文件</span><br><span class="line">返回值：成功返回0，失败返回非0</span><br><span class="line">stream：流，表示要更改缓冲类型的流</span><br><span class="line">buf：缓冲区地址 填NULL就是系统默认缓冲区</span><br><span class="line">mode：要改成的缓冲区类型</span><br><span class="line">	_IONBF：无缓冲</span><br><span class="line">	_IOLBF：行缓冲</span><br><span class="line">	_IOFBF：全缓冲</span><br><span class="line">size：要更改buf的大小（单位字节）填BUFSIZ的话就是系统默认缓冲区大小</span><br></pre></td></tr></table></figure>

<p>错误perror、errno、stderr</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">errno：错误号，用于内核调用完函数后设置调用结果的编号，int型</span><br><span class="line">perror：输出对应错误号的信息</span><br><span class="line">stderr：标准出错流 -- 无缓冲，通常结合fprintf使用</span><br></pre></td></tr></table></figure>

<p>标准流：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">标准输入流：stdin -- 0</span><br><span class="line">标准输出流：stdout -- 1</span><br><span class="line">标准出错流：stderr -- 2</span><br><span class="line"></span><br><span class="line">每打开一个终端，都会默认打开这三个流</span><br></pre></td></tr></table></figure>

<h3 id="2-刷新流的缓冲区：fflush"><a href="#2-刷新流的缓冲区：fflush" class="headerlink" title="2. 刷新流的缓冲区：fflush"></a>2. 刷新流的缓冲区：fflush</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fflush(FILE *stream);</span><br><span class="line">功能：强制刷新一个流（Linux下不能刷新stdin）</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回0，失败返回EOF</span><br><span class="line">stream：要刷新的流</span><br></pre></td></tr></table></figure>

<h3 id="3-打开文件-流：open-fopen"><a href="#3-打开文件-流：open-fopen" class="headerlink" title="3. 打开文件/流：open,fopen"></a>3. 打开文件/流：open,fopen</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char* pathname,int flags,mode_t mode);</span><br><span class="line">功能：open是c标准库之外的系统调用函数。用来打开一个文件</span><br><span class="line">头文件：#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt;</span><br><span class="line">返回值：成功返回文件描述符。失败返回</span><br><span class="line">pathname：要打开的文件名（包含路径）</span><br><span class="line">flags:指定文件的打开/创建模式：</span><br><span class="line">	O_RDONLY(只读) </span><br><span class="line">	O_WRONLY(只写) </span><br><span class="line">	O_RDWR (读写)</span><br><span class="line">这些是常用的且必选一，还有其它选用的参数，中间用|结合  </span><br><span class="line">	O_CREAT：如果该文件不存在，就创建一个新的文件，并用第三的参数为其设置权限。</span><br><span class="line">    O_EXCL：如果使用O_CREAT时文件存在，则可返回错误消息。这一参数可测试文件是否存在。</span><br><span class="line">    O_NOCTTY：使用本参数时，如文件为终端，那么终端不可以作为调用open()系统调用的那个进程的控制终端</span><br><span class="line">    O_APPEND：以添加方式打开文件，所以对文件的写操作都在文件的末尾进行。</span><br><span class="line">    O_TRUNC：如文件已经存在，那么打开文件时先删除文件中原有数据。（截断式打开：如果文件有内容，先清空文件内容，再打开）</span><br><span class="line">mode：指定文件的访问权限，是由（-rw-r--r--）之类的组成的参数值（0644）</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">FILE *fopen(const char *pathname, const char *mode);</span><br><span class="line">功能：让内核打开一个文件并且标记它</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回流指针，失败返回NULL</span><br><span class="line">pathname：要打开的文件名（包含路径）</span><br><span class="line">mode：打开文件的方式（只读、只写...）</span><br><span class="line">	“r”：只读方式打开文件，文件必须存在</span><br><span class="line">	“w”：只写方式打开文件，如果文件存在则清空文件，如果文件不存在则创建文件</span><br><span class="line">	“a”：以追加方式打开文件，如果文件不存在则创建文件</span><br><span class="line">	“r+”：读写方式打开文件，文件必须存在</span><br><span class="line">	“w+”：读写方式打开文件，如果文件存在则清空文件，如果文件不存在则创建文件</span><br><span class="line">	“a+”：读写方式打开文件，如果文件不存在则创建文件，并在文件末尾写入数据</span><br><span class="line">	(注意：a+在追加时会从文件末尾另起一行再加，想要在末尾加就用fseek偏移后用fputs)</span><br><span class="line">注：如果操作二进制文件，那么打开文件时的方式可以加上b(如r+b, wb等)，但是Linux下不区分二进制流和文本流</span><br></pre></td></tr></table></figure>
<h4 id="open-和fopen-区别"><a href="#open-和fopen-区别" class="headerlink" title="open()和fopen()区别"></a>open()和fopen()区别</h4><p> <code>open()</code> 和 <code>fopen()</code> 都是用于打开文件的函数，但是它们有以下几个主要的区别：</p>
<blockquote>
<ol>
<li><strong>语法不同</strong>：<code>open()</code> 是一个系统调用，使用 C 语言的语法，而 <code>fopen()</code> 是一个标准 C 库函数，使用 C 标准库的语法。</li>
<li><strong>返回值不同</strong>：<code>open()</code> 的返回值是一个文件描述符，而 <code>fopen()</code> 的返回值是一个文件指针。</li>
<li><strong>文件模式不同</strong>：<code>open()</code> 可以打开任何类型的文件，包括设备文件和管道等，而 <code>fopen()</code> 只能打开普通文件。此外，<code>open()</code> 可以指定文件的打开模式，如只读、只写、读写等，而 <code>fopen()</code> 只能指定文件的访问模式，如只读、只写、读写等。</li>
<li><strong>缓冲不同</strong>：<code>fopen()</code> 打开文件时会创建一个缓冲区，用于提高读写效率，而 <code>open()</code> 不会创建缓冲区。</li>
<li>如果需要打开普通文件并使用标准 C 库函数进行读写操作，应该使用 <code>fopen()</code> 函数；如果需要打开设备文件、管道等非普通文件，或者需要更细粒度的文件访问控制，应该使用 <code>open()</code> 系统调用函数。</li>
</ol>
</blockquote>
<h3 id="4-关闭文件-流：close和fclose"><a href="#4-关闭文件-流：close和fclose" class="headerlink" title="4. 关闭文件/流：close和fclose"></a>4. 关闭文件/流：close和fclose</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int close(int fd)</span><br><span class="line">功能：关闭文件描述符，但不删除文件（删除用unlink()）</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：成功返回0，失败返回EOF</span><br><span class="line">fd：要关闭的文件标识符</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fclose(FILE *stream)</span><br><span class="line">功能：关闭已经打开的流,防止文件损坏</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回0，失败返回EOF</span><br><span class="line">stream：要关闭的流</span><br></pre></td></tr></table></figure>
<h4 id="close-和fclose-区别"><a href="#close-和fclose-区别" class="headerlink" title="close()和fclose()区别"></a>close()和fclose()区别</h4><blockquote>
<ol>
<li><strong>关闭文件不同</strong>：close关闭open打开的文件，fclose关闭fopen打开的文件。</li>
<li><strong>缓冲不同</strong>：close不会刷新缓冲区，fclose会刷新缓冲区</li>
</ol>
</blockquote>
<h3 id="5，文件-流偏移：lseek和fseek"><a href="#5，文件-流偏移：lseek和fseek" class="headerlink" title="5，文件/流偏移：lseek和fseek"></a>5，文件/流偏移：lseek和fseek</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">off_t lseek(int fd, off_t offset, int whence);</span><br><span class="line">功能：用于在打开的文件描述符中设置文件偏移量。文件偏移量是文件中下一个读取或写入操作的位置。</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：成功返回off_t整型(头文件是&lt;sys/types.h&gt;)新的文件偏移量，如果出错则返回-1。</span><br><span class="line">fd：文件描述符，</span><br><span class="line">offset：偏移量，</span><br><span class="line">whence：基准位置。可以取下面的值</span><br><span class="line">	- `SEEK_SET`：相对位置从文件开头开始计算。</span><br><span class="line">	- `SEEK_CUR`：相对位置从当前位置开始计算。</span><br><span class="line">	- `SEEK_END`：相对位置从文件结尾开始计算。</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fseek(FILE *stream, long offset, int whence);</span><br><span class="line">功能：用于设置文件指针的位置</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回0，失败返回非0</span><br><span class="line">stream：指向要设置位置的文件的指针</span><br><span class="line">offset：是要设置的相对位置</span><br><span class="line">whence：是指定相对位置的起始点。可以取下面的值</span><br><span class="line">	- `SEEK_SET`：相对位置从文件开头开始计算。</span><br><span class="line">	- `SEEK_CUR`：相对位置从当前位置开始计算。</span><br><span class="line">	- `SEEK_END`：相对位置从文件结尾开始计算。</span><br></pre></td></tr></table></figure>

<h4 id="lseek-和fseek-区别"><a href="#lseek-和fseek-区别" class="headerlink" title="lseek()和fseek()区别"></a>lseek()和fseek()区别</h4><blockquote>
<ol>
<li><strong>操作文件不同</strong>：lseek操作open打开的文件流，fseek操作fopen打开的文件描述符。</li>
<li><strong>缓冲不同</strong>：lseek不会刷新缓冲区，fseek会刷新缓冲区</li>
</ol>
</blockquote>
<h3 id="6-读写文件-流："><a href="#6-读写文件-流：" class="headerlink" title="6. 读写文件/流："></a>6. 读写文件/流：</h3><h3 id="6-1-按字符读：getc，fgetc"><a href="#6-1-按字符读：getc，fgetc" class="headerlink" title="6.1 按字符读：getc，fgetc"></a>6.1 按字符读：getc，fgetc</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int getc(FILE *stream);</span><br><span class="line">功能：从文件里面读取一个字符</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回读到的字符，失败返回EOF</span><br><span class="line">stream：要读的流</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fgetc(FILE *stream);</span><br><span class="line">功能：从流里面读取一个字符</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回读到的字符，失败返回EOF</span><br><span class="line">stream：要读的流</span><br></pre></td></tr></table></figure>
<p>两者功能等价，但getc()函数的参数可以是任何类型的文件指针，包括标准输入、标准输出和标准错误，或者是文件描述符。而fgetc()函数的参数必须是一个指向文件的指针。</p>
<h3 id="6-2-按字符写：putc，fputc"><a href="#6-2-按字符写：putc，fputc" class="headerlink" title="6.2 按字符写：putc，fputc"></a>6.2 按字符写：putc，fputc</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int putc(int c, FILE *stream);</span><br><span class="line">功能：往文件里面写一个字符</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回写入的字符，失败返回EOF</span><br><span class="line">c：要写的字符</span><br><span class="line">stream：要写入的流</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fputc(int c, FILE *stream);</span><br><span class="line">功能：往流里面写一个字符</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回写入的字符，失败返回EOF</span><br><span class="line">c：要写的字符</span><br><span class="line">stream：要写入的流</span><br></pre></td></tr></table></figure>
<p>两者完全等价，参数都能填文件指针或者文件描述符</p>
<h3 id="6-3-按行读：gets，fgets"><a href="#6-3-按行读：gets，fgets" class="headerlink" title="6.3 按行读：gets，fgets"></a>6.3 按行读：gets，fgets</h3><p>gets()函数可能会导致缓冲区溢出，不建议使用。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">char *fgets(char *s, int size, FILE *stream);</span><br><span class="line">功能：读取一行的内容</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回s的地址，失败返回NULL</span><br><span class="line">s：要把内容读到哪里去（缓冲区）</span><br><span class="line">size：预计要读的字节数，一般用sizeof()</span><br><span class="line">stream：从哪个流读取</span><br><span class="line"></span><br><span class="line">注：fgets是表示遇到了换行符才终止并且会把换行符存进去，如果size比一行的数据大，就读完所有内容。size如果比一行数据小，只读size-1个，追加一个&#x27;<span class="tag">\</span>0&#x27;，表示没读完。(即后面一定会加&#x27;<span class="tag">\</span>0&#x27;，在遇到文件末尾时才会&#x27;<span class="tag">\<span class="name">n</span></span>&#x27;,再加&#x27;<span class="tag">\</span>0&#x27;。在可以在&#x27;<span class="tag">\</span>0&#x27;前面是否有&#x27;<span class="tag">\<span class="name">n</span></span>&#x27;来判断一行是否读取完。)</span><br></pre></td></tr></table></figure>
<p><strong><font color="red">注意：sizeof(str)是指的str的有效长度，即整个长度-1。设char str[6],那么sizeof(str)为5。</font></strong></p>
<h3 id="6-4-按行写：puts-fputs"><a href="#6-4-按行写：puts-fputs" class="headerlink" title="6.4 按行写：puts,fputs"></a>6.4 按行写：puts,fputs</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int puts(const char *str);</span><br><span class="line">功能：将一个字符串输出到标准输出流。</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回非负数，失败返回EOF</span><br><span class="line">s：要写入的内容所在的缓冲区</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fputs(const char *s, FILE *stream);</span><br><span class="line">功能：往一个流里面写一行数据</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回非负数，失败返回EOF</span><br><span class="line">s：要写入的内容所在的缓冲区</span><br><span class="line">stream：要写入的流</span><br></pre></td></tr></table></figure>
<p>puts会在字符串输出后自动添加一个换行，fputs不会添加</p>
<h3 id="6-5-按对象读：read，fread"><a href="#6-5-按对象读：read，fread" class="headerlink" title="6.5 按对象读：read，fread"></a>6.5 按对象读：read，fread</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">size_t read(int fd, void *buf, size_t count);</span><br><span class="line">功能：从文件描述符中读取数据的系统调用</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：读取到的字节数，如果读取到文件末尾则返回0，错误返回EOF</span><br><span class="line">fd：文件描述符</span><br><span class="line">buf：要存放读出数据的缓冲区</span><br><span class="line">count：要读取的字节数</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</span><br><span class="line">功能：从流里面读取内容，内容分了组（对象）</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回实际读到的对象个数，失败返回EOF</span><br><span class="line">ptr：要把读到内容放在哪个缓冲区</span><br><span class="line">size：每个对象的字节大小</span><br><span class="line">nmemb：预计要读多少个对象</span><br><span class="line">stream：要读的流</span><br><span class="line"></span><br><span class="line">注：size * nmemb不能超过缓冲区(ptr)大小</span><br></pre></td></tr></table></figure>
<h4 id="read-和fread-区别"><a href="#read-和fread-区别" class="headerlink" title="read()和fread()区别"></a>read()和fread()区别</h4><blockquote>
<p>read函数是系统调用，直接与操作系统交互，因此它的效率比fread函数高。但是，fread函数是标准库函数，具有更好的移植性和可移植性。在读取文本文件时，fread函数会自动进行字符集转换，而read函数则不会。<br>所以如果需要高效地读取二进制文件，可以使用read函数；如果需要读取文本文件或者需要移植性更好的代码，可以使用fread函数。</p>
</blockquote>
<h3 id="6-6-按对象写：write，fwrite"><a href="#6-6-按对象写：write，fwrite" class="headerlink" title="6.6 按对象写：write，fwrite"></a>6.6 按对象写：write，fwrite</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">size_t write(int fd, const void *buf, size_t count);</span><br><span class="line">功能：将数据从指定的缓冲区写入到文件描述符中</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：成功返回写入的字节数，如果错误返回EOF</span><br><span class="line">fd：文件描述符</span><br><span class="line">buf：要写入的数据所在的缓冲区</span><br><span class="line">count：要写入的字节数</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream);</span><br><span class="line">功能：把缓冲区的内容写入到流里面</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回实际写入的对象个数，失败返回EOF</span><br><span class="line">ptr：要写入的数据所在的缓冲区</span><br><span class="line">size：每个对象的字节大小</span><br><span class="line">nmemb：预计要写入的对象个数</span><br><span class="line">stream：要写入的流</span><br></pre></td></tr></table></figure>
<h4 id="write-和fwrite-区别"><a href="#write-和fwrite-区别" class="headerlink" title="write()和fwrite()区别"></a>write()和fwrite()区别</h4><blockquote>
<ul>
<li>write 函数是系统调用函数，直接将数据写入到文件中，而 fwrite 函数是标准库函数，先将数据写入到缓冲区中，再由标准库将缓冲区中的数据写入到文件中。</li>
<li>write 函数的参数中需要指定文件描述符，而 fwrite 函数的参数中需要指定文件流。</li>
<li>write 函数的返回值是实际写入的字节数，而 fwrite 函数的返回值是实际写入的数据项个数。</li>
</ul>
</blockquote>
<h3 id="7-重定向"><a href="#7-重定向" class="headerlink" title="7. 重定向"></a>7. 重定向</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">FILE *freopen(const char *pathname, const char *mode, FILE *stream);</span><br><span class="line">功能：打开一个文件并且会产生一个流，stream所表示的流会被替代</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回流指针，失败返回NULL</span><br><span class="line">pathname：要打开的文件</span><br><span class="line">mode：打开文件的方式(&quot;w&quot;之类的)</span><br><span class="line">stream：要重定向的流</span><br></pre></td></tr></table></figure>
<p>重定向例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    fp = freopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This will be written to output.txt\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，freopen 函数将文件名为 output.txt 的文件与标准输出流 stdout 关联起来，打开方式为写入模式。然后，程序使用 printf 函数向 stdout 中写入一条消息，这条消息会被重定向写到 output.txt 文件中。最后，程序关闭文件指针 fp，结束程序。<br><strong>注意：freopen 函数只能用于重新定向标准输入输出流，不能用于其他类型的流</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>LINUX</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>day32-c++结构体，类</title>
    <url>/2023/04/19/day32-c++%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="day32-c-结构体，类"><a href="#day32-c-结构体，类" class="headerlink" title="day32-c++结构体，类"></a><font color="green">day32-c++结构体，类</font></h1><!--mroe-->
<h1 id="一、c-引用和指针"><a href="#一、c-引用和指针" class="headerlink" title="一、c++引用和指针"></a>一、c++引用和指针</h1><p>指针和引用有以下几个主要的区别：</p>
<ul>
<li><p>指针是一个变量，存储的是一个地址，指向内存的一个存储单元；引用是原变量的一个别名，跟原来的变量实质上是同一个东西。</p>
</li>
<li><p>指针可以有多级，引用只能是一级。</p>
</li>
<li><p>指针可以在定义的时候不初始化，引用必须在定义的时候初始化。</p>
</li>
<li><p>指针可以指向NULL，引用不可以为NULL。</p>
</li>
<li><p>指针初始化之后可以再改变，引用不可以。</p>
</li>
<li><p>sizeof 的运算结果不同，指针返回指针类型的大小，引用返回原变量类型的大小。</p>
</li>
<li><p>自增运算意义不同，指针自增之后指向后面的内存，引用自增相当于原变量自增。</p>
</li>
</ul>
<p>所以，在一些场合下，比如动态内存分配、多态、链表、树等数据结构、函数参数等，指针是更合适或者必须的选择。当然，在一些场合下，比如函数返回值、常量对象等，引用是更安全或者更高效的选择。另外，在C++中还有一些智能指针（如unique_ptr, shared_ptr, weak_ptr等）和标准容器（如vector, list, map等），可以简化或者避免一些原生指针的使用。</p>
<p>下面是几个引用的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传递函数参数：引用可以用来作为函数参数，传递变量的引用而不是副本，可以避免在函数调用时产生额外的内存开销，并且可以让函数修改原始数据。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    increment(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值：引用可以用来返回函数的结果，避免了拷贝构造函数的调用，提高程序的效率</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">max</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    max(x, y) = <span class="number">30</span>; <span class="comment">// 将x赋值为30</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h1 id="二、c-结构体和类"><a href="#二、c-结构体和类" class="headerlink" title="二、c++结构体和类"></a>二、c++结构体和类</h1><p>在c语言中，结构体只能包含数据成员，不能包含函数成员。而在c++中，结构体可以包含函数成员，甚至可以包含虚函数。这样，c++中的结构体就具有了类的功能，可以实现封装、继承和多态。但是，c++中的结构体和类还是有一些区别的，主要有以下几点：</p>
<ul>
<li>结构体的默认访问权限是public，而类的默认访问权限是private。这意味着，在结构体内部定义的成员变量和成员函数，默认都是公有的，可以在结构体外部访问。而在类内部定义的成员变量和成员函数，默认都是私有的，只能在类内部访问。</li>
<li>结构体的默认继承方式是public，而类的默认继承方式是private。这意味着，在用一个结构体派生另一个结构体时，默认保持基类的访问权限不变。而在用一个类派生另一个类时，默认将基类的公有成员和保护成员变为私有成员。</li>
<li>结构体不能作为模板参数，而类可以。这意味着，在定义模板时，不能用struct关键字来指定类型参数，只能用class或typename关键字。</li>
</ul>
<p>例如，我们可以定义一个学生结构体，包含姓名、年龄、成绩等信息:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个学生结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="comment">// 数据成员</span></span><br><span class="line"><span class="built_in">string</span> name; <span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line"><span class="keyword">double</span> score; <span class="comment">// 成绩</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Student(<span class="built_in">string</span> n, <span class="keyword">int</span> a, <span class="keyword">double</span> s) &#123;</span><br><span class="line">name = n;</span><br><span class="line">age = a;</span><br><span class="line">score = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者用初始化列表:&lt;成员&gt;(数值)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">Student(<span class="built_in">string</span> n ,<span class="keyword">int</span> a,<span class="keyword">double</span> s) : name(n),age(a),score(s)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">~Student(); <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成绩：&quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student ::~Student()&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;析构函数&quot;</span>&lt;&lt;denl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个学生对象</span></span><br><span class="line"><span class="function">Student <span class="title">s</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 调用成员函数</span></span><br><span class="line">s.show();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构函数的作用是在对象销毁时释放对象分配的资源，如：</p>
<blockquote>
<ul>
<li>释放动态分配的内存：如果在对象创建时使用了new操作符分配了动态内存，则需要在析构函数中使用delete操作符释放这些内存，以避免内存泄漏。</li>
<li>关闭文件：如果在对象创建时打开了文件或其他资源，则需要在析构函数中关闭这些文件或资源，以避免资源泄漏。</li>
<li>清理对象状态：如果对象有一些状态需要清理，例如释放锁、删除文件等，也可以在析构函数中完成。<br>需要注意的是，析构函数是在对象销毁时自动调用的，无法手动调用，因此应该确保在析构函数中释放所有的资源和状态。</li>
</ul>
</blockquote>
<br>
<br>

<hr>
<h1 id="三、this指针"><a href="#三、this指针" class="headerlink" title="三、this指针"></a>三、this指针</h1><p>this指针是一个隐含的指针，它指向调用成员函数的对象。在成员函数内部，可以通过this指针来访问对象的数据成员和其他成员函数。this指针的类型是类类型的指针，例如，如果类名是Car，那么this指针的类型就是Car*。</p>
<p>this指针有以下几个作用：</p>
<ol>
<li>区分同名的数据成员和形参。例如，如果成员函数的形参和数据成员同名，可以用this指针来区分它们。如下面的代码所示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_price; <span class="comment">// 数据成员</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetPrice</span><span class="params">(<span class="keyword">int</span> m_price)</span> <span class="comment">// 成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_price = m_price; <span class="comment">// this指针指向调用该函数的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>实现链式操作。例如，如果成员函数的返回值是类类型的引用，可以用this指针来返回当前对象的引用，从而实现链式操作。如下面的代码所示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_price; <span class="comment">// 数据成员</span></span><br><span class="line">    <span class="function">Car&amp; <span class="title">SetPrice</span><span class="params">(<span class="keyword">int</span> m_price)</span> <span class="comment">// 返回类类型的引用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_price = m_price; <span class="comment">// this指针指向调用该函数的对象</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car car;</span><br><span class="line">    car.SetPrice(<span class="number">20000</span>).SetPrice(<span class="number">30000</span>); <span class="comment">// 链式操作，先后给car对象赋值20000和30000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>作为函数的参数。例如，如果有一个友元函数或者全局函数，需要访问类的私有成员，可以用this指针作为参数传递给该函数。(和1差不多)如下面的代码所示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_price; <span class="comment">// 私有数据成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetPrice</span><span class="params">(<span class="keyword">int</span> m_price)</span> <span class="comment">// 成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_price = m_price; <span class="comment">// this指针指向调用该函数的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">ShowPrice</span><span class="params">(Car* car)</span></span>; <span class="comment">// 声明友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowPrice</span><span class="params">(Car* car)</span> <span class="comment">// 友元函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; car-&gt;m_price &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 可以访问私有数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car car;</span><br><span class="line">    car.SetPrice(<span class="number">20000</span>); <span class="comment">// 给car对象赋值20000</span></span><br><span class="line">    ShowPrice(&amp;car); <span class="comment">// 传递car对象的地址给友元函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<br>

</li>
</ol>
<hr>
<h1 id="四、分配和释放内存"><a href="#四、分配和释放内存" class="headerlink" title="四、分配和释放内存"></a>四、分配和释放内存</h1><p>C++中的new和delete操作符，以及它们和C语言中的malloc和free函数的区别。这些都是用于动态分配和释放内存的方法，但是它们有一些重要的不同点，需要我们了解和注意。</p>
<p>首先，new和delete是C++中的操作符，而malloc和free是C中的函数。这意味着new和delete可以被重载（就是自定义新的功能），而malloc和free不能。另外，new和delete可以根据对象的类型自动计算所需的内存大小，而malloc和free需要我们手动指定字节数。</p>
<p>其次，new不仅分配内存，而且会调用类的构造函数，delete会调用类的析构函数，而malloc只分配内存，不会进行初始化类成员工作，free不会调用析构函数。这意味着new和delete可以保证对象的完整性和正确性，而malloc和free可能会导致内存泄漏或未定义行为。</p>
<p>最后，new在分配内存失败时，会抛出异常，而malloc在分配内存失败时，会返回NULL。这意味着new需要使用try-catch语句来处理异常，而malloc需要使用if语句来检查返回值。另外，new可以使用定位new来指定分配内存的位置，而malloc不能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++中用于代替 malloc() 与 free();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//开辟一个int</span></span><br><span class="line"><span class="keyword">delete</span> p1;          <span class="comment">//释放       </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *ptr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];   <span class="comment">//开辟64个char </span></span><br><span class="line"><span class="keyword">delete</span> [] ptr;              <span class="comment">//释放空间 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ps = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">delete</span> [] ps;</span><br><span class="line"></span><br><span class="line">node *ptr_node = <span class="keyword">new</span> node;   <span class="comment">//开辟一个node</span></span><br><span class="line"><span class="keyword">delete</span> ptr_node;             <span class="comment">//释放一个node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：对于基本类型释放时直接delete ptr,对于数组空间 delete [] ptr </span></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h1 id="五、特殊的成员函数"><a href="#五、特殊的成员函数" class="headerlink" title="五、特殊的成员函数"></a>五、特殊的成员函数</h1><h2 id="5-1-构造函数"><a href="#5-1-构造函数" class="headerlink" title="5.1 构造函数"></a>5.1 构造函数</h2><p>构造函数是一种特殊的成员函数，它的名字和类名相同，没有返回值，可以有参数也可以没有参数。构造函数的作用是在类的对象被创建时，对对象的数据成员进行初始化，为对象分配内存空间，并执行一些必要的操作。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;id = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student object created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个Student对象</span></span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">1001</span>, <span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 输出：Student object created.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-析构函数"><a href="#5-2-析构函数" class="headerlink" title="5.2 析构函数"></a>5.2 析构函数</h2><p>析构函数也是一种特殊的成员函数，它的名字是类名前加上一个波浪号(~)，没有返回值，也没有参数。析构函数的作用是在类的对象被销毁时，对对象的数据成员进行清理，释放对象占用的内存空间，并执行一些必要的操作。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;id = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student object created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">~Student() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student object destroyed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个Student对象</span></span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">1001</span>, <span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 输出：Student object created.</span></span><br><span class="line"><span class="comment">// 程序结束时，s1对象被销毁</span></span><br><span class="line"><span class="comment">// 输出：Student object destroyed.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-赋值函数"><a href="#5-3-赋值函数" class="headerlink" title="5.3 赋值函数"></a>5.3 赋值函数</h2><p>首先，看一段代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    stu(<span class="keyword">int</span> id,<span class="built_in">string</span> name)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setid</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main&#123;&#125;&#123;</span><br><span class="line">    <span class="function">sut <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="string">&quot;tom&quot;</span>)</span></span>;</span><br><span class="line">    sut b = a;</span><br><span class="line">    a.setid(<span class="number">2</span>);</span><br><span class="line">    b.showid();<span class="comment">//应该是1，但结果是2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码体现了对象如果直接赋值给另一个对象，并不是数据的拷贝，而只是把b指向了和a同一个空间。想要解决这种问题，c++引入了赋值函数和拷贝函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 赋值运算符重载函数</span></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; other) &#123;</span><br><span class="line"><span class="comment">// 判断是否为自赋值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line"><span class="comment">// 释放当前对象占用的资源</span></span><br><span class="line"><span class="comment">// 根据other复制当前对象的成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回当前对象的引用</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>赋值函数是一种特殊的成员函数，它的名字是operator=，有一个返回值类型为类类型的引用，有一个参数类型为类类型的常量引用。赋值函数的作用是在类的对象之间进行赋值操作时，对对象的数据成员进行逐个赋值，并返回左操作数的引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> age) : m_age(age) &#123;</span><br><span class="line">        m_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_name, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值函数</span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123; <span class="comment">// 避免自我赋值</span></span><br><span class="line">            <span class="keyword">delete</span>[] m_name;</span><br><span class="line">            m_age = other.m_age;</span><br><span class="line">            m_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(other.m_name) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(m_name, other.m_name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name = &quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;, age = &quot;</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    p1 = p2; <span class="comment">// 调用赋值函数</span></span><br><span class="line">    p1.print(); <span class="comment">// 输出name = Jerry, age = 30</span></span><br><span class="line">    p2.print(); <span class="comment">// 输出name = Jerry, age = 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-4-拷贝函数"><a href="#5-4-拷贝函数" class="headerlink" title="5.4 拷贝函数"></a>5.4 拷贝函数</h2><p>c++中拷贝函数是一种特殊的成员函数，它用于在创建对象时复制另一个对象的数据。拷贝函数的一般形式是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类名(<span class="keyword">const</span> 类名 &amp;obj) &#123;</span><br><span class="line">  <span class="comment">// 拷贝obj的数据到当前对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拷贝函数的作用是实现深拷贝，即不仅复制对象的基本类型成员，还复制对象的指针成员所指向的内存空间。如果没有定义拷贝函数，编译器会自动生成一个默认的拷贝函数，但它只能实现浅拷贝，即只复制对象的基本类型成员和指针值，而不复制指针所指向的内存空间。这样可能会导致内存泄漏或重复释放的问题。</p>
<p>拷贝函数的使用场景有以下几种：</p>
<ul>
<li>当一个对象作为参数传递给一个函数时，会调用拷贝函数创建一个临时对象。</li>
<li>当一个对象作为返回值从一个函数返回时，会调用拷贝函数创建一个临时对象。</li>
<li>当使用初始化列表或赋值运算符初始化一个对象时，会调用拷贝函数复制另一个对象的数据。</li>
</ul>
<p>拷贝函数是c++中重要的特性之一，它可以保证对象的数据安全和完整。在编写c++程序时，应该根据需要合理地定义和使用拷贝函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> age) : m_age(age) &#123;</span><br><span class="line">        m_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_name, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝函数</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person&amp; other) &#123;</span><br><span class="line">        m_age = other.m_age;</span><br><span class="line">        m_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(other.m_name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_name, other.m_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name = &quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;, age = &quot;</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    Person p2 = p1; <span class="comment">// 调用拷贝函数</span></span><br><span class="line">    p1.print(); <span class="comment">// 输出name = Tom, age = 20</span></span><br><span class="line">    p2.print(); <span class="comment">// 输出name = Tom, age = 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>拷贝函数和赋值函数的区别主要有以下几点：</p>
<ul>
<li>拷贝函数用于创建新对象，赋值函数用于修改已存在的对象。</li>
<li>拷贝函数只能有一个参数，即被拷贝的对象的引用，而赋值函数可以有多个参数，但第一个参数必须是被赋值的对象的引用。</li>
<li>拷贝函数不需要返回值，而赋值函数需要返回被赋值的对象的引用，以便进行连续赋值。</li>
<li>拷贝函数不需要考虑自拷贝的情况，而赋值函数需要在函数内部判断是否为自赋值，以避免出现错误。</li>
<li>拷贝函数不需要释放当前对象占用的资源，而赋值函数需要在复制之前释放当前对象占用的资源，以防止内存泄漏。</li>
</ul>
</blockquote>
<p>如果使用默认的拷贝函数和赋值函数，则会进行浅拷贝。当类中含有指针类型的数据成员时要避免浅拷贝。如果需要进行深拷贝，则需要自定义拷贝函数和赋值函数，实现拷贝构造函数以及赋值操作时，为指针开辟新的空间。</p>
<h2 id="5-5-友员函数"><a href="#5-5-友员函数" class="headerlink" title="5.5 友员函数"></a>5.5 友员函数</h2><p>在C++中，友元（friend）是一种特殊的关系，它允许一个类的非成员函数或另一个类访问该类的私有成员和保护成员。这个关系可以在类的定义中通过friend关键字来声明。</p>
<p>友元函数是一个在类外定义的函数，它可以访问该类的私有成员和保护成员。声明一个函数为友元函数的方法是在该类的定义中使用friend关键字，后跟函数的声明。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">myFriendFunction</span><span class="params">(MyClass obj)</span></span>; <span class="comment">// 友元函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFriendFunction</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; obj.x; <span class="comment">// 可以访问MyClass类的私有成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，一个类也可以成为另一个类的友元。这个类就可以访问该类的私有成员和保护成员。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFriendClass</span>;</span> <span class="comment">// 友元类声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFriendClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj.x; <span class="comment">// 可以访问MyClass类的私有成员</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是，友元关系是单向的，不具有传递性。即如果类A是类B的友元，类C是类A的友元，那么类C不能访问类B的私有成员和保护成员。友员函数虽然可以访问类的私有和保护成员，但它并不是该类的成员函数，也不受该类的访问控制规则的约束。因此，友员函数不能使用this指针，也不能直接访问该类的成员名，而必须通过对象名、引用或指针来访问。另外，友员函数也不能被继承或多态。<strong>友元虽然可以打破类的封装性，但应该谨慎使用，因为它破坏了类的封装性原则，使代码更加复杂和难以维护。</strong></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>day31-c++介绍</title>
    <url>/2023/04/18/day31-c++%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="day31-c-介绍"><a href="#day31-c-介绍" class="headerlink" title="day31-c++介绍"></a><font color="green">day31-c++介绍</font></h1><a id="more"></a>

<h1 id="一、c-简介"><a href="#一、c-简介" class="headerlink" title="一、c++简介"></a>一、c++简介</h1><p>C++是一种编程语言，它是在C语言的基础上发展而来的，增加了面向对象、泛型和异常处理等特性。C++是一种多范式的语言，它支持面向过程、面向对象、泛型和函数式等编程范式。C++也是一种编译型的语言，它需要通过编译器将源代码转换为可执行的机器码。</p>
<p>C++的特点有以下几点：</p>
<ul>
<li>C++是一种高效的语言，它提供了底层的访问能力，可以直接操作内存和硬件，也可以利用现代的优化技术提高性能。</li>
<li>C++是一种灵活的语言，它允许程序员根据不同的需求选择不同的编程风格和技术，也可以与其他语言进行混合编程。</li>
<li>C++是一种可移植的语言，它遵循了国际标准，可以在不同的平台和操作系统上运行，也可以利用标准模板库（STL）和第三方库扩展功能。</li>
</ul>
<p>C++的适用场景有以下几点：</p>
<ul>
<li>C++适合开发需要高性能、高可靠性、高安全性的系统软件和应用软件，例如操作系统、数据库、网络通信、图形图像、游戏等领域。</li>
<li>C++适合开发需要跨平台、跨语言的软件，例如嵌入式系统、物联网、云计算、人工智能等领域。</li>
<li>C++适合开发需要利用现有代码或库的软件，例如基于C语言或其他语言的遗留代码或开源代码等。</li>
</ul>
<p>C++的学习路线有以下几点：</p>
<ul>
<li>入门阶段：学习C++的基本语法和面向对象编程思想，掌握类、对象、继承、多态等概念，熟悉常用的标准库和第三方库，完成一些简单的项目实践。</li>
<li>进阶阶段：学习C++的高级特性和泛型编程思想，掌握模板、异常处理、智能指针等概念，深入理解STL的原理和实现，完成一些复杂的项目实践。</li>
<li>提高阶段：学习C++的最新标准和新特性，掌握lambda表达式、移动语义、并发编程等概念，关注C++的发展趋势和前沿技术，完成一些创新的项目实践。</li>
</ul>
<br>
<br>

<hr>
<h2 id="二、c-开发环境"><a href="#二、c-开发环境" class="headerlink" title="二、c++开发环境"></a>二、c++开发环境</h2><ul>
<li><p>Linux下的c++开发工具</p>
<blockquote>
<p>vim，gedit，vscode，g++</p>
</blockquote>
</li>
<li><p>windows下的c++开发工具</p>
<blockquote>
<p>devcpp，vsxode+winGW</p>
</blockquote>
</li>
<li><p>windows + linux </p>
<blockquote>
<p>用ssh在windows上远程连接Linux</p>
</blockquote>
</li>
</ul>
<br>
<br>

<hr>
<h2 id="三、c-基础知识"><a href="#三、c-基础知识" class="headerlink" title="三、c++基础知识"></a>三、c++基础知识</h2><h3 id="3-1-c-基本结构"><a href="#3-1-c-基本结构" class="headerlink" title="3.1 c++基本结构"></a>3.1 c++基本结构</h3><p>C++是一种面向对象的编程语言，它由以下几个部分组成：</p>
<ul>
<li>预处理器指令：用于引入头文件，定义宏，设置条件编译等。</li>
<li>全局变量和常量：用于在整个程序中存储和访问数据。</li>
<li>函数：用于封装一组相关的语句，实现特定的功能。</li>
<li>类：用于定义一种新的数据类型，包含数据成员和成员函数。</li>
<li>对象：用于创建类的实例，调用成员函数，访问数据成员。</li>
<li>继承：用于实现类之间的关系，使子类可以继承父类的特性和行为。</li>
<li>多态：用于实现不同类型的对象可以使用相同的接口，根据对象的实际类型执行不同的操作。</li>
<li>模板：用于实现泛型编程，使函数和类可以适用于不同类型的参数和数据。</li>
</ul>
<p>C++基本结构的示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cpp</span><br><span class="line"><span class="comment">// 预处理器指令</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 引入输入输出流头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// 使用标准命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量和常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>; <span class="comment">// 定义一个常量</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 定义一个变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> <span class="comment">// 定义一个无参无返回值的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出一行文字</span></span><br><span class="line">count++; <span class="comment">// 变量自增</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> // 定义一个圆类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有部分</span></span><br><span class="line"><span class="keyword">double</span> radius; <span class="comment">// 数据成员，半径</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 公有部分</span></span><br><span class="line">Circle(<span class="keyword">double</span> r) <span class="comment">// 构造函数，初始化半径</span></span><br><span class="line">&#123;</span><br><span class="line">radius = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="comment">// 成员函数，计算面积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printHello(); <span class="comment">// 调用函数</span></span><br><span class="line"><span class="function">Circle <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 创建对象，传入半径为5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The area of the circle is &quot;</span> &lt;&lt; c.getArea() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出圆的面积</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The count is &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出变量的值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示程序正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2-c-和c语法上的不同"><a href="#3-2-c-和c语法上的不同" class="headerlink" title="3.2 c++和c语法上的不同"></a>3.2 c++和c语法上的不同</h3><ol>
<li>隐式类型转换</li>
</ol>
<p>在C中，可以隐式地将一个类型的变量赋值给另一个类型的变量，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> y = x; <span class="comment">// 隐式地将int转换为double</span></span><br></pre></td></tr></table></figure>

<p>这种隐式类型转换可能会导致精度损失或数据溢出，但是C编译器不会报错，只会给出一个警告。</p>
<p>而在C++中，这种隐式类型转换是不允许的，编译器会报错，提示类型不匹配。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> y = x; <span class="comment">// 错误：不能将int转换为double</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是因为C++更加注重类型安全，要求程序员显式地进行类型转换，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x); <span class="comment">// 显式地将int转换为double</span></span><br></pre></td></tr></table></figure>

<p>这样可以避免一些潜在的错误和风险。</p>
<ol start="2">
<li>函数重载</li>
</ol>
<p>在C中，不能定义两个或多个同名但参数不同的函数，即使它们的返回值也不同。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125; <span class="comment">// 错误：重复定义了函数add</span></span><br></pre></td></tr></table></figure>

<p>这是因为C中的函数名是一个全局唯一的标识符，不能有重复。</p>
<p>而在C++中，可以定义两个或多个同名但参数不同的函数，这称为函数重载。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125; <span class="comment">// 正确：重载了函数add</span></span><br></pre></td></tr></table></figure>

<p>这是因为C++中的函数名是一个由函数名和参数列表组成的复合标识符，只要参数列表不同，就可以有相同的函数名。而且参数可以写默认值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfln</span><span class="params">(<span class="keyword">const</span> a = <span class="string">&quot;hello&quot;</span>, <span class="keyword">int</span> b=<span class="number">4</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数重载可以提高代码的可读性和灵活性，可以根据不同的参数类型选择合适的函数实现。</p>
<p>但要注意参数类型不一致时，会发生转换，但如果有两个符合条件的函数（例如输入的参数是int和float，把float转为int可以调用函数1，把int转为float可以调用函数2），编译器就会发生错误</p>
<ol start="3">
<li>结构体变量声明</li>
</ol>
<p>在C中，定义一个结构体类型后，要声明一个该类型的变量，需要在变量名前加上关键字struct。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p</span>;</span> <span class="comment">// 声明一个结构体变量p</span></span><br></pre></td></tr></table></figure>

<p>而在C++中，定义一个结构体类型后，要声明一个该类型的变量，可以省略关键字struct。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p; <span class="comment">// 声明一个结构体变量p</span></span><br></pre></td></tr></table></figure>

<p>这是因为C++中的结构体类型和类类型是一致的，都属于用户自定义类型，可以直接使用其名称作为变量类型。</p>
<p>省略关键字struct可以简化代码的书写和阅读。</p>
<h3 id="3-3-c-作用域"><a href="#3-3-c-作用域" class="headerlink" title="3.3 c++作用域"></a>3.3 c++作用域</h3><p>C++作用域是指变量或函数在程序中的可见范围。C++有四种作用域，范围从大到小：全局作用域、命名空间作用域和类作用域、局部作用域。</p>
<ul>
<li>全局作用域<br>全局作用域是指定义在函数外部的变量或函数，它们在程序的任何地方都可以访问。全局变量或函数的命名应该避免与其他库或模块的命名冲突，否则会导致链接错误或不可预期的行为。</li>
<li>命名空间作用域<br>命名空间作用域是指定义在命名空间内部的变量或函数，它们可以在同一个命名空间内或者使用命名空间限定符访问。命名空间是一种组织代码的方式，可以避免不同模块之间的命名冲突，也可以提高代码的可读性和可维护性。C++标准库中的所有内容都位于std命名空间中，使用时需要加上std::前缀，或者使用using声明引入。</li>
<li>类作用域<br>类作用域是指定义在类内部的变量或函数，它们可以在类内部或者使用类对象访问。类是一种封装数据和操作的抽象，可以实现面向对象编程的特性，如封装、继承和多态。类内部的变量称为数据成员，类内部的函数称为成员函数。数据成员和成员函数可以有不同的访问权限，如公有、私有和保护，这样可以控制类对象对它们的访问程度。</li>
<li>局部作用域<br>局部作用域是指定义在函数内部的变量或函数，它们只能在函数内部使用。局部变量或函数的生命周期只限于函数的执行期间，函数结束后，它们会被销毁。局部变量或函数可以隐藏同名的全局变量或函数，这样可以提高程序的模块化和封装性。</li>
</ul>
<h3 id="3-4-c-引用"><a href="#3-4-c-引用" class="headerlink" title="3.4 c++引用"></a>3.4 c++引用</h3><p>C++中的引用是一种特殊的变量，它可以用来表示另一个变量的别名。引用的作用是可以让我们通过不同的名字访问同一个内存地址，从而实现对变量的间接操作。引用的声明方式是在变量类型后面加上一个&amp;符号，然后给出引用的名字和初始化的变量。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>; <span class="comment">// 声明一个整型变量x</span></span><br><span class="line">    <span class="keyword">int</span> &amp;y = x; <span class="comment">// 声明一个整型引用y，指向x</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    change(a,b);<span class="comment">//a,b的值能被转换，a=2，b=1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用有以下几个特点：</p>
<ul>
<li>引用必须在声明时初始化，不能像指针那样先声明后赋值。</li>
<li>引用一旦初始化，就不能改变指向的对象，也就是说引用是常量指针。</li>
<li>引用没有自己的内存空间，它只是指向另一个变量的别名，所以不能对引用取地址。</li>
<li>引用可以作为函数的参数和返回值，从而实现传递和返回对象的效果。</li>
</ul>
<p>引用的优点是可以简化代码的书写，避免使用指针带来的复杂性和风险。引用的缺点是可能造成代码的可读性和可维护性降低，因为不容易区分引用和原始变量。因此，在使用引用时，应该遵循以下原则：</p>
<ul>
<li>尽量使用const引用，以防止修改指向的对象。</li>
<li>尽量避免使用多层引用，以防止产生混乱和错误。</li>
<li>尽量避免使用引用的引用，以防止出现未定义的行为。</li>
</ul>
<h3 id="3-5-内联函数"><a href="#3-5-内联函数" class="headerlink" title="3.5 内联函数"></a>3.5 内联函数</h3><p>c++中可以用宏函数提高效率，但安全性降低</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//宏函数只会进行引用，不是真正的函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max1;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">  max1 = max(a++,b); <span class="comment">//实际上是((a++)&gt;(b)?(a++):(b));</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;max1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//结果是max=8，a=9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c++中引入了inlien关键字（内联函数），用来实现类似于宏函数的效果<br>但内联函数通过空间换取的时间，相当于直接把内联函数的代码嵌如到主函数中。空间开销大，一般内联函数不能太复杂</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max1;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">7</span>,b=<span class="number">4</span>;</span><br><span class="line">  max1 = max(a++,b);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;max1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//结果是max=7，a=8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-const关键字"><a href="#3-6-const关键字" class="headerlink" title="3.6 const关键字"></a>3.6 const关键字</h3><ol>
<li>const修饰类的成员函数</li>
</ol>
<p>当我们在类的成员函数后面加上const关键字时，表示这个函数是一个常成员函数，它不会修改对象的任何数据成员。这样可以保证对象的状态不被意外改变，也可以增加代码的可读性和可维护性。</p>
<p>常成员函数的特点有：</p>
<ul>
<li>常成员函数只能访问类的const成员变量和const成员函数，不能访问非const的成员。</li>
<li>常成员函数不能修改类的任何数据成员，也不能调用非const的成员函数（因为这些操作都可能改变对象的状态）。</li>
<li>常成员函数可以被非const对象和const对象调用，但非const成员函数只能被非const对象调用。</li>
<li>常成员函数可以被重载，即可以存在同名的const和非const版本的成员函数，它们的区别在于是否有const修饰符。</li>
</ul>
<p>常成员函数的语法格式为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">返回值类型 类名::函数名(参数列表) const;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> * name, <span class="keyword">int</span> age, <span class="keyword">float</span> score );</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>; <span class="comment">//非const成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getname</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//const成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//const成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getscore</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//const成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Student::getname</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Student::getage</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Student::getscore</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>const修饰类的成员变量</li>
</ol>
<p>当我们在类的成员变量前面加上const关键字时，表示这个变量是一个常数据成员，它只能在初始化列表中赋值，不能在其他地方修改。这样可以保证对象的数据不被意外改变，也可以增加代码的安全性和效率。</p>
<p>常数据成员的特点有：</p>
<ul>
<li>常数据成员必须在初始化列表中赋值，不能在构造函数体或其他地方赋值。</li>
<li>常数据成员只能被const成员函数访问，不能被非const的成员函数访问。</li>
<li>常数据成员可以是静态或非静态的，静态常数据成员还必须在类外初始化。</li>
</ul>
<p>常数据成员的语法格式为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">public:</span><br><span class="line">    类名(参数列表):常数据成员(初始值)&#123;...&#125;</span><br><span class="line">private:</span><br><span class="line">    const 数据类型 数据名;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> r):radius(r),area(PI*r*r)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> radius;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> area;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> radius; <span class="comment">//常数据成员</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> area; <span class="comment">//常数据成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>const修饰对象<br>首先，我们需要明确一点，const修饰的是对象本身，而不是对象的类型。也就是说，const修饰的对象仍然属于原来的类型，只不过它的状态不能被改变。例如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x_(x), y_(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; x_ = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; y_ = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> y_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x_;</span><br><span class="line">    <span class="keyword">int</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// p1是一个普通的Point对象</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Point <span class="title">p2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// p2是一个const Point对象</span></span><br><span class="line"></span><br><span class="line">p1.setX(<span class="number">10</span>); <span class="comment">// OK，可以修改p1的状态</span></span><br><span class="line">p2.setX(<span class="number">20</span>); <span class="comment">// 错误，不能修改p2的状态</span></span><br><span class="line"></span><br><span class="line">Point* pp1 = &amp;p1; <span class="comment">// OK，可以用普通指针指向普通对象</span></span><br><span class="line">Point* pp2 = &amp;p2; <span class="comment">// 错误，不能用普通指针指向const对象</span></span><br><span class="line"><span class="keyword">const</span> Point* pp3 = &amp;p1; <span class="comment">// OK，可以用const指针指向普通对象</span></span><br><span class="line"><span class="keyword">const</span> Point* pp4 = &amp;p2; <span class="comment">// OK，可以用const指针指向const对象</span></span><br><span class="line"></span><br><span class="line">pp1-&gt;setX(<span class="number">30</span>); <span class="comment">// OK，可以通过普通指针修改普通对象的状态</span></span><br><span class="line">pp2-&gt;setX(<span class="number">40</span>); <span class="comment">// 错误，不能通过普通指针修改const对象的状态</span></span><br><span class="line">pp3-&gt;setX(<span class="number">50</span>); <span class="comment">// 错误，不能通过const指针修改普通对象的状态</span></span><br><span class="line">pp4-&gt;setX(<span class="number">60</span>); <span class="comment">// 错误，不能通过const指针修改const对象的状态</span></span><br></pre></td></tr></table></figure>
从上面的例子可以看出，当我们用const修饰一个自定义对象时，有以下几个效果：</li>
</ol>
<ul>
<li>我们不能直接调用该对象的任何非const成员函数，因为这些函数可能会修改该对象的状态。</li>
<li>我们不能用普通指针或引用来指向该对象，因为这样可能会通过指针或引用来修改该对象的状态。</li>
<li>我们只能调用该对象的const成员函数，因为这些函数保证了不会修改该对象的状态。</li>
<li>我们只能用const指针或引用来指向该对象，因为这样保证了不会通过指针或引用来修改该对象的状态。</li>
</ul>
<h3 id="3-6-static关键字"><a href="#3-6-static关键字" class="headerlink" title="3.6 static关键字"></a>3.6 static关键字</h3><ol>
<li>static可以使类的成员变量和成员函数与类的对象无关，即不需要创建对象就可以访问。static修饰的成员变量和成员函数属于类本身，而不属于某个对象，因此它们只有一份，被所有对象共享。这样可以节省内存空间，也可以实现一些全局的功能。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> value) : m_value(value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s_count = &quot;</span> &lt;&lt; s_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_count; <span class="comment">// 静态成员变量</span></span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyClass::s_count = <span class="number">0</span>; <span class="comment">// 静态成员变量初始化要在类外</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    MyClass::printCount(); <span class="comment">// 输出s_count = 0</span></span><br><span class="line">    obj1.printCount(); <span class="comment">// 输出s_count = 0</span></span><br><span class="line">    obj2.printCount(); <span class="comment">// 输出s_count = 0</span></span><br><span class="line">    MyClass::s_count = <span class="number">1</span>; <span class="comment">// 静态成员变量修改</span></span><br><span class="line">    MyClass::printCount(); <span class="comment">// 输出s_count = 1</span></span><br><span class="line">    obj1.printCount(); <span class="comment">// 输出s_count = 1</span></span><br><span class="line">    obj2.printCount(); <span class="comment">// 输出s_count = 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>static可以实现类的封装性，即隐藏类的实现细节。static修饰的成员变量和成员函数只能在类的内部或者友元函数中访问，不能在类的外部访问。这样可以保护类的数据和行为，防止被外部修改或者滥用。</li>
<li>static可以实现类的多态性，即同一个函数名可以有不同的行为。static修饰的成员函数是静态绑定的，即在编译时就确定了调用哪个函数。static修饰的成员函数不能被子类重写，也不能使用虚函数表实现动态绑定。这样可以提高程序的执行效率，也可以避免一些运行时错误。</li>
</ol>
<p>总之，static在自定义类中的作用是使类的成员变量和成员函数与对象无关、实现类的封装性和多态性。在使用static时，需要注意以下几点：</p>
<ul>
<li>static修饰的成员变量需要在类外初始化，否则会报错。</li>
<li>static修饰的成员函数不能访问非静态的成员变量和成员函数，否则会报错。</li>
<li>static修饰的成员函数不能被声明为const或者volatile，否则会报错。</li>
<li>static修饰的成员函数不能使用this指针，因为this指针指向当前对象，而静态成员函数与对象无关。</li>
</ul>
<br>
<br>

<hr>
<h2 id="四、c-编译"><a href="#四、c-编译" class="headerlink" title="四、c++编译"></a>四、c++编译</h2><p>c和c++混合编译时，先分别编译成.o文件，在放在一起编译</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析</title>
    <url>/2020/04/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><font color="green">概述</font></h1><p>算法分析是关于计算机程序和资源利用的研究</p>
<h2 id><a href="#" class="headerlink" title></a><a id="more"></a></h2><h1 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a><font color="green">数学模型</font></h1><p>大多数程序得到数学模型所需步骤：</p>
<ol>
<li>确定输入模型，定义问题规模（n）</li>
<li>识别循环与递归</li>
<li>根据内循环或每部递归的操作确定成本模型</li>
<li>对于给定的输入，判断这些操作的执行频率</li>
</ol>
<hr>
<h1 id="两种常见讨论情况"><a href="#两种常见讨论情况" class="headerlink" title="两种常见讨论情况"></a><font color="green">两种常见讨论情况</font></h1><blockquote>
<p>最坏情况：T(n)定义为输入规模为 n 时的最长运行时间<br>平均情况：T(n)定义为输入规模为 n 时所有可能输入的期望值(通常是均匀分布时的情况)</p>
</blockquote>
<p>为了不被硬件因素所影响，对算法的分析采用了 <font color="red">渐进分析</font></p>
<blockquote>
<p>渐进分析：</p>
<ol>
<li>忽略依赖于机器性能的常量</li>
<li>只关注运行时间的增长</li>
</ol>
</blockquote>
<hr>
<br>
<br>

<h1 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a><font color="green">渐进符号</font></h1><h2 id="大-O-记号法：-上界"><a href="#大-O-记号法：-上界" class="headerlink" title="大$O$记号法：(上界)"></a>大$O$记号法：(上界)</h2><p>f(n) = $O$(g(n)) 表示存在适当常数 (c&gt;0 $n_0$&gt;0) 使得 0 &lt;= f(n) &lt;= c*g(n) 其中 n &gt;= $n_0$<br><strong>注：这里的=不是等于的意思，更多是指 f(n) 属于 $O$(g(n)) 集合。 即$O$(g(n))是一个函数集，集合内有 f(n)</strong></p>
<blockquote>
<p>例：$2n^2 = O(n^3)$</p>
</blockquote>
<p>宏展开：<br>&nbsp;&nbsp;&nbsp; 当等式左右两边都存在$O$( )时，这时=相当于$\epsilon$</p>
<blockquote>
<p>例：$n^2+O(n) = O(n^2)$ &gt; &nbsp;&nbsp;&nbsp;对于任意 f(n)$\epsilon O(n)$，都有对应的 h(n)$\epsilon O(n)$<br>注：不能反推</p>
</blockquote>
<h2 id="大-Omega-记号法：-下界"><a href="#大-Omega-记号法：-下界" class="headerlink" title="大 $\Omega$记号法：(下界)"></a>大 $\Omega$记号法：(下界)</h2><p>f(n) = $O$(g(n)) 表示存在适当常数 (c&gt;0 $n_0$&gt;0) 使得 0 &lt;= c*g(n) &lt;= f(n) 其中 n &gt;= $n_0$</p>
<blockquote>
<p>例：$\sqrt{n}=\Omega(\lg n)$</p>
</blockquote>
<h2 id="大-Theta-记号法："><a href="#大-Theta-记号法：" class="headerlink" title="大 $\Theta$记号法："></a>大 $\Theta$记号法：</h2><p>$\Theta(g(n)) = O(g(n)) \bigcap \Omega(g(n))$</p>
<p>理解：左右两边增长速率一样</p>
<p>用法：写个公式，去掉它的低阶项，并忽略前面的常数因子(系数)</p>
<h2 id="严格符号："><a href="#严格符号：" class="headerlink" title="严格符号："></a>严格符号：</h2><p>与渐进符号的区别在于：</p>
<ul>
<li>渐进符号表示渐进符号内的函数在经过某一点后便大于或小于原函数</li>
<li>严格符号表示严格符号内的函数是完全大于或小于原函数</li>
</ul>
<h3 id="o-记号"><a href="#o-记号" class="headerlink" title="o 记号"></a>o 记号</h3><p>f(n)完全小于 o(g(n)),与$O$对应</p>
<h3 id="omega-记号"><a href="#omega-记号" class="headerlink" title="$\omega$记号"></a>$\omega$记号</h3><p>f(n)完全大于$\omega$(g(n))，与$O$对应</p>
<hr>
<br>
<br>

<h1 id="递归式的三种解法"><a href="#递归式的三种解法" class="headerlink" title="递归式的三种解法"></a><font color="green">递归式的三种解法</font></h1><h2 id="补充知识：数学归纳法"><a href="#补充知识：数学归纳法" class="headerlink" title="补充知识：数学归纳法"></a>补充知识：数学归纳法</h2><p>用来证明一个命题在问题规模为 n 时成立</p>
<ol>
<li>证明 n=1 时成立</li>
<li>假设 n=n-1 时成立，如求出(n-1)+1 时成立</li>
<li>则命题成立</li>
</ol>
<h2 id="1-代换法"><a href="#1-代换法" class="headerlink" title="1. 代换法"></a>1. 代换法</h2><ol>
<li>先猜答案得到最高阶</li>
<li>验证这个递归式是否按照数学归纳法满足条件</li>
</ol>
<blockquote>
<p>例：T(n)=4T(n/2)+n</p>
<ol>
<li>(猜)忽略常数 n，由 T(n)=4T(n/2) 可看出当 n 减 2 倍，系数增加 4 倍。$n^2$符合这一标准,假定 T(n)=$O(n^2)$</li>
<li>(证)将递归式展开得 T(n)=$4T(n/2)+n$ &lt;= $cn^2$+n = $cn^2$-(-n)<blockquote>
<p>$O(n^2)$=$c(n)^2$</p>
</blockquote>
</li>
<li>因为要证明的是 T(n)=$O(n^2)$ 所以 T(n) &lt;= $cn^2$-(-n) 中(-n)大于等于 0</li>
</ol>
</blockquote>
<p>但这里发现了因为 n&gt;=1 所以上式不成立。是我们做错了吗，让我们想想有什么办法可以改变这个常数。<br>当我们对 $O(n^2)$ 进行展开时，我们是忽略了常数项的，因为它对 n 为无穷大时作用很小，但作用小就表明还是有一定的作用，我们试着把常数项带进来，即改进 T(n)=$O(n^2)$ 时的条件</p>
<blockquote>
<p>改进：<br>T(n) =$O(n^2)$ &lt;=$c_1n^2-c_2n$ (多了常数项)<br>T(n)=$4T(n/2)+n$ &lt;= $4(c_1(n/2)^2-c_2(n/2))+n=c_1n^2-c_2n-(c_2-1)n$<br>要使 T(n)=$O(n^2)$则要满足$(c_2-1)n$ &gt;= 0 (当$c_2$ &gt;= 1 时成立)<br>并且 T(1) &lt;=$c_1-c_2$ 成立<br>可以得出 T(n+1) &lt;= $c_1(n+1)^2-c_2(n+1)$ (当$c_1&gt;&gt;c_2$时成立)(算一下就出来了)<br>这时条件 T(1)，T(n)和 T(1)推出 T(n+1)都有了<br>最后得出 T(n) = $O(n^2)$</p>
</blockquote>
<h2 id="2-递归树法"><a href="#2-递归树法" class="headerlink" title="2. 递归树法"></a>2. 递归树法</h2><ol>
<li>将递归式按树的形式展开(不用全画出来)(并且每次递归时 n 的和都要减少而不是增大)</li>
<li>根据每层的和的规律，求出总子叶节点<ul>
<li>如果每层和一样，用每层的和乘以树的高度就行<blockquote>
<p>树要对称，高用每次递归式减少的数(每层为等差)或除以的数(每层为等比)来求<br>等差的话 h=n-k+1 (k 为每层 n 减少的数)<br>等比的话 h=$log_kn$ (k 为每层 n 除的数)</p>
</blockquote>
</li>
<li>如果树不对称或者每层和成等比排列，不用求具体值，都是有规律相加的，求其上界就行</li>
</ul>
</li>
<li>判断总子叶节点小于等于某个相近的值，便可求出其最高阶</li>
</ol>
<p>例：<br><img src="/2020/04/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/diGuiShuFa.jpg" alt="递归树"></p>
<h2 id="3-主方法"><a href="#3-主方法" class="headerlink" title="3.主方法"></a>3.主方法</h2><p>相当于套公式，且适用情况少<br>原理是递归树，可以自己去推导下,这三个主要区别是总子叶节点数的判断不同。（1 是因为每层和在增加，最后一层和占主导。2 是因为每层和一样，和乘以高。3 是因为每层和在减少，第一层和占主导）<br>限制：递归式要满足于 $T(n)=aT(n/b)+f(n)$ &nbsp;&nbsp;&nbsp;a&gt;=1,b&gt;1,f(n)渐进趋正<br>主思路：比较 f(n)和$n^{\log_ba}$</p>
<p>1.</p>
<p>若对某个常数 $\varepsilon&gt;0有$<br>$f(n)= \omicron (n^{\log_b{a-\varepsilon} })$<br>那么<br>$T(n)= \theta (n^{log_ba})$</p>
<p>2.</p>
<p>若<br>$f(n)=\theta(n^{log_ba})f(n)$<br>则<br>$T(n)=\theta(n^{log_ba}\lg n)T(n)$</p>
<p>3.</p>
<p>若对某个常数 $\varepsilon&gt;0有$<br>$f(n) = \Omega(n^{\log_b{a+\varepsilon} })f(n)$<br>且对于某个常数 c&lt;1 和所有足够大的 n 有<br>$af(\frac nb)\le cf(n)$<br>则<br>$T(n)=\theta(f(n))T(n)$</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>算法</tag>
        <tag>概念</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>day40-ARM简介</title>
    <url>/2023/05/16/day40-ARM%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="day40-ARM简介"><a href="#day40-ARM简介" class="headerlink" title="day40-ARM简介"></a><font color="green">day40-ARM简介</font></h1><!--mroe-->

<h2 id="一、ARM基础知识"><a href="#一、ARM基础知识" class="headerlink" title="一、ARM基础知识"></a>一、ARM基础知识</h2><h3 id="1-1变量"><a href="#1-1变量" class="headerlink" title="1.1变量"></a>1.1变量</h3><p>ARM处理器采用32位架构，这意味着它可以一次处理32位（4字节）的数据，**<font color="red">ARM的地址0X00000000是以字节为单位的，即PC每次移动4字节</font>**。ARM处理器也支持8位（1字节）和16位（2字节）的数据类型，分别称为字节（byte）和半字（halfword）。在ARM中，一个字（word）是32位（4字节）的数据类型。</p>
<p>在C语言中，我们可以使用不同的数据类型来定义变量，例如char，short，int，long等。这些数据类型在不同的编译器和平台下可能有不同的大小。例如，在一个32位的ARM平台上，一个char类型的变量占用1个字节，一个short类型的变量占用2个字节，一个int类型的变量占用4个字节，一个long类型的变量也占用4个字节。但是，在一个64位的ARM平台上，一个long类型的变量可能占用8个字节。</p>
<p>为了避免这种不确定性，我们可以使用C99标准提供的固定宽度整数类型，例如int8_t，int16_t，int32_t等。这些类型可以保证在不同的平台下具有相同的大小和符号性。例如，在任何平台上，一个int8_t类型的变量都占用1个字节，并且是有符号的。</p>
<h3 id="1-2指令集"><a href="#1-2指令集" class="headerlink" title="1.2指令集"></a>1.2指令集</h3><p>指令集是一组定义了处理器能够执行的操作的指令。不同的处理器可能有不同的指令集。ARM处理器提供了三种指令集：ARM指令集，Thumb指令集和Thumb-2指令集。</p>
<ul>
<li>ARM指令集：这是最早和最基本的指令集，它包含了一些32位宽度的指令。这些指令可以实现复杂和强大的功能，但是也占用较多的内存空间。</li>
<li>Thumb指令集：这是为了优化内存使用而设计的指令集，它包含了一些16位宽度的指令。这些指令可以实现简单和常用的功能，但是也牺牲了一些灵活性和性能。</li>
<li>Thumb-2指令集：这是为了兼顾内存使用和性能而设计的指令集，它包含了一些16位和32位混合宽度的指令。这些指令可以实现大部分ARM指令集和Thumb指令集的功能，并且提供了更多的优化选项。</li>
</ul>
<h3 id="1-3工作模式"><a href="#1-3工作模式" class="headerlink" title="1.3工作模式"></a>1.3工作模式</h3><table>
<thead>
<tr>
<th align="center">工作模式</th>
<th align="center">特权级别</th>
<th align="center">寄存器集合</th>
<th align="center">异常处理</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">用户模式</td>
<td align="center">非特权</td>
<td align="center">R0-R15</td>
<td align="center">无</td>
<td align="center">正常执行程序，不能直接访问硬件资源或切换模式</td>
</tr>
<tr>
<td align="center">系统模式</td>
<td align="center">特权</td>
<td align="center">R0-R15</td>
<td align="center">无</td>
<td align="center">运行具有特权的操作系统任务，可以访问所有系统资源</td>
</tr>
<tr>
<td align="center">快速中断模式</td>
<td align="center">特权</td>
<td align="center">R0-R7, R8_fiq-R14_fiq, SPSR_fiq, R15</td>
<td align="center">处理高速数据传输或通道处理</td>
<td align="center">处理高优先级的中断请求，拥有独立的寄存器集合</td>
</tr>
<tr>
<td align="center">外部中断模式</td>
<td align="center">特权</td>
<td align="center">R0-R12, R13_irq, R14_irq, SPSR_irq, R15</td>
<td align="center">处理一般情况下的中断</td>
<td align="center">处理低优先级的中断请求，共享寄存器集合</td>
</tr>
<tr>
<td align="center">管理模式</td>
<td align="center">特权</td>
<td align="center">R0-R12, R13_svc, R14_svc, SPSR_svc, R15</td>
<td align="center">处理软件中断或系统初始化</td>
<td align="center">操作系统使用的保护模式，处理软件中断或系统调用</td>
</tr>
<tr>
<td align="center">数据访问终止模式</td>
<td align="center">特权</td>
<td align="center">R0-R12, R13_abt, R14_abt, SPSR_abt, R15</td>
<td align="center">处理存储器故障或实现虚拟存储器和存储器保护</td>
<td align="center">当数据或指令预取终止时进入该模式，可用于虚拟存储或存储保护</td>
</tr>
<tr>
<td align="center">未定义指令中止模式</td>
<td align="center">特权</td>
<td align="center">R0-R12, R13_und, R14_und, SPSR_und, R15</td>
<td align="center">处理未定义的指令或支持硬件协处理器的软件仿真</td>
<td align="center">当执行未定义指令时进入该模式，可用于支持硬件协处理器的软件仿真</td>
</tr>
</tbody></table>
<h3 id="1-4寄存器"><a href="#1-4寄存器" class="headerlink" title="1.4寄存器"></a>1.4寄存器</h3><p>寄存器是处理器内部的一种高速存储单元，它可以用来存放数据、指令、地址或状态信息。寄存器的访问速度比内存快得多，因此处理器通常会把频繁使用的数据或指令放在寄存器中，以提高执行效率。</p>
<h4 id="ARM有哪些寄存器？"><a href="#ARM有哪些寄存器？" class="headerlink" title="ARM有哪些寄存器？"></a>ARM有哪些寄存器？</h4><p>ARM处理器一般共有37个寄存器，其中包括：</p>
<ul>
<li>31个通用寄存器，包括程序计数器（PC）在内，都是32位的寄存器。</li>
<li>6个状态寄存器，都是32位的寄存器，但只使用了其中的12位。</li>
</ul>
<p>ARM处理器共有7种不同的处理器模式，在每一种处理器模式中有一组相应的寄存器。在任意一种处理器模式下，可见的寄存器包括15个通用寄存器（R0~R14）、一个或者二个状态寄存器以及程序计数器（PC）。在所有的寄存器中，有些是各模式共用同一个物理寄存器，有些寄存器是各个模式自己拥有独立的物理寄存器。</p>
<h4 id="ARM通用寄存器有什么作用？"><a href="#ARM通用寄存器有什么作用？" class="headerlink" title="ARM通用寄存器有什么作用？"></a>ARM通用寄存器有什么作用？</h4><p>ARM通用寄存器（R0-R15）可分为三类：不分组寄存器R0~R7；分组寄存器R8~R14；程序计数器PC。</p>
<ul>
<li>不分组寄存器R0~R7</li>
</ul>
<p>不分组寄存器R0~R7在所有处理器模式下，它们每一个都访问一样的32位寄存器。它们是真正的通用寄存器，没有体系结构所隐含的特殊用途。根据“ARM-thumb过程调用标准”，R0-R3用作传入函数参数，传出函数返回值。在子程序调用之间，可以将R0-R3用于任何用途。被调用函数在返回之前不必恢复R0-R3。如果调用函数需要再次使用R0-R3的内容，则它必须保留这些内容。</p>
<ul>
<li>分组寄存器R8~R14</li>
</ul>
<p>分组寄存器R8～R14对应的物理寄存器取决于当前的处理器模式。要访问特定的物理寄存器而不依赖当前的处理器模式，则要使用规定的名字。寄存器R8~R12各有两组物理寄存器：一组为FIQ模式，另一组为除了FIQ以外的所有模式。根据“ARM-thumb过程调用标准”，R4-R11被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。在Thumb程序中，通常只能使用R4-R7来保存局部变量。寄存器R12用作子程序间暂时寄存器IP。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复R12。</p>
<ul>
<li>程序计数器PC</li>
</ul>
<p>程序计数器PC是通用寄存器中最特殊的一个，它总是指向当前正在执行指令后面两条指令处（因为ARM采用了流水线机制）。PC不能直接参与算术运算或逻辑运算，在某些情况下可以将PC当作一个普通地址来读取或写入数据。</p>
<h2 id="什么是状态寄存器？"><a href="#什么是状态寄存器？" class="headerlink" title="什么是状态寄存器？"></a>什么是状态寄存器？</h2><p>状态寄存器是ARM处理器中用来保存当前程序运行时的状态信息的寄存器。状态寄存器有两种类型：当前程序状态寄存器（CPSR）和保存程序状态寄存器（SPSR）。CPSR是所有处理器模式下都可访问的，而SPSR只有在异常模式下才有，并且每种异常模式都有一个对应的SPSR。当异常发生时，SPSR用于保存CPSR的内容，以便在异常返回后恢复原来的状态。</p>
<h4 id="CPSR有哪些字段？"><a href="#CPSR有哪些字段？" class="headerlink" title="CPSR有哪些字段？"></a>CPSR有哪些字段？</h4><p>CPSR是一个32位的寄存器，它可以分为四个8位的区域：标志域（F）、状态域（S）、扩展域（X）和控制域（C）。每个区域都有一些特定的位，用来表示不同的信息。下面是CPSR的结构图：</p>
<p><img src="/2023/05/16/day40-ARM%E7%AE%80%E4%BB%8B/cpsr.png" alt="CPSR结构图"></p>
<ul>
<li>标志域（F）</li>
</ul>
<p>标志域包含四个条件码标志位：N、Z、C、V。这些标志位用来表示算术或逻辑运算的结果的特征，例如是否为负数、是否为零、是否有进位或借位、是否有溢出等。这些标志位可以用来控制指令的条件执行，例如BEQ表示如果Z为1则跳转，BGT表示如果N和V相同且Z为0则跳转等。</p>
<ul>
<li>状态域（S）</li>
</ul>
<p>状态域包含一些与处理器模式相关的位，例如Q、J、T、GE[3:0]等。这些位用来表示处理器的一些特殊状态，例如是否发生饱和运算、是否处于Jazelle模式、是否处于Thumb模式、是否有SIMD运算大于等于等。</p>
<ul>
<li>扩展域（X）</li>
</ul>
<p>扩展域包含一些与处理器扩展相关的位，例如IT[7:0]、E等。这些位用来表示处理器的一些扩展功能，例如是否处于Thumb-2 if-then块中、是否使用大端字节序等。</p>
<ul>
<li>控制域（C）</li>
</ul>
<p>控制域包含一些与处理器控制相关的位，例如I、F、M[4:0]等。这些位用来表示处理器的一些控制选项，例如是否屏蔽中断、是否屏蔽快速中断、当前处于哪种处理器模式等。</p>
<h4 id="SPSR有哪些作用？"><a href="#SPSR有哪些作用？" class="headerlink" title="SPSR有哪些作用？"></a>SPSR有哪些作用？</h4><p>SPSR是保存程序状态寄存器，它只有在异常模式下才存在，并且每种异常模式都有一个对应的SPSR。当异常发生时，SPSR会自动保存CPSR的内容，以便在异常返回后恢复原来的状态。SPSR和CPSR具有相同的结构和字段，只是不能直接访问或修改。要访问或修改SPSR，必须使用专门的指令MRS或MSR，并指定要操作的字段。</p>
<h4 id="NZCV"><a href="#NZCV" class="headerlink" title="NZCV"></a>NZCV</h4><p>NZCV是CPSR寄存器中的标志域（F）的四个条件码标志位，它们分别表示：</p>
<ul>
<li>N：负数标志位（Negative）。当算术或逻辑运算的结果为负数时，N=1；当结果为非负数时，N=0。例如，如果执行<code>SUBS R0, R1, R2</code>指令后，R0的值为0xFFFFFFFF，则N=1；如果R0的值为0x00000001，则N=0。</li>
<li>Z：零标志位（Zero）。当算术或逻辑运算的结果为零时，Z=1；当结果为非零时，Z=0。例如，如果执行<code>SUBS R0, R1, R2</code>指令后，R0的值为0x00000000，则Z=1；如果R0的值为0x00000001，则Z=0。</li>
<li>C：进位标志位（Carry）。当算术或逻辑运算产生进位或借位时，C=1；当没有进位或借位时，C=0。例如，如果执行<code>ADDS R0, R1, R2</code>指令后，R1和R2的最高位相加产生进位，则C=1；如果没有进位，则C=0。如果执行SUBS R0, R1, R2指令后，R1小于R2产生借位，则C=0；如果没有借位，则C=1。</li>
<li>V：溢出标志位（Overflow）。当算术或逻辑运算产生有符号数溢出时，V=1；当没有溢出时，V=0。例如，如果执行<code>ADDS R0, R1, R2</code>指令后，R1和R2的符号相同，但是R0的符号与它们不同，则V=1；如果没有这种情况，则V=0。如果执行SUBS R0, R1, R2指令后，R1和R2的符号不同，但是R0的符号与R2相同，则V=1；如果没有这种情况，则V=0。<br>这四个标志位可以用来控制指令的条件执行，例如：</li>
</ul>
<blockquote>
<p>BEQ：如果Z=1，则跳转到指定地址。<br>BNE：如果Z=0，则跳转到指定地址。<br>BCS：如果C=1，则跳转到指定地址。<br>BCC：如果C=0，则跳转到指定地址。<br>BMI：如果N=1，则跳转到指定地址。<br>BPL：如果N=0，则跳转到指定地址。<br>BVS：如果V=1，则跳转到指定地址。<br>BVC：如果V=0，则跳转到指定地址。</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="二、ARM指令系统语法格式"><a href="#二、ARM指令系统语法格式" class="headerlink" title="二、ARM指令系统语法格式"></a>二、ARM指令系统语法格式</h2><h3 id="2-1-语法格式"><a href="#2-1-语法格式" class="headerlink" title="2.1 语法格式"></a>2.1 语法格式</h3><p>一条ARM指令语法格式分为如下几个部分：</p>
<blockquote>
<p>&lt;opcode&gt; {&lt;cond&gt;} {S} &lt;Rd&gt;,&lt;Rn&gt; {,<shifter_operand>}</shifter_operand></p>
</blockquote>
<p>其中，&lt;&gt;内的项是必须的， {}内的项是可选的，如&lt;opcode&gt;是指令助记符，是必须的，而 {&lt;cond&gt;}为指令执行条件，是可选的，如果不写则使用默认条件AL (无条件执行)。</p>
<p>编码后的机器码格式如下所示：<br><img src="/2023/05/16/day40-ARM%E7%AE%80%E4%BB%8B/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" alt="指令格式"></p>
<p>（1）Opcode 指令助记符，如LDR，STR 等</p>
<p>（2）Cond 执行条件，如EQ，NE 等</p>
<p>（3）S 是否影响CPSR 寄存器的值，书写时影响CPSR，否则不影响</p>
<p>（4）Rd 目标寄存器</p>
<p>（5）Rn 第一个操作数的寄存器</p>
<p>（6）shifter_operand 第二个操作数</p>
<p>仔细看表格中的shifter_operand所占的位数：12位。</p>
<p>要用一个12位的编码来表示任意的32位数是绝对不可能的 （12位数有2^12^种可能，而32位数有 2^32^ 种）。 但是又要用12位的编码来表示32位数，怎么办？ 只有在表示数的数量上做限制。 通过编码来实现用12位的编码来表示32位数。</p>
<h3 id="2-2-编码显示"><a href="#2-2-编码显示" class="headerlink" title="2.2 编码显示"></a>2.2 编码显示</h3><h4 id="合法立即数"><a href="#合法立即数" class="headerlink" title="合法立即数"></a>合法立即数</h4><p>ARM中采用了一种叫做modified immediate constants的方法，来扩展立即数的范围。这种方法是把12位分成两部分，8位用来表示一个常数（immed_8），4位用来表示一个循环右移的次数（rotate_imm）。</p>
<p>循环右移就是把一个二进制数的最右边的一位移到最左边，然后重复这个操作若干次。比如00010011循环右移一次就变成10001001，再循环右移一次就变成01000100。</p>
<p>通过这种方法，可以用8位常数循环右移偶数次（0到30次），来生成一些32位的数值。比如00000000000000000000000011111111（255）可以循环右移16次，得到11111111000000000000000000000000（4278190080）。</p>
<p>这样就可以用12位来编码一些32位的立即数了。但是并不是所有的32位数都可以用这种方法表示，只有符合一定规律的才可以。比如必须是8个连续的1或0，然后循环移动偶数次。</p>
<p>所以在ARM中，有些立即数是合法的，有些是非法的。合法的立即数就是能用modified immediate constants方法表示的，非法的就是不能用这种方法表示的。判断一个立即数是否合法，可以先看它是否在0到255之间，如果是，就直接用8位表示，不需要移动。如果不是，就看它是否能由一个8位常数循环右移偶数次得到，并且移动次数最小。如果能，就用8位常数和移动次数表示。如果不能，就说明它是非法的立即数。</p>
<h4 id="非法立即数"><a href="#非法立即数" class="headerlink" title="非法立即数"></a>非法立即数</h4><p>为了处理非法立即数，有以下几种常用的方法：</p>
<ul>
<li>使用LDR伪指令，把非法立即数放在代码段或数据段中，然后用LDR指令从内存中加载到寄存器中。比如LDR R1, =0x12345678。</li>
<li>使用多条指令，把非法立即数分成几个合法的立即数，然后用移位和逻辑运算组合起来。比如MOV R1, #0x12000000; ORR R1, R1, #0x3456; LSL R1, R1, #8; ORR R1, R1, #0x78。</li>
<li>使用协处理器指令MCR或MRC，把非法立即数写入或读出协处理器的寄存器中。比如MCR P15, 0, R1, C2, C0, 0; LDR R1, =0x12345678; MCR P15, 0, R1, C2, C0, 0。</li>
</ul>
<br>
<br>

<hr>
<h2 id="三、-ARM条件指令"><a href="#三、-ARM条件指令" class="headerlink" title="三、 ARM条件指令"></a>三、 ARM条件指令</h2><h3 id="3-1-条件执行指令码"><a href="#3-1-条件执行指令码" class="headerlink" title="3.1 条件执行指令码"></a>3.1 条件执行指令码</h3><h4 id="什么是条件执行指令码？"><a href="#什么是条件执行指令码？" class="headerlink" title="什么是条件执行指令码？"></a>什么是条件执行指令码？</h4><p>条件执行指令码是指在ARM指令中附加的一个两位或三位的后缀，用来表示该指令是否根据某些条件来执行。条件执行指令码可以用来实现条件判断语句，避免不必要的跳转，提高代码的效率和可读性。</p>
<h4 id="条件执行指令码有哪些？"><a href="#条件执行指令码有哪些？" class="headerlink" title="条件执行指令码有哪些？"></a>条件执行指令码有哪些？</h4><p>条件执行指令码有以下几种：</p>
<table>
<thead>
<tr>
<th align="center">后缀</th>
<th align="center">标志寄存器</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">EQ</td>
<td align="center">Z == 1</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">NE</td>
<td align="center">Z == 0</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">CS/HS</td>
<td align="center">C == 1</td>
<td align="center">无符号大于或等于</td>
</tr>
<tr>
<td align="center">CC/LO</td>
<td align="center">C == 0</td>
<td align="center">无符号小于</td>
</tr>
<tr>
<td align="center">MI</td>
<td align="center">N == 1</td>
<td align="center">负数</td>
</tr>
<tr>
<td align="center">PL</td>
<td align="center">N == 0</td>
<td align="center">正数或零</td>
</tr>
<tr>
<td align="center">VS</td>
<td align="center">V == 1</td>
<td align="center">溢出</td>
</tr>
<tr>
<td align="center">VC</td>
<td align="center">V == 0</td>
<td align="center">无溢出</td>
</tr>
<tr>
<td align="center">HI</td>
<td align="center">C == 1 &amp;&amp; Z == 0</td>
<td align="center">无符号大于</td>
</tr>
<tr>
<td align="center">LS</td>
<td align="center">C == 0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">GE</td>
<td align="center">N == V</td>
<td align="center">有符号大于或等于</td>
</tr>
<tr>
<td align="center">LT</td>
<td align="center">N != V</td>
<td align="center">有符号小于</td>
</tr>
<tr>
<td align="center">GT</td>
<td align="center">Z == 0 &amp;&amp; N == V</td>
<td align="center">有符号大于</td>
</tr>
<tr>
<td align="center">LE</td>
<td align="center">Z == 1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">AL</td>
<td align="center">任何情况</td>
<td align="center">始终</td>
</tr>
</tbody></table>
<h4 id="如何使用条件执行指令码？"><a href="#如何使用条件执行指令码？" class="headerlink" title="如何使用条件执行指令码？"></a>如何使用条件执行指令码？</h4><p>条件执行指令码可以附加在任何ARM指令的操作码后面，表示该指令只有在满足相应的条件时才执行，否则不执行。例如，以下代码表示如果R0和R1相等，则将R2和R3相加，并将结果保存在R4中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMP R0, R1</span><br><span class="line">ADDEQ R4, R2, R3</span><br></pre></td></tr></table></figure>
<p>如果不使用条件执行指令码，上面的代码可以用以下方式实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMP R0, R1</span><br><span class="line">BNE skip</span><br><span class="line">ADD R4, R2, R3</span><br><span class="line">skip:</span><br></pre></td></tr></table></figure>
<p>可以看出，使用条件执行指令码可以减少一条跳转指令，简化代码的结构。</p>
]]></content>
      <categories>
        <category>ARM</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2020/05/05/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><font color="green">简介</font></h1><p>我们关注的主要对象是重新排列数组元素的算法，其中每个元素都有一个主键，排序算法的目的就是将所有的元素的主键按照某种方式排列（通常是按照大小或是字母顺序） </p>
<a id="more"></a> 
<p>常见的十大算法：<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588689912090&di=3d31e8a2f7ab8a74d03f295e5a2c6f25&imgtype=0&src=http://img.mp.itc.cn/upload/20160925/6689ac6a8e954126aefebaf492994cfc_th.jpeg" alt="排序算法"></p>
<blockquote>
<p>稳定：指如果有相同的数，排序后本来在前面的还是在前面<br>out-place：指用了额外的空间</p>
</blockquote>
<hr>
<br>

<p>下面我们在介绍排序算法时将从这几个方向入手：</p>
<ul>
<li>算法思路</li>
<li>算法图解</li>
<li>基本代码实现</li>
<li>易踩坑点</li>
<li>优化思路</li>
</ul>
<p><strong>如未特别说明，下面的变量都是从0开始的</strong></p>
<hr>
<br>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><font color="green">冒泡排序</font></h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>从头开始遍历数据，当前者的主键(值)大于后者时，两者交换位置，直到最后一位</li>
<li>此时数据的最大值一定排在了最后一位，排好的最大值便固定，无需再排</li>
<li>重复1的操作，直到最后两个数排序完成</li>
</ol>
<p>总结：外部循环<code>数据个数-1</code>次，内部循环<code>数组长度-n-1</code>次，每次内部循环比较当前位和后一位的值的大小，判断是否交换</p>
<h2 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3438712239,3527372442&fm=26&gp=0.jpg" alt="冒泡排序"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp; <span class="comment">//帮助交换</span></span><br><span class="line">            <span class="keyword">boolean</span> falg = <span class="keyword">false</span>; <span class="comment">//检查是否已经排好</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                falg = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123; <span class="comment">//每次排序后的最大位可以忽略</span></span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        falg =<span class="keyword">true</span>;</span><br><span class="line">                        temp=arr[j+<span class="number">1</span>];</span><br><span class="line">                        arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                        arr[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!falg) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点"><a href="#易踩坑点" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>一共循环 <code>数据个数-1</code> 次 ，因为最后一次确定第二个值的同时也把最小值确定了</li>
<li>每次遍历后的最大值要忽略，所以每次内部循环时循环次数要-1次</li>
<li>因为比较是和后面的数比较，所以当后面的数到最大值即当前数到倒数第二个时就说明内部循环完，否则数组越界</li>
</ol>
<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>如果有次内循环中没有发生交换，说明已经有序</p>
<hr>
<br>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><font color="green">选择排序</font></h1><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>先把第一个数记成最小值，遍历整个数组，记录遍历时遇见的最小值</li>
<li>遍历完一次后将最小值和第一个数交换位置，下一次遍历从第二个数开始</li>
<li>重复上述操作，直到最后两个数遍历完成</li>
</ol>
<h2 id="算法图解-1"><a href="#算法图解-1" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="http://www.west.cn/cms/images/2019-01-10/q5dlczui1fw.gif" alt="选择排序"></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min;<span class="comment">//记录最小数</span></span><br><span class="line">        <span class="keyword">int</span> temp; <span class="comment">//帮助交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length;i++)&#123;</span><br><span class="line">            min = i; <span class="comment">//将最小值初始化为遍历的第一个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;arr[min])&#123; <span class="comment">//*当某数小于当前最小数(别写成i)时，将最小数的索引改成该数的索引</span></span><br><span class="line">                    min =j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行交换</span></span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-1"><a href="#易踩坑点-1" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>开始时我们是把第一个数当成最小值的，所以是从第二个数开始遍历的</li>
<li>i值的含义有两个，一个是遍历次数，一个是当前遍历最小时应所处的位置</li>
</ol>
<hr>
<br>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><font color="green">插入排序</font></h1><h2 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>遍历数组，将当前数组插入左边已排好数据中</li>
<li>插入方法：先记录当前值，遍历左边，将当前数左边的数向右移动，直到遇见比当前数小的数，此时空白部分便是要插入的地方</li>
</ol>
<h2 id="算法图解-2"><a href="#算法图解-2" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;    </span><br><span class="line">        <span class="comment">//插入法</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            temp=arr[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j];j--)&#123; <span class="comment">//别忘了j要大于0</span></span><br><span class="line">                arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-2"><a href="#易踩坑点-2" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>i是从第二个数开始的</li>
<li>为了插入而进行的遍历一定别忘了j要大于0，(因为每次都是j和j+1比较)如果当前值正好是最小值，则数组会越界</li>
<li>这里j的含义是当前值最后插入的位置的左边</li>
</ol>
<hr>
<br>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><font color="green">希尔排序</font></h1><h2 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>先将数据分成间隔为h的许多小组，先让小组进行排序(插入排序法)</li>
<li>在把间隔缩短（小组变少，每个组中数变多）再进行插入排序</li>
<li>重复上述步骤，直到最后间隔为1时排序(即整个数据排序)</li>
</ol>
<blockquote>
<p>注：h也称为增量序列，对于最优增量序列目前还没有结论，主要的增量序列有Shell 增量序列，Hibbard 增量序列，Knuth 增量序列</p>
</blockquote>
<h2 id="算法图解-3"><a href="#算法图解-3" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" alt="希尔排序"></p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = arr.length; <span class="comment">//总数</span></span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">1</span>;<span class="comment">//增量序列</span></span><br><span class="line">        <span class="keyword">while</span>(h&lt;N/<span class="number">3</span>) h= h*<span class="number">3</span>+<span class="number">1</span>; <span class="comment">//Knuth 增量序列计算得来的h</span></span><br><span class="line">        <span class="comment">//插入法</span></span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;N;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i]; <span class="comment">//因为arr[i]的值可能会变，保存插入值</span></span><br><span class="line">                <span class="keyword">for</span>(;j-h&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j-h];j=j-h)&#123;</span><br><span class="line">                    arr[j] = arr[j-h];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            h=h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-3"><a href="#易踩坑点-3" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>和插入排序一样，i是从h而不是0开始的(h代表的是第一个小组的第二个数)</li>
<li>这里j的含义是当前数再小组中该插入的位置(和插入排序j的含义不同)，所以不是要 j&gt;=0而是要 j-h&gt;=0 (因为每次都是j和j-h比较)</li>
<li>这里是从h开始遍历到结束，效果是先让每个小组的第二个数和前面比较后再让每个小组的第三个数和前面比较，如此循环</li>
</ol>
<h2 id="优化思路-1"><a href="#优化思路-1" class="headerlink" title="优化思路"></a>优化思路</h2><p>增量序列的不同会影响排序算法效率</p>
<hr>
<br>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><font color="green">归并排序</font></h1><h2 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>将数组分成两部分</li>
<li>左部分和右部分分别排序，直到左部分或右部分只有一个数时返回</li>
<li>将两部分合并起来</li>
</ol>
<p>合并方法：</p>
<ul>
<li>传入需要合并的部分的开头，中间和结尾数，将该部分数组放入辅助数组对应位置中</li>
<li>左部分开头和右部分开头创建指针分别遍历：</li>
<li>当左边遍历完时，将右边的数传入原数组</li>
<li>当右边遍历完时，将左边的数传入原数组</li>
<li>当左边小于右边时，将左边的数传入原数组</li>
<li>当右边小于左边时，将右边的数传入原数组</li>
</ul>
<h2 id="算法图解-4"><a href="#算法图解-4" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=4070550482,2402998767&fm=26&gp=0.jpg" alt="归并算法"></p>
<p>合并步骤：</p>
<p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1120323612,2379483011&fm=15&gp=0.jpg" alt="归并算法2"></p>
<h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux; <span class="comment">//归并时所用的辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并两个有序子数据：先将要归并的数据保存到辅助数组中，用两个指针指向辅助数组的前面和中间+1分成两数组</span></span><br><span class="line">    <span class="comment">//两数组依次比较，将较小的数放进原数组对应位置，然后较小数所在的数组指针上移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并子数组，先将数据存入辅助数组中，用两指针二分辅助数组并遍历</span></span><br><span class="line">    <span class="comment">//mid为左边数组的最右边，即最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//辅助指针</span></span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将要归并的数据保存到辅助数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;=hi;k++)&#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;=hi;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;mid) a[k] = aux[j++];<span class="comment">//左边数组遍历完时，直接加右边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;hi) a[k] = aux[i++];<span class="comment">//右边数组遍历完时，直接加左边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aux[i]&gt;aux[j]) a[k] = aux [j++]; <span class="comment">//当右边的比左边的小时，加右边</span></span><br><span class="line">            <span class="keyword">else</span> a[k] = aux [i++]; <span class="comment">//当左边的比右边的小时，加左边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自顶向下的归并排序,将数组不断地二分直到直到只有一个数，再向上合并返回</span></span><br><span class="line">    <span class="comment">//将数组分成左右两部分，每个部分进行排序，排完后再合并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        mergeSort1(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo ,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span>; <span class="comment">//如果最前面和最后面一样说明已经分成最小单位</span></span><br><span class="line">        <span class="keyword">int</span> mid = (hi-lo)/<span class="number">2</span>+lo;</span><br><span class="line">        mergeSort1(a,lo,mid);</span><br><span class="line">        mergeSort1(a,mid+<span class="number">1</span>,hi);</span><br><span class="line">        <span class="keyword">if</span>(a[mid+<span class="number">1</span>]&gt;=a[mid]) <span class="keyword">return</span>; <span class="comment">//优化，如果排好序的右边最小值已经大于左边最大值，说明已经有序</span></span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-4"><a href="#易踩坑点-4" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>合并时传入的 mid (中间值)含义是左部分的最后一个数，算 mid 时记得要加 lo，写右边排序时记得传入的是 mid+1</li>
<li>合并中，将数据存入辅助数组是记得要&lt;=最后一位数而不是&lt;</li>
<li>判断是否左部分或右部分只含有一个数(传入的最左边的索引<code>lo</code> &gt;= 最右边的索引<code>hi</code>)</li>
</ol>
<h2 id="优化思路-2"><a href="#优化思路-2" class="headerlink" title="优化思路"></a>优化思路</h2><p>左右两边排好了之后，如果这时左部分的最大值&lt;=右部分的最小值的，说明已经有序，不用再合并</p>
<h3 id="自下向顶的归并"><a href="#自下向顶的归并" class="headerlink" title="自下向顶的归并"></a>自下向顶的归并</h3><p>除了上面的自顶向下的归并方法，还存在自下向顶的归并的方法：</p>
<ul>
<li><p>每个子数组长度为1开始，2个一组归并，再4个一组归并，直到整个归并</p>
<p>图解：<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E8%87%AA%E4%B8%8B%E5%90%91%E9%A1%B6.jpg" alt="自顶向下"></p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i*=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//因为归并是两个归并，所以每次指针k要移动2个子数组长度</span></span><br><span class="line">            <span class="comment">//可以把一个子数组的i个 数看成一个整体，k的循环就要小于a.length - i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.length - i; k=k+i*<span class="number">2</span>)&#123;</span><br><span class="line">                merge(a,k,k+i-<span class="number">1</span>,Math.min(k+i*<span class="number">2</span>-<span class="number">1</span>,a.length-<span class="number">1</span>)); <span class="comment">//有可能最后一组数不够，要判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>易踩坑点：</p>
<ol>
<li>因为k的作用是指向两个子数组合并的开头，如果最后的个数连一个子数组都没达到的话，那在合并时传入的中间值k+i-1就会发生数组出界问题，所以 k&lt;a.length-i</li>
<li>如果最后只剩一个不全数组，则放到下一轮，如果最后剩一个好的左部分和一个不全的右部分，两者可以合并，但要注意此时传入的最右边的值就不是 k+i*2-1 而是 a.length-1</li>
</ol>
<hr>
<br>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><font color="green">快速排序</font></h1><h2 id="算法思路-5"><a href="#算法思路-5" class="headerlink" title="算法思路"></a>算法思路</h2><p>和归并排序有异曲同工之妙，都采用分治法，但不同点是归并是先分别排序后归并，快速是分开时先排序再分别排序</p>
<ol>
<li>确定一位中间值(一般取第一个数),遍历数组，小于等于中间值的放左边，大于等于中间值的放右边</li>
<li>对中间值左边的数组排序</li>
<li>对中间值右边的数组排序</li>
</ol>
<p>上面 1 的具体步骤：</p>
<ol>
<li>将左边第一个数设为中间值</li>
<li>左边第二个和最右边分别设置两指针向中间遍历，直到左边的指针大于等于右边的指针</li>
<li>当左边遍历时遇见大于中间值的数停下，当右边遍历时遇见小于中间值的数停下</li>
<li>当两指针停下后交换两指针所值的数</li>
<li>遍历完后j所指的一定是小于等于中间值的，将j所在的数与第一个数交换，返回j(中间值所在位置)</li>
</ol>
<h2 id="算法图解-5"><a href="#算法图解-5" class="headerlink" title="算法图解"></a>算法图解</h2><p>整体思路：</p>
<p><img src="https://img-blog.csdnimg.cn/20200318212047646.png" alt="快速排序"></p>
<p>左右排序：</p>
<p>i和j最后一次交换时<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F2.jpg" alt="快速排序2"></p>
<p>i和j最后一次没有交换时<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F3.jpg" alt="快速排序3"></p>
<h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将数组有序二分并返回切分元素位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建两个辅助指针和切分元素</span></span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = hi+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i,j指针向中间遍历，直到遇见不符合的数或边界停下，两者都停下时将两数进行交换</span></span><br><span class="line">        <span class="comment">//当遍历完时i的位置可能会比j大(最后两个数发生交换时，i，j同时移动)可能相等(最后两个数没发生交换时，i，j其中一个移动)</span></span><br><span class="line">        <span class="comment">//遍历完时j的位置一定在小于等于切分元素的数的索引上，将这两个数交换，j所指的便是切分元素索引</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[++i] &lt; v) <span class="keyword">if</span>(i==hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (a[--j] &gt; v) ;<span class="comment">//这里本来还有个判断j是否跑到了最左边(当切分元素是该数据中最小值时)，但因为v在最左边，j一定会停在lo上</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        a[lo] = a[j];</span><br><span class="line">        a[j] = v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        quick(a , <span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span>;  <span class="comment">//可以在某个情况后改成插入排序</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        quick(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        quick(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="易踩坑点-5"><a href="#易踩坑点-5" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>数组切分时创建并初始化 i 与 j 是让 i ，j 等于第一个数和最后一个数的后一位，并且先加减再操作。如果是让 i ，j 等于第二个数和最后一个数并且先操作在加减时会很麻烦，不仅要在内循环中写i++，j–，在arr[i]和arr[j]交换后也要写i++，j– <strong>最好是先移动指针再操作</strong></li>
<li>返回中间值后，中间值是不再参与排序的</li>
<li>小心i和j出界的问题，当i到最右边或j到左边时，也要停止指针移动(j比较特殊，因为j到最左边时一定是等于v的，不可能越界)</li>
</ol>
<h2 id="优化思路-3"><a href="#优化思路-3" class="headerlink" title="优化思路"></a>优化思路</h2><p>防止特殊情况，可以先把数据打乱再排</p>
<h3 id="三切分法："><a href="#三切分法：" class="headerlink" title="三切分法："></a>三切分法：</h3><p>思路：</p>
<ul>
<li>对于有大量的重复数而言，可以使用三分切法，将数据分成大于v，等于，小于iv三部分，v代表中间值<ul>
<li>三个辅助指针i,lt,gt，i来遍历数组，直到大于gt(等于gt时还要再判断一次)</li>
<li>如果i遇见小的数，和lt交换并两者++，如果遇见大的数，和gt交换，gt–，i不动(因为无法保证gt所在的值，lt一定为v)</li>
<li>最后lt，gt都在中间段的最左边和最右边</li>
</ul>
</li>
</ul>
<p>图示：<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B8%89%E5%90%91%E5%88%87%E5%88%86.jpg" alt="快速排序三向切分"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">quick3way</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        quick(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick3way</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi&lt;=lo) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lt = lo;</span><br><span class="line">        <span class="keyword">int</span> gt = hi;</span><br><span class="line">        <span class="keyword">int</span> i  = lo+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v  = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=gt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;v) exchange(a,i++,lt++); <span class="comment">//lt一定为v，交换后i为v，可以移动</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;v) exchange(a,i,gt--); <span class="comment">//无法确定gt处的值，交换后不能动i</span></span><br><span class="line">            <span class="keyword">else</span> i++; <span class="comment">//i处等于v</span></span><br><span class="line">            &#125;</span><br><span class="line">        quick3way(a,lo,lt-<span class="number">1</span>);</span><br><span class="line">        quick3way(a,gt+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[x];</span><br><span class="line">        a[x] = a[y];</span><br><span class="line">        a[y] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>易踩坑点：</p>
<ol>
<li>因为lt是一定等于v的并且在等于v数组的最左边，所以和i所在值交换后两者可以一起++，但由于不知道gt所在的值，所以和i所在值交换后只能让gt–，i不动</li>
<li>记得当i=gt时还要再判断一次</li>
</ol>
<hr>
<br>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><font color="green">计数排序</font></h1><h2 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h2><ol>
<li>找到数组中最大的值</li>
<li>创建一个长度为最大值+1的数组，遍历原数组把数放在值相同的辅助数组下(如遍历到5，则让辅助数组temp[5]++)</li>
<li>遍历辅助数组，将不等于0的索引依次返回给原数组</li>
</ol>
<h2 id="算法图解-6"><a href="#算法图解-6" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="计数排序"></p>
<h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">counting</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = findMax(a);</span><br><span class="line">        counting(a,max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">counting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//用作a的指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:a)&#123;</span><br><span class="line">            temp[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                a[k++] = i;</span><br><span class="line">                temp[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;max) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="易踩坑点-6"><a href="#易踩坑点-6" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>数组计数是从0开始的，记得创建数组时长度为 max+1 这样数组的最后一位才是max</li>
<li>当取出一个数后，该数上的计数(即 temp[ i ] )要-1</li>
<li>注意当前给的代码中因为是用的<code>temp[i]--</code>所以不稳定，可以改成一个从0开始小于temp[i]的循环</li>
</ol>
<hr>
<br>

<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><font color="green">桶排序</font></h1><h2 id="算法思路-6"><a href="#算法思路-6" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>找到数组最大值</li>
<li>根据最大值创建n个桶，每个桶中存放一定范围的数</li>
<li>将每个桶中的数据排序</li>
<li>遍历桶，返回桶中的数</li>
</ol>
<p><strong>因为这个算法本身比较麻烦且用得不多，就不再演示了</strong></p>
<hr>
<br>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><font color="green">基数排序</font></h1><h2 id="算法思路-7"><a href="#算法思路-7" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>找到数据中 位数最高的数（即最大数有多少位）</li>
<li>创建一个二维数组，第一维 0~9 代表某位上可能出现的数，第二维用来存某位相同的数（如12，42都放在arr[2][n]中）</li>
<li>从个位数开始，遍历数组，将个位上相同的数存入相同一维的二维数组中（这里需要一个辅助一维数组来记录二维数组的一维上有多少存储的数）</li>
<li>遍历二维数组，依次返回给原数组</li>
<li>再从十位开始，重复上述操作，如果没十位则补0.循环最高位数次</li>
</ol>
<blockquote>
<p>二维数组可以这样理解：一共有0<del>9的桶，某位上值和桶的索引一样时放进桶中，从下到上放入桶中。一维数组也是0</del>9，每个位置的值就代表桶中有多少存入的值以及下一个该存入该桶的数的位置</p>
</blockquote>
<h2 id="算法图解-7"><a href="#算法图解-7" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="基数排序"></p>
<h2 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> high = findHigh(a);</span><br><span class="line">        radix(a,high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][a.length]; <span class="comment">//放数据的桶，一共要有10个桶(0~9),桶中最多存a中所有的数</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>; <span class="comment">//用于计算某位上的数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一共循环的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=high;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] bucketContent = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//记录每个桶有多少数已经下一个数应该存放在桶的哪里</span></span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>; <span class="comment">//用于将桶中数据返回给数组时对数组的指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算某位上的数进行分组,放入桶里</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : a) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (value / m) % <span class="number">10</span>; <span class="comment">//如果该数没有更高位，temp就为0</span></span><br><span class="line">                bucket[temp][bucketContent[temp]] = value;<span class="comment">//bucketContent[temp]可以表示该存入该桶的数的位置</span></span><br><span class="line">                bucketContent[temp]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将桶中数据返回数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;bucket.length;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bucketContent[k]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bucketContent[k];j++)&#123;</span><br><span class="line">                        a[n++] = bucket[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m=m*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findHigh</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;max)&#123;</span><br><span class="line">                max = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String temp = Integer.toString(max);</span><br><span class="line">        <span class="keyword">return</span> temp.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-7"><a href="#易踩坑点-7" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>每循环完一次后辅助一维数组要清0，即要放入循环中</li>
<li>用m计算位时，没有该位的运算结果就为0</li>
<li>每次记得m*10</li>
</ol>
<hr>
<br>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><font color="green">堆排序</font></h1><p><del>还没学到二叉树呢，以后补</del></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法，排序算法，基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day30-网络编程连接</title>
    <url>/2023/04/11/day30-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="day29-网络编程简介"><a href="#day29-网络编程简介" class="headerlink" title="day29-网络编程简介"></a><font color="green">day29-网络编程简介</font></h1><a id="more"></a>
<h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1-1-网络协议模型："><a href="#1-1-网络协议模型：" class="headerlink" title="1.1 网络协议模型："></a>1.1 网络协议模型：</h3><p>​OSI七层协议模型：</p>
<blockquote>
<p>​应用层<br>​表示层<br>​会话层<br>​传输层<br>​网络层<br>​数据链路层<br>​物理层</p>
</blockquote>
<p>​TCP/IP四层协议模型：</p>
<blockquote>
<p>应用层：<br>​传输层：TCP、UDP<br>​网络层：IP<br>​物理与网络接口层    </p>
</blockquote>
<h3 id="1-2-ip，端口-套接字"><a href="#1-2-ip，端口-套接字" class="headerlink" title="1.2 ip，端口,套接字"></a>1.2 ip，端口,套接字</h3><p>IP：</p>
<blockquote>
<p>IP：在网络中唯一标识一台主机<br>​IPV4: 4字节  32bit<br>点分十进制：  “192.168.1.45”<br>二进制形式：11000000 10101000 00000001 00101101</p>
</blockquote>
<p>端口：</p>
<blockquote>
<p>PORT：端口号 unsigned short<br>1-1023：系统端口<br>1024-5000：一般应用程序接口<br>5001-65535：系统预留用户自定义接口</p>
</blockquote>
<p>​套接字：</p>
<blockquote>
<p>本质：是一种特殊的文件描述符<br>TCP通信流程：<br>服务器：<br>socket() –&gt; bind() –&gt; listen() –&gt; accept() –&gt; read()/write() –&gt; close()<br>客户端：<br>socket() –&gt; connect() –&gt; read()/write() –&gt; close()</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="二、网络编程相关接口函数"><a href="#二、网络编程相关接口函数" class="headerlink" title="二、网络编程相关接口函数"></a>二、网络编程相关接口函数</h2><h3 id="2-1创建套接字-–-socket"><a href="#2-1创建套接字-–-socket" class="headerlink" title="2.1创建套接字 – socket"></a>2.1创建套接字 – socket</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line"></span><br><span class="line">功能：socket函数用于创建一个套接字（socket）</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：成功返回套接字的文件描述符.失败，将返回-1，并设置errno变量表示错误类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    domain：指定套接字的协议族（protocol family），常见的协议族包括AF_INET（IPv4协议）、AF_INET6（IPv6协议）和AF_UNIX（本地协议）等。</span><br><span class="line">    type：指定套接字的类型（socket type），常见的套接字类型包括SOCK_STREAM（面向连接的流套接字）和SOCK_DGRAM（无连接的数据报套接字）等。</span><br><span class="line">    protocol：指定套接字所使用的协议（protocol），常见的协议包括IPPROTO_TCP（TCP协议）、IPPROTO_UDP（UDP协议）和IPPROTO_SCTP（SCTP协议）等。默认选项填0。</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="2-2绑定本机IP地址和端口号"><a href="#2-2绑定本机IP地址和端口号" class="headerlink" title="2.2绑定本机IP地址和端口号"></a>2.2绑定本机IP地址和端口号</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line"></span><br><span class="line">功能：将一个套接字（socket）绑定到一个本地地址（IP地址和端口号）</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt;         </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;netinet/ip.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">sockfd：通过socket创建得到的套接字</span><br><span class="line">addr：服务器地址结构的首地址，结构体是sockaddr_in</span><br><span class="line">addrlen：地址结构的大小  </span><br><span class="line">返回值：</span><br><span class="line">成功返回0，失败返回-1</span><br><span class="line">       	</span><br><span class="line">       	   	</span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">sa_family_t    sin_family; /* 一般使用AF_INET（IPv4协议族）或AF_INET6（IPv6协议族） */</span><br><span class="line">in_port_t      sin_port;   /* 表示端口号，以网络字节序表示 */</span><br><span class="line">struct in_addr sin_addr;   /* internet address */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct in_addr &#123;</span><br><span class="line">uint32_t       s_addr;     /* IPv4地址，网络字节序 */</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line">相关函数：</span><br><span class="line">inet_addr(&quot;192.168.1.23&quot;);  //将点分十进制IP转换为整数形式（字节序）</span><br><span class="line">char *inet_ntoa(struct in_addr address); //将整数形式的地址转换为点分十进制</span><br><span class="line">    		</span><br><span class="line">sin_addr.s_addr = htons(INADDR_ANY); //任意本地IP地址</span><br><span class="line">       </span><br><span class="line">sockaddr_in.sin_port = htons(6666); //用于将16位的主机字节序（little-endian）的整数转换为网络字节序（big-endian）的整数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-3设置监听套接字-–-listen"><a href="#2-3设置监听套接字-–-listen" class="headerlink" title="2.3设置监听套接字 – listen"></a>2.3设置监听套接字 – listen</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">用于将一个套接字转换为被动套接字，用于服务器端的网络编程。被动套接字可以接收来自客户端的连接请求。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">成功，将返回0。</span><br><span class="line">失败，将返回-1，并设置errno变量表示错误类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：需要转换为被动套接字的套接字的文件描述符。</span><br><span class="line">    backlog：表示请求连接队列的最大长度，也就是可以同时接收的连接请求数量的上限。该参数的取值一般为5到128之间。</span><br></pre></td></tr></table></figure>



<h3 id="2-4等待客户端连接-–-accept"><a href="#2-4等待客户端连接-–-accept" class="headerlink" title="2.4等待客户端连接 – accept"></a>2.4等待客户端连接 – accept</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">accept函数用于从监听套接字中接收来自客户端的连接请求，创建一个新的套接字，并将其绑定到客户端的地址。该新的套接字可以用于与客户端进行通信。</span><br><span class="line"></span><br><span class="line">头文件：    </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">如果accept函数调用成功，将返回一个非负整数，表示新创建的套接字的文件描述符。该文件描述符可以用于后续的套接字操作（如send、recv等）。</span><br><span class="line">如果accept函数调用失败，将返回-1，并设置errno变量表示错误类型。  </span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：需要接受连接请求的监听套接字的文件描述符（file descriptor）。</span><br><span class="line"></span><br><span class="line">    addr：指向客户端地址的指针，是一个sockaddr结构体类型指针。在accept函数返回时，客户端的地址信息将被填充到该结构体中。记得要强转。</span><br><span class="line">    int connfd = accept(sockfd, (struct sockaddr *)&amp;caddr, &amp;c_len);</span><br><span class="line"></span><br><span class="line">    addrlen：指向addr结构体的大小的指针。在accept函数返回时，该指针将被设置为客户端地址结构体的大小。sizeof(caddr);</span><br><span class="line"></span><br><span class="line">accept(sockfd, NULL, NULL);//意思是接受监听套接字上的连接请求，但不获取客户端的地址信息。</span><br></pre></td></tr></table></figure>
<h3 id="2-5向服务器发起连接-–-connect"><a href="#2-5向服务器发起连接-–-connect" class="headerlink" title="2.5向服务器发起连接 – connect"></a>2.5向服务器发起连接 – connect</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line"></span><br><span class="line">功能：将套接字连接到远程主机的地址。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">如果connect函数调用成功，将返回0。</span><br><span class="line">如果connect函数调用失败，将返回-1，并设置errno变量表示错误类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：需要连接到远程主机的套接字的文件描述符。</span><br><span class="line">    addr：指向远程主机地址的指针，是一个sockaddr结构体类型指针。该结构体包含了远程主机的IP地址和端口号等信息。</span><br><span class="line">    addrlen：指定addr结构体的大小。</span><br></pre></td></tr></table></figure>

<h3 id="2-6发送接收数据-–-send、recv"><a href="#2-6发送接收数据-–-send、recv" class="headerlink" title="2.6发送接收数据 – send、recv"></a>2.6发送接收数据 – send、recv</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">功能：用于向已连接的套接字发送/接收数据。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">成功将返回实际发送/接收的字节数。</span><br><span class="line">失败将返回-1，并设置errno变量表示错误类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：需要发送/接收数据的套接字的文件描述符。</span><br><span class="line">    buf：指向待发送/接收数据的缓冲区的指针。</span><br><span class="line">    len：待发送/接收数据的字节数。</span><br><span class="line">    flags：用于控制数据发送/接收的方式的标志位，一般设置为0即可。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.在发送数据时，可以通过设置flags参数的值来控制数据发送的方式，例如设置为MSG_DONTWAIT将数据设置为非阻塞模式。一般情况下，flags的取值应该为0。</span><br><span class="line">2. 在发送数据时，应该确保buf指向的缓冲区中的数据已经准备好。如果缓冲区中的数据还没有完全准备好，可以使用select或poll等函数进行等待，以避免因缓冲区未就绪而导致的发送失败。</span><br></pre></td></tr></table></figure>

<p><strong><font color="red">在进行TCP协议传输的时候，要注意数据流传输的特点，recv和send不一定是一一对应的（一般情况下是一一对应），也就是说并不是send一次，就一定recv一次就接收完，有可能send一次，recv多次才接收完，也可能send多次，一次recv就接收完了。这和网络束调有关。</font></strong></p>
<p>示例代码：</p>
<p>客户端向服务端发送图片：</p>
<ul>
<li><p>服务端：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、绑定本机IP地址和端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET; <span class="comment">//ipv4</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">6666</span>); <span class="comment">//把主机字节序转换为网络字节序再赋值</span></span><br><span class="line">    <span class="comment">//saddr.sin_addr.s_addr = inet_addr(&quot;192.168.12.15&quot;);//将点分十进制转换为整形再赋值</span></span><br><span class="line">    saddr.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);  <span class="comment">//计算数据结构的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bind success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、设置监听套接字</span></span><br><span class="line">    ret = listen(sockfd, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;caddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(caddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c_len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wait for a new client...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(sockfd, (struct sockaddr *)&amp;caddr, &amp;c_len);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;link success! ip -- %s port -- %d\n&quot;</span>, inet_ntoa(caddr.sin_addr), ntohs(caddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.jpg&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open 1.jpg&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>( (ret = read(connfd, buf, <span class="number">64</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(fd, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(connfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket success!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、向服务器发起连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.12.15&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = connect(sockfd, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;link success!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.jpg&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open 1.jpg&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((ret = read(fd, buf, <span class="number">64</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(sockfd, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

</li>
</ul>
<br>
<br>

<hr>
<h2 id="三、服务器模型"><a href="#三、服务器模型" class="headerlink" title="三、服务器模型"></a>三、服务器模型</h2><h3 id="3-1-循环服务器"><a href="#3-1-循环服务器" class="headerlink" title="3.1 循环服务器"></a>3.1 循环服务器</h3><blockquote>
<ol>
<li>服务器端从连接请求队列中提取请求，建立连接并返回新的已经连接套接字；</li>
<li>服务器端通过已经连接的套接字循环接受数据，处理并发送给客户端直到客户端关闭；</li>
<li>服务器关闭已连接套接字，返回步骤（1）处理下一个客户端；<br>-———————————————————————–</li>
<li>服务器端采用循环嵌套来实现：外层循环依次提取客户端的请求队列并建立TCP连接，内层循环接受处理连接客户端的所有数据，直到客户端关闭；</li>
<li>如果当前客户端没有处理结束，其他客户端必须一直等待；</li>
</ol>
</blockquote>
<h3 id="3-2-并发服务器"><a href="#3-2-并发服务器" class="headerlink" title="3.2 并发服务器"></a>3.2 并发服务器</h3><blockquote>
<ol>
<li>服务器端父进程从连接请求队列中提取请求，建立连接并返回新的已创建套接字；</li>
<li>服务器端父进程创建子进程为客户端服务，客户端关闭连接时，子进程结束；</li>
<li>服务器端父进程关闭已连接套接字，返回步骤（1）；<br>-———————————————————————</li>
<li>服务器端父进程一旦接收到客户端的连接请求，便建立好连接并创建新的子进程。这意味着每个客广端在服务器端有一个专门的子进程为其服务。</li>
<li>服务器端的多个子进程同时运行 （宏观上），处理多个容户端。</li>
<li>服务器端的父进程不具体处理每个客户端的数据请求。</li>
</ol>
</blockquote>
<h4 id="3-2-1多进程并发服务器"><a href="#3-2-1多进程并发服务器" class="headerlink" title="3.2.1多进程并发服务器"></a>3.2.1多进程并发服务器</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">socket(...)</span><br><span class="line">bind(...)</span><br><span class="line">listen(...)</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    accept(...)</span><br><span class="line">    if(fork(...)==0)</span><br><span class="line">    &#123;</span><br><span class="line">        process(...);</span><br><span class="line">        close(...);</span><br><span class="line">        exit(...);</span><br><span class="line">    &#125;</span><br><span class="line">    close(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_handler</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、绑定本机IP地址和端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET; <span class="comment">//ipv4</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">6666</span>); <span class="comment">//把主机字节序转换为网络字节序再赋值</span></span><br><span class="line">    <span class="comment">//saddr.sin_addr.s_addr = inet_addr(&quot;192.168.12.15&quot;);//将点分十进制转换为整形再赋值</span></span><br><span class="line">    saddr.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);  <span class="comment">//计算数据结构的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bind success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、设置监听套接字</span></span><br><span class="line">    ret = listen(sockfd, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;caddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(caddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c_len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    signal(<span class="number">17</span>, wait_handler);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait for a new client...\n&quot;</span>);</span><br><span class="line">        connfd = accept(sockfd, (struct sockaddr *)&amp;caddr, &amp;c_len);</span><br><span class="line">        <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;link success! ip -- %s port -- %d\n&quot;</span>, inet_ntoa(caddr.sin_addr), ntohs(caddr.sin_port));</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//close(sockfd);</span></span><br><span class="line">            <span class="comment">//5、接收数据</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">                ret = read(connfd, buf, <span class="number">64</span>);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client leave!\n&quot;</span>);</span><br><span class="line">                    close(connfd);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv %dbytes: %s\n&quot;</span>, ret, buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//close(connfd);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2多线程并发服务器"><a href="#3-2-2多线程并发服务器" class="headerlink" title="3.2.2多线程并发服务器"></a>3.2.2多线程并发服务器</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">socket(...)</span><br><span class="line">bind(...)</span><br><span class="line">listen(...)</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    accept(...)</span><br><span class="line">    if(pthread_create(...)== 0)</span><br><span class="line">    &#123;</span><br><span class="line">        process(...);</span><br><span class="line">        close(...);</span><br><span class="line">        exit(...);</span><br><span class="line">    &#125;</span><br><span class="line">    close(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">c_info</span>;</span></span><br><span class="line">&#125;C;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    C c1;</span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、绑定本机IP地址和端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET; <span class="comment">//ipv4</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">6666</span>); <span class="comment">//把主机字节序转换为网络字节序再赋值</span></span><br><span class="line">    <span class="comment">//saddr.sin_addr.s_addr = inet_addr(&quot;192.168.12.15&quot;);//将点分十进制转换为整形再赋值</span></span><br><span class="line">    saddr.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);  <span class="comment">//计算数据结构的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bind success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、设置监听套接字</span></span><br><span class="line">    ret = listen(sockfd, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;caddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(caddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c_len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait for a new client...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> connfd = accept(sockfd, (struct sockaddr *)&amp;caddr, &amp;c_len);</span><br><span class="line">        <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c1.c_fd = connfd;</span><br><span class="line">        c1.c_info = caddr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;link success! ip -- %s port -- %d\n&quot;</span>, inet_ntoa(caddr.sin_addr), ntohs(caddr.sin_port));</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;thread, <span class="literal">NULL</span>, func, &amp;c1) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pthread_detach(thread);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//int connfd = *(int *)arg;</span></span><br><span class="line">    C c2 = *(C *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、接收数据</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">        ret = read(c2.c_fd, buf, <span class="number">64</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client leave!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv %dbytes: %s  ip -- %s\n&quot;</span>, ret, buf, inet_ntoa(c2.c_info.sin_addr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(c2.c_fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="四、udp通信"><a href="#四、udp通信" class="headerlink" title="四、udp通信"></a>四、udp通信</h2><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>UDP（User Datagram Protocol，用户数据报协议）是一种无连接的、不可靠的网络传输协议。与TCP协议不同，UDP不会建立连接、不会保证数据传输的可靠性和完整性，也不会进行数据重传和流量控制等操作。UDP仅仅提供了最基本的数据传输服务，而且传输速度快，传输效率高，因此常用于实时性要求较高的网络通信，比如音视频通信、在线游戏等。</p>
<blockquote>
<p>UDP通信的基本流程如下：</p>
<ol>
<li><p>服务器和客户端都需要创建UDP套接字，并指定通信协议和端口号。</p>
</li>
<li><p>客户端向服务器发送数据包，数据包中包含了目标地址和端口号、数据等信息。在UDP协议中，发送数据包不需要建立连接，因此可以直接发送。</p>
</li>
<li><p>服务器接收到客户端发送的数据包后，解析数据包中的目标地址和端口号，并根据这些信息将响应数据包发送回客户端。</p>
</li>
<li><p>客户端接收到服务器发送的响应数据包后，解析数据包中的数据并进行相应的处理。</p>
</li>
</ol>
</blockquote>
<h3 id="4-2-相关函数"><a href="#4-2-相关函数" class="headerlink" title="4.2 相关函数"></a>4.2 相关函数</h3><ul>
<li><p>sendto</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">sendto函数用于通过指定的socket向目标地址发送数据，支持发送UDP数据报和raw IP数据包。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">sendto函数返回发送的字节数，如果返回值为-1则表示发送失败，可通过errno变量获取错误码。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：表示需要发送数据的socket文件描述符；</span><br><span class="line">    buf：表示待发送的数据缓冲区；</span><br><span class="line">    len：表示待发送的数据长度；</span><br><span class="line">    flags：表示发送数据的可选项，例如是否启用MSG_DONTWAIT标志来设置非阻塞模式；</span><br><span class="line">    dest_addr：表示目标地址信息；</span><br><span class="line">    addrlen：表示目标地址信息的长度，通常为sizeof(struct sockaddr)。</span><br></pre></td></tr></table></figure>
</li>
<li><p>recvfrom</p>
</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">recvfrom函数用于从指定的socket接收数据，并将发送者的地址信息存储在src_addr中，支持接收UDP数据报和raw IP数据包。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">recvfrom函数返回接收到的字节数，如果返回值为-1则表示接收失败，可通过errno变量获取错误码。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：表示需要接收数据的socket文件描述符；</span><br><span class="line">    buf：表示接收数据的缓冲区；</span><br><span class="line">    len：表示缓冲区的长度；</span><br><span class="line">    flags：表示接收数据的可选项，例如是否启用MSG_DONTWAIT标志来设置非阻塞模式；</span><br><span class="line">    src_addr：表示发送者的地址信息；</span><br><span class="line">    addrlen：表示发送者地址信息的长度，应当初始化为sizeof(struct sockaddr)。</span><br><span class="line"></span><br><span class="line">注意：src_addr和addrlen应当事先分配好内存，并在调用recvfrom函数时作为参数传入</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<p>服务器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、绑定本机IP地址和端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、接收数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;caddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(caddr));</span><br><span class="line">    <span class="keyword">int</span> c_len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">        ret = recvfrom(sockfd, buf, <span class="number">64</span>, <span class="number">0</span>, (struct sockaddr *)&amp;caddr, &amp;c_len);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recvform&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip:%s -- recv %dbytes: %s&quot;</span>,inet_ntoa(caddr.sin_addr), ret, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码有两个注意点：</p>
<ol>
<li>当需要取地址时(&amp;),不能直接写<del>&amp;sizeof(caddr)</del>,要先用一个变量接收sizeof(caddr),再对变量进行取地址。</li>
<li>注意换行符，因为终端输出是行缓冲，所以没有换行符的话很容易导致无法打印。</li>
</ol>
</blockquote>
<p>客服端：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、发送数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.12.15&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fgets(buf, <span class="number">64</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>设置非阻塞相关函数 – fcntl</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fcntl(int fd, int cmd, ... /* arg */ );</span><br><span class="line"></span><br><span class="line">功能</span><br><span class="line">fcntl函数是一个通用的文件控制函数，其功能非常广泛。该函数可以执行的命令包括：</span><br><span class="line"></span><br><span class="line">    1. F_DUPFD： 复制文件描述符</span><br><span class="line">当应用程序需要使用多个文件描述符来操作同一个文件时，可以使用F_DUPFD命令来复制文件描述符。该命令需要一个整数参数arg，表示要创建的新文件描述符的最小值。该函数将返回一个新的文件描述符，该文件描述符是不小于arg的最小整数。</span><br><span class="line">    2. F_GETFD： 获取文件描述符标志</span><br><span class="line">应用程序可以使用F_GETFD命令获取一个文件描述符的标志。该命令不需要arg参数，而是返回一个整数值，表示该文件描述符的标志。</span><br><span class="line">    3. F_SETFD： 设置文件描述符标志</span><br><span class="line">应用程序可以使用F_SETFD命令来设置一个文件描述符的标志。该命令需要一个整数参数arg，表示要设置的标志。该函数将返回0表示成功，-1表示失败。</span><br><span class="line">    4. F_GETFL： 获取文件状态标志</span><br><span class="line">应用程序可以使用F_GETFL命令获取一个文件的状态标志。该命令不需要arg参数，而是返回一个整数值，表示该文件的状态标志。</span><br><span class="line">    5. F_SETFL： 设置文件状态标志</span><br><span class="line">应用程序可以使用F_SETFL命令来设置一个文件的状态标志。该命令需要一个整数参数arg，表示要设置的状态标志。该函数将返回0表示成功，-1表示失败。</span><br><span class="line">    6. F_GETLK： 获取文件锁定信息</span><br><span class="line">应用程序可以使用F_GETLK命令获取一个文件的锁定信息。该命令需要一个指向flock结构体的指针arg。该结构体包含锁定类型、锁定起始位置和锁定长度等信息。如果文件未被锁定，则返回一个flock结构体，其中l_type字段被设置为F_UNLCK。如果文件已被锁定，则返回一个指定锁定信息的flock结构体。</span><br><span class="line">    7. F_SETLK： 设置文件锁定信息（非阻塞）</span><br><span class="line">应用程序可以使用F_SETLK命令来设置一个文件的锁定信息，该命令是非阻塞的，如果文件已经被其他进程锁定，该命令将立即返回EACCES错误。该命令需要一个指向flock结构体的指针arg，该结构体包含要设置的锁定类型、锁定起始位置和锁定定长等信息</span><br><span class="line">    8. F_SETLKW： 设置文件锁定信息（阻塞）</span><br><span class="line">应用程序可以使用F_SETLKW命令来设置一个文件的锁定信息，该命令是阻塞的，如果文件已经被其他进程锁定，则该命令将一直阻塞，直到获取锁为止。该命令需要一个指向flock结构体的指针arg，该结构体包含要设置的锁定类型、锁定起始位置和锁定定长等信息。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">参数：</span><br><span class="line">fd：文件描述符</span><br><span class="line">cmd：</span><br><span class="line">    F_GETFL:获取文件属性状态</span><br><span class="line">    F_SETFL:设置文件属性状态</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    根据参数cmd的不同返回不同的值</span><br><span class="line">    cmd -- F_GETFL:返回获取的文件属性状态</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">1、获取文件描述符对应属性状态</span><br><span class="line">    int flag = fcntl(fd, F_GETFL, 0);</span><br><span class="line">2、将flag添加设置非阻塞方式</span><br><span class="line">    flag = flag | O_NONBLOCK;</span><br><span class="line">3、将新的状态属性设置到文件描述符中</span><br><span class="line">    fcntl(fd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flock结构体定义如下：</span><br><span class="line">struct flock &#123;</span><br><span class="line">    short l_type;   /* 锁定类型，可以是F_RDLCK或F_WRLCK或F_UNLCK */</span><br><span class="line">    short l_whence; /* 锁定起始位置，可以是SEEK_SET、SEEK_CUR或SEEK_END */</span><br><span class="line">    off_t l_start;  /* 锁定起始位置相对于l_whence的偏移量 */</span><br><span class="line">    off_t l_len;    /* 锁定定长，如果为0，则锁定到文件结束 */</span><br><span class="line">    pid_t l_pid;    /* 加锁进程的PID，仅用于F_GETLK命令 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<br>
<br>

<hr>
<h2 id="五、IO多路复用"><a href="#五、IO多路复用" class="headerlink" title="五、IO多路复用"></a>五、IO多路复用</h2><h3 id="5-1-IP多路复用基本概念"><a href="#5-1-IP多路复用基本概念" class="headerlink" title="5.1 IP多路复用基本概念"></a>5.1 IP多路复用基本概念</h3><p>IO多路复用是一种高效的IO处理模式，它可以让一个线程或进程同时监控多个文件描述符（通常是socket）的状态，从而实现并发的IO操作。IO多路复用的作用是提高系统的资源利用率，减少不必要的阻塞和上下文切换，提高程序的性能和响应速度。</p>
<p>为什么需要IO多路复用呢？我们先来看看常见的IO模型有哪些：</p>
<ul>
<li>阻塞IO：当我们调用read或write函数时，如果没有数据可读或可写，那么程序就会被阻塞，直到数据到达或发送完成。这种模式下，每个文件描述符都需要一个线程或进程来处理，如果有大量的文件描述符，那么就会消耗大量的内存和CPU资源，而且大部分时间都在等待数据，效率很低。</li>
<li>非阻塞IO：当我们调用read或write函数时，如果没有数据可读或可写，那么程序就会立即返回一个错误码，表示操作不能进行。这种模式下，我们需要不断地轮询文件描述符的状态，来判断是否可以进行IO操作。这种模式虽然避免了阻塞，但是也浪费了大量的CPU资源在无效的轮询上，而且轮询的频率很难控制。</li>
<li>信号驱动IO：当我们调用sigaction函数时，可以让内核在文件描述符可读或可写时发送一个信号给我们，然后我们在信号处理函数中进行IO操作。这种模式下，我们不需要轮询文件描述符的状态，而是由内核主动通知我们。但是信号驱动IO也有一些缺点，比如信号处理函数的执行环境受到限制，不能进行一些可能阻塞的操作；信号可能丢失或合并；信号处理函数可能被中断等。</li>
<li>异步IO：当我们调用aio_read或aio_write函数时，可以让内核在文件描述符可读或可写时自动完成数据的拷贝，并在完成后通知我们。这种模式下，我们不需要关心文件描述符的状态，也不需要自己进行数据的拷贝，完全交给内核来处理。但是异步IO在Linux上并不完善，很多系统调用并不支持异步IO。</li>
</ul>
<p>从上面可以看出，每种IO模型都有各自的优缺点，没有一种是完美的。那么有没有一种模式可以兼顾效率和简洁呢？答案就是IO多路复用。</p>
<p>IO多路复用的基本概念是，通过一个函数（如select，poll，epoll等）来监控多个文件描述符的状态，当有一个或多个文件描述符可读或可写时，函数返回，告诉我们哪些文件描述符可以进行IO操作。这样，我们就可以在一个线程或进程中处理多个文件描述符的IO事件，而不需要为每个文件描述符创建一个线程或进程，也不需要轮询或等待信号。</p>
<p>IO多路复用的作用是，提高系统的资源利用率，减少不必要的阻塞和上下文切换，提高程序的性能和响应速度。IO多路复用适合于以下场景：</p>
<ul>
<li>文件描述符数量较多，但每个文件描述符的IO操作并不频繁，大部分时间都处于空闲状态。</li>
<li>文件描述符的IO操作都是非阻塞的，不会导致线程或进程挂起。</li>
<li>文件描述符的类型不同，可能是socket，也可能是文件，管道等。</li>
<li>需要同时处理多种类型的事件，比如读写事件，错误事件，超时事件等。</li>
</ul>
<p>IO多路复用常用在网络编程中，比如实现高并发的服务器程序。通过IO多路复用，服务器可以在一个线程或进程中同时监听和处理多个客户端的连接请求和数据交互。这样可以节省系统资源，提高服务器的吞吐量和并发能力。</p>
<blockquote>
<p>流程：</p>
<ol>
<li>创建表</li>
<li>向表中添加需要监测的文件描述符</li>
<li>循环监测表<br>(1)遍历表，判断是否有文件描述符有响应<br>(2)如果有响应，需要判断是哪一个文件描述符响应，然后实现对应IO操作</li>
</ol>
</blockquote>
<h3 id="5-2-IO多路复用的相关函数"><a href="#5-2-IO多路复用的相关函数" class="headerlink" title="5.2 IO多路复用的相关函数"></a>5.2 IO多路复用的相关函数</h3><h4 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int select (int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict exceptfds, struct timeval *restrict timeout);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">select函数可以指定一个超时时间，在这个时间内，如果指定的文件描述符集合中有任何一个文件描述符发生了可读，可写或异常事件，select函数就会返回，并告知哪些文件描述符已经就绪。如果在超时时间内没有任何事件发生，select函数就会返回0。如果发生了错误，select函数就会返回-1，并设置errno变量。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">select函数返回的是就绪的文件描述符的个数，如果超时则返回0，如果出错则返回-1。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">    nfds：指定要监视的文件描述符的范围，一般是最大的文件描述符加1。</span><br><span class="line"></span><br><span class="line">    readfds：指向一个fd_set类型的指针，表示要监视的可读文件描述符集合。如果为NULL，则表示不关心任何文件的可读事件。</span><br><span class="line"></span><br><span class="line">    writefds：指向一个fd_set类型的指针，表示要监视的可写文件描述符集合。如果为NULL，则表示不关心任何文件的可写事件。</span><br><span class="line"></span><br><span class="line">    exceptfds：指向一个fd_set类型的指针，表示要监视的异常文件描述符集合。如果为NULL，则表示不关心任何文件的异常事件。</span><br><span class="line"></span><br><span class="line">    timeout：指向一个timeval结构体的指针，表示select函数的超时时间。如果为NULL，则表示无限等待。如果为0，则表示不等待，立即返回。如果为非零值，则表示等待指定的秒数和微秒数。</span><br><span class="line"></span><br><span class="line">fd_set类型和timeval结构体：</span><br><span class="line"></span><br><span class="line">fd_set类型是一个位图类型，每一位对应一个文件描述符。可以使用以下几个宏来操作fd_set类型：</span><br><span class="line"></span><br><span class="line">    void FD_ZERO(fd_set *set)：清空一个fd_set类型变量的所有位。</span><br><span class="line"></span><br><span class="line">    void FD_SET(int fd, fd_set *set)：将一个文件描述符fd加入到一个fd_set类型变量中。</span><br><span class="line"></span><br><span class="line">    void FD_CLR(int fd, fd_set *set)：将一个文件描述符fd从一个fd_set类型变量中移除。</span><br><span class="line"></span><br><span class="line">    int FD_ISSET(int fd, fd_set *set)：检查一个文件描述符fd是否在一个fd_set类型变量中。判断指定的文件描述符是否有响应，结果为真--有响应</span><br><span class="line"></span><br><span class="line">timeval结构体定义如下：</span><br><span class="line"></span><br><span class="line">struct timeval &#123;</span><br><span class="line">  long tv_sec;  /* 秒 */</span><br><span class="line">  long tv_usec; /* 微秒 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>select机制流程：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1、定义监测表,清空表</span><br><span class="line">   	fd_set rfds;</span><br><span class="line">	FD_ZERO(&amp;rfds);</span><br><span class="line">2、向表中添加要监测的文件描述符0、3</span><br><span class="line">    FD_SET(0, &amp;rfds);</span><br><span class="line">	FD_SET(3, &amp;rfds);</span><br><span class="line">	int maxfd = 3+1;</span><br><span class="line">3、循环监测表</span><br><span class="line">    int i = 0;</span><br><span class="line">4、创建监测表的替代（检测表每次响应之后会变，所以每次都要更新）</span><br><span class="line">    fd_set rfds_tmp = rfds;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        rfds = rfds_tmp;</span><br><span class="line">        select(maxfd, &amp;rfds, NULL, NULL, NULL);</span><br><span class="line">        for(i = 0; i &lt; maxfd; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(FD_ISSET(i, &amp;rfds))</span><br><span class="line">            &#123;</span><br><span class="line">                if(i == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                   //实现对应IO操作 </span><br><span class="line">                &#125;</span><br><span class="line">                else if(i == 3)</span><br><span class="line">                &#123;</span><br><span class="line">                    //实现对应IO操作</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">poll函数用于监视一组文件描述符，以确定它们中是否有文件描述符准备好读取、写入或出现异常情况。该函数允许应用程序在一个地方等待多个事件，而不需要阻塞或使用轮询方式查询。在调用poll函数后，内核将扫描文件描述符集合，确定哪些文件描述符已经准备好读取、写入或出现异常情况，然后将事件报告给应用程序。移植性好。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">poll函数返回事件数量，即就绪的文件描述符数量。如果在超时时间内没有任何事件发生，poll函数将返回0。如果发生错误，则返回-1，并设置errno变量来指示错误类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    -fds参数是一个指向pollfd结构体数组的指针，poll函数是在内核中实现的，因此应用程序无法直接控制poll函数的执行方式。应用程序需要为每个要监视的文件描述符创建一个pollfd结构体，并将其放入一个pollfd数组中。，该结构体定义如下：</span><br><span class="line"></span><br><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd;        /* 文件描述符 */</span><br><span class="line">    short events;  /* 需要监视的事件，可以是POLLIN、POLLOUT、POLLERR等 */</span><br><span class="line">    short revents; /* 实际发生的事件，由内核填充 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">其中，fd字段表示需要监视的文件描述符，events字段表示需要监视的事件，可以是POLLIN（可读事件）、POLLOUT（可写事件）、POLLERR（错误事件）等，revents字段表示实际发生的事件，由内核填充。</span><br><span class="line"></span><br><span class="line">    -nfds参数是fds数组中的文件描述符数量。</span><br><span class="line">    -timeout参数指定等待时间，以毫秒为单位。如果timeout为-1，则表示永远等待，直到事件发生。如果timeout为0，则表示不等待，仅对fds数组中的文件描述符进行一次扫描。如果timeout大于0，则表示等待timeout毫秒后，如果还没有事件发生，则返回。</span><br></pre></td></tr></table></figure>
<p>poll流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建表：</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfds</span>[100];</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    pfds[i].fd = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加要监测的文件描述符</span></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">pfds[++pos].fd = <span class="number">0</span>;</span><br><span class="line">pfds[pos].events = POLLIN;</span><br><span class="line">pfds[++pos].fd = <span class="number">3</span>;</span><br><span class="line">pfds[pos].events = POLLIN;	</span><br><span class="line">		</span><br><span class="line"><span class="comment">//循环进行poll检测：</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ret = poll();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= pos; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pfds[i].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pfds[i].fd == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//对应IO操作                            </span></span><br><span class="line">            &#125;                        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码（poll实现并发服务器）<br><img src="/2023/04/11/day30-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%BF%9E%E6%8E%A5/poll.jpg" alt="poll"></p>
<h4 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h4><p>epoll函数是一种高效的I/O多路复用技术，Linux特有。用于监视多个文件描述符的可读可写状态。与select和poll函数相比，epoll函数的优势在于：</p>
<ul>
<li>支持较大规模的文件描述符集合，可以监视成千上万个文件描述符；</li>
<li>采用内核回调机制，避免了轮询和阻塞等方式的低效问题；</li>
<li>支持多种事件触发方式，包括边沿触发和水平触发等；</li>
<li>可以通过epoll_ctl函数动态地添加、删除和修改文件描述符。</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">-epoll_create函数用于创建一个新的epoll实例，并返回一个代表该实例的文件描述符。这个文件描述符用于控制和访问该epoll实例，可以使用epoll_ctl函数向该实例中添加或删除文件描述符。</span><br><span class="line">-epoll_ctl函数用于向epoll实例中添加、修改或删除文件描述符，并指定需要监视的事件类型。这个函数可以动态地添加、删除和修改文件描述符，以便动态地调整事件的监视方式。</span><br><span class="line">-epoll_wait函数用于等待文件描述符的I/O事件，一旦有数据可读或可写，就会触发相应的回调函数进行处理。该函数将一直阻塞，直到有文件描述符的I/O事件发生或等待超时。函数返回发生事件的文件描述符数量，并将事件信息保存在events参数指定的结构体数组中。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">epoll_create函数返回一个新的epoll实例的文件描述符。这个文件描述符就是用于控制和访问该epoll实例的句柄，也就是所谓的“用于控制监测表的句柄”。如果发生错误，则返回-1，并设置errno变量来指示错误类型。</span><br><span class="line">epoll_ctl和epoll_wait函数的返回值与select和poll函数类似，表示事件数量或执行结果。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">epoll_create的参数：</span><br><span class="line">    -size表示需要监视的文件描述符数量，该参数实际上是epoll实例的内部事件表大小，可以设置为任意值。</span><br><span class="line">int epoll_ctl的参数：</span><br><span class="line">    epfd：句柄</span><br><span class="line">    op：控制选项</span><br><span class="line">		EPOLL_CTL_ADD   添加</span><br><span class="line">        EPOLL_CTL_MOD   修改</span><br><span class="line">        EPOLL_CTL_DEL   删除</span><br><span class="line">    fd：要控制的文件描述符的值</span><br><span class="line">    event:监测表中某一个元素的地址，也就是要控制的文件描述符在epoll_event数组中的位置的地址</span><br><span class="line">epoll_wait的参数：</span><br><span class="line">    epfd：句柄</span><br><span class="line">    events：监测表的首地址</span><br><span class="line">    maxevents：监测文件描述符的个数</span><br><span class="line">    timeout：设置超时的时间</span><br></pre></td></tr></table></figure>

<p>epoll流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epfds</span>[100];</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    epfds[i].data.fd = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">epfds[++pos].data.fd = <span class="number">0</span>;</span><br><span class="line">epfds[pos].events = EPOLLIN;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, <span class="number">0</span>, &amp;epfds[pos]);</span><br><span class="line">epfds[++pos].data.fd = <span class="number">3</span>;</span><br><span class="line">epfds[pos].events = EPOLLIN;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, <span class="number">3</span>, &amp;epfds[pos]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = epoll_wait(epfd, epfds, pos + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ret; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (epfds[i].events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (epfds[i].data.fd == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 对应IO操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="六、设置套接字属性"><a href="#六、设置套接字属性" class="headerlink" title="六、设置套接字属性"></a>六、设置套接字属性</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);</span><br><span class="line">int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">功能：获取/设置套接字选项的值。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt;         </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">如果函数调用成功，返回值为0；如果函数调用失败，返回值为-1。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：套接字</span><br><span class="line">    level：</span><br><span class="line">        SOL_SOCKET: 通用套接字层</span><br><span class="line">      	IPPROTO_IP： IP层</span><br><span class="line">      	IPPROTO_TCP： TCP层</span><br><span class="line">    optname:</span><br><span class="line">      			套接字属性设置对应的功能选项，一般填对应宏</span><br><span class="line">    optval：</span><br><span class="line">      			获取套接字属性对应的值的地址</span><br><span class="line">    optlen：</span><br><span class="line">      			optval值的长度/地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置属性表：level<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;SOL_SOCKET</p>
<table>
<thead>
<tr>
<th align="center">参数optname</th>
<th align="center">宏的作用</th>
<th align="center">对应参数optval的类型</th>
<th align="center">可能会填的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SO_BROADCAST</td>
<td align="center">允许发送广播数据</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_DEBUG</td>
<td align="center">循序调试</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_DONTROUTE</td>
<td align="center">不查找路由</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_ERROR</td>
<td align="center">获的套接字错误</td>
<td align="center">int</td>
<td align="center">一个整型变量，用于存储套接字上最后一次操作的错误状态。</td>
</tr>
<tr>
<td align="center">SO_KEEPALIVE</td>
<td align="center">保持连接</td>
<td align="center">int</td>
<td align="center">一个整型变量，用于存储保持连接选项的值（0表示不支持，1表示支持）。</td>
</tr>
<tr>
<td align="center">SO_LINGER</td>
<td align="center">延迟关闭连接</td>
<td align="center">struct linger</td>
<td align="center">一个 struct linger 类型的结构体变量，用于存储延迟关闭选项的值。</td>
</tr>
<tr>
<td align="center">SO_OOBINLINE</td>
<td align="center">带外数据放入正常数据流</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_RCVBUF</td>
<td align="center">接收缓冲区大小</td>
<td align="center">int</td>
<td align="center">一个整型变量，用于存储接收缓冲区的大小。</td>
</tr>
<tr>
<td align="center">SO_SNDBUF</td>
<td align="center">发送缓冲区大小</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_RCVLOWAT</td>
<td align="center">接收缓冲区下限</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_SNDWAIT</td>
<td align="center">发送缓冲区下限</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_RCVTIMEO</td>
<td align="center">接收超时</td>
<td align="center">struct timeval</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_SNDTIMEO</td>
<td align="center">发送超时</td>
<td align="center">struct timeval</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_REUSEADDR</td>
<td align="center">允许重用本机地址和端口</td>
<td align="center">int</td>
<td align="center">一个整型变量，用于存储地址重用选项的值（0表示不支持，1表示支持）。</td>
</tr>
<tr>
<td align="center">SO_TYPE</td>
<td align="center">获得套接字类型</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_BSDCOMPAT</td>
<td align="center">与BSD系统兼容</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">组播广播对应optname ：</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>                        IPPROTO_IP
------------------------------------------------------
IP_ADD_MEMBERSHIP    加入到组播组中               struct ip_mreq 
IP_MULTICAST_IF      允许开启组播报文的接口       struct ip_mreq    </code></pre>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//允许重用本机地址和端口</span></span><br><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> opt_len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">if</span>(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, opt_len) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时检测</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">mt</span> = &#123;</span><span class="number">5</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(mt);</span><br><span class="line">    ret = setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;mt, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取缓冲区大小</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">int</span> val_len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">if</span>(getsockopt(connfd, SOL_SOCKET, SO_RCVBUF, &amp;size, &amp;val_len) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;getsockopt&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv_buf = %d\n&quot;</span>, size);</span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="七、域套接字"><a href="#七、域套接字" class="headerlink" title="七、域套接字"></a>七、域套接字</h2><p>​和tcp基本相同:</p>
<p>​        服务器：</p>
<p>​            socket () –&gt;  bind() –&gt; listen() –&gt; accept() –&gt; read()/write() –&gt; close()</p>
<p>​        客户端：</p>
<p>​            socket () –&gt;  connect() –&gt; read()/write() –&gt; close()</p>
<p>有两处改动：</p>
<ol>
<li>socket<blockquote>
<p>tcp:socket(AF_UNIX, SOCK_STREAM, 0);<br>udp:socket(AF_UNIX, SOCK_DGRAM, 0);</p>
</blockquote>
</li>
<li>AF_UNIX对应的地址结构:struct sockaddr_un<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">   <span class="keyword">sa_family_t</span> sun_family;        <span class="comment">//AF_UNIX</span></span><br><span class="line">   <span class="keyword">char</span>        sun_path[<span class="number">108</span>];     <span class="comment">//套接字文件的名称(包含路径)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建套接字</span></span><br><span class="line"><span class="keyword">int</span> sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket success!\n&quot;</span>);</span><br><span class="line"><span class="comment">//2、绑定本机IP地址和端口号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">saddr</span>;</span></span><br><span class="line">saddr.sun_family = AF_UNIX;</span><br><span class="line"><span class="built_in">strcpy</span>(saddr.sun_path, <span class="string">&quot;mysocket&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);  <span class="comment">//计算数据结构的长度</span></span><br><span class="line"><span class="keyword">int</span> ret = bind(sockfd, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind success!\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="八、广播和组播"><a href="#八、广播和组播" class="headerlink" title="八、广播和组播"></a>八、广播和组播</h2><h3 id="8-1-IP分类"><a href="#8-1-IP分类" class="headerlink" title="8.1 IP分类"></a>8.1 IP分类</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">A类：美国高校、国内大型公司</span><br><span class="line">   取值范围： 0.0.0.0 ~ 127.255.255.255</span><br><span class="line">   以0开头</span><br><span class="line"></span><br><span class="line">   网络号：第一个字节为网络号</span><br><span class="line">   主机号：后三个字节为主机号   </span><br><span class="line">    广播IP：主机号全为1</span><br><span class="line">B类:私有IP</span><br><span class="line">	以10开头</span><br><span class="line">    取值范围：128.0.0.0 ~ 191.255.255.255</span><br><span class="line">    网络号：前两个字节</span><br><span class="line">    主机号：后两个字节</span><br><span class="line"></span><br><span class="line">C类：私有IP</span><br><span class="line">    以110开头</span><br><span class="line">    取值范围：192.0.0.0 ~ 223.255.255.255</span><br><span class="line">    网络号：前三个字节</span><br><span class="line">    主机号：后一个字节</span><br><span class="line">    </span><br><span class="line">D类：组播</span><br><span class="line">	以1110开头</span><br><span class="line">    	224.0.0.0 ~ 239.255.255.255</span><br><span class="line">    </span><br><span class="line">    	239.10.0.1 -- 组播IP</span><br></pre></td></tr></table></figure>
<h3 id="8-2-广播"><a href="#8-2-广播" class="headerlink" title="8.2 广播"></a>8.2 广播</h3><p>​发送方 向当前IP的广播地址发送数据，广播地址将接收的数据转发给当前网络号下的所有主机    </p>
<p>服务器流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建套接字</span></span><br><span class="line">socket();</span><br><span class="line"><span class="comment">//2、绑定IP地址和端口号 （绑定广播IP）</span></span><br><span class="line">bind();<span class="comment">//192.168.12.255</span></span><br><span class="line"><span class="comment">//3、收发数据</span></span><br><span class="line">sendto()/recvfrom();</span><br><span class="line"><span class="comment">//4、关闭套接字</span></span><br><span class="line">close();</span><br></pre></td></tr></table></figure>

<p>客户端流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建套接字</span></span><br><span class="line">socket();</span><br><span class="line"><span class="comment">//2、设置套接字属性，使其允许发送广播数据</span></span><br><span class="line">setsockopt();   <span class="comment">//SO_BROADCAST</span></span><br><span class="line"><span class="comment">//3、发送数据 -- 向广播地址发送</span></span><br><span class="line">sendto();</span><br><span class="line"><span class="comment">//4、关闭套接字</span></span><br><span class="line">close();</span><br></pre></td></tr></table></figure>

<h3 id="8-3-组播"><a href="#8-3-组播" class="headerlink" title="8.3 组播"></a>8.3 组播</h3><p>​先将接收方的ip加入到指定的组播组中去，发送方向组播组中发送数据，组播ip负责将接收的内容转发给当前组播组中的所有ip</p>
<p>服务器流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建套接字</span></span><br><span class="line">socket();</span><br><span class="line"><span class="comment">//2、设置套接字属性，将当前IP加入到组播组中去</span></span><br><span class="line">setsockopt();  <span class="comment">//IP_ADD_MEMBERSHIP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、绑定IP地址和端口号 （绑定组播IP）</span></span><br><span class="line">bind();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、接收数据</span></span><br><span class="line">recvfrom();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭套接字</span></span><br><span class="line">close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span>  &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span>   <span class="comment">/* IP multicast address of group */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span>   <span class="comment">/* local IP address of interface */</span></span><br><span class="line">&#125;;</span><br><span class="line">用法：</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">my_group</span>;</span></span><br><span class="line">	my_group.imr_multiaddr.s_addr = inet_addr(<span class="string">&quot;239.10.0.1&quot;</span>); <span class="comment">//组播ip</span></span><br><span class="line">    my_group.imr_interface.s_addr = inet_addr(<span class="string">&quot;192.168.12.15&quot;</span>);  <span class="comment">//当地ip</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建套接字</span></span><br><span class="line">socket();</span><br><span class="line"><span class="comment">//2、设置套接字属性，允许发送组播数据</span></span><br><span class="line">setsockopt();  <span class="comment">//IP_MULTICAST_IF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、发送数据</span></span><br><span class="line">sendto();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭套接字</span></span><br><span class="line">close();</span><br></pre></td></tr></table></figure>

<p>组播示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将本机ip加入到组播组中去</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">my_group</span>;</span></span><br><span class="line">    my_group.imr_multiaddr.s_addr = inet_addr(<span class="string">&quot;239.10.0.1&quot;</span>);</span><br><span class="line">    my_group.imr_interface.s_addr = inet_addr(<span class="string">&quot;192.168.12.15&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(my_group);</span><br><span class="line">    setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;my_group, len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    <span class="comment">//saddr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;239.10.0.1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd,(struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;caddr, <span class="number">0</span> , <span class="keyword">sizeof</span>(caddr));</span><br><span class="line">    <span class="keyword">int</span> c_len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">        recvfrom(sockfd, buf, <span class="number">64</span>, <span class="number">0</span>, (struct sockaddr*)&amp;caddr, &amp;c_len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip -- %s:%s&quot;</span>, inet_ntoa(caddr.sin_addr), buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="九、sqlite3数据库"><a href="#九、sqlite3数据库" class="headerlink" title="九、sqlite3数据库"></a>九、sqlite3数据库</h2><p>下载sqlite3:</p>
<blockquote>
<p>sudo apt-get install sqlite3</p>
<p>sudo apt-get install libsqlite3-dev</p>
</blockquote>
<h3 id="9-1-sqlite3基础命令"><a href="#9-1-sqlite3基础命令" class="headerlink" title="9.1 sqlite3基础命令"></a>9.1 sqlite3基础命令</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">.help:帮助手册，查看所有命令</span><br><span class="line">.quit:退出</span><br><span class="line">.exit:退出</span><br><span class="line">.tables:查看表名</span><br><span class="line">.schema:查看表</span><br></pre></td></tr></table></figure>

<h3 id="9-2-sql语句"><a href="#9-2-sql语句" class="headerlink" title="9.2 sql语句"></a>9.2 sql语句</h3><p>(1)创建表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">create table &lt;table_name&gt; (info1 type1，info2 type2.....);</span><br></pre></td></tr></table></figure>

<p>(2)删除表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">drop table &lt;table_name&gt;;</span><br></pre></td></tr></table></figure>

<p>(3)插入表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">insert into &lt;table_name&gt; values(information1， information2...);</span><br></pre></td></tr></table></figure>

<p>(4)查询表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询所有数据</span></span><br><span class="line">select * from &lt;table_name&gt;;</span><br><span class="line"><span class="comment">//查询指定信息</span></span><br><span class="line">select * from &lt;table_name&gt; where info=information;</span><br><span class="line">select * from &lt;table_name&gt; where info=information <span class="keyword">and</span> info=information;</span><br></pre></td></tr></table></figure>

<p>(5)删除表中的指定信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> from &lt;table_name&gt; where info=information;</span><br></pre></td></tr></table></figure>

<p>(6)修改表中指定信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">update &lt;table_name&gt; <span class="built_in">set</span> info=new_information where info=old_information;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-sqlite3相关接口函数"><a href="#9-3-sqlite3相关接口函数" class="headerlink" title="9.3 sqlite3相关接口函数"></a>9.3 sqlite3相关接口函数</h3><p>使用了sqlite3相关函数后编译时要加库<code>-lsqlite3</code></p>
<p>(1)创建或者打开数据库文件 – sqlite3_open</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int   sqlite3_open(char  *path,   sqlite3 **db)；</span><br><span class="line"></span><br><span class="line">功能：打开数据库</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    	成功返回0，失败返回错误码</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    	path：数据库文件名(包含路径)</span><br><span class="line">    	db：控制数据库文件的句柄的地址</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">char *sqlite3_errmsg(sqlite3 *db) -- 打印错误信息</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    	错误信息</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    	db：句柄</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2)关闭数据库文件 – sqlite3_close()</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int   sqlite3_close(sqlite3 *db);</span><br><span class="line"></span><br><span class="line">功能：关闭数据库</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功返回0，失败返回错误码</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    db：句柄</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(3) 执行sql语句 – sqlite3_exec()</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">typedef  int (*sqlite3_callback)(void *, int, char **, char **);</span><br><span class="line"></span><br><span class="line">int   sqlite3_exec(sqlite3 *db, const  char  *sql,  sqlite3_callback callback, void *arg,  char **errmsg);</span><br><span class="line"></span><br><span class="line">功能：在c中执行数据库命令，并用callback回调函数接收返回值</span><br><span class="line">头文件：#include &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功返回0，失败返回错误码</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">	db：句柄</span><br><span class="line">    sql：sql语句的首地址(也就是存放sql指令的字符串的首地址)</span><br><span class="line">    callback:回调函数，主要处理sql返回的信息</span><br><span class="line">    arg：用于给回调函数传参数</span><br><span class="line">    errmsg：错误信息的首地址</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">/*******************************************************************************/</span><br><span class="line"></span><br><span class="line">typedef  int (*sqlite3_callback)(void *para, int f_num, char **f_value, char **f_name);</span><br><span class="line"></span><br><span class="line">功能：每找到一条记录自动执行一次回调函数，没找到就不会执行</span><br><span class="line">返回值：成功返回0，失败返回-1</span><br><span class="line">para：传递给回调函数的参数，也就是上面的arg</span><br><span class="line">f_num：记录中包含的字段数目</span><br><span class="line">f_value：包含每个字段值的指针数组</span><br><span class="line">f_name：包含每个字段名称的指针数组</span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>day28-进程线程</title>
    <url>/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="day28-进程线程"><a href="#day28-进程线程" class="headerlink" title="day28-进程线程"></a><font color="green">day28-进程线程</font></h1><p>下面当我问你LINUX下的c语言中的函数是，你要从函数原型，功能，头文件，返回值，参数这几个方面讲解，并给出示例代码和使用函数的注意事项，明白了吗</p>
<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h3><ul>
<li>程序：是一些二进制、数据的有序集合，没有被加载到内存。没有“生命”</li>
<li>进程：程序执行一次的过程。程序执行时资源分配的总称。Linux 是一个多道程序设计系统，因此系统中存在彼此相互独立的进程同时运行。</li>
<li>页表：<br>&emsp;&emsp;在 Linux 中，每个进程都有自己的页表，用于映射虚拟地址到物理地址。页表是由一系列页表项（PTE）组成的数据结构，每个页表项对应着虚拟地址空间中的一个页面（通常是4KB），并描述了该页面的物理地址、访问权限等信息。<br>&emsp;&emsp;Linux 中的页表采用了多级页表的结构，即每个页表项可以指向下一级的页表，最终指向物理页面。<br>&emsp;&emsp;Linux 中的页表是按需分配的，即当进程需要访问某个虚拟地址时，如果该地址对应的页表项不存在，则会触发缺页异常，内核会根据需要分配新的物理页面，并更新页表项，使得虚拟地址能够正确映射到物理地址。</li>
<li>线程：线程是进程中的执行单元，它与进程共享同一个地址空间，因此线程之间可以直接共享数据。线程相对于进程来说更加轻量级。多个线程可以共享一个进程的以下资源(可执行的指令,静态数据,进程中打开的文件描述符,信号处理函数,当前工作目录用户ID,用户组ID)<a id="more"></a>
<h3 id="2-守护进程"><a href="#2-守护进程" class="headerlink" title="2. 守护进程"></a>2. 守护进程</h3></li>
</ul>
<p>&emsp;&emsp;守护进程：在某些用户空间中，即使用户退出登录，仍然会有一些后台进程在运行，不会被用户或终端影响，这些进程被称为<code>守护进程</code>。<br>&emsp;&emsp;Linux 中有一种特殊的守护进程被称为<code>计划守护进程</code>，计划守护进程可以每分钟醒来一次检查是否有工作要做，做完会继续回到睡眠状态等待下一次唤醒。</p>
<h3 id="3-父进程与子进程"><a href="#3-父进程与子进程" class="headerlink" title="3. 父进程与子进程"></a>3. 父进程与子进程</h3><p>&emsp;&emsp;在 Linux 系统中，进程通过非常简单的方式来创建，<code>fork</code>系统调用会创建一个源进程的拷贝(副本)。调用<code>fork</code>函数的进程被称为<code>父进程</code>，使用 fork 函数创建出来的进程被称为 <code>子进程</code>。父进程和子进程都有自己的内存映像。<strong>如果在子进程创建出来后</strong>，父进程修改了一些变量等，那么子进程是看不到这些变化的，也就是<code>fork</code>后，父进程和子进程相互独立。</p>
<p>&emsp;&emsp;虽然父进程和子进程保持相互独立，但是它们却能够共享相同的文件，如果在 fork 之前，父进程已经打开了某个文件，那么 fork 后，父进程和子进程仍然共享这个打开的文件。对共享文件的修改会对父进程和子进程同时可见。</p>
<p>&emsp;&emsp;那么该如何区分父进程和子进程呢？子进程只是父进程的拷贝，所以它们几乎所有的情况都一样，包括内存映像、变量、寄存器等。区分的关键在于fork函数调用后的返回值，如果fork后返回一个非零值，这个非零值即是子进程的<code>进程标识符</code>(pid)，而会给子进程返回一个零值,<font color="blue">即在程序中,<code>pid==0</code>的代码为子进程的代码，而<code>pid &gt; 0</code>的代码为父进程的代码</font>。父进程在 fork 后会得到子进程的 PID，这个 PID 即能代表这个子进程的唯一标识符也就是 PID。如果子进程想要知道自己的 PID，可以调用<code>getpid</code>方法。父进程可以生成多个子进程，子进程也能生成自己的子进程。</p>
<h3 id="4-Linux进程间的通信"><a href="#4-Linux进程间的通信" class="headerlink" title="4. Linux进程间的通信"></a>4. Linux进程间的通信</h3><p>Linux进程间的通信（IPC）大致可以分为6种</p>
<ol>
<li>信号 signal</li>
<li>无名管道 pipe</li>
<li>共享内存 shared memory</li>
<li>先入先出队列（也叫有名管道） fifo</li>
<li>消息队列 message queue</li>
<li>套接字 socket</li>
<li>信号量 semaphore</li>
</ol>
<blockquote>
<p>有两个东西可以标识一个IPC结构：标识符(ID)和键(key)。</p>
<p>ID是IPC结构的内部名。内部即在进程内部使用，这样的标识方法是不能支持进程间通信的。</p>
<p>key就是IPC结构的外部名。当多个进程，针对同一个key调用get函数(msgget等)，这些进程得到的ID其实是标识了同一个IPC结构。多个进程间就可以通过这个IPC结构通信。</p>
</blockquote>
<br>

<h4 id="4-1-信号-signal"><a href="#4-1-信号-signal" class="headerlink" title="4.1 信号 signal"></a>4.1 信号 signal</h4><h5 id="4-1-1-信号的基本概念"><a href="#4-1-1-信号的基本概念" class="headerlink" title="4.1.1 信号的基本概念"></a>4.1.1 信号的基本概念</h5><p>&emsp;&emsp;信号是在软件层次对中断机制的一种模拟，是一种异步通信方式。信号可以直接进行用户空间进程和内核之间的交互，内核也能利用它来通知用户空间进程发生了哪些系统事件。</p>
<h5 id="4-1-2-信号的处理流程"><a href="#4-1-2-信号的处理流程" class="headerlink" title="4.1.2 信号的处理流程"></a>4.1.2 信号的处理流程</h5><p>&emsp;&emsp;操作系统给进程发送信号，本质上是给进程的task_struct（是 Linux 内核中的一个通过双向链表来组织的结构体，它代表了一个进程或线程）中写入数据，修改相应的task_struct字段(里面有进程 ID、进程状态、进程优先级、进程的父进程、进程的子进程等等)，然后进程在合适的时间(内核态发回用户态时)去处理所接受的信号。<br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt="信号处理"></p>
<p>例子说明：</p>
<blockquote>
<ol>
<li>假设用户启动一个交互式的前台进程，然后输入ctrl+c结束它，系统通过键盘产生一个硬件中断。</li>
<li>cpu暂停用户空间的代码，cpu从用户态切换至内核态处理中断</li>
<li>系统驱动程序将ctlr+c解释为一个SIGINT信号，并将其记在该进程的task_struct中的信号位上；</li>
<li>当某时刻进程从内核态返回用户态继续执行之前，检查task_struct中的信号域，SIGINT信号的默认处理动作为终止进程，所以直接终止进程而不再返回到它的用户空间代码。</li>
</ol>
</blockquote>
<h5 id="4-1-3-常用的信号-前面是它的编号"><a href="#4-1-3-常用的信号-前面是它的编号" class="headerlink" title="4.1.3 常用的信号(前面是它的编号)"></a>4.1.3 常用的信号(前面是它的编号)</h5><p>Linux 中可以通过<code>kill -l</code>查看信号表</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.  SIGHUP：   本信号在用户终端结束时发出，通常是在终端的控制进程结束时，通知同一会话期内的各个作业，这时他们与控制终端不在关联。比如，登录Linux时，系统会自动分配给登录用户一个控制终端，在这个终端运行的所有程序，包括前台和后台进程组，一般都属于同一个会话。当用户退出时，所有进程组都将收到该信号，这个信号的默认操作是终止进程。此外对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</span><br><span class="line">2.  SIGINT：   程序终止信号。当用户按下CRTL+C时通知前台进程组终止进程。</span><br><span class="line">3.  SIGQUIT：  Ctrl+<span class="tag">\<span class="name">控</span></span>制，进程收到该信号退出时会产生core文件，类似于程序错误信号。</span><br><span class="line">4.  SIGILL：   执行了非法指令。通常是因为可执行文件本身出现错误，或者数据段、堆栈溢出时也有可能产生这个信号。</span><br><span class="line">5.  SIGTRAP：  由断点指令或其他陷进指令产生，由调试器使用。</span><br><span class="line">6.  SIGABRT：  调用abort函数产生，将会使程序非正常结束。</span><br><span class="line">7.  SIGBUS：   非法地址。包括内存地址对齐出错。比如访问一个4个字长的整数，但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法地址的非法访问触发。</span><br><span class="line">8.  SIGFPE：   发生致命的算术运算错误。</span><br><span class="line">9.  SIGKILL：  用来立即结束程序的运行。不能被捕捉、阻塞或忽略，只能执行默认动作。</span><br><span class="line">10. SIGUSR1：  留给用户使用，用户可自定义。</span><br><span class="line">11. SIGSEGV：  访问未分配给用户的内存区。或操作没有权限的区域。</span><br><span class="line">12. SIGUSR2：  留给用户使用，用户可自定义。</span><br><span class="line">13. SIGPIPE：  管道破裂信号。当对一个读进程已经运行结束的管道执行写操作时产生。</span><br><span class="line">14. SIGALRM：  时钟定时信号。由alarm函数设定的时间终止时产生。</span><br><span class="line">15. SIGTERM：  程序结束信号。shell使用kill产生该信号，当结束不了该进程，尝试使用SIGKILL信号。</span><br><span class="line">16. SIGSTKFLT：堆栈错误。</span><br><span class="line">17. SIGCHLD：  子进程结束，父进程会收到。如果子进程结束时父进程不等待或不处理该信号，子进程会变成僵尸进程。</span><br><span class="line">18. SIGCONT：  让一个停止的进程继续执行。</span><br><span class="line">19. SIGSTOP：  停止进程执行。不能被捕捉、阻塞或忽略，只能执行默认动作。</span><br><span class="line">20. SIGTSTP：  停止终端交互运行，可以被忽略。按下Ctrl+z发出这个信号。</span><br><span class="line">21. SIGTTIN：  当后台进程需要从终端接收数据时，所有进程会收到该信号，暂停执行。</span><br><span class="line">22. SIGTTOU：  与SIGTTIN类似，在后台的进程向终端输出数据时产生。</span><br><span class="line">23. SIGURG：   套接字上出现紧急情况时产生。向当前正在运行的进程发出些信号，报告有紧急数据到达，如网络带外数据到达。</span><br><span class="line">24. SIGXCPU：  超过CPU时间资源限制时产生的信号。</span><br><span class="line">25. SIGXFSZ：  当进程企图扩大文件以至于超过文件大小资源限制时产生。</span><br><span class="line">26. SIGVTALRM：虚拟使用信号。计算的是进程占用CPU调用的时间。</span><br><span class="line">27. SIGPROF：  包括进程使用CPU的时间以及系统调用的时间。</span><br><span class="line">28. SIGWINCH： 窗口大小改变时。</span><br><span class="line">29. SIGIO：    文件描述符准备就绪，表示可以进行输入输出操作。</span><br><span class="line">30. SIGPWR：   电源失效信号，即关机。</span><br><span class="line">31. SIGSYS：   非法的系统调用。</span><br></pre></td></tr></table></figure>

<h5 id="4-1-4-信号的处理"><a href="#4-1-4-信号的处理" class="headerlink" title="4.1.4 信号的处理"></a>4.1.4 信号的处理</h5><p>信号的3种状态：</p>
<blockquote>
<p>未决：进程接收到信号，但是还没有处理它。这个信号会被添加到进程的信号掩码中，等待进程处理。<br>阻塞：进程可以选择阻塞某些信号，这样当这些信号发送时，进程不会接收到它们。阻塞信号可以通过 sigprocmask() 函数设置。<br>处理：当进程接收到一个信号时，它需要处理这个信号。处理信号的方式可以是执行一个信号处理函数，或者使用默认的信号处理方式。可以使用 signal() 函数或 sigaction() 函数来设置信号处理函数。</p>
</blockquote>
<p>信号的5种默认处理动作</p>
<blockquote>
<p>Term    终止进程<br>Ign    当前进程忽略此信号<br>Core    终止进程，并生成一个Core文件<br>Stop    暂停当前进程<br>Cont    继续执行当前被暂停的进程</p>
</blockquote>
<h5 id="4-1-5-信号集"><a href="#4-1-5-信号集" class="headerlink" title="4.1.5 信号集"></a>4.1.5 信号集</h5><p>信号集：顾名思义，就是信号的集合。在linux中，它的类型是<code>sigset_t</code>,大小是64bits。（Linux中一个只有64个信号）。在头文件<code>signal.h</code>提供了五个处理信号集的函数。</p>
<br>

<h4 id="4-2-无名管道-pipe"><a href="#4-2-无名管道-pipe" class="headerlink" title="4.2 无名管道 pipe"></a>4.2 无名管道 pipe</h4><h5 id="4-2-1-pipe的基本概念"><a href="#4-2-1-pipe的基本概念" class="headerlink" title="4.2.1 pipe的基本概念"></a>4.2.1 pipe的基本概念</h5><p>&emsp;&emsp;管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
<ol>
<li><p>其本质是一个伪文件(实为内核缓冲区)</p>
</li>
<li><p>由两个文件描述符引用，一个表示读端，一个表示写端。</p>
</li>
<li><p>规定数据从管道的写端流入管道，从读端流出。</p>
</li>
</ol>
<p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p>管道的局限性：<br>① 数据自己读不能自己写。<br>② 数据一旦被读走，便不在管道中存在，不可反复读取。<br>③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。<br>④ 只能在有公共祖先的进程间使用管道。<br>常见的通信方式有，单工通信、半双工通信、全双工通信。</p>
<h5 id="4-2-2-pipe的创建"><a href="#4-2-2-pipe的创建" class="headerlink" title="4.2.2 pipe的创建"></a>4.2.2 pipe的创建</h5><p>&emsp;&emsp;管道两端可分别用描述符fd[0] 以及fd[1]来描述。需要注意的是，管道两端的任务是固定的，一端只能用于读，由描述符fd[0]表示，称其为管道读端，另一端只能用于写，由描述符fd[1]来表示，称其为管道写端。如果试图从管道写端读数据，或者向管道读端写数据都将导致出错。</p>
<p>&emsp;&emsp;管道是一种文件，因此对文件操作的I/O函数都可以用于管道，如read，write等。</p>
<h5 id="4-2-3-pipe的读写"><a href="#4-2-3-pipe的读写" class="headerlink" title="4.2.3 pipe的读写"></a>4.2.3 pipe的读写</h5><p>&emsp;&emsp;如果某个进程要读取管道中的数据，那么该进程应当关闭fd[1]，向管道写数据的进程应当关闭fd[0]。因为管道只能用于具有亲缘关系的进程间的通信，在进行通信时，他们共享文件描述符。在使用前，应及时地关闭不需要的管道的另一端，以避免意外错误的发生。</p>
<p>&emsp;&emsp;进程在管道的读端读数据时，如果管道的写端不存在，则读进程认为已经读到了数据的末尾，读函数返回读出的字节数为0；管道的写端如果存在，且请求读取的字节数大于PIPE_BUF，则返回管道中现有的所有数据；如果请求的字节数不大于PIPE_BUF，则返回管道中现有的所有数据（此时，管道中数据量小于请求的数据量），或者返回请求的字节数（此时，管道中数据量大于等于请求的数据量）。</p>
<h5 id="4-2-4-pipe的实现细节"><a href="#4-2-4-pipe的实现细节" class="headerlink" title="4.2.4 pipe的实现细节"></a>4.2.4 pipe的实现细节</h5><p>在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。如下图<br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/pipe.jpg" alt="pipe"></p>
<h4 id="4-3-共享内存-shared-memory"><a href="#4-3-共享内存-shared-memory" class="headerlink" title="4.3 共享内存 shared memory"></a>4.3 共享内存 shared memory</h4><h5 id="4-3-1-共享内存概念"><a href="#4-3-1-共享内存概念" class="headerlink" title="4.3.1 共享内存概念"></a>4.3.1 共享内存概念</h5><p>&emsp;&emsp;实现进程间通信最简单也是最直接的方法就是共享内存——为参与通信的多个进程在内存中开辟一个共享区。由于进程可以直接对共享内存进行读写操作，因此这种通信方式效率特别高，但其弱点是，它没有互斥机制，需要信号量之类的手段来配合。</p>
<h5 id="4-3-2-共享内存方法"><a href="#4-3-2-共享内存方法" class="headerlink" title="4.3.2 共享内存方法"></a>4.3.2 共享内存方法</h5><blockquote>
<p>为了实现共享内存，就需要做两件事：</p>
<ol>
<li>在内存划出一块区域来作为共享区；</li>
<li>把这个区域映射到参与通信的各个进程空间。</li>
</ol>
</blockquote>
<p>&emsp;&emsp;在Linux中，共享内存有两种方式：System V IPC和POSIX IPC。</p>
<p>&emsp;&emsp;System V IPC：System V IPC是一种传统的IPC机制，它提供了三种IPC方式：消息队列、共享内存和信号量。其中，共享内存是一种最快的IPC方式，因为它直接将内存映射到进程的地址空间中，避免了数据的拷贝和内核态和用户态之间的切换。共享内存的使用需要调用一系列的函数，包括shmget()、shmat()、shmdt()和shmctl()等。</p>
<p>&emsp;&emsp;POSIX IPC：POSIX IPC是一种比System V IPC更加灵活和可移植的IPC机制，它提供了两种IPC方式：消息队列和共享内存。与System V IPC不同的是，POSIX IPC使用命名对象来标识IPC资源，这些对象存储在文件系统中，可以在进程间共享。POSIX共享内存的使用需要调用一系列的函数，包括shm_open()、shm_unlink()、mmap()和munmap()等。</p>
<h5 id="4-3-3-文件映射"><a href="#4-3-3-文件映射" class="headerlink" title="4.3.3 文件映射"></a>4.3.3 文件映射</h5><h6 id="4-3-3-1-mmap的基本概念"><a href="#4-3-3-1-mmap的基本概念" class="headerlink" title="4.3.3.1 mmap的基本概念"></a>4.3.3.1 mmap的基本概念</h6><p>&emsp;&emsp;通常在内存划出一个区域的方法是，在内存中打开一个文件，若通过系统调用<code>mmap()</code>把这个文件所占用的内存空间映射到参与通信的各个进程地址空间，则这些进程就都可以看到这个共享区域，进而实现进程间的通信。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面（脏页面是指已经被修改但还没有被写回到磁盘的页面）到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。<br>&emsp;&emsp;总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。而且这个映射的过程是动态的，即请求多少映射多少。所以mmap适用与大型文件的操作。<br>&emsp;&emsp;mmap()原型如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line"></span><br><span class="line">功能：将一个文件或者其它对象映射到进程的地址空间中，从而让进程可以像访问内存一样访问这些对象。</span><br><span class="line">返回值：返回映射区域的起始地址。如果调用失败，则返回MAP_FAILED宏。</span><br><span class="line">addr：指定映射的起始地址，通常设置为0，表示让系统自动选择一个合适的地址。</span><br><span class="line">length：指定映射区域的长度，单位是字节。</span><br><span class="line">prot：指定映射区域的保护方式，可以是以下值的按位或：</span><br><span class="line">    PROT_EXEC：可执行</span><br><span class="line">    PROT_READ：可读</span><br><span class="line">    PROT_WRITE：可写</span><br><span class="line">    PROT_NONE：不可访问</span><br><span class="line">flags：指定映射区域的标志，可以是以下值的按位或：</span><br><span class="line">    MAP_SHARED：共享映射</span><br><span class="line">    MAP_PRIVATE：私有映射</span><br><span class="line">    MAP_ANONYMOUS：匿名映射</span><br><span class="line">fd：指定要映射的文件描述符，如果是匿名映射，则设置为-1。</span><br><span class="line">offset：指定映射区域在文件中的偏移量，通常设置为0。。</span><br></pre></td></tr></table></figure>
<h6 id="4-3-3-2-mmap的文件映射过程"><a href="#4-3-3-2-mmap的文件映射过程" class="headerlink" title="4.3.3.2 mmap的文件映射过程"></a>4.3.3.2 mmap的文件映射过程</h6><p><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/mmap.jpg" alt="mmap"><br>mmap本身其实是一个很简单的操作，在进程页表中添加一个页表项，该页表项是物理内存的地址。调用mmap的时候，内核会在该进程的地址空间的映射区域查找一块满足需求的空间用于映射该文件，然后生成该虚拟地址的页表项，改页表项此时的有效位（标志是否已经在物理内存中）为0，页表项的内容是文件的磁盘地址，此时mmap的任务已经完成。第一次访问该块内存的时候，因为页表项的有效位还是0，就会发生缺页中断，然后CPU会使用该页表项的内容也就是磁盘的文件地址，讲该地址指向的内容加载到物理内存，并需改页表项的内容为该物理地址，有效位置为1。 </p>
<p>简而言之，就是在进程对应的虚存段添加一个段，也就是创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。在创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，引发缺页异常（缺页指的是当进程需要访问的页面不在物理内存中时，就会发生缺页中断，此时操作系统会将该页面从磁盘中读取到内存中，以满足进程的需求。），内核进行请页。</p>
<p><font color="blue">再简单点，就是在进程的虚拟地址的合适位置添加一个vm_area_struct结构体。而进程的页表用于映射虚拟地址到物理地址，所以会给添加的结构体添加一个页表项即物理内存的地址。通过这个进程中映射的地址就能访问到共享的物理地址了</font><br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/mmap2.jpg" alt="mmap"></p>
<h5 id="4-3-4-共享内存的映射"><a href="#4-3-4-共享内存的映射" class="headerlink" title="4.3.4 共享内存的映射"></a>4.3.4 共享内存的映射</h5><p>&emsp;&emsp;共享内存通信方式与上面的mmap()方式极为相似，但因为建立一个文件的目的仅是为了通信，于是这种文件没有永久保存的意义，因此IPC并没有使用正规的文件系统，而是在系统初始化时在磁盘交换区建立了一个专门用来实现共享内存的特殊临时文件系统shm，当系统断电后，其中的文件会全部自行销毁。（不是人为的，mapp创造的内存空间随着进程的消亡而消亡，而共享内存的是在断电后才消失）</p>
<h5 id="4-3-5-共享内存的结构"><a href="#4-3-5-共享内存的结构" class="headerlink" title="4.3.5 共享内存的结构"></a>4.3.5 共享内存的结构</h5><p>在 Linux 中，kern_ipc_perm 结构体用于跟踪进程间通信（IPC）对象的权限。IPC 对象包括消息队列、信号量和共享内存段等。<br>(这里只展示了有关共享内存的结构体，IPC还有很多其它的结构体，shmid_kernel，ipc_id_ary，ipc_ids是共享内存中独有的，而kern_ipc_perm也能用于其它IPC中)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="keyword">key_t</span> key;          <span class="comment">/* 键值 */</span></span><br><span class="line">    <span class="keyword">uid_t</span> uid;          <span class="comment">/* 拥有者的用户 ID */</span></span><br><span class="line">    <span class="keyword">gid_t</span> gid;          <span class="comment">/* 拥有者的组 ID */</span></span><br><span class="line">    <span class="keyword">uid_t</span> cuid;         <span class="comment">/* 创建者的用户 ID */</span></span><br><span class="line">    <span class="keyword">gid_t</span> cgid;         <span class="comment">/* 创建者的组 ID */</span></span><br><span class="line">    <span class="keyword">mode_t</span> mode;        <span class="comment">/* 访问权限 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> seq; <span class="comment">/* 序列号 */</span></span><br><span class="line">    <span class="keyword">key_serial_t</span> sem_perm_seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>共享内存段的内核数据结构shmid_kernel如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> /* <span class="title">private</span> <span class="title">to</span> <span class="title">the</span> <span class="title">kernel</span> */</span></span><br><span class="line"><span class="class">&#123;</span>	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span>	<span class="title">shm_perm</span>;</span>        <span class="comment">//描述进程间通信许可的结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *		<span class="title">shm_file</span>;</span>            <span class="comment">//指向共享内存文件的指针</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		shm_nattch;            <span class="comment">//挂接到本段共享内存的进程数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		shm_segsz;            <span class="comment">//段大小</span></span><br><span class="line">	<span class="keyword">time_t</span>			shm_atim;            <span class="comment">//最后挂接时间</span></span><br><span class="line">	<span class="keyword">time_t</span>			shm_dtim;            <span class="comment">//最后解除挂接时间</span></span><br><span class="line">	<span class="keyword">time_t</span>			shm_ctim;            <span class="comment">//最后变化时间</span></span><br><span class="line">	<span class="keyword">pid_t</span>			shm_cprid;            <span class="comment">//创建进程的PID</span></span><br><span class="line">	<span class="keyword">pid_t</span>			shm_lprid;            <span class="comment">//最后使用进程的PID</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span>	*<span class="title">mlock_user</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了便于管理，内核把共享内存区的所有描述结构shmid_kernel都存放在结构ipc_id_ary中的一个数组中。结构ipc_id_ary的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">p</span>[0];</span>            <span class="comment">//存放段描述结构的数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样，为了描述一个共享内存区的概貌，内核使用了数据结构ipc_ids。该结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> in_use;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> seq;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> seq_max;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">rw_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">ipcs_idr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span> *<span class="title">entries</span>;</span>        <span class="comment">//指向struct ipc_id_ary的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由多个共享段组成的共享区的结构如下所示：<br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%85%B1%E4%BA%AB%E5%8C%BA%E7%BB%93%E6%9E%84.jpg" alt="共享区结构"><br>IPC内核中有许多的结构体：</p>
<p>在共享内存中，ipc_ids结构体维护了所有共享内存的ID，ipc_id_ary结构体维护了共享内存的索引，kern_ipc_perm结构体维护了共享内存的权限信息，shmid_kernel结构体维护了共享内存的管理信息。这些结构体相互配合，实现了IPC机制的管理和控制。</p>
<p>它们之间的关系如下所示：</p>
<p>ipc_ids中存储了所有IPC对象的ID，每个ID对应一个ipc_id_ary中的元素。</p>
<p>ipc_id_ary中存储了所有IPC对象的ID，每个ID对应一个kern_ipc_perm结构体。</p>
<p>kern_ipc_perm结构体中包含了一个指向共享内存的指针，这个指针指向一个shmid_kernel结构体。</p>
<h4 id="4-4-先入先出队列（也叫有名管道）-fifo"><a href="#4-4-先入先出队列（也叫有名管道）-fifo" class="headerlink" title="4.4 先入先出队列（也叫有名管道） fifo"></a>4.4 先入先出队列（也叫有名管道） fifo</h4><p>&emsp;&emsp;FIFO和Pipe都可以用于进程间通信，但它们的实现方式略有不同。Pipe是一种匿名管道，它只存在于内存中，而FIFO是一种特殊的文件类型，它存在于文件系统中。因此，FIFO可以用于不同进程甚至不同计算机之间的通信，而Pipe只能用于具有亲缘关系的进程之间的通信。</p>
<p>&emsp;&emsp;FIFO主要用于缓冲速度不匹配的通信。例如生产者（数据产生者）可能在短时间内生成大量数据，导致消费者（数据使用方）无法立即处理完，那么就需要用到队列。生产者可以突然生成大量数据存到队列中，然后就去休息，消费者再有条不紊地将数据一条条取出解析。通常会结合DMA操作。</p>
<p>&emsp;&emsp;FIFO为一种特殊的文件类型，它在文件系统中有对应的路径。当一个进程以读(r)的方式打开该文件，而另一个进程以写(w)的方式打开该文件，那么内核就会在这两个进程之间建立管道，所以FIFO实际上也由内核管理，不与硬盘打交道。之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序。FIFO只是借用了文件系统(file system,命名管道是一种特殊类型的文件，因为Linux中所有事物都是文件，它在文件系统中以文件名的形式存在。)来为管道命名。写模式的进程向FIFO文件中写入，而读模式的进程从FIFO文件中读出。当删除FIFO文件时，管道连接也随之消失。FIFO的好处在于我们可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接</p>
<h5 id="4-4-1-fifo的实现方式"><a href="#4-4-1-fifo的实现方式" class="headerlink" title="4.4.1 fifo的实现方式"></a>4.4.1 fifo的实现方式</h5><p>fifo 是用户空间的实现，而 kfifo 是内核空间的实现。</p>
<p>kfifo是linux内核的对队列功能的实现。在内核中，它被称为无锁环形队列。</p>
<p>所谓无锁，就是当只有一个生产者和只有一个消费者时，操作fifo不需要加锁。这是因为kfifo出队和入队时，不会改动到相同的变量。</p>
<p>kfifo使用了in和out两个变量分别作为入队和出队的索引：<br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/kfifo.jpg" alt="kfifo"></p>
<ul>
<li>入队n个数据时，in变量就+n</li>
<li>出队k个数据时，out变量就+k</li>
<li>out不允许大于in（out等于in时表示fifo为空）</li>
<li>in不允许比out大超过fifo空间（比如上图，in最多比out多8，此时表示fifo已满）<br>如果in和out大于fifo空间了，比如上图中的8，会减去8后重新开始吗？</li>
</ul>
<p>不，这两个索引会一直往前加，不轻易回头，为出入队操作省下了几个指令周期。</p>
<p>那入队和出队的数据从哪里开始存储/读取呢，我们第一时间会想到，把 in/out 用“%”对fifo大小取余就行了，是吧？</p>
<p>不，取余这种耗费资源的运算，内核开发者怎会轻易采用呢，kfifo的办法是，把 <code>in/out &amp; fifo-&gt;mask</code>。这个mask等于fifo的空间大小减一（其要求fifo的空间必须是2的次方大小）。这个“与”操作可比取余操作快得多了。</p>
<p>由此，kfifo就实现了“无锁”“环形”队列。</p>
<p>了解了上述原理，我们就能意识到，这个无锁只是针对“单生产者-单消费者”而言的。“多生产者”时，则需要对入队操作进行加锁；同样的，“多消费者”时需要对出队操作进行加锁。</p>
<h4 id="4-5-消息队列-Message"><a href="#4-5-消息队列-Message" class="headerlink" title="4.5 消息队列 Message"></a>4.5 消息队列 Message</h4><h5 id="4-5-1-消息队列概念"><a href="#4-5-1-消息队列概念" class="headerlink" title="4.5.1 消息队列概念"></a>4.5.1 消息队列概念</h5><p>消息队列是消息的链接表 ,存放在内核中并由消息队列标识符标识。我们将称消息队列为“队列”，其标识符为“队列 I D”。我们并不一定要以先进先出次序取消息，也可以按消息的类型字段取消息。消息队列的优点是能够实现异步通信。缺点是消息的大小受到限制。<br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/mes.jpg" alt="mes"></p>
<h4 id="4-7-信号量-semaphore"><a href="#4-7-信号量-semaphore" class="headerlink" title="4.7 信号量 semaphore"></a>4.7 信号量 semaphore</h4><h5 id="4-7-1-信号量概述"><a href="#4-7-1-信号量概述" class="headerlink" title="4.7.1 信号量概述"></a>4.7.1 信号量概述</h5><p>信号量与其他进程间通信方式不大相同，它主要提供对进程间共享资源访问控制机制。相当于内存中的标志，进程可以根据它判定是否能够访问某些共享资源（临界区，类似于互斥锁），同时，进程也可以修改该标志。除了用于访问控制外，还可用于进程同步。信号量有以下两种类型：</p>
<ul>
<li>二值信号量：最简单的信号量形式，信号量的值只能取0或1，类似于互斥锁。<br>注：二值信号量能够实现互斥锁的功能，但两者的关注内容不同。信号量强调共享资源，只要共享资源可用，其他进程同样可以修改信号量的值；互斥锁更强调进程，占用资源的进程使用完资源后，必须由进程本身来解锁。</li>
<li>计算信号量：信号量的值可以取任意非负值（当然受内核本身的约束）。</li>
</ul>
<h5 id="4-7-2-Linux信号量"><a href="#4-7-2-Linux信号量" class="headerlink" title="4.7.2 Linux信号量"></a>4.7.2 Linux信号量</h5><p>linux对信号量的支持状况与消息队列一样，在red had 8.0发行版本中支持的是系统V的信号量。因此，本文将主要介绍系统V信号量及其相应API。在没有声明的情况下，以下讨论中指的都是系统V信号量。</p>
<p>注意：通常所说的系统V信号量指的是计数信号量集。</p>
<h5 id="4-7-2-信号量和内核"><a href="#4-7-2-信号量和内核" class="headerlink" title="4.7.2 信号量和内核"></a>4.7.2 信号量和内核</h5><ol>
<li><p>系统V信号量是随内核持续的，只有在内核重起或者显示删除一个信号量集时，该信号量集才会真正被删除。因此系统中记录信号量的数据结构（struct ipc_ids sem_ids）位于内核中，系统中的所有信号量都可以在结构sem_ids中找到访问入口。</p>
</li>
<li><p>下图说明了内核与信号量是怎样建立起联系的：<br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/xinhaodeng.jpg" alt="sem"></p>
</li>
</ol>
<p>其中：structipc_ids sem_ids是内核中记录信号量的全局数据结构；描述一个具体的信号量及其相关信息。</p>
<p>其中，struct sem结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">  <span class="keyword">int</span> semval; <span class="comment">// current value    </span></span><br><span class="line">  <span class="keyword">int</span> sempid; <span class="comment">// pid of last operation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上图可以看出，全局数据结构struct ipc_ids sem_ids可以访问到struct ipc_id ipcid的一个成员：struct kern_ipc_perm；而每个struct kern_ipc_perm能够与具体的信号量集对应起来是因为在该结构中，有一个key_t类型成员key，而key则唯一确定一个信号量集struct sem_array；同时，结构struct sem_array的最后一个成员sem_nsems确定了该信号量在信号量集中的顺序，这样内核就能够记录每个信号量的信息了。</p>
<p>kern_ipc_perm结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内核中全局数据结构sem_ids能够访问到该结构；</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span>  <span class="comment">// IPC 命名空间</span></span><br><span class="line">    <span class="keyword">uid_t</span> uid;  <span class="comment">// 拥有者的用户 ID</span></span><br><span class="line">    <span class="keyword">gid_t</span> gid;  <span class="comment">// 拥有者的组 ID</span></span><br><span class="line">    <span class="keyword">uid_t</span> cuid;  <span class="comment">// 创建者的用户 ID</span></span><br><span class="line">    <span class="keyword">gid_t</span> cgid;  <span class="comment">// 创建者的组 ID</span></span><br><span class="line">    <span class="keyword">mode_t</span> mode;  <span class="comment">// 访问权限</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> locked:<span class="number">1</span>;  <span class="comment">// 锁定标志</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> deleted:<span class="number">1</span>;  <span class="comment">// 删除标志</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;  <span class="comment">// IPC 对象的 ID</span></span><br><span class="line">    <span class="keyword">key_t</span> key;  <span class="comment">// IPC 对象的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>  <span class="comment">// RCU 头</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*系统中的每个信号量集对应一个sem_array 结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">sem_perm</span>;</span>  <span class="comment">// 信号量的内核 IPC 权限</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span>  <span class="comment">// 指向信号量集合的第一个信号量的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_nsems;  <span class="comment">// 信号量集合中信号量的数量</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_otime;  <span class="comment">// 最后一次 semop 操作的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_ctime;  <span class="comment">// 最后一次修改 sem_array 的时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">sem_pending</span>;</span>  <span class="comment">// 指向等待信号量的进程队列的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> **<span class="title">sem_pending_last</span>;</span>  <span class="comment">// 指向等待信号量的进程队列的最后一个 sem_queue 结构体的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">undo</span>;</span>  <span class="comment">// 指向撤销操作链表的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *sem_unused;  <span class="comment">// 未使用的信号量的数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，sem_queue结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 系统中每个因为信号量而睡眠的进程，都对应一个sem_queue结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> * <span class="title">next</span>;</span> <span class="comment">/* next entry in the queue */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> ** <span class="title">prev</span>;</span> <span class="comment">/* previous entry in the queue, *(q-&gt;prev) == q */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">sleeper</span>;</span> <span class="comment">/* this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> * <span class="title">undo</span>;</span> <span class="comment">/* undo structure */</span></span><br><span class="line">    <span class="keyword">int</span> pid; <span class="comment">/* process id of requesting process */</span></span><br><span class="line">    <span class="keyword">int</span> status; <span class="comment">/* completion status of operation */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> * <span class="title">sma</span>;</span> <span class="comment">/* semaphore array for operations */</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">/* internal sem id */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> * <span class="title">sops</span>;</span> <span class="comment">/* array of pending operations */</span></span><br><span class="line">    <span class="keyword">int</span> nsops; <span class="comment">/* number of operations */</span></span><br><span class="line">    <span class="keyword">int</span> alter; <span class="comment">/* operation will alter semaphore */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-7-3-操作信号量"><a href="#4-7-3-操作信号量" class="headerlink" title="4.7.3 操作信号量"></a>4.7.3 操作信号量</h5><p>对信号量的操作无非有下面三种类型：</p>
<ol>
<li><p>打开或创建信号量 与消息队列的创建及打开基本相同，不再详述。</p>
</li>
<li><p>信号量值操作 linux可以增加或减小信号量的值，相应于对共享资源的释放和占有。具体参见后面的semop系统调用。</p>
</li>
<li><p>获得或设置信号量属性： 系统中的每一个信号量集都对应一个struct sem_array结构，该结构记录了信号量集的各种信息，存在于系统空间。为了设置、获得该信号量集的各种信息及属性，在用户空间有一个重要的联合结构与之对应，即union semun。</p>
</li>
</ol>
<p><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/sem.jpg" alt="sem"></p>
<p>联合semun数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span> val;                  <span class="comment">// 用于SETVAL操作，表示信号量的初始值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>     <span class="comment">// 用于IPC_STAT和IPC_SET操作，指向一个semid_ds结构体，用于获取和设置信号量集的属性</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;    <span class="comment">// 用于GETALL和SETALL操作，指向一个无符号短整型数组，用于获取和设置信号量集中每个信号量的值</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> defined(__linux__)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span>    <span class="comment">// 用于IPC_INFO操作，指向一个seminfo结构体，用于获取信号量实现的一些限制</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">semid_ds数据结构在&lt;sys/sem.h&gt;头文件中定义如下：</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span> <span class="comment">// 信号量集合的权限结构体，包含了拥有者、创建者的用户和组ID，以及权限信息</span></span><br><span class="line">    <span class="keyword">time_t</span>          sem_otime; <span class="comment">// 上次semop操作的时间，如果没有操作则为0</span></span><br><span class="line">    <span class="keyword">time_t</span>          sem_ctime; <span class="comment">// 上次semctl操作更改信号量集合的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   sem_nsems; <span class="comment">// 信号量集合中信号量的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">ipc_perm结构体在&lt;sys/ipc.h&gt;头文件中定义如下:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="keyword">key_t</span>  __key;     <span class="comment">// 外部键，用于获取IPC对象的键值</span></span><br><span class="line">    <span class="keyword">uid_t</span>  uid;       <span class="comment">// 拥有者（用户）的用户ID</span></span><br><span class="line">    <span class="keyword">gid_t</span>  gid;       <span class="comment">// 拥有者（用户）的组ID</span></span><br><span class="line">    <span class="keyword">uid_t</span>  cuid;      <span class="comment">// 创建者（用户）的用户ID</span></span><br><span class="line">    <span class="keyword">gid_t</span>  cgid;      <span class="comment">// 创建者（用户）的组ID</span></span><br><span class="line">    <span class="keyword">mode_t</span> mode;      <span class="comment">// 读写权限标志，包括用户、组和其他用户的读写权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果在包含&lt;sys/sem.h&gt;头文件之前定义了_GNU_SOURCE特性测试宏，那么seminfo结构体将在&lt;sys/sem.h&gt;头文件中定义。_GNU_SOURCE是一个预处理器宏，用于启用GNU扩展功能。</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> semmap;     <span class="comment">// 系统范围内映射的信号量集数的上限</span></span><br><span class="line">    <span class="keyword">int</span> semmni;     <span class="comment">// 系统范围内信号量标识符数（信号量集）的上限</span></span><br><span class="line">    <span class="keyword">int</span> semmns;     <span class="comment">// 系统范围内信号量数的上限</span></span><br><span class="line">    <span class="keyword">int</span> semmnu;     <span class="comment">// 系统范围内未使用信号量数的上限</span></span><br><span class="line">    <span class="keyword">int</span> semmsl;     <span class="comment">// 单个信号量集中信号量数的上限</span></span><br><span class="line">    <span class="keyword">int</span> semopm;     <span class="comment">// 单个`semop`操作中可以执行的最大操作数</span></span><br><span class="line">    <span class="keyword">int</span> semume;     <span class="comment">// 单个进程可持有的信号量撤销结构（undo structure）的最大数量</span></span><br><span class="line">    <span class="keyword">int</span> semusz;     <span class="comment">// 系统范围内的信号量撤销结构总大小的上限</span></span><br><span class="line">    <span class="keyword">int</span> semvmx;     <span class="comment">// 单个信号量的最大值</span></span><br><span class="line">    <span class="keyword">int</span> semaem;     <span class="comment">// 系统范围内的调整值（adjust）的最大值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//semmsl、semmns、semopm和semmni这些设置可以通过/proc/sys/kernel/sem进行修改；请参阅proc(5)文档了解详细信息。</span></span><br></pre></td></tr></table></figure>

<h3 id="5-Linux线程的同步和互斥"><a href="#5-Linux线程的同步和互斥" class="headerlink" title="5. Linux线程的同步和互斥"></a>5. Linux线程的同步和互斥</h3><h4 id="5-1-线程同步"><a href="#5-1-线程同步" class="headerlink" title="5.1 线程同步"></a>5.1 线程同步</h4><p>同步是指多个线程按照约定的顺序相互配合完成一件事情，例如一个线程需要等待另一个线程的结果才能继续执行。<br>Linux线程的同步和进程的差不多，都是用的信号量来进行p/v操作。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">信号量操作：</span><br><span class="line"></span><br><span class="line">​			创建信号量 -- sem_init()</span><br><span class="line"></span><br><span class="line">​			P操作 -- 申请资源 -- sem_wait()</span><br><span class="line"></span><br><span class="line">​					if（资源）</span><br><span class="line"></span><br><span class="line">​					&#123;</span><br><span class="line"></span><br><span class="line">​							执行代码;</span><br><span class="line"></span><br><span class="line">​							信号量值-1；</span><br><span class="line"></span><br><span class="line">​					&#125;</span><br><span class="line"></span><br><span class="line">​					else</span><br><span class="line"></span><br><span class="line">​					&#123;</span><br><span class="line"></span><br><span class="line">​							阻塞；  //直到有资源才会继续执行</span><br><span class="line"></span><br><span class="line">​					&#125;</span><br><span class="line"></span><br><span class="line">​			V操作 -- 释放资源 -- sem_post()</span><br><span class="line"></span><br><span class="line">​					信号量值+1；</span><br><span class="line"></span><br><span class="line">​					如果有阻塞需要资源代码，则会唤醒让其继续执行</span><br></pre></td></tr></table></figure>

<p>但也有不同：</p>
<ul>
<li>posix的信号量常用于线程，system v的信号量常用于进程的同步。</li>
<li>posix的信号量是个非负整数，system v的信号量是一个或多个信号量的集合，对应一个信号量结构体。</li>
<li>posix的信号量是基于内存的，放在共享内存中，由名字来标识。system v的信号量是基于内核的，放在内核里面。</li>
</ul>
<h4 id="5-2-线程互斥锁"><a href="#5-2-线程互斥锁" class="headerlink" title="5.2 线程互斥锁"></a>5.2 线程互斥锁</h4><p>互斥主要用来保护临界资源，任何时刻最多只有一个线程能访问该资源，必须先获得互斥锁才能访问临界资源，访问完后要释放互斥锁。多个线程访问只有一个互斥锁的资源时会进行争抢，所以无法知道哪个线程会抢到该资源</p>
<p>线程的同步和互斥都是为了保证数据的一致性和正确性，但同步更强调线程之间的逻辑关系，而互斥更强调线程之间的排他性。</p>
<br>
<br>

<hr>
<h2 id="二、相关函数使用"><a href="#二、相关函数使用" class="headerlink" title="二、相关函数使用"></a>二、相关函数使用</h2><h3 id="2-1-进程"><a href="#2-1-进程" class="headerlink" title="2.1 进程"></a>2.1 进程</h3><h4 id="2-1-1-进程的创建"><a href="#2-1-1-进程的创建" class="headerlink" title="2.1.1 进程的创建"></a>2.1.1 进程的创建</h4><h5 id="子进程创建fork"><a href="#子进程创建fork" class="headerlink" title="子进程创建fork"></a>子进程创建fork</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pid_t fork(void);</span><br><span class="line">功能：创建一个子进程出来，并和父进程并发执行</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：如果调用成功，fork()函数将返回两次。在父进程中，它返回子进程的进程ID，而在子进程中，它返回0。如果调用失败，则返回一个负值，表示错误类型。(可以用pid是否等于0来分别编写子进程函数(==0)和父进程函数(&gt;0))</span><br><span class="line"></span><br><span class="line">注：父进程和子进程空间完全独立</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child process, x = %d\n&quot;</span>, ++x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the parent process, x = %d\n&quot;</span>, --x);</span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 父进程等待子进程执行完毕</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上示例代码创建了一个新的进程，它的执行结果取决于操作系统调度进程的顺序。在该示例代码中，父进程和子进程分别执行不同的代码段，从而改变变量x的值。父进程调用wait()函数等待子进程执行完毕，以便正确处理进程的退出状态。</span></span><br></pre></td></tr></table></figure>

<h5 id="实时拷贝vfork："><a href="#实时拷贝vfork：" class="headerlink" title="实时拷贝vfork："></a>实时拷贝vfork：</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pid_t vfork(void);</span><br><span class="line">功能：创建一个子进程出来,创建的新进程与父进程共享同一个地址空间，因此在子进程中修改变量或调用函数可能会影响到父进程的数据。</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：返回0给子进程，返回子进程的id(&gt;0)给父进程，-1出错</span><br><span class="line"></span><br><span class="line">注：一定是子进程先运行，并且子进程不结束exit()或者不调用exec函数簇，父进程不会运行（正确运行）</span><br></pre></td></tr></table></figure>
<h5 id="进程替换exec族："><a href="#进程替换exec族：" class="headerlink" title="进程替换exec族："></a>进程替换exec族：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int execl(const char *path, const char *arg0, ..., const char *argn, (char *) NULL);</span><br><span class="line">int execlp(const char *file, const char *arg0, ..., const char *argn, (char *) NULL);</span><br><span class="line">int execle(const char *path, const char *arg0, ..., const char *argn, (char *) NULL, char *const envp[]);</span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line">int execve(const char *path, char *const argv[], char *const envp[]);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">exec()函数族用于在当前进程中执行一个新的程序，替换当前进程的镜像。这些函数的不同之处在于它们的参数形式和处理方式不同。换句话说，就是在调用进程内部执行一个可执行文件。进程 ID 并未改变。exec 只是用另一个新程序替换了当前进程的正文、数据、堆和栈段（进程替换）。</span><br><span class="line">execl()函数将程序名和参数逐个列举出来，每个参数都是一个独立的字符串，以NULL指针结束。</span><br><span class="line">execlp()函数与execl()函数相似，但是它还允许通过PATH环境变量查找可执行文件。</span><br><span class="line">execle()函数与execl()函数类似，但是它还允许指定环境变量。</span><br><span class="line">execv()函数和execl()函数类似，但是它接受一个字符串数组作为参数列表。</span><br><span class="line">execvp()函数和execlp()函数类似，但是它接受一个字符串数组作为参数列表。</span><br><span class="line">execve()函数和execle()函数类似，但是它接受一个字符串数组作为参数列表，并允许指定环境变量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">返回值：如果调用成功，exec()函数将不会返回。如果调用失败，则返回-1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">path：要执行的程序的路径名。</span><br><span class="line">file：要执行的程序的文件名，如果没有指定路径，则使用PATH环境变量查找可执行文件。</span><br><span class="line">arg0 ~ argn：要传递给新程序的参数列表。</span><br><span class="line">argv：一个字符串数组，包含要传递给新程序的参数列表。</span><br><span class="line">envp：一个字符串数组，包含要传递给新程序的环境变量列表，**以NULL指针结束**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：argn和envp数组要用NULL来表示结束，否则会出错</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *envp[] = &#123;<span class="string">&quot;USER=chatgpt&quot;</span>, <span class="string">&quot;PATH=/bin&quot;</span>, <span class="literal">NULL</span>&#125;; <span class="comment">//</span></span><br><span class="line">  execle(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>, envp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这行代码不会执行，除非 execle() 失败。\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个程序将使用 execle() 函数执行 /bin/ls 程序，并使用 ls -l 作为命令行参数。它还将设置两个新的环境变量 USER 和 PATH。如果 execle() 函数成功，则它不会返回，而是执行 /bin/ls 程序，如果失败则会返回-1。</span></span><br></pre></td></tr></table></figure>
<br>

<h4 id="2-1-2-进程的退出"><a href="#2-1-2-进程的退出" class="headerlink" title="2.1.2 进程的退出"></a>2.1.2 进程的退出</h4><h5 id="进程退出exit"><a href="#进程退出exit" class="headerlink" title="进程退出exit"></a>进程退出exit</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">void exit(int status);</span><br><span class="line">功能：终止程序的执行，并返回给操作系统一个退出状态。</span><br><span class="line">头文件：#include &lt;stdlib.h&gt;</span><br><span class="line">返回值：无返回值，程序将终止执行。</span><br><span class="line">参数：</span><br><span class="line">    status：可选参数，用于指定程序的退出状态。</span><br></pre></td></tr></table></figure>
<h5 id="exit"><a href="#exit" class="headerlink" title="_exit"></a>_exit</h5><p>_exit() 函数也用于终止程序的执行，但它不会执行任何清理工作，例如关闭文件描述符或刷新流缓冲区等操作。不刷新缓冲区的话，可能会导致输出的内容不及时或不完整。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-进程的等待wait"><a href="#2-1-2-进程的等待wait" class="headerlink" title="2.1.2 进程的等待wait"></a>2.1.2 进程的等待wait</h4><h5 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pid_t wait(int *status);</span><br><span class="line">功能：调用该函数进程阻塞，直到任一一个子进程结束或者是该进程接收到了一个信号为止，如果该进程没有子进程或者其子进程已经结束，wait函数会立即返回。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt;、#include &lt;sys/wait.h&gt;</span><br><span class="line">返回值：如果成功，则返回子进程的进程 ID，否则返回-1。</span><br><span class="line">参数：</span><br><span class="line">    status：可选参数，用于获取子进程的退出状态。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建子进程失败。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是子进程，进程 ID 为 %d。\n&quot;</span>, getpid());</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程结束。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是父进程，进程 ID 为 %d。\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = wait(&amp;status);</span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;等待子进程结束失败。\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;子进程 %d 结束，退出状态为 %d。\n&quot;</span>, child_pid, status);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个程序创建了一个子进程，并在子进程中等待 3 秒钟后退出，并返回状态码 42。在父进程中，我们使用 wait() 函数等待子进程的结束，并获取其退出状态。如果 wait() 函数成功，则返回子进程的进程 ID，并将子进程的退出状态存储在 status 参数中。在本例中，父进程将打印子进程的进程 ID 和退出状态。如果等待子进程结束失败，则程序将返回非零值</span></span><br></pre></td></tr></table></figure>

<h5 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid, int *status, int options);</span><br><span class="line">功能：waitpid() 函数与 wait() 函数类似，也用于等待一个子进程的结束，并获取该子进程的退出状态。但 waitpid() 函数提供了更多的控制选项，例如可以等待特定进程的结束，可以在不阻塞的情况下查询进程状态等。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt;、#include &lt;sys/wait.h&gt;</span><br><span class="line">返回值：如果成功，则返回子进程的进程 ID，否则返回-1。</span><br><span class="line">参数：</span><br><span class="line">    pid：要等待的进程 ID，如果为-1，则表示等待任何子进程的结束。</span><br><span class="line">    status：可选参数，用于获取子进程的退出状态。</span><br><span class="line">    options：等待选项，可以是 0（阻塞模式）或 WNOHANG（非阻塞模式）。</span><br><span class="line"></span><br><span class="line">注：非阻塞模式下父进程可能会在子进程结束前就执行过了waitpid导致接收不到子进程的退出状态。</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-守护进程"><a href="#2-1-3-守护进程" class="headerlink" title="2.1.3 守护进程"></a>2.1.3 守护进程</h4><h5 id="守护进程的定义"><a href="#守护进程的定义" class="headerlink" title="守护进程的定义"></a>守护进程的定义</h5><ol>
<li><p>守护进程是脱离于终端并且在后台运行的进程</p>
</li>
<li><p>守护进程脱离终端是为了避免在执行过程中的信息在任何终端上显示，并且不被任何终端产生的终端信息所打断</p>
</li>
<li><p>守护进程通常在系统引导装入时启动</p>
</li>
</ol>
<h5 id="守护进程的作用"><a href="#守护进程的作用" class="headerlink" title="守护进程的作用"></a>守护进程的作用</h5><ol>
<li><p>守护进程是一个生存周期较长的进程，通常独立于控制终端并且周期性的执行某种任务或者等待处理某些待发生的事件</p>
</li>
<li><p>大多数服务都是通过守护进程实现的</p>
</li>
<li><p>关闭终端，相应的进程都会被关闭，而守护进程却能够突破这种限制</p>
</li>
</ol>
<h5 id="守护进程的创建过程："><a href="#守护进程的创建过程：" class="headerlink" title="守护进程的创建过程："></a>守护进程的创建过程：</h5><blockquote>
<ol>
<li>创建子进程，父进程退出。这样可以使子进程成为孤儿进程，从而被init进程收养，避免成为僵尸进程。</li>
<li>在子进程中创建新会话。这样可以使子进程摆脱原来的会话，进程组，控制终端的影响，成为新会话的首进程和组长进程。</li>
<li>改变当前工作目录为根目录。这样可以使子进程不依赖于原来的工作目录，避免影响文件系统的卸载和挂载。</li>
<li>重设文件权限掩码。这样可以使子进程拥有更大的文件操作权限，避免受到原来的权限掩码的限制。</li>
<li>关闭不需要的文件描述符。这样可以使子进程释放无用的资源，避免占用系统资源和引起安全问题。</li>
</ol>
</blockquote>
<h5 id="查看系统中的守护进程"><a href="#查看系统中的守护进程" class="headerlink" title="查看系统中的守护进程"></a>查看系统中的守护进程</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ps -axj</span><br><span class="line"></span><br><span class="line">PPID：父进程ID</span><br><span class="line">PID： 进程ID</span><br><span class="line">PGID：进程组ID</span><br><span class="line">SID:  会话期ID</span><br><span class="line">TTY:  终端ID</span><br><span class="line">TPGID:终端进程组ID</span><br><span class="line">STAT: 状态</span><br><span class="line">UID:  用户</span><br><span class="line">TIME: 运行时间</span><br></pre></td></tr></table></figure>
<h5 id="守护进程的创建的代码实现："><a href="#守护进程的创建的代码实现：" class="headerlink" title="守护进程的创建的代码实现："></a>守护进程的创建的代码实现：</h5><p>需要用到的函数</p>
<ul>
<li><p>setsid函数</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pid_t setsid(void);</span><br><span class="line"></span><br><span class="line">功能：用于创建一个新的会话，该会话成为当前进程的会话，同时将当前进程设置为该会话的首进程，该函数还将当前进程的进程组ID设置为其进程ID。这意味着当前进程将成为一个新的进程组和会话的首进程，不再属于原来的进程组或会话。</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：函数成功调用返回新会话的ID号，如果出错则返回-1。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>getdtablesize函数</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int getdtablesize(void);</span><br><span class="line"></span><br><span class="line">功能：getdtablesize()函数用于获取当前进程可以打开的最大文件描述符数量，但由于该函数已经过时，不再被建议使用。取而代之的是使用getrlimit()函数来获取最大文件描述符数量。</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：函数成功调用返回当前进程可以打开的最大文件描述符数量，如果出错则返回-1。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>getrlimit函数</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int getrlimit(int resource, struct rlimit *rlim);</span><br><span class="line">int setrlimit(int resource, const struct rlimit *rlim);</span><br><span class="line"></span><br><span class="line">功能：   getrlimit()函数用于获取指定资源的当前软限制和硬限制值。</span><br><span class="line">        setrlimit()函数则用于设置指定资源的软限制和硬限制值。</span><br><span class="line">头文件：#include &lt;sys/time.h&gt;  #include &lt;sys/resource.h&gt;</span><br><span class="line">返回值：getrlimit()函数成功调用返回0，失败返回-1；</span><br><span class="line">        setrlimit()函数成功调用返回0，失败返回-1。</span><br><span class="line">参数：getrlimit()函数有两个参数，分别是资源类型和rlim结构体的指针，其中rlim结构体用来存储获取到的软限制和硬限制值。资源类型可以是以下常量之一：</span><br><span class="line">    RLIMIT_CPU：CPU时间限制。</span><br><span class="line">    RLIMIT_FSIZE：文件大小限制。</span><br><span class="line">    RLIMIT_DATA：数据段大小限制。</span><br><span class="line">    RLIMIT_STACK：栈大小限制。</span><br><span class="line">    RLIMIT_CORE：核心转储文件大小限制。</span><br><span class="line">    RLIMIT_RSS：驻留内存集大小限制。</span><br><span class="line">    RLIMIT_NOFILE：打开的文件数量限制。</span><br><span class="line">    RLIMIT_AS：虚拟内存总量限制。</span><br><span class="line">    RLIMIT_NPROC：进程数量限制。</span><br><span class="line">    RLIMIT_MEMLOCK：内存锁定大小限制。</span><br><span class="line">    RLIMIT_LOCKS：文件锁数量限制。</span><br><span class="line">    RLIMIT_SIGPENDING：挂起的信号数量限制。</span><br><span class="line">    RLIMIT_MSGQUEUE：POSIX消息队列的大小限制。</span><br><span class="line">    RLIMIT_NICE：优先级限制。</span><br><span class="line">    RLIMIT_RTPRIO：实时优先级限制。</span><br><span class="line">    RLIMIT_RTTIME：实时时间限制。</span><br><span class="line">setrlimit()函数有两个参数，分别是资源类型和rlim结构体的指针，其中rlim结构体用来存储新的软限制和硬限制值。</span><br><span class="line"></span><br><span class="line">rlimt结构体定义如下：</span><br><span class="line">struct rlimit &#123;</span><br><span class="line">    rlim_t rlim_cur;  // 软限制值</span><br><span class="line">    rlim_t rlim_max;  // 硬限制值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rlim_t是一个无符号整型类型</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>umask函数</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">mode_t umask(mode_t cmask);</span><br><span class="line"></span><br><span class="line">功能：用来设置当前进程的文件创建屏蔽字。文件创建屏蔽字是一种文件权限掩码，用来掩盖掉新建的文件的某些权限。文件创建屏蔽字是一个由9个常量按位或构成的mode_t类型的值，对应9种访问权限。在文件创建时，系统会将umask值和用户创建一个新文件或目录时指定一个文件权限值按位取反后进行按位与操作，以得到最终权限值。文件创建屏蔽字可以分为硬限制和软限制。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;sys/stat.h&gt;</span><br><span class="line">返回值：函数成功调用返回原文件创建屏蔽字的值，如果出错则返回-1。</span><br></pre></td></tr></table></figure>
</li>
<li><p>chdir函数</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int chdir(const char *path);</span><br><span class="line"></span><br><span class="line">功能：用来改变当前进程的工作目录，即将当前工作目录更改为path指定的目录。</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：函数成功调用返回0，失败返回-1。</span><br><span class="line">参数：path，表示要改变的工作目录路径。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建子进程失败</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程继续执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 脱离终端</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符,gettablesize()用于获取当前进程的文件描述符数量上限,循环关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int fdtablesize = getdtablesize();</span></span><br><span class="line">    <span class="comment">//for(fd = 0;fd&lt;fdtablesize;fd++) close(fd);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = getrlimit(RLIMIT_NOFILE, &amp;rlim);</span><br><span class="line">    <span class="keyword">for</span>(fd=<span class="number">0</span>;fd &lt; ret:fd++) close(fd);</span><br><span class="line">    <span class="comment">// 设置文件权限掩码，umask(0)不屏蔽任何权限</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变工作目录 通常是把&quot;/&quot;或&quot;/tmp&quot;作为守护进程的当前目录</span></span><br><span class="line">    chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理信号</span></span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    signal(SIGHUP, handle_signal);</span><br><span class="line">    signal(SIGTERM, handle_signal);</span><br><span class="line">    signal(SIGINT, handle_signal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动守护进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 守护进程的主要工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-2-线程"><a href="#2-2-线程" class="headerlink" title="2.2 线程"></a>2.2 线程</h3><h4 id="2-2-1-线程的创建"><a href="#2-2-1-线程的创建" class="headerlink" title="2.2.1 线程的创建"></a>2.2.1 线程的创建</h4><h5 id="进程创建pthread-create"><a href="#进程创建pthread-create" class="headerlink" title="进程创建pthread_create"></a>进程创建pthread_create</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</span><br><span class="line"></span><br><span class="line">功能：用于创建一个新的线程，并执行指定的函数。线程创建后立即执行指定的函数，如果指定的函数执行完毕后没有调用pthread_exit函数或返回值为NULL，则线程将自动调用pthread_exit函数并返回NULL。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;pthread.h&gt;</span><br><span class="line">返回值：函数成功调用返回0，失败返回错误码。</span><br><span class="line">参数：</span><br><span class="line">    thread：指向线程ID的指针，用于存储新线程的ID。</span><br><span class="line">    attr：指向线程属性结构体的指针，用于指定新线程的属性，如果为NULL则使用默认属性。</span><br><span class="line">    start_routine：指向线程函数的指针，表示新线程要执行的函数。</span><br><span class="line">    arg：指向void类型的指针，表示传递给线程函数的参数。</span><br><span class="line"></span><br><span class="line">注意：用了pthred函数后编译时要在后面链接一个phread库。-lpthread</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-线程的等待pthread-join"><a href="#2-2-2-线程的等待pthread-join" class="headerlink" title="2.2.2 线程的等待pthread_join"></a>2.2.2 线程的等待pthread_join</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pthread_join(pthread_t thread, void **retval);</span><br><span class="line"></span><br><span class="line">功能：用于等待指定的线程结束，并获取线程的返回值。如果指定的线程已经结束，则该函数会立即返回；否则该函数会阻塞当前线程，直到指定的线程结束为止。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;pthread.h&gt;</span><br><span class="line">返回值：函数成功调用返回0，失败返回错误码。</span><br><span class="line">参数：</span><br><span class="line">    thread：要等待的线程ID。</span><br><span class="line">    retval：指向指针的指针，用于存储线程的返回值。</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-线程的取消pthread-cancel"><a href="#2-2-3-线程的取消pthread-cancel" class="headerlink" title="2.2.3 线程的取消pthread_cancel"></a>2.2.3 线程的取消pthread_cancel</h4><blockquote>
<p>线程有取消类型：</p>
<p>是否允许取消，pthread_setcancelstate()，参数可选值：</p>
<blockquote>
<p>PTHREAD_CANCEL_ENABLE 这是默认值，该线程可以响应取消请求。<br>PTHREAD_CANCEL_DISABLE 无法响应取消请求</p>
</blockquote>
<p>设置取消类型，pthread_setcanceltype()，参数可选值：</p>
<blockquote>
<p>PTHREAD_CANCEL_ASYNCHRONOUS，异步方式，当发出取消请求后，线程可能会在任何点被杀死。<br>PTHREAD_CANCEL_DEFERRED，延迟方式，线程只会在特定的取消点（cancellation points，调用某个函数前）被杀死。</p>
</blockquote>
</blockquote>
<blockquote>
<p>在Linux系统中，以下是一些常见的取消点：</p>
<blockquote>
<ul>
<li>I/O操作，如read、write、open等</li>
<li>等待信号，如sigsuspend、sigwait等</li>
<li>等待锁，如pthreadmutexlock、pthreadmutextimedlock等</li>
<li>等待条件变量，如pthreadcondwait、pthreadcondtimedwait等</li>
<li>睡眠，如sleep、nanosleep等</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pthread_cancel(pthread_t thread);</span><br><span class="line"></span><br><span class="line">功能：pthread_cancel函数用于请求取消指定的线程。线程在接收到取消请求后，可以选择立即取消或者继续执行直到响应取消请求为止。线程可以通过设置线程取消状态来控制是否接收取消请求。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;pthread.h&gt;</span><br><span class="line">返回值：函数成功调用返回0，失败返回错误码。</span><br><span class="line">参数：</span><br><span class="line">    thread：要取消的线程ID。</span><br><span class="line"></span><br><span class="line">注意：pthread_cancel只是像线程发送了一个取消请求，如果线程的退出</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running.\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);  <span class="comment">// 线程执行10秒</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is exiting.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to create new thread.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;New thread created successfully.\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);  <span class="comment">// 稍微等待一下</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_cancel(thread_id) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Failed to cancel thread.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thread is canceled.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个程序中创建了一个线程并让线程运行10秒，主线程运行2秒后调pthread_cancel取消线程，并pthread_join等待阻塞,但因为sleep是一个取消点，线程会被取消返回，所以整个进程在大概2秒后结束。如果 pthread_join 在 pthread_cancel之前或者没有取消点，整个进程则会运行大概10秒后结束。</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-线程的退出pthread-exit"><a href="#2-2-4-线程的退出pthread-exit" class="headerlink" title="2.2.4 线程的退出pthread_exit"></a>2.2.4 线程的退出pthread_exit</h4><ul>
<li>需要回收的pthread_exit和自然退出<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">void pthread_exit(void *retval);</span><br><span class="line"></span><br><span class="line">功能:pthread_exit()函数用于结束当前线程的执行，并返回一个指定的返回值。如果没有调用pthread_exit()函数，线程将在函数返回时自动退出。</span><br><span class="line"></span><br><span class="line">头文件: #include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">返回值:pthread_exit()函数没有返回值，它只是用于结束当前线程的执行。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    void *retval：即线程返回值的指针（记得要是void）。retval参数可以用来指定当前线程的返回值，这个返回值可以被其他线程调用pthread_join()函数获取。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">    1. pthread_exit函数和return语句的区别是，pthread_exit函数只会终止当前线程，不会影响进程中其他线程的执行，而return语句会终止整个进程。此外，pthread_exit函数可以自动调用线程清理程序和析构函数</span><br><span class="line">    2. pthread_exit函数和pthread_cancel函数的区别是，pthread_exit函数是线程主动退出的方式，它可以指定一个返回值给其他线程；pthread_cancel函数是线程被动退出的方式，它是由其他线程发送一个取消请求给目标线程，然后目标线程在取消点检查并终止执行。被取消的线程可以选择忽略取消或者控制如何被取消。</span><br><span class="line">    3. pthread_detach函数可以使线程与主线程分离，不需要等待或回收，而pthread_exit函数可以使线程退出，但需要其他线程调用pthread_join函数来等待或回收（自然退出也是）。另外，pthread_detach函数是在线程运行过程中调用的，pthread_exit函数是在线程结束时调用的。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>示例代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *value_ptr = (<span class="keyword">int</span> *) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread function started with value %d\n&quot;</span>, *value_ptr);</span><br><span class="line">    *value_ptr += <span class="number">1</span>;</span><br><span class="line">    pthread_exit(value_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">int</span> *return_value_ptr;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_func, &amp;value);</span><br><span class="line">    pthread_join(thread, (<span class="keyword">void</span> **) &amp;return_value_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread returned value %d\n&quot;</span>, *return_value_ptr);</span><br><span class="line">    <span class="built_in">free</span>(return_value_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//在这个例子中，我们使用 pthread_create 创建了一个新线程，并传递了一个指向整数值 value 的指针。线程函数 thread_func 接受这个值，将其加 1，然后使用指向更新后值的指针调用 pthread_exit。在主线程中，我们调用 pthread_join 等待子线程终止并检索其返回值。然后我们打印出返回值并释放其分配的内存。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自动回收的pthread_detach</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pthread_detach(pthread_t thread);</span><br><span class="line"></span><br><span class="line">功能：主线程中使用，用于将指定的线程标记为可被回收资源的状态，从而让线程在终止时能够自动释放占用的资源，无需其他线程调用pthread_join来等待其退出。</span><br><span class="line">头文件：#include &lt;pthread.h&gt;</span><br><span class="line">返回值：函数返回值为0表示成功，返回其他值表示失败。</span><br><span class="line">函数参数：</span><br><span class="line">  thread: 要被标记为可被回收状态的线程的线程ID。</span><br><span class="line"></span><br><span class="line">注意：只能对还未被其他线程使用pthread_join函数等待的线程进行pthread_detach操作。</span><br></pre></td></tr></table></figure>
<br>

<h3 id="2-3-进程间通信"><a href="#2-3-进程间通信" class="headerlink" title="2.3 进程间通信"></a>2.3 进程间通信</h3><h4 id="2-3-1-无名管道pipe"><a href="#2-3-1-无名管道pipe" class="headerlink" title="2.3.1 无名管道pipe"></a>2.3.1 无名管道pipe</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pipe(int pipefd[2]);</span><br><span class="line"></span><br><span class="line">功能:用于创建一个管道，它返回两个文件描述符，一个用于读取管道中的数据，一个用于写入数据到管道中。</span><br><span class="line">头文件:在使用pipe函数时需要包含头文件&lt;unistd.h&gt;，该头文件中包含了pipe函数的声明。</span><br><span class="line">返回值:pipe函数成功执行时返回0，失败时返回-1。</span><br><span class="line">参数:</span><br><span class="line">    fd:该数组用于存储创建的管道的读取和写入文件描述符。fd[0]用于读取管道中的数据，fd[1]用于向管道中写入数据。</span><br><span class="line"></span><br><span class="line">注意：pipe有读写特性</span><br><span class="line">读特性</span><br><span class="line">	写端存在：</span><br><span class="line">        管道中有数据：返回读到的字节数</span><br><span class="line">        管道中无数据：阻塞</span><br><span class="line">    写端不存在：</span><br><span class="line">       	管道中有数据：返回读到的字节数</span><br><span class="line">        管道中无数据：返回0</span><br><span class="line">写特性</span><br><span class="line">    读端存在：</span><br><span class="line">        空间足够：返回写入的字节数</span><br><span class="line">        空间不足：阻塞</span><br><span class="line">    读端不存在：    </span><br><span class="line">        无论是否有空间：管道破裂</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="keyword">char</span>* msg = <span class="string">&quot;Hello, parent process!&quot;</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], msg, <span class="built_in">strlen</span>(msg) + <span class="number">1</span>); <span class="comment">// 写入管道</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="keyword">ssize_t</span> num = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 读取管道数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received message from child process: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个子进程，并在父子进程间创建一个管道，子进程写管道，父进程读管道</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-有名管道fifo"><a href="#2-3-2-有名管道fifo" class="headerlink" title="2.3.2 有名管道fifo"></a>2.3.2 有名管道fifo</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">功能：mkfifo函数用于创建一个FIFO文件，FIFO文件是一种特殊的文件，可以实现进程间通信。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt;  #include &lt;sys/stat.h&gt;</span><br><span class="line">返回值：函数返回值为0表示成功，返回其他值表示失败。</span><br><span class="line">参数：</span><br><span class="line">    pathname: FIFO文件的路径和名称。</span><br><span class="line">    mode: FIFO文件的权限。</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* fifo_name = <span class="string">&quot;./myfifo&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建FIFO文件</span></span><br><span class="line">    <span class="keyword">if</span> (mkfifo(fifo_name, <span class="number">0666</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 打开FIFO文件</span></span><br><span class="line">        <span class="keyword">if</span> ((fd = open(fifo_name, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从FIFO读取数据</span></span><br><span class="line">        <span class="keyword">if</span> (read(fd, buf, <span class="keyword">sizeof</span>(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received message from parent: %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">        close(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 打开FIFO文件</span></span><br><span class="line">        <span class="keyword">if</span> ((fd = open(fifo_name, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向FIFO写入数据</span></span><br><span class="line">        <span class="keyword">char</span>* message = <span class="string">&quot;Hello, child process!&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (write(fd, message, <span class="built_in">strlen</span>(message)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除FIFO文件</span></span><br><span class="line">    <span class="keyword">if</span> (unlink(fifo_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;unlink error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这个示例代码中，使用mkfifo函数创建一个名为&quot;myfifo&quot;的FIFO文件，然后创建子进程。在父进程中，使用open函数打开FIFO文件，并使用write函数向其中写入一条消息。在子进程中，使用open函数打开FIFO文件，并使用read函数从其中读取一条消息。在最后，使用unlink函数删除FIFO文件。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-共享内存"><a href="#2-3-3-共享内存" class="headerlink" title="2.3.3 共享内存"></a>2.3.3 共享内存</h4><h5 id="生成键值-ftok"><a href="#生成键值-ftok" class="headerlink" title="生成键值 ftok"></a>生成键值 ftok</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">key_t ftok(const char *pathname, int proj_id);</span><br><span class="line"></span><br><span class="line">功能：ftok函数用于生成一个唯一的键值，这个键值通常用于创建或获取共享内存、消息队列等系统对象。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt;  #include &lt;sys/ipc.h&gt;</span><br><span class="line">返回值：函数返回值为一个非零整数，如果生成键值失败则返回-1。</span><br><span class="line">函数参数：</span><br><span class="line">    pathname: 已存在的文件路径和名称，用于生成键值。可以填&quot;.&quot;表示当前目录</span><br><span class="line">    proj_id: 项目ID，用于进一步生成键值。可以填0~255。</span><br><span class="line">注意事项：</span><br><span class="line">    1. ftok函数根据文件路径和名称以及项目ID生成一个唯一的键值，这个键值通常用于创建或获取共享内存、消息队列等系统对象。</span><br><span class="line">    2. 为了保证生成的键值唯一，需要选择一个具有唯一性的文件路径和名称以及项目ID。</span><br><span class="line">    3. 在使用ftok函数生成键值时，需要注意文件路径和名称的正确性以及是否具有可读可写的权限。</span><br></pre></td></tr></table></figure>

<h5 id="创建共享内存shmget"><a href="#创建共享内存shmget" class="headerlink" title="创建共享内存shmget"></a>创建共享内存shmget</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line"></span><br><span class="line">功能：shmget函数用于创建或获取一个共享内存段。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt;</span><br><span class="line">返回值：函数返回值为共享内存段的标识符，如果创建或获取共享内存段失败则返回-1。</span><br><span class="line">函数参数：</span><br><span class="line">    key: 共享内存段的键值。</span><br><span class="line">    size: 共享内存段的大小。</span><br><span class="line">    shmflg: 共享内存段的标志位，用于指定共享内存的权限和创建方式等。中间用 | 来连接。</span><br><span class="line">        - IPC_CREAT：如果共享内存段不存在，则创建它。</span><br><span class="line">        - IPC_EXCL：如果同时指定了 IPC_CREAT 和 IPC_EXCL，并且共享内存段已经存在，则返回错误。</span><br><span class="line">        - SHM_HUGETLB：使用大页面分配共享内存段。</span><br><span class="line">        - SHM_NORESERVE：不为共享内存段保留交换空间。</span><br><span class="line">        - 0664：共享内存的权限（也可以是其它的数）</span><br></pre></td></tr></table></figure>

<h5 id="映射共享内存shmat"><a href="#映射共享内存shmat" class="headerlink" title="映射共享内存shmat"></a>映射共享内存shmat</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line"></span><br><span class="line">功能：shmat函数用于将共享内存段映射到当前进程的地址空间，并返回共享内存段的起始地址。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt;  #include &lt;sys/shm.h&gt;</span><br><span class="line">返回值：函数返回值为共享内存段的起始地址，如果映射失败则返回-1。</span><br><span class="line">函数参数：</span><br><span class="line">    shmid: 共享内存段的标识符。</span><br><span class="line">    shmaddr: 映射共享内存段的首地址，通常设置为NULL。</span><br><span class="line">    shmflg: 映射共享内存段的标志位，用于指定映射的方式和权限等。一般填0，为读写</span><br></pre></td></tr></table></figure>

<h5 id="解除共享内存的映射shmdt"><a href="#解除共享内存的映射shmdt" class="headerlink" title="解除共享内存的映射shmdt"></a>解除共享内存的映射shmdt</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int shmdt(const void *shmaddr);</span><br><span class="line"></span><br><span class="line">功能：shmdt函数用于解除共享内存段和当前进程地址空间的映射。</span><br><span class="line">头文件：#include &lt;sys/shm.h&gt;</span><br><span class="line">返回值：函数成功时返回 0，失败时返回 -1。</span><br><span class="line">函数参数：</span><br><span class="line">    shmaddr：指向共享内存区域的指针。通常，该指针是由 shmat() 函数返回的共享内存区域地址。</span><br><span class="line">注意事项：</span><br><span class="line">    1. 在调用 shmdt 函数分离共享内存区域后，程序不应该再使用该指针访问共享内存，因为这样会导致未定义的行为。</span><br><span class="line">    2. 如果当前进程是最后一个附加到该共享内存区域的进程，那么该共享内存区域会被系统自动删除。</span><br></pre></td></tr></table></figure>

<h5 id="控制共享内存shmctl"><a href="#控制共享内存shmctl" class="headerlink" title="控制共享内存shmctl"></a>控制共享内存shmctl</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span><br><span class="line"></span><br><span class="line">功能：shmctl 函数用于对共享内存区域进行控制操作，包括获取共享内存区域的状态信息、修改共享内存区域的权限和删除共享内存区域等操作。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：函数成功时返回 0，失败时返回 -1。</span><br><span class="line"></span><br><span class="line">函数参数：</span><br><span class="line"></span><br><span class="line">    shmid：共享内存区域的标识符，由 shmget 函数返回。</span><br><span class="line">    cmd：控制操作命令。常见的操作命令包括：</span><br><span class="line">        IPC_STAT：获取共享内存区域的状态信息，将共享内存的相关信息保存到 buf 结构体中。</span><br><span class="line">        IPC_SET：修改共享内存区域的状态信息，使用 buf 结构体中的信息更新共享内存的相关属性。</span><br><span class="line">        IPC_RMID：删除共享内存区域。</span><br><span class="line">    buf：指向 shmid_ds 结构体的指针，用于存储共享内存区域的状态信息或更新共享内存的相关属性。如果 cmd 参数为 IPC_STAT 或 IPC_SET，则需要传入一个有效的 shmid_ds 结构体指针。</span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">    1. 在使用 shmctl 函数删除共享内存区域时，应该确保没有任何进程正在使用该共享内存，否则删除操作会失败。</span><br><span class="line">    2. 如果 shmctl 函数的 cmd 参数为 IPC_RMID，则系统会立即删除共享内存区域，而不管当前是否有进程正在使用该共享内存。</span><br></pre></td></tr></table></figure>

<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">char</span> *shm, *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个唯一的 key</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;R&#x27;</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享内存段</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHM_SIZE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将共享内存段连接到当前进程的地址空间</span></span><br><span class="line">    <span class="keyword">if</span> ((shm = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="keyword">char</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向共享内存段写入数据</span></span><br><span class="line">    s = shm;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">        *s++ = c;</span><br><span class="line">    &#125;</span><br><span class="line">    *s = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从共享内存段读取数据并输出</span></span><br><span class="line">    <span class="keyword">for</span> (s = shm; *s != <span class="string">&#x27;\0&#x27;</span>; s++) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(*s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将共享内存段从当前进程的地址空间分离</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(shm) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmdt&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除共享内存段</span></span><br><span class="line">    <span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码中首先使用 ftok 函数生成一个唯一的 key，然后使用 shmget 函数创建一个大小为 SHM_SIZE 的共享内存段，并将其连接到当前进程的地址空间中。接着，向共享内存段写入数据，从共享内存段读取数据并输出。最后，将共享内存段从当前进程的地址空间分离，并使用 shmctl 函数删除共享内存段。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-进程间异步通信-信号"><a href="#2-3-4-进程间异步通信-信号" class="headerlink" title="2.3.4 进程间异步通信-信号"></a>2.3.4 进程间异步通信-信号</h4><h5 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h5><ul>
<li><p>kill</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int kill(pid_t pid, int sig);</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;sys/types.h&gt;  #include &lt;signal.h&gt;</span><br><span class="line">返回值：函数返回值为 0 表示成功，返回 -1 表示失败。</span><br><span class="line">参数：</span><br><span class="line">        pid：指定进程或进程组的进程 ID，可以取以下几个值：</span><br><span class="line">                &gt;0：发送信号给进程 ID 为 pid 的进程。</span><br><span class="line">                0：发送信号给当前进程所在进程组中的所有进程。</span><br><span class="line">                -1：发送信号给所有有权限发送信号的进程。</span><br><span class="line">                &lt;-1：发送信号给进程组 ID 为 -pid 的进程组中的所有进程。</span><br><span class="line">        sig：指定要发送的信号的编号或者名字，可以是以下几个值：</span><br><span class="line">                SIGKILL：无条件终止进程。</span><br><span class="line">                SIGTERM：向进程发送终止信号，请求进程自己终止。</span><br><span class="line">                SIGINT：中断信号，通常是通过键盘发送给进程的。</span><br><span class="line">                其他信号编号，可以参考上面信号部分的笔记</span><br><span class="line">注意事项：</span><br><span class="line">1. 只有具有特权的进程才能向其他进程发送信号。</span><br><span class="line">2. SIGKILL和SIGSTOP信号不能被进程捕获或忽略，一旦进程接收到该信号，它会立即终止。</span><br><span class="line">3. SIGTERM 信号可以被进程捕获或忽略，进程可以在收到该信号后进行清理工作后再终止。</span><br><span class="line">4. 如果向进程组发送信号，则该信号会被所有在该进程组中的进程接收到。</span><br></pre></td></tr></table></figure>
</li>
<li><p>raise</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int raise(int sig);</span><br><span class="line"></span><br><span class="line">功能：raise()函数用于发送一个信号给调用进程或者线程。这个函数可以用来模拟信号的接收，以便测试信号处理函数。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：成功时，返回0；失败时，返回非0值。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sig：要发送的信号。信号可以是SIGTERM、SIGABRT等，具体取决于您想要发送的信号类型。</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">1. 当一个进程或线程收到一个信号时，它将暂停当前的工作，并根据信号的类型来执行相应的处理函数。因此，在使用raise()函数时要注意不要产生死锁或者循环依赖。</span><br><span class="line">2. 在多线程环境下，raise()函数可能发送信号给同一进程中的任意线程，而不是特定的调用线程。所以，在多线程环境下使用raise()函数时，要特别注意。</span><br><span class="line">3. 该函数仅将信号发送到调用它的进程或线程。主要用于测试或模拟信号处理。</span><br></pre></td></tr></table></figure>
<h5 id="信号的等待"><a href="#信号的等待" class="headerlink" title="信号的等待"></a>信号的等待</h5></li>
<li><p>定时器alarm</p>
</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line"></span><br><span class="line">功能：alarm()函数用于设置一个实时闹钟，当闹钟到期时，会向当前进程发送SIGALRM信号。如果在闹钟到期之前再次调用alarm()，则先前设置的闹钟会被新的设置覆盖。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：如果之前已经设置了闹钟，则返回剩余的秒数，否则返回0。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">    unsigned int seconds：从当前时间开始，经过的秒数。设置为0表示取消先前设置的闹钟。</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">1. 在使用alarm()函数之前，请确保已经正确注册了信号处理函数（如SIGALRM信号），以便在信号发送后可以正确处理。</span><br><span class="line">2. alarm()函数不是线程安全的，因此在多线程环境下使用时要小心。在多线程环境下，建议使用timer_create()和timer_settime()等函数来设置定时器。</span><br><span class="line">3. alarm()函数设置的闹钟是进程级别的，而非线程级别的。因此，所有线程共享同一个闹钟。</span><br><span class="line">4. 一个进程只允许一个闹钟，如果在上一个闹钟还没结束时调用了另一个闹钟，则新闹钟的返回值是前一个闹钟还剩下的时间</span><br></pre></td></tr></table></figure>

<ul>
<li>进程暂停pause</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pause(void);</span><br><span class="line"></span><br><span class="line">功能：pause()函数用于使调用进程暂停，直到收到一个信号。当收到信号后，该函数会返回，并且进程会继续执行。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：pause()函数在成功接收信号后返回-1，并设置errno为EINTR。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">1. pause()函数通常与信号处理函数一起使用，当需要让进程等待信号时，可以使用pause()函数。</span><br><span class="line">2. 如果进程在调用pause()之前就已经收到信号，那么pause()函数可能会导致进程永久阻塞。</span><br><span class="line">3. 在多线程环境下使用pause()函数时要小心，因为它会影响整个进程。在多线程环境下，可以考虑使用条件变量、信号量等其他同步原语。</span><br></pre></td></tr></table></figure>

<h5 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line"></span><br><span class="line">功能：signal()函数用于设置信号处理函数。当进程接收到指定类型的信号时，它将执行给定的信号处理函数。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：成功时，返回先前的信号处理函数指针；失败时，返回SIG_ERR。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">int signum：要设置处理函数的信号。例如，SIGINT、SIGTERM等。</span><br><span class="line">sighandler_t handler：用于处理指定信号的函数指针。可以是用户定义的处理函数，也可以是SIG_IGN（忽略信号）或SIG_DFL（使用默认操作）。</span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">1. 信号处理函数应尽量简短且不阻塞，写在信号产生之前，因为它会中断正常的程序执行。此外，请确保信号处理函数是可重入的，因为它可能在任何时间被调用。</span><br><span class="line">2. signal()函数在不同的系统和库实现中可能具有不同的行为。在某些情况下，建议使用sigaction()函数代替signal()函数，以获得更可靠和可移植的行为。</span><br></pre></td></tr></table></figure>

<h5 id="信号的示例代码"><a href="#信号的示例代码" class="headerlink" title="信号的示例代码"></a>信号的示例代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGALRM信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigalrm_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程: 收到SIGALRM信号，发送SIGUSR1信号给父进程\n&quot;</span>);</span><br><span class="line">    kill(getppid(), SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGUSR1信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigusr1_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;父进程: 收到SIGUSR1信号\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;创建子进程失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">if</span> (signal(SIGALRM, sigalrm_handler) == SIG_ERR) &#123;</span><br><span class="line">            perror(<span class="string">&quot;子进程: 注册SIGALRM信号处理函数失败&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程: 设置3秒后触发闹钟\n&quot;</span>);</span><br><span class="line">        alarm(<span class="number">3</span>);</span><br><span class="line">        pause();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">if</span> (signal(SIGUSR1, sigusr1_handler) == SIG_ERR) &#123;</span><br><span class="line">            perror(<span class="string">&quot;父进程: 注册SIGUSR1信号处理函数失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程: 等待SIGUSR1信号\n&quot;</span>);</span><br><span class="line">        pause();</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程: 子进程已退出\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这个示例中，我们首先创建了一个子进程。子进程设置了一个3秒后触发的闹钟，并注册了一个处理SIGALRM信号的信号处理函数。然后子进程调用pause()函数等待信号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父进程注册了一个处理SIGUSR1信号的信号处理函数，并调用pause()函数等待信号。当子进程的闹钟触发后，它会接收到SIGALRM信号并调用信号处理函数，这个函数会向父进程发送SIGUSR1信号。父进程接收到SIGUSR1信号后，执行信号处理函数并继续执行。最后，父进程等待子进程退出并打印一条消息</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-5-进程间同步和互斥"><a href="#2-3-5-进程间同步和互斥" class="headerlink" title="2.3.5 进程间同步和互斥"></a>2.3.5 进程间同步和互斥</h4><h5 id="生成键值-ftok-1"><a href="#生成键值-ftok-1" class="headerlink" title="生成键值 ftok"></a>生成键值 ftok</h5><p>和共享内存相似，生成信号量前要先生成一个键值：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">key_t ftok(const char *pathname, int proj_id);</span><br><span class="line"></span><br><span class="line">功能：ftok函数用于生成一个唯一的键值，这个键值通常用于创建或获取共享内存、消息队列等系统对象。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt;  #include &lt;sys/ipc.h&gt;</span><br><span class="line">返回值：函数返回值为一个非零整数，如果生成键值失败则返回-1。</span><br><span class="line">函数参数：</span><br><span class="line">    pathname: 已存在的文件路径和名称，用于生成键值。可以填&quot;.&quot;表示当前目录</span><br><span class="line">    proj_id: 项目ID，用于进一步生成键值。可以填0~255</span><br><span class="line">注意事项：</span><br><span class="line">    1. ftok函数根据文件路径和名称以及项目ID生成一个唯一的键值，这个键值通常用于创建或获取共享内存、消息队列等系统对象。</span><br><span class="line">    2. 为了保证生成的键值唯一，需要选择一个具有唯一性的文件路径和名称以及项目ID。</span><br><span class="line">    3. 在使用ftok函数生成键值时，需要注意文件路径和名称的正确性以及是否具有可读可写的权限。</span><br></pre></td></tr></table></figure>

<h5 id="创建信号量集semget"><a href="#创建信号量集semget" class="headerlink" title="创建信号量集semget"></a>创建信号量集semget</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int semget(key_t key, int nsems, int semflg);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line"></span><br><span class="line">semget 函数用于获取一个信号量集的标识符。如果指定的键值 key 对应的信号量集已经存在，则返回该信号量集的标识符；否则，根据指定的键值 key 和信号量集的数量 nsems 创建一个新的信号量集，并返回其标识符。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"></span><br><span class="line">如果成功，semget 函数返回一个非负整数，即信号量集的标识符；否则，返回 -1 并设置 errno 变量以指示错误。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">        - key_t key：一个键值，用于标识信号量集。可以使用 ftok 函数生成一个键值。</span><br><span class="line">        - int nsems：信号量集中信号量的数量。</span><br><span class="line">        - int semflg：标志位，用于指定信号量集的访问权限和行为。可以使用 IPC_CREAT 标志位创建一个新的信号量集。</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">1. semget 函数是一个系统调用，它可以用于在进程间共享信号量集。如果多个进程使用相同的键值调用 semget 函数，则它们将共享同一个信号量集。</span><br><span class="line">2. semget 函数返回的标识符可以用于后续的信号量操作，如 semop 函数。</span><br><span class="line">3. 如果您使用 IPC_CREAT 标志位创建一个新的信号量集，则需要使用 semctl 函数来初始化信号量集中的每个信号量。</span><br></pre></td></tr></table></figure>

<h5 id="操作信号量集semop"><a href="#操作信号量集semop" class="headerlink" title="操作信号量集semop"></a>操作信号量集semop</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int semop(int semid, struct sembuf *sops, size_t nsops);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line"></span><br><span class="line">semop 函数用于对一个信号量集进行操作。它可以对一个或多个信号量进行 P 操作或 V 操作，也可以对一个或多个信号量进行 Z 操作。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">如果成功，semop 函数返回 0；否则，返回 -1 并设置 errno 变量以指示错误。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">        - int semid：信号量集的标识符，即 semget 函数返回的值。</span><br><span class="line">        - struct sembuf *sops：指向一个 sembuf 结构体数组的指针，每个 sembuf 结构体描述了一个信号量操作。</span><br><span class="line">        - size_t nsops：sembuf 结构体数组的长度。</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line">1. semop 函数是一个系统调用，它可以用于在进程间共享信号量集。</span><br><span class="line">2. semop 函数可以对一个或多个信号量进行操作，每个操作由一个 sembuf 结构体描述。</span><br><span class="line">3. semop 函数可以对信号量进行 P 操作、V 操作或 Z 操作。</span><br><span class="line">4. 如果您使用了 SEM_UNDO 标志位，则在进程退出时会自动撤销信号量操作。</span><br><span class="line">5. 如果您使用了 IPC_NOWAIT 标志位，则 semop 函数会立即返回，而不是等待信号量变为 0。</span><br></pre></td></tr></table></figure>

<p>sembuf 结构体定义如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">struct sembuf &#123;</span><br><span class="line">    unsigned short sem_num;  // 信号量在信号量集中的编号</span><br><span class="line">    short sem_op;            // 信号量操作，可以是 P、V 或 Z</span><br><span class="line">    short sem_flg;           // 操作标志，可以是 IPC_NOWAIT 或 SEM_UNDO</span><br><span class="line">&#125;;</span><br><span class="line">sem_op 可以是以下值之一：</span><br><span class="line">        - sem_op &gt; 0：V 操作，即释放一个信号量。</span><br><span class="line">        - sem_op &lt; 0：P 操作，即获取一个信号量。</span><br><span class="line">        - sem_op = 0：Z 操作，即等待一个信号量变为 0。</span><br><span class="line"></span><br><span class="line">sem_flg 可以是以下值之一：</span><br><span class="line">        - 0：默认值，表示在操作完成之前等待信号量变为 0。</span><br><span class="line">        - IPC_NOWAIT：表示不等待信号量变为 0，立即返回。</span><br><span class="line">        - SEM_UNDO：表示在进程退出时自动撤销信号量操作。</span><br></pre></td></tr></table></figure>

<h5 id="改变信号量集semctl"><a href="#改变信号量集semctl" class="headerlink" title="改变信号量集semctl"></a>改变信号量集semctl</h5><ul>
<li>semun结构体<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">union semun &#123; </span><br><span class="line">    int val; //用于SETVAL命令 </span><br><span class="line">    struct semid_ds *buf; //用于IPC_STAT和IPC_SET命令 </span><br><span class="line">    unsigned short *array; //用于GETALL和SETALL命令 </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    结构体semun的val是用于设置或获取信号量集的值的整数，它是用于SETVAL命令的参数，表示要设置的信号量的值。例如，如果要将第0个信号量的值设置为1，可以这样写：</span><br><span class="line">    union semun arg; arg.val = 1; semctl(semid, 0, SETVAL, arg);</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int semctl(int semid, int semnum, int cmd, ...);</span><br><span class="line"></span><br><span class="line">函数功能:</span><br><span class="line">semctl 函数允许我们控制信号量，包括获取或设置信号量的值、初始化信号量、删除信号量等。</span><br><span class="line"></span><br><span class="line">头文件:#include &lt;sys/sem.h&gt;</span><br><span class="line"></span><br><span class="line">返回值:</span><br><span class="line">semctl 函数的返回值取决于 cmd 参数的值，具体如下：</span><br><span class="line">        当 cmd 为 IPC_STAT 时，返回值为 0，表示成功。</span><br><span class="line">        当 cmd 为 IPC_SET 时，返回值为 0，表示成功。</span><br><span class="line">        当 cmd 为 IPC_RMID 时，返回值为 0，表示成功。</span><br><span class="line">        其他情况下，返回值为信号量集合的值或者 -1，表示出错。</span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">semid：信号量集合的 ID，由 semget 函数返回。</span><br><span class="line">semnum：信号量在集合中的编号，从 0 开始。</span><br><span class="line">cmd：要执行的操作</span><br><span class="line">        IPC_STAT：获取信号量集的状态信息，包括信号量集的 ID、拥有者的 ID、访问权限、信号量集中的信号量数量等。需要传入一个指向 semid_ds 结构体的指针，用于保存信号量集的状态信息。</span><br><span class="line">        IPC_SET：设置信号量集的状态信息，例如设置信号量集的访问权限、设置信号量集中信号量的数量等。需要传入一个指向 semid_ds 结构体的指针，用于设置信号量集的状态信息。</span><br><span class="line">        IPC_RMID：删除信号量集。不需要传入参数，可以传入一个 NULL 指针。</span><br><span class="line">        GETVAL：获取指定信号量的当前值。不需要传入参数，可以传入一个 NULL 指针。</span><br><span class="line">        SETVAL：设置指定信号量的值。需要传入一个 int 类型的参数，表示要设置的信号量的值。</span><br><span class="line">        GETALL：获取信号量集中所有信号量的值。需要传入一个指向 unsigned short 类型数组的指针，用于保存所有信号量的当前值。</span><br><span class="line">        SETALL：设置信号量集中所有信号量的值。需要传入一个指向 unsigned short 类型数组的指针，用于设置所有信号量的值。</span><br><span class="line">        GETPID：获取上一次操作该信号量的进程 ID。不需要传入参数，可以传入一个 NULL 指针。</span><br><span class="line">        GETNCNT：获取正在等待信号量的进程数。不需要传入参数，可以传入一个 NULL 指针。</span><br><span class="line">        GETZCNT：获取等待信号量变为 0 的进程数。不需要传入参数，可以传入一个 NULL 指针。</span><br><span class="line">...：根据 cmd 的值不同，后面的参数也不同。</span><br><span class="line"></span><br><span class="line">注意事项</span><br><span class="line">semctl 函数可以对一个信号量集合进行多种操作，包括获取或设置信号量的值、初始化信号量、删除信号量等。</span><br><span class="line">semctl 函数的第三个参数 cmd 决定了要执行的操作，具体操作请参考 semctl 的手册。</span><br><span class="line">semctl 函数的第四个参数是一个可选参数，根据 cmd 的值不同，后面的参数也不同。具体参数请参考 semctl 的手册。</span><br><span class="line">semctl 函数是一个比较底层的函数，如果不是很熟悉信号量的使用，建议使用更高级别的函数，如 semop。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> initval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun arg;</span><br><span class="line">    arg.val = initval;</span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, semnum, SETVAL, arg) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_sem</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span> = &#123;</span>semnum, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;buf, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semop&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_sem</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span> = &#123;</span>semnum, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;buf, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semop&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semid, retval;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">union</span> semun arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的信号量集合</span></span><br><span class="line">    key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((semid = semget(key, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量集合中的第一个信号量</span></span><br><span class="line">    init_sem(semid, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待信号量，相当于 P 操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for semaphore...\n&quot;</span>);</span><br><span class="line">    wait_sem(semid, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Semaphore acquired.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放信号量，相当于 V 操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Releasing semaphore...\n&quot;</span>);</span><br><span class="line">    signal_sem(semid, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取信号量的值</span></span><br><span class="line">    retval = semctl(semid, <span class="number">0</span>, GETVAL, arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The value of the semaphore is %d\n&quot;</span>, retval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除信号量集合</span></span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, <span class="number">0</span>, IPC_RMID, arg) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这个示例代码中，我们首先使用 ftok 函数创建一个用于标识信号量集合的 key。然后使用 semget 函数创建一个新的信号量集合，并使用 init_sem 函数初始化了信号量集合中的第一个信号量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来，我们使用 wait_sem 函数等待信号量，这里的信号量初值为 1，因此程序不会一直阻塞在这里。等待信号量之后，我们使用 signal_sem 函数释放信号量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接着，我们使用 semctl 函数获取信号量的值，并打印出来。最后，我们使用 semctl 函数删除信号量集合</span></span><br></pre></td></tr></table></figure>
<h4 id="2-3-6-消息队列"><a href="#2-3-6-消息队列" class="headerlink" title="2.3.6 消息队列"></a>2.3.6 消息队列</h4><h5 id="创建键值ftok"><a href="#创建键值ftok" class="headerlink" title="创建键值ftok"></a>创建键值ftok</h5><h5 id="消息队列创建msgget"><a href="#消息队列创建msgget" class="headerlink" title="消息队列创建msgget"></a>消息队列创建msgget</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int msgget(key_t key, int msgflg);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    1. 如果给定的键值 key 对应的消息队列已经存在，则返回其标识符。</span><br><span class="line">    2. 如果给定的键值 key 对应的消息队列不存在，则根据给定的标志 msgflg 创建一个新的消息队列，并返回其标识符。</span><br><span class="line">头文件：</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/ipc.h&gt;</span><br><span class="line">    #include &lt;sys/msg.h&gt;</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回一个非负整数，表示消息队列的标识符。</span><br><span class="line">    失败：返回 -1，并设置 errno 错误码以指示错误的类型。</span><br><span class="line">参数：</span><br><span class="line">    -key：用于标识消息队列的键值。</span><br><span class="line">    -msgflg：用于指定消息队列的访问权限和创建方式的标志。</span><br><span class="line">            -IPC_CREAT：如果消息队列不存在，则创建一个新的消息队列，并返回其标识符。如果消息队列已经存在，则返回其标识符。</span><br><span class="line">            -IPC_EXCL：如果消息队列已经存在，则返回错误（EEXIST）。</span><br><span class="line">            -IPC_PRIVATE：创建一个新的消息队列，并将其关联到一个新的私有键值上。这种方式只能由当前进程及其子进程访问。</span><br><span class="line">注意：</span><br><span class="line">1. 在使用消息队列之前，必须先定义一个消息结构体，以便可以将消息传递到队列中。</span><br><span class="line">2. 在使用完消息队列后，应该使用 msgctl 函数删除它。可以通过设置 IPC_RMID 标志来删除消息队列。</span><br><span class="line"></span><br><span class="line">消息结构体：</span><br><span class="line">struct msgbuf &#123;</span><br><span class="line">    long mtype;</span><br><span class="line">    char mtext[MSG_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mtype的值可以用来区分不同的消息内容或不同的消息来源，也可以用来实现消息的优先级或过滤。</span><br></pre></td></tr></table></figure>
<h5 id="消息队列的发送msgsnd"><a href="#消息队列的发送msgsnd" class="headerlink" title="消息队列的发送msgsnd"></a>消息队列的发送msgsnd</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    将一个消息发送到指定的消息队列中。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/ipc.h&gt;</span><br><span class="line">    #include &lt;sys/msg.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：返回 0。</span><br><span class="line">    失败：返回 -1，并设置 errno 错误码以指示错误的类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    -msqid：要发送消息的消息队列标识符。</span><br><span class="line">    -msgp：指向一个消息结构体的指针，用于指定要发送的消息。消息结构体必须包含一个 long 类型的成员 mtype，表示消息类型。在发送消息之前，需要设置该成员的值。</span><br><span class="line">    -msgsz：要发送的消息的大小，以字节为单位。一般可以为(sizeof(MSG)-sizeof(long))即除 mtype 以外的消息部分的大小。</span><br><span class="line">    -msgflg：用于指定发送消息的行为的标志。0代表默认。它是一些位掩码，可以使用按位或运算符将它们组合在一起。常用的标志包括：</span><br><span class="line">        -IPC_NOWAIT：如果消息队列已满，则不等待并立即返回错误（EAGAIN）。</span><br><span class="line">        -MSG_NOERROR：如果消息的大小超过消息队列中定义的最大消息大小，则将消息截断并发送其截断后的部分，而不返回错误（但是，截断后的消息可能无法使用 msgrcv 函数完全接收）。</span><br></pre></td></tr></table></figure>

<h5 id="消息队列的接收msgrcv"><a href="#消息队列的接收msgrcv" class="headerlink" title="消息队列的接收msgrcv"></a>消息队列的接收msgrcv</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">功能：从指定的消息队列中接收一个消息，并将其存储到指定的消息结构体中。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/ipc.h&gt;</span><br><span class="line">    #include &lt;sys/msg.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：返回接收到的消息的大小（以字节为单位）。</span><br><span class="line">    失败：返回 -1，并设置 errno 错误码以指示错误的类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    -msqid：要接收消息的消息队列标识符。</span><br><span class="line">    -msgp：指向一个消息结构体的指针，用于存储接收到的消息。消息结构体必须包含一个 long 类型的成员 mtype，表示消息类型。在接收消息之前，需要设置该成员的值。</span><br><span class="line">    -msgsz：存储接收到的消息的缓冲区大小，以字节为单位。一般可以为(sizeof(MSG)-sizeof(long))</span><br><span class="line">    -msgtyp：要接收的消息类型。如果设置为 0，则接收队列中的第一条消息。一般要和要发送消息的结构体中的mtype中的值一样（有点像协议，两边约定同一个端口，即mtype的值）</span><br><span class="line">    -msgflg：用于指定接收消息的行为的标志。0表示默认。它是一些位掩码，可以使用按位或运算符将它们组合在一起。常用的标志包括：</span><br><span class="line">        -IPC_NOWAIT：如果消息队列中没有符合条件的消息，则立即返回错误（ENOMSG）。</span><br><span class="line">        -MSG_EXCEPT：用于指定接收队列中第一个不等于 msgtyp 的消息。如果没有这样的消息，则返回错误（ENOMSG）。</span><br><span class="line">        -MSG_NOERROR：如果消息的大小超过存储接收到的消息的缓冲区的大小，则将消息截断并接收其截断后的部分，而不返回错误。</span><br></pre></td></tr></table></figure>

<h5 id="内存空间中值的设定memset"><a href="#内存空间中值的设定memset" class="headerlink" title="内存空间中值的设定memset"></a>内存空间中值的设定memset</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">void *memset(void *s, int c, size_t n);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">将一段内存空间的前 n 个字节设置为指定的值。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">返回指向目标内存空间的指针 s。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    s：指向要填充的内存空间的指针。</span><br><span class="line">    c：要设置的值，以 int 类型表示，但实际上只使用一个字节。通常使用无符号字符（unsigned char）类型的值，例如 &#x27;<span class="tag">\</span>0&#x27; 或 0xFF。</span><br><span class="line">    n：要设置的字节数。</span><br></pre></td></tr></table></figure>
<h5 id="消息队列的示例代码"><a href="#消息队列的示例代码" class="headerlink" title="消息队列的示例代码"></a>消息队列的示例代码</h5><p>这里实现的是同一目录下的两个进程之间相互发送和接受信息，注意里面的key值要一样</p>
<p>A文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;MSG;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN (sizeof(MSG)-sizeof(long)) <span class="comment">//发送消息的大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPEA 100  <span class="comment">//A向B发送消息的类型，msgtyp</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPEB 200  <span class="comment">//B向A发送消息的类型，msgtyp</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">//创建键值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(key, IPC_CREAT|<span class="number">0666</span>); <span class="comment">//创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        msg.mtype = TYPEA;  <span class="comment">//设置消息类型</span></span><br><span class="line">        fgets(msg.mtext, <span class="number">1024</span>, <span class="built_in">stdin</span>); </span><br><span class="line">        ret = msgsnd(msgid, &amp;msg, LEN, <span class="number">0</span>); <span class="comment">//发送消息类型为TYPEA，大小为LEN的消息</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg)); <span class="comment">//将消息中的值清空</span></span><br><span class="line">        ret = msgrcv(msgid, &amp;msg, LEN, TYPEB, <span class="number">0</span>); <span class="comment">//接收消息类型为TYPEB，大小为LEN的消息</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv:%s\n&quot;</span>, msg.mtext);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>B文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;MSG;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN (sizeof(MSG)-sizeof(long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPEA 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPEB 200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(key, IPC_CREAT|<span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        ret = msgrcv(msgid, &amp;msg, LEN, TYPEA, <span class="number">0</span>);<span class="comment">//接收消息类型为TYPEA，大小为LEN的消息</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv:%s\n&quot;</span>, msg.mtext);</span><br><span class="line"></span><br><span class="line">        msg.mtype = TYPEB;</span><br><span class="line">        fgets(msg.mtext, <span class="number">1024</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        ret = msgsnd(msgid, &amp;msg, LEN, <span class="number">0</span>);<span class="comment">//发送消息类型为TYPEB，大小为LEN的消息</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-4-线程间同步和互斥"><a href="#2-4-线程间同步和互斥" class="headerlink" title="2.4 线程间同步和互斥"></a>2.4 线程间同步和互斥</h3><h4 id="2-4-1-同步"><a href="#2-4-1-同步" class="headerlink" title="2.4.1 同步"></a>2.4.1 同步</h4><ul>
<li><p>初始化信号量sem_init</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">sem_init() 函数用于初始化一个 POSIX 信号量（Semaphore），该信号量用于线程间或进程间同步和互斥访问共享资源。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">若调用成功则返回 0，否则返回 -1 并设置 errno 错误码。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">        sem：指向要初始化的信号量的指针。</span><br><span class="line">        pshared：指定信号量是线程共享还是进程共享，如果是线程共享，则 pshared 值为 0，否则为非零值。对于不同的进程，只有当它们都指定同一个 pshared 值时，它们才能够共享同一个信号量。</span><br><span class="line">        value：指定信号量的初值。如果初值为 0，则所有试图使用该信号量进行 wait 操作的线程或进程将会被阻塞。</span><br></pre></td></tr></table></figure>
</li>
<li><p>等待信号量sem_wait</p>
</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int sem_wait(sem_t *sem);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">sem_wait() 函数用于对指定的 POSIX 信号量进行 wait 操作，即尝试从信号量中取走一个资源，如果当前没有资源，则阻塞等待直到有资源可用。</span><br><span class="line">头文件：#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">若调用成功则返回 0，否则返回 -1 并设置 errno 错误码。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">sem：指向要进行 wait 操作的 POSIX 信号量的指针。</span><br></pre></td></tr></table></figure>
<p>示例代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">sem_t</span> empty, full, mutex;</span><br><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        item = rand() % <span class="number">100</span>; <span class="comment">// 生产一个随机数</span></span><br><span class="line">        sem_wait(&amp;empty); <span class="comment">// 等待缓冲区非满</span></span><br><span class="line">        sem_wait(&amp;mutex); <span class="comment">// 互斥访问缓冲区</span></span><br><span class="line">        buffer[in] = item; <span class="comment">// 将 item 放入缓冲区</span></span><br><span class="line">        in = (in + <span class="number">1</span>) % BUFFER_SIZE; <span class="comment">// 更新 in 指针</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者生产了 %d\n&quot;</span>, item);</span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// 释放缓冲区</span></span><br><span class="line">        sem_post(&amp;full); <span class="comment">// 增加缓冲区中的项目数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;full); <span class="comment">// 等待缓冲区非空</span></span><br><span class="line">        sem_wait(&amp;mutex); <span class="comment">// 互斥访问缓冲区</span></span><br><span class="line">        item = buffer[out]; <span class="comment">// 从缓冲区中取出一个项目</span></span><br><span class="line">        out = (out + <span class="number">1</span>) % BUFFER_SIZE; <span class="comment">// 更新 out 指针</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者消费了 %d\n&quot;</span>, item);</span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// 释放缓冲区</span></span><br><span class="line">        sem_post(&amp;empty); <span class="comment">// 增加缓冲区中的空闲位置数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    sem_init(&amp;empty, <span class="number">0</span>, BUFFER_SIZE); <span class="comment">// 初始化 empty 为 BUFFER_SIZE</span></span><br><span class="line">    sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 初始化 full 为 0</span></span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 初始化 mutex 为 1</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    sem_destroy(&amp;empty);</span><br><span class="line">    sem_destroy(&amp;full);</span><br><span class="line">    sem_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个生产者-消费者问题的解决方案，使用了信号量来实现线程之间的同步和互斥。其中，sem_init() 用于初始化信号量，sem_wait() 用于等待信号量的值变为非零，sem_post() 用于增加信号量的值。在生产者线程中，当缓冲区非满时，生产者将一个项目放入缓冲区，并增加缓冲区中的项目数；在消费者线程中，当缓冲区非空时，消费者从缓冲区中取出一个项目，并增加缓冲区中的空闲位置数。同时，为了保证线程之间的互斥访问，使用了一个互斥信号量 mutex。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-互斥锁"><a href="#2-4-2-互斥锁" class="headerlink" title="2.4.2 互斥锁"></a>2.4.2 互斥锁</h4><ul>
<li>创建互斥锁pthread_mutex_init</li>
</ul>
<p>设函数中有pthread_mutex_t mutex;</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);</span><br><span class="line"></span><br><span class="line">功能：pthread_mutex_init() 函数用于初始化一个互斥锁</span><br><span class="line">头文件：#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">若调用成功则返回 0，否则返回一个非零错误码。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">        mutex：指向要初始化的互斥锁的指针。</span><br><span class="line">        attr：指向 pthread_mutexattr_t 类型的互斥锁属性对象的指针。如果该参数为 NULL，则使用默认属性。</span><br></pre></td></tr></table></figure>

<ul>
<li>请求互斥锁pthread_mutex_lock</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pthread_mutex_lock(pthread_mutex_t *mutex);</span><br><span class="line"></span><br><span class="line">功能：pthread_mutex_lock() 函数用于请求锁，如果当前锁已被其他线程持有，则调用线程将会阻塞等待，直到锁被释放。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">若调用成功则返回 0，否则返回一个非零错误码。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">        mutex：指向要请求的互斥锁的指针。</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex); <span class="comment">// 请求锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running with the mutex locked.\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 模拟线程执行任务</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex); <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread has released the mutex.\n&quot;</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>); <span class="comment">// 初始化互斥锁</span></span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex); <span class="comment">// 请求锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread is running with the mutex locked.\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 模拟线程执行任务</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex); <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread has released the mutex.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex); <span class="comment">// 销毁互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>进程线程</tag>
      </tags>
  </entry>
</search>
