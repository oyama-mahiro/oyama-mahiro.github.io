<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言基础-递归</title>
    <url>/2020/04/28/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><font color="#7CFC00">基本概念</font></h1><p>C 语言允许函数调用它自己，这种调用的过程称为递归</p>
<a id="more"></a>

<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><blockquote>
<p>栈：一种数据结构，其特点为先进后出</p>
<blockquote>
<p>C 语言在执行代码时会从 main()开始依次将调用的函数放入栈中<br>放完后便将栈中的方法，从栈顶一个个取出并执行</p>
</blockquote>
</blockquote>
<p>如图( 计算 3! )：</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/diguis.jpg" alt="递归原理图"></p>
<p>解释：</p>
<ol>
<li>开始执行，先将<code>main( )</code>函数放入栈底并执行</li>
<li>遇到了<code>fun(3)</code>后把 <code>mian( )</code>函数暂时放在栈中，去调用<code>fun(3)</code>函数</li>
<li>执行<code>fun(3)</code>时又发现调用了<code>fun(2)</code>，又把<code>fun(2)</code>放入栈中去掉<code>fun(1)</code></li>
<li><code>fun(1)</code>时发现没有调用了( 此时<code>fun(1)</code>在栈顶 )，便开始返回，把返回值给了<code>fun(2)</code>，<code>fun(2)</code>也继续下面的语句，返回给了<code>fun(3)</code></li>
<li>最后<code>fun(3)</code>返回给<code>main( )</code>，<code>main( )</code>继续执行下面的语句</li>
</ol>
<p>由此可以看成递归的形成至少需要两个条件：</p>
<ol>
<li>变化的参数</li>
<li>递归终止条件</li>
</ol>
<blockquote>
<p>栈溢出：内存空间是有限的，分配给 C 程序的栈空间也是有限的，如果递归没有结束条件的话就会导致无限的调用，形成栈溢出</p>
</blockquote>
<hr>
<br>
<br>

<h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a><font color="#7CFC00">尾递归</font></h1><p>最简单的递归形式就是把递归调用置于函数的末尾，即正好在 <code>return</code> 语句之前。这种形式的递归被称为 <u>尾递归</u> (如上图所示)，它相当于循环。</p>
<p><strong>如果效果和循环差不多时最好使用循环</strong></p>
<hr>
<br>
<br>

<h1 id="递归的优缺点"><a href="#递归的优缺点" class="headerlink" title="递归的优缺点"></a><font color="#7CFC00">递归的优缺点</font></h1><p>递归的语法易被人理解，但空间成本消耗太大。所以在使用递归时要特别注意，尤其是<font color="red">效率优先</font>的程序</p>
<br>

<blockquote>
<p>注：main( )函数可以调用自己，且两函数间不可以相互调用</p>
</blockquote>
<hr>
<br>
<br>

<h1 id="递归算法实战-汉诺塔问题"><a href="#递归算法实战-汉诺塔问题" class="headerlink" title="递归算法实战-汉诺塔问题"></a><font color="#7CFC00">递归算法实战-汉诺塔问题</font></h1><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p>
<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>
<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1159565693,4014945639&fm=26&gp=0.jpg" alt="汉诺塔"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们倒着的开始，假如要移动 64 个</p>
<ol>
<li>我们要把上面的 63 个移动到 B</li>
<li>把第 64 个移动到 C</li>
<li>把 B 上的 63 个移动到 C</li>
</ol>
<p>那么就会产生问题了：怎么移动那 63 个呢<br>和上面的思路一样</p>
<ol>
<li>我们要把上面的 62 个移动到 B</li>
<li>把第 63 个移动到 C</li>
<li>把 B 上的 62 个移动到 C</li>
</ol>
<p>直到问题变为：怎么移动上面的那 1 个呢，这时我们就会了，移动了 1 个后，我们就会移动 2 个，移动 2 个后，我们就会第 3 个，依次下去，就能把 64 个都移动完了</p>
<p>所以整个过程是</p>
<ol>
<li>我们要把上面的<code>n-1</code>个移动到 B</li>
<li>把第<code>n</code>个移动到 C</li>
<li>把 B 上的<code>n-1</code>个移动到 C</li>
</ol>
<blockquote>
<p>其中移动 n-1 个盘子的操作是递归操作<br>1，3 步分别用了递归</p>
</blockquote>
<p>下面是 java 语言代码实现部分( <del>用 C 表达出来的效果不好啊，还是 java 的看着舒服</del> ，其实基本都是一样的):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        move(A.size(),A,B,C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从这开始看</span></span><br><span class="line">    <span class="comment">//盘子用数字代替，n代表需要移动的盘子数，List是盘子的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当需要移动的盘子数只有1个时，此时这个盘子就是最下面的，其它的都移动到B上(第一步)或者A(第三步)上了了</span></span><br><span class="line">        <span class="comment">// 把A的盘子直接移动到C就行了</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            C.add(A.remove(A.size()-<span class="number">1</span>)); <span class="comment">//注意这里是最下面的盘子数最大</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没到最上面时，则一直重复123步骤</span></span><br><span class="line">        move(n-<span class="number">1</span>,A,C,B); <span class="comment">//对应第一步</span></span><br><span class="line">        C.add(A.remove(A.size()-<span class="number">1</span>));  <span class="comment">//对应第二步</span></span><br><span class="line">        move(n-<span class="number">1</span>,B,A,C);  <span class="comment">//对应第三步</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<br>
<br>

<h1 id="递归总结"><a href="#递归总结" class="headerlink" title="递归总结"></a><font color="#7CFC00">递归总结</font></h1><p>要运用递归的地方都有以下的共同点</p>
<ol>
<li>拥有大量重复的步骤，或者说可将复杂的步骤转换为计算大但容易理解的重复步骤</li>
<li>拥有当达到某种条件时，可返回一个确定值，即遇见某种情况时可向前推导</li>
</ol>
<p>这样便可以将代表条件的变量设为函数参数，把步骤设为函数具体代码</p>
<hr>
<br>
<br>

<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a><font color="#7CFC00">推荐阅读</font></h1><p>知乎-<a href="https://www.zhihu.com/question/24385418">如何理解汉诺塔的递推</a><br><a href="https://leetcode-cn.com/explore/featured/card/recursion-i/">leetcode-递推</a>(有点难度)</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>C语言</tag>
        <tag>递归</tag>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础-存储类别</title>
    <url>/2020/05/09/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB/</url>
    <content><![CDATA[<h1 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a><font color="green">存储类别</font></h1><p>在理解存储类别前，先要复习一些概念和术语。</p>
<ul>
<li>对象：对于储存在内存中的数据，被储存的每个值都占用一定的物理内存。这样的一块内存成为对象(和面向对象的对象概念不同)</li>
<li>存储期：对象在内存中保留了多长的时间。</li>
<li>标识符用于访问对象，可以用<strong>作用域</strong>和<strong>链接</strong>描述标识符，表明了程序的哪些部分可以使用它。</li>
</ul>
<p>我们先介绍`作用域、链接和储存期的含义，再介绍具体的存储类别</p>
<a id="more"></a>

<h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h2><p>作用域描述程序中可访问标识符的区域。<br>一个C变量的作用域可以是:</p>
<ul>
<li>块作用域：花括号内的代码，if语句或循环所控制的代码</li>
<li>函数作用域：仅用于goto语句的标签。再块中定义但作用域是整个函数</li>
<li>函数原型作用域：从形参定义处到原型声明结束</li>
<li>文件作用域：定义在函数外面，从它的定义到该定义所在的文件的末尾均可见</li>
</ul>
<blockquote>
<p>注意：当一个源代码中包含一个或多个头文件时，会把所有头文件和编译器源代码文件都看成是一个包含信息的单独文件，文件作用域的实际可见范围是整个翻译单元</p>
</blockquote>
<h2 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h2><p>链接指该变量访问范围<br>C变量有3种链接属性：<strong>外部链接，内部链接或无链接</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;具有块作用域、函数作用域和函数原型作用域的变量都是无链接变量<br>&nbsp;&nbsp;&nbsp;&nbsp;文件作用域的变量可以是外部链接和内部链接，<br>&nbsp;&nbsp;&nbsp;&nbsp;内部链接变量比外部链接变量前面多了个static ，内部链接变量只能在翻译单元中使用，外部链接变量可以在多文件程序中使用</p>
<h2 id="3-存储期"><a href="#3-存储期" class="headerlink" title="3.存储期"></a>3.存储期</h2><p>作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。<br>C对象有4种存储期：</p>
<ol>
<li>静态存储期：关键字static，如果对象具有静态储存期，那么它在程序的执行期间一直存在   <font color="red">注意：文件作用域变量都具有静态存储期，但它的static表示的是其链接属性</font></li>
<li>线程存储期: _Thread_local</li>
<li>自动存储期: 通常是块作用域的变量所具有</li>
<li>动态分配存储期： 从声明处到块末尾而不是块头到末尾</li>
</ol>
<h2 id="5种存储类别"><a href="#5种存储类别" class="headerlink" title="5种存储类别"></a>5种存储类别</h2><table>
<thead>
<tr>
<th>存储类别</th>
<th>存储期</th>
<th>作用域</th>
<th>链接</th>
<th>声明方式</th>
</tr>
</thead>
<tbody><tr>
<td>自动(局部变量)</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内</td>
</tr>
<tr>
<td>寄存器</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内，使用关键字<code>register</code></td>
</tr>
<tr>
<td>静态外部链接(全局变量)</td>
<td>静态</td>
<td>文件</td>
<td>外部</td>
<td>所有函数外</td>
</tr>
<tr>
<td>静态内部链接(static全局变量)</td>
<td>静态</td>
<td>文件</td>
<td>内部</td>
<td>所有函数外，翻译单元中，使用关键字<code>static</code></td>
</tr>
<tr>
<td>静态无链接(静态局部变量)</td>
<td>静态</td>
<td>块</td>
<td>无</td>
<td>块内，使用关键字<code>static</code></td>
</tr>
</tbody></table>
<ul>
<li>如果内层块种声明的变量和外层块的变量同名时，优先内层块的变量</li>
<li>寄存器变量储存在寄存器中，所以无法获取其地址</li>
<li>局部静态变量在程序的执行时间一直存在但只能在块内部使用，其值有继承性（就像Java里面的成员变量）</li>
<li>要在外部使用全局变量或在块中使用全局变量或static全局变量。也必须先声明，而且声明前面要加关键字extern</li>
<li>局部变量和静态局部变量在本文件中只能在声明后使用</li>
</ul>
<h3 id="存储类别的初始化"><a href="#存储类别的初始化" class="headerlink" title="存储类别的初始化"></a>存储类别的初始化</h3><ul>
<li>局部变量不会初始化，但其变量值是分配空间范围中的任意值</li>
<li>静态变量如未人为初始化，则自动初始化为0</li>
</ul>
<h3 id="存储类别说明符"><a href="#存储类别说明符" class="headerlink" title="存储类别说明符"></a>存储类别说明符</h3><ul>
<li>auto:声明局部变量，可忽略</li>
<li>register:声明寄存器变量</li>
<li>static:声明静态类型</li>
<li>extern:  声明时调用（全局/static全局） 变量</li>
<li>_Thread_local：声明线程存储期，可以和 static或extern一起使用</li>
</ul>
<hr>
<br>

<h2 id="存储类别与函数"><a href="#存储类别与函数" class="headerlink" title="存储类别与函数"></a>存储类别与函数</h2><p>函数也有存储类别。</p>
<ul>
<li>外部函数<blockquote>
<p>double a(int i)</p>
</blockquote>
</li>
<li>静态函数<blockquote>
<p>static double a(int i)</p>
</blockquote>
</li>
<li>内联函数<blockquote>
<p>extern double a(int i)</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>C语言</tag>
        <tag>基础</tag>
        <tag>存储类别</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown笔记-基础</title>
    <url>/2020/04/26/Markdown%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Markdown-概述"><a href="#Markdown-概述" class="headerlink" title="Markdown 概述"></a>Markdown 概述</h1><p>Markdown 是一种轻量级标记语言，与 2004 年创建。<br>后缀为<code>.md</code>或<code>.maekdown</code>，可导出 HTML，Word，pdf 等多种格式文档</p>
<a id="more"></a>

<hr>
<br>

<h1 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h1><h2 id="1-使用-和-标记一级和二级标题"><a href="#1-使用-和-标记一级和二级标题" class="headerlink" title="1.使用=和-标记一级和二级标题"></a>1.使用=和-标记一级和二级标题</h2><blockquote>
<p>这是一级标题<br>==========<br>这是二级标题<br>-—————–</p>
</blockquote>
<h2 id="2-使用-号标记标题"><a href="#2-使用-号标记标题" class="headerlink" title="2.使用#号标记标题"></a>2.使用#号标记标题</h2><blockquote>
<p># 一级标题<br>## 二级标题<br>### 三级标题<br>…<br>###### 六级标题</p>
</blockquote>
<p><strong>注：#后要加空格</strong></p>
<hr>
<br>
<br>

<h1 id="Markdown-段落与字体格式"><a href="#Markdown-段落与字体格式" class="headerlink" title="Markdown 段落与字体格式"></a>Markdown 段落与字体格式</h1><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>1.在段落末尾使用两个以上空格加回车为换行</p>
<p>2.在段落与段落之间留出一个空行为换段落</p>
<h2 id="字体格式"><a href="#字体格式" class="headerlink" title="字体格式"></a>字体格式</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><blockquote>
<p>*斜体文本* &gt; _斜体文本_ &gt; **粗体文本** &gt;__粗体文本__ &gt; ***粗斜体文本*** &gt;___粗斜体文本___</p>
</blockquote>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>&nbsp; 在一行内用三个以上的星号，减号，下划线，在建立一个分割线<br>&nbsp; 注意：行内不能有其他东西</p>
<blockquote>
<p>***<br> -–<br>_ _ _<br>-———–</p>
</blockquote>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a><del>删除线</del></h3><p>&nbsp; 如果要在文字上添加删除线，则在文字两端加上两个波浪线~~</p>
<blockquote>
<p>~~要删除线的文字~~</p>
</blockquote>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>&nbsp; <u>下划线</u>可以通过 HTML 的<code>&lt;u&gt;</code>标签来实现</p>
<blockquote>
<p>&lt;u&gt;带下划线的文本&lt;/u&gt;</p>
</blockquote>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>&nbsp; 在需要脚注<a href="%E6%97%A0%E8%AE%BA%E5%86%99%E4%BB%80%E4%B9%88%E8%84%9A%E6%B3%A8%E5%90%8D%EF%BC%8C%E6%9C%80%E5%90%8E%E9%83%BD%E4%BC%9A%E5%8F%98%E6%88%90%E6%95%B0%E5%AD%97%E6%8E%92%E5%88%97%E6%96%B9%E5%BC%8F">^像这样</a>的文字后写[^脚注名]，并在后面的某个地方用[^要注明的文本]: 内容 来使用脚注。<u>且无论写什么脚注名，最后都会变成数字排列方式</u></p>
<blockquote>
<p>[^脚注名]</p>
<p>[^脚注名]: 脚注内容</p>
</blockquote>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;将选中的文字用灰色背景加重（<code>像这样</code>）,就在文字的两旁加`</p>
<blockquote>
<p>`文字`</p>
</blockquote>
<h3 id="特殊符号失效"><a href="#特殊符号失效" class="headerlink" title="特殊符号失效"></a>特殊符号失效</h3><p>&nbsp; 如果想让特殊符号失效，即打出原有符号样子(如#),则在特殊符号前加反切线\</p>
<blockquote>
<p>\<br> \&lt;\u&gt;…&lt;/u&gt;</p>
</blockquote>
<hr>
<br>
<br>

<h1 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h1><p>&nbsp; Markdown 支持有序列表和无序列表（在标记后面要有空格）</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记</p>
<blockquote>
<p>* 第一项<br>* 第二项<br>* 第三项</p>
<p>+ 第一项<br>+ 第二项<br>+ 第三项</p>
<p>- 第一项<br>- 第二项<br>- 第三项</p>
</blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<br>

<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表使用数字加上<code>.</code>号来表示，如：</p>
<blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
</blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<hr>
<br>
<br>

<h1 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h1><p>Markdown 区块引用时在段落开头使用&gt;号，后面要跟个空格符号</p>
<blockquote>
<p>&gt;区块内文字,效果就是这像一行一样出现阴影</p>
<blockquote>
<p>打多个&gt;还可以还可以内嵌(如这行的&gt;&gt;)</p>
</blockquote>
</blockquote>
<ol>
<li>区块中使用列表的话，就在&gt;后面用列表语法就行<blockquote>
<p>&gt; 1. 第一项<br>&gt; 2. 第二项<br>&gt; 3. 第三项</p>
<p>&gt; + 第一项<br>&gt; + 第二项<br>&gt; + 第三项</p>
</blockquote>
</li>
</ol>
<br>

<ol start="2">
<li>列表中使用区块，则要在&gt;前添加四个空格的缩进</li>
</ol>
<blockquote>
<p>* 第一项<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;区块内容<br>* 第二项</p>
</blockquote>
<p>效果如下：</p>
<ul>
<li>第一项<blockquote>
<p>区块内容</p>
</blockquote>
</li>
<li>第二项</li>
</ul>
<hr>
<br>
<br>

<h1 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h1><ul>
<li>如果是段落上的一个函数或片段的代码可以用反引号(`)将内容包起来</li>
</ul>
<blockquote>
<p>`printf()`函数</p>
</blockquote>
<p><code>printf()</code>函数<br><br></p>
<ul>
<li>如果是代码区块，则使用 4 个空格或者一个制表符(Tab 键)</li>
</ul>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 代码内容</p>
</blockquote>
<pre><code>public static void main(String[] args)&#123;
    System.out.println(&quot;hello,world&quot;)
&#125;</code></pre>
<br>

<ul>
<li>也可以用 ``` …. ``` 来包裹一段代码，还可以在```后面指定一种语言</li>
</ul>
<blockquote>
<p>```java<br>public static void main(String[] args){<br>System.out.println(“hello,world”)<br>}<br>```</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<br>
<br>

<h1 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h1><ul>
<li>普通方式</li>
</ul>
<blockquote>
<p>[链接名称](链接地址)<br>或者&lt;链接地址&gt;</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/3b638180e42c">技术文档书写规范</a></p>
<p><a href="https://www.jianshu.com/p/3b638180e42c">https://www.jianshu.com/p/3b638180e42c</a><br><br></p>
<ul>
<li>高级链接<br>如果链接太长时，可在[连接名称]后面设置一个[标签名],则可在后面的任意位置写[标签名]: 链接<br><strong>注意：<code>[标签名]:</code> 冒号前面以及两个中括号之间[][]不要留空格</strong></li>
</ul>
<blockquote>
<p>[技术文档书写规范][1]<br>[csdn 官网][csdn]</p>
<p>[1]: <a href="https://www.jianshu.com/p/3b638180e42c">https://www.jianshu.com/p/3b638180e42c</a> &gt;[csdn]: <a href="https://www.csdn.net/">https://www.csdn.net/</a></p>
</blockquote>
<p><a href="https://www.jianshu.com/p/3b638180e42c">技术文档书写规范</a><br><a href="https://www.csdn.net/">csdn 官网</a></p>
<hr>
<br>
<br>

<h1 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote>
<p>![alt 属性文本](图片地址)</p>
<p>![alt 属性文本](图片地址 “title 属性文本”)</p>
</blockquote>
<p>alt 为图片加载出错时的代替文本<br>title 为鼠标放在图片上时所显示的文字</p>
<h2 id="图片地址的传入方法"><a href="#图片地址的传入方法" class="headerlink" title="图片地址的传入方法"></a>图片地址的传入方法</h2><ol>
<li>通过图床将图上传到网上后使用图片的链接<blockquote>
<p>![图片加载出错](<a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg">https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http%3A%2F%2Fgss0.baidu.com%2F-4o3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2F810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg</a> “这是 title 属性”)</p>
</blockquote>
</li>
</ol>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587895752391&di=e2f0ba8e2108ab4f04b19700233f121f&imgtype=0&src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg" alt="图片加载出错" title="这是title属性"><br><br></p>
<ol start="2">
<li>将图片存入本地，通过 <a href="https://blog.csdn.net/chudelong1/article/details/90697409">绝对路径/相对路径</a> 来加载图片(相对路径是以当前的 md 文件所在目录为起点)</li>
</ol>
<blockquote>
<p>![图片出不来了](./mdphoto/markdownlearn/0.jpg)</p>
</blockquote>
<p><img src="/2020/04/26/Markdown%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/0.jpg" alt="图片出不来了"></p>
<p>当然，当地址过长时也可以像链接那样将(…)变成变量名</p>
<blockquote>
<p>![图片加载出错][photo 1]</p>
<p>[photo 1]: <a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg">https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http%3A%2F%2Fgss0.baidu.com%2F-4o3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2F810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg</a></p>
</blockquote>
<p><strong><u>注意：如果是想将本地连接的图片通过 hexo 传到远端时，直接使用是无效的,要实现下列步骤</u></strong></p>
<ol>
<li>配置 hexo 根下的<code>_config.yml</code>里面的<code>post_asset_folder:false</code>这个选项设置为<code>true</code>。</li>
<li>git bash 安装插件：<code>npm install https://github.com/7ym0n/hexo-asset-image --save</code> , 安装之后再生成新 md 文件时同目录下会出现同名的文件夹，图片可放进那里</li>
<li>这时再使用上面的语法便能成功</li>
</ol>
<hr>
<br>
<br>

<h1 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h1><p>&nbsp; Markdown 中制作表格用<code>|</code>来分割不同的单元格，用<code>-</code>在分割表头和其它行</p>
<blockquote>
<p>|表头 1|表头 2|表头 3|<br>| :&nbsp;—&nbsp;&nbsp; &nbsp;|:&nbsp;&nbsp; —&nbsp;&nbsp;: |&nbsp;&nbsp;&nbsp;—&nbsp;&nbsp;: |<br>|左对齐|中对齐|右对齐|<br>|左对齐效果|中对齐效果|右对齐效果|</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">表头 1</th>
<th align="center">表头 2</th>
<th align="right">表头 3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">左对齐</td>
<td align="center">中对齐</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td align="left">左对齐效果</td>
<td align="center">中对齐效果</td>
<td align="right">右对齐效果</td>
</tr>
</tbody></table>
<br>
<br>

<p>还能设置表格的对齐方式(默认向左对齐)：</p>
<ul>
<li><strong><code>-:</code></strong> 设置内容和标题栏右对齐</li>
<li><strong><code>:-:</code></strong> 设置内容和标题栏中对齐</li>
<li><strong><code>:-</code></strong> 设置内容和标题栏左对齐</li>
</ul>
<p><strong>注：最右边的<code>|</code>可以省略</strong></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Markdown基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day11-c数组与指针</title>
    <url>/2023/03/08/day11-c%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="day11-c数组与指针"><a href="#day11-c数组与指针" class="headerlink" title="day11-c数组与指针"></a><font color="green">day11-c数组与指针</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><p>​    字符数组和字符串</p>
<p>​        字符数组：存放的数据是字符数据</p>
<p>​        字符串：由一个或者多个字符组成，在字符串的末尾有一个隐藏的空字符 – ‘\0’</p>
<p>​        char a[50] = “hello”;    </p>
<a id="more"></a>

<h3 id="2-字符串函数："><a href="#2-字符串函数：" class="headerlink" title="2.字符串函数："></a>2.字符串函数：</h3><blockquote>
<p>字符串长度函数 – strlen()<br>字符串连接函数– strcat()<br>字符串拷贝函数 – strcpy()<br>字符串比较函数– strcmp()</p>
</blockquote>
<p><strong>注：<code>int a[10]=&#123;0&#125;</code>相当于把数组a中的所有元素给赋值成’\0’，但是<font color="red">int a[arr]={0}</font>则错误，因为在数组长度为变量时不能同时进行赋值</strong><br><strong>同时也不能把字符串常量赋值给一个字符数组，因为字符数组本身也是个常量 <font color="red">char s[10];s=”abcdefg”</font>是错误的。</strong></p>
<br>
<br>

<hr>
<h2 id="二、指针"><a href="#二、指针" class="headerlink" title="二、指针"></a>二、指针</h2><h3 id="1、指针相关运算符"><a href="#1、指针相关运算符" class="headerlink" title="1、指针相关运算符"></a>1、指针相关运算符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;:获取内容的地址</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">	&amp;a --&gt; 获取到a的地址</span><br><span class="line">    </span><br><span class="line">*：获取地址中的内容</span><br><span class="line">    *(&amp;a) == a == <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、指针变量"><a href="#2、指针变量" class="headerlink" title="2、指针变量"></a>2、指针变量</h3><p>​    指针变量就是用于存放地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; *指针变量名;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">//将a的地址存放在了一个名为p的指针变量中</span></span><br><span class="line">p == &amp;a;</span><br><span class="line">*p = *(&amp;a) == a == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="3、指针变量的赋值"><a href="#3、指针变量的赋值" class="headerlink" title="3、指针变量的赋值"></a>3、指针变量的赋值</h3><p>赋值运算符的左值和右值类型一定要相同</p>
<p>(1)将一个变量的地址赋值给一个具有相同数据类型的指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>(2)将一个已有的指针赋值给一个 具有相同数据类型的指针变量</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *q = p;</span><br><span class="line"></span><br><span class="line">q == p == &amp;a;</span><br></pre></td></tr></table></figure>

<p>(3)将0值赋值给一个指针变量 – 空指针</p>
<p>野指针：定义一个指针，没有明确指向，不能访问野指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>(4)将一个数组的数组名赋值给一个具有相同数据类型的指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a; <span class="comment">// a == &amp;a[0]</span></span><br></pre></td></tr></table></figure>

<p>(5)把一个复合形式的表达式的值赋给一个具有相同数据类型的指针变量</p>
<h3 id="4、指针的运算"><a href="#4、指针的运算" class="headerlink" title="4、指针的运算"></a>4、指针的运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">// &amp;a == 0x2000</span></span><br><span class="line">p+n --&gt; p向高地址位偏移n个元素大小的字节数  <span class="comment">//元素指，该指针指向的内容</span></span><br><span class="line">p-n --&gt; p向低地址位偏移n个元素大小的字节数</span><br><span class="line"></span><br><span class="line">p+n == p+n*<span class="keyword">sizeof</span>(元素类型)  <span class="comment">//在该例中元素类型为int</span></span><br><span class="line">    </span><br><span class="line">注意：指针运算中没有 指针 + 指针、指针 * 指针、 指针 / 指针，因为没有任何实际意义 </span><br><span class="line">    但是有指针 - 指针</span><br><span class="line">    </span><br><span class="line">    指针-指针表示相同类型的两个指针之间相差多少个元素,结果的正负，仅代表地址高低</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">	<span class="keyword">int</span> *q = &amp;b;</span><br><span class="line">	q - p ==  (q-p)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="5、指针和一维数组"><a href="#5、指针和一维数组" class="headerlink" title="5、指针和一维数组"></a>5、指针和一维数组</h3><p>将一个一维数组的数组名赋值给一个具有相同数据类型的指针变量, 我们就可以通过该指针访问数组中所有元素</p>
<blockquote>
<p><strong>注：数组名不能递增递减</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line">*p == a[<span class="number">0</span>];</span><br><span class="line">*(p+<span class="number">1</span>) == a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p++; <span class="comment">// p = p+1; right</span></span><br><span class="line">a++; <span class="comment">// a = a+1; error  数组名不能递增递减</span></span><br><span class="line"></span><br><span class="line">数组a中的第三个元素的表达方式:</span><br><span class="line">	a[<span class="number">2</span>]、 *(p+<span class="number">2</span>)、 *(&amp;a[<span class="number">2</span>])、p[<span class="number">2</span>]、 *(a+<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h3 id="6、指针和二维数组-–-行指针（数组指针）"><a href="#6、指针和二维数组-–-行指针（数组指针）" class="headerlink" title="6、指针和二维数组 – 行指针（数组指针）"></a>6、指针和二维数组 – 行指针（数组指针）</h3><p>​    本质：数组指针是一个指针，存放的内容是地址，指针指向的内容是一个一维数组</p>
<p>​    二维数组的数组名是一个行指针，指向二维数组的首地址，行指针+n相当于地址偏移n行元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//行指针的定义一般形式</span></span><br><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; (*指针变量名)[列数];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line"></span><br><span class="line">*(*(p+<span class="number">1</span>)+<span class="number">2</span>) == 第二行第三个元素</span><br><span class="line">*(*(p+<span class="number">0</span>)+<span class="number">1</span>) == 第一行第二个元素</span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">258</span>;                                                      </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)&amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(++p));</span><br><span class="line">  &#125;</span><br><span class="line">  ````</span><br><span class="line">程序运行结果是  &lt;u&gt;2,1&lt;/u&gt;  </span><br><span class="line"></span><br><span class="line">解：<span class="number">258</span>的<span class="number">16</span>进制为<span class="number">102</span>，按照<span class="keyword">int</span>的存储方式为 <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span>，p指针先到<span class="number">02</span>，因为转移到<span class="keyword">char</span>后+<span class="number">1</span>为前进一个字符，则p指针跳到了<span class="number">01.</span>  </span><br><span class="line"></span><br><span class="line">### <span class="number">2.</span> </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *arr[<span class="number">3</span>]=&#123;a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>]&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<p>程序运行结果是  <u>8</u></p>
<p>解：arr数组里的都是指针，sizeof指向第一个元素即指针，所以大小为8，不是a[0][3]中的12.</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>&emsp;若有以下说明和语句，int c[4][5],(*p)[5];p=c;能正确引用c数组元素的是<u> D</u>.<br>(A) p+1      (B) *(p+3)     　(C) *(p+1)+3   (D) *(p[0]+2) </p>
<p>解：b错误原因是p+3仅代表地址，加个*只能表示p[3].</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>C语言</tag>
        <tag>指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>day12-c指针</title>
    <url>/2023/03/08/day12-c%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="day12-c指针"><a href="#day12-c指针" class="headerlink" title="day12-c指针"></a><font color="green">day12-c指针</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、指针变量的赋值"><a href="#1、指针变量的赋值" class="headerlink" title="1、指针变量的赋值"></a>1、指针变量的赋值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> *q = p;   <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">char</span> *m = <span class="literal">NULL</span>; <span class="comment">//空指针 3</span></span><br><span class="line"><span class="keyword">int</span> *n = b; <span class="comment">// n == &amp;b[0] //4</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>


<h3 id="2、指针变量的运算"><a href="#2、指针变量的运算" class="headerlink" title="2、指针变量的运算"></a>2、指针变量的运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p+n --&gt; 向高地址位偏移n个元素的字节数</span><br><span class="line">p-n --&gt; 向低地址位偏移n个元素的字节数</span><br><span class="line">    </span><br><span class="line">指针-指针：计算两个相同类型的指针之间相差的元素个数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、指针和一维数组"><a href="#3、指针和一维数组" class="headerlink" title="3、指针和一维数组"></a>3、指针和一维数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line">*p == a[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4、指针和二维数组"><a href="#4、指针和二维数组" class="headerlink" title="4、指针和二维数组"></a>4、指针和二维数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">二维数组的数组名也表示整个二维数组的首地址。但是是一个行地址</span><br><span class="line"></span><br><span class="line">    数组指针定义的一般形式：</span><br><span class="line">    	&lt;存储类型&gt; &lt;数据类型&gt; (*数组指针名)[列数];</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	a == &amp;a[<span class="number">0</span>] </span><br><span class="line">	a+<span class="number">1</span> == &amp;a[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line">	*(*(p+<span class="number">1</span>)+<span class="number">1</span>) --&gt; 二维数组中第二行第二个元素</span><br></pre></td></tr></table></figure>

<hr>
<br>
<br>

<h2 id="二、指针"><a href="#二、指针" class="headerlink" title="二、指针"></a>二、指针</h2><h3 id="1、指针数组"><a href="#1、指针数组" class="headerlink" title="1、指针数组"></a>1、指针数组</h3><p>​        数组指针(行指针)：本质是指针，存放地址值，指向的内容是一个一维数组的地址</p>
<p>​        指针数组：本质是数组。如果一个数组中所有元素都是地址，那么该数组称为指针数组</p>
<h3 id="2、指针数组的定义"><a href="#2、指针数组的定义" class="headerlink" title="2、指针数组的定义"></a>2、指针数组的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; *数组名[元素个数];</span><br><span class="line">	例：</span><br><span class="line">    	<span class="keyword">int</span> a, b, c;</span><br><span class="line">		<span class="keyword">int</span> *addr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;</span><br><span class="line">		addr[<span class="number">0</span>] == &amp;a;</span><br><span class="line">		addr[<span class="number">1</span>] == &amp;b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、多级指针–二级指针-难点"><a href="#3、多级指针–二级指针-难点" class="headerlink" title="3、多级指针–二级指针(难点)"></a>3、多级指针–二级指针(<strong>难点</strong>)</h3><p>​    定义一个指针变量，有几个星号就是几级指针</p>
<p>​    二级指针的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; **指针变量名;</span><br><span class="line">例：</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">	<span class="keyword">int</span> **q = &amp;p;</span><br><span class="line">	</span><br><span class="line">	*q == p == &amp;a</span><br><span class="line">	**q == *p == *&amp;a == a == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>注意</strong>：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line"><span class="keyword">int</span> *q[<span class="number">2</span>] = &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;;</span><br><span class="line"></span><br><span class="line">p:数组指针名，p+<span class="number">1</span>偏移一行数据大小</span><br><span class="line">q:指针数组名，q+<span class="number">1</span>偏移一个指针大小</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **x = p; <span class="comment">//error****</span></span><br><span class="line"><span class="keyword">int</span> **x = q;  <span class="comment">//right</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4、const指针"><a href="#4、const指针" class="headerlink" title="4、const指针"></a>4、const指针</h3><p>​    const修饰的变量为只读属性，不能直接修改该变量的值</p>
<p>​    const指针</p>
<p>​    (1)const 数据类型 *指针变量名;</p>
<p>​         数据类型 const *指针变量名;    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//right</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error  *p被修饰为只读</span></span><br></pre></td></tr></table></figure>

<p>​        const修饰是指针指向的内容，不能修改指针指向的数据，但是可以修改指针变量中的地址值</p>
<p>​    </p>
<p>​    (2)数据类型 *  const  指针变量名；   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error p被修饰为只读</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//right</span></span><br></pre></td></tr></table></figure>

<p>​    const修饰的指针变量p，不能修改指针变量的值，但是可以修改指针指向内容的值</p>
<p>（3）const 数据类型 *  const  指针变量名；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error p被修饰为只读</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error *p被修饰为只读</span></span><br></pre></td></tr></table></figure>

<p>​    const同时修饰指针变量和指针指向内容，两者都不能修改</p>
<h3 id="5、void指针"><a href="#5、void指针" class="headerlink" title="5、void指针"></a>5、void指针</h3><p>​        void – 空类型，不确定类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br><span class="line">指针p中可以存放任意类型的地址值</span><br><span class="line">*p = <span class="number">2</span>;  <span class="comment">//error  void指针在使用之前需要将void类型指针强制转换为需要的类型</span></span><br><span class="line">*(<span class="keyword">int</span> *)p = <span class="number">2</span>; <span class="comment">//right</span></span><br></pre></td></tr></table></figure>



<h3 id="6、字符指针和字符串"><a href="#6、字符指针和字符串" class="headerlink" title="6、字符指针和字符串"></a>6、字符指针和字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">50</span>] = &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">&quot;hello&quot;</span>; <span class="comment">//right</span></span><br><span class="line">如果将一个字符串赋值给一个字符指针，相当于把该字符串的首地址赋值给字符指针变量</span><br><span class="line"></span><br><span class="line">注意：如果将一个字符串常量赋值给一个指针变量，那么通过该指针不能修改字符串每一个字符的值</span><br></pre></td></tr></table></figure>


<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>若有以下定义，且0≤i＜4，则不正确的赋值语句是<u>&emsp;B&emsp;</u>.<br>int b[4][6], *p, *q[4];<br>（A）q[i] = b[i];           （B） p = b;<br>（C）p = b[i]               （D） q[i] = &amp;b[0][0];</p>
<p>解：表示b的话要用二次指针来表示二维数组的地址。这样的话*p仅代表所对应的行地址</p>
<p>​    </p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>指针</tag>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>day13-c指针，函数</title>
    <url>/2023/03/08/day13-c%E6%8C%87%E9%92%88%EF%BC%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="day13-c指针，函数"><a href="#day13-c指针，函数" class="headerlink" title="day13-c指针，函数"></a><font color="green">day13-c指针，函数</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、指针数组"><a href="#1、指针数组" class="headerlink" title="1、指针数组"></a>1、指针数组</h3><p>​    本质：数组</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt;*指针数组名[元素个数];</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> b[<span class="number">50</span>] = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">50</span>] = <span class="string">&quot;qwe&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> *p[<span class="number">3</span>] = &#123;a, b, c&#125;;</span><br><span class="line">	p[<span class="number">0</span>] == a;</span><br><span class="line">	p[<span class="number">2</span>] == b;</span><br><span class="line">	p[<span class="number">3</span>] <span class="comment">//error</span></span><br><span class="line">    *(p[<span class="number">0</span>]) == <span class="string">&#x27;h&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">char</span> **q = p = &amp;a;</span><br><span class="line">	q+<span class="number">1</span> = p+<span class="number">1</span> = &amp;b;</span><br><span class="line">	*q = *p = *(&amp;a) == a;</span><br><span class="line">	**q = *a = <span class="string">&#x27;h&#x27;</span>     </span><br><span class="line">        </span><br><span class="line">    p == &amp;p[<span class="number">0</span>];    </span><br><span class="line">        </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> *p[<span class="number">2</span>] = &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;;</span><br><span class="line">	*(p[<span class="number">0</span>]) == **p == p[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、二级指针"><a href="#2、二级指针" class="headerlink" title="2、二级指针"></a>2、二级指针</h3><p>​     将一级指针的地址称为二级指针</p>
<p>​        int a = 2;</p>
<p>​        int *p = &a;</p>
<p>​        int **q = &p;  //q就是定义的一个二级指针，地址中存放一级指针的值</p>
<h3 id="3、const指针"><a href="#3、const指针" class="headerlink" title="3、const指针"></a>3、const指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//right</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<h3 id="4、void指针"><a href="#4、void指针" class="headerlink" title="4、void指针"></a>4、void指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br><span class="line">p+<span class="number">1</span> <span class="comment">// error  void类型指针在使用时需要类型强转</span></span><br><span class="line">(<span class="keyword">int</span> *)p+<span class="number">1</span> <span class="comment">// 偏移4字节</span></span><br><span class="line">(<span class="keyword">char</span> *)p+<span class="number">1</span> <span class="comment">// 偏移1字节</span></span><br><span class="line"></span><br><span class="line">注意：<span class="keyword">void</span>类型的指针不能使用递增递减运算符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、字符指针和字符串"><a href="#5、字符指针和字符串" class="headerlink" title="5、字符指针和字符串"></a>5、字符指针和字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">6</span>] = <span class="string">&quot;haha&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">&quot;hello&quot;</span>; <span class="comment">//将字符串hello的首地址赋值给指针变量p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *p); <span class="comment">//right</span></span><br><span class="line">*p = <span class="string">&#x27;z&#x27;</span>; <span class="comment">//error hello是一个字符串常量，不能修改里面的字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;asd&quot;</span>); <span class="comment">//error</span></span><br><span class="line"><span class="built_in">strcpy</span>(a, <span class="string">&quot;asd&quot;</span>); <span class="comment">//right	</span></span><br></pre></td></tr></table></figure>



<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><p>概念：函数是一个实现特定功能的代码模块，函数有返回值，也可能没有</p>
<p>​            返回值：函数的结果</p>
<h3 id="1、函数的封装-定义"><a href="#1、函数的封装-定义" class="headerlink" title="1、函数的封装(定义)"></a>1、函数的封装(定义)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">	&lt;数据类型&gt; 函数名(形式参数)</span><br><span class="line">	&#123;</span><br><span class="line">    	功能代码模块;  <span class="comment">//语句块</span></span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">return</span> 表达式; </span><br><span class="line">	&#125;</span><br><span class="line">	数据类型：跟函数返回值的类型一致，如果一个函数没有返回值，则填<span class="keyword">void</span></span><br><span class="line">    函数名：遵循标识符标识符的命名规范，函数命名一般和功能相关。函数名也代表函数的起始地址</span><br><span class="line">    形式参数：形式参数决定了，函数调用时需要传入的实参的个数、类型、顺序，多个形式参数之间用逗号隔开。</span><br><span class="line">    如果函数不需要形式参数，可以省略不写，或者填<span class="keyword">void</span></span><br><span class="line">    <span class="keyword">return</span>：函数结束的标志，后面的表达式的值为函数的结果。如果没有返回值，可以选择不填或者只填<span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="2、函数的调用"><a href="#2、函数的调用" class="headerlink" title="2、函数的调用"></a>2、函数的调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    函数名(实际参数);</span><br><span class="line">	实际参数必须跟形式参数的个数、类型、顺序一致。如果没有形式参数，那么实际参数可以省略</span><br></pre></td></tr></table></figure>

<h3 id="3、函数的声明"><a href="#3、函数的声明" class="headerlink" title="3、函数的声明"></a>3、函数的声明</h3><p>​    在使用函数之前需要对函数进行函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">声明的一般形式：</span><br><span class="line">   &lt;数据类型&gt; 函数名(形式参数); 	</span><br><span class="line"></span><br><span class="line">	函数的声明中变量名是可以省略的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在add.h中声明了#include &lt;stdio.h&gt;后，在其他要用到#include &lt;stdio.h&gt;的函数中可以直接声明#include”add.h”就行。</p>
</blockquote>
<h3 id="4、头文件一般格式"><a href="#4、头文件一般格式" class="headerlink" title="4、头文件一般格式"></a>4、头文件一般格式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ADD_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ADD_H__</span></span><br><span class="line"></span><br><span class="line">头文件声明</span><br><span class="line"></span><br><span class="line">函数声明</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、函数的传参"><a href="#5、函数的传参" class="headerlink" title="5、函数的传参"></a>5、函数的传参</h3><p>(1)赋值传递</p>
<p>&emsp;&emsp;在调用函数时，将普通变量的值直接赋值给形参。因为形式参数和实际参数在内存中存储的地址不同，所以        在函数中无论怎样改变形式参数的值，对实际参数是没有任何影响的</p>
<p>(2)地址传递</p>
<p>&emsp;&emsp;在调用函数时，将普通变量的地址直接赋值给形参。可以通过修改形式参数，间接修改实参的值</p>
<p>(3)全局变量</p>
<p>&emsp;&emsp;因为全局变量的作用域在整个文件中有效，所有在当前文件的任何一个函数中都可以当作参数使用</p>
<h3 id="6、数组传参"><a href="#6、数组传参" class="headerlink" title="6、数组传参"></a>6、数组传参</h3><p>&emsp;&emsp;数组传参需要传入指定数组的首地址，如果该数组是一个整型数组，那么在传入数组首地址的同时，还需要传入数组元素的个数</p>
<hr>
   <br>
   <br>

<h2 id="7、易错点"><a href="#7、易错点" class="headerlink" title="7、易错点"></a>7、易错点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>]=a; <span class="comment">//error</span></span><br><span class="line"><span class="keyword">int</span> *p=a;<span class="comment">//error</span></span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]);<span class="comment">//error一定为8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row=a[<span class="number">1</span>]-a[<span class="number">0</span>];   <span class="comment">//二维数组列数计算，用下一行的地址减去第一行的地址。即使二维数组只有一列也行</span></span><br><span class="line"><span class="keyword">int</span> line=<span class="keyword">sizeof</span>(a)/(row*<span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));​   <span class="comment">//二维数组行数计算</span></span><br></pre></td></tr></table></figure>

<h3 id="指针数组与数组指针的区别"><a href="#指针数组与数组指针的区别" class="headerlink" title="指针数组与数组指针的区别"></a>指针数组与数组指针的区别</h3><p>例：<br>int a[2][3]={1,2,3,4,5,6};<br>int (*p)[3]=a;<br>int *p[2]={a[0],a[1]};</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">指针数组</th>
<th align="center">数组指针</th>
</tr>
</thead>
<tbody><tr>
<td align="center">本质</td>
<td align="center">元素是指针的数组</td>
<td align="center">指向数组的行指针</td>
</tr>
<tr>
<td align="center">形式</td>
<td align="center">int *p[3]={a[0],a[1]};</td>
<td align="center">int (*p)[3]=a;</td>
</tr>
<tr>
<td align="center">p+1</td>
<td align="center">=&amp;p[1]=&amp;a[1]=&amp;&amp;a[1][0]</td>
<td align="center">=&amp;p[1]=&amp;a[1]=&amp;&amp;a[1][0]</td>
</tr>
<tr>
<td align="center">sizeof(p)</td>
<td align="center">整个数组的大小</td>
<td align="center">一定为8(即指针的大小)</td>
</tr>
<tr>
<td align="center">*(p+1)<strong>值一样但形式不一样</strong></td>
<td align="center">p[1]=a[1]=&amp;a[1][0]</td>
<td align="center">=a[1]=&amp;a[1][0]</td>
</tr>
<tr>
<td align="center">sizeof(*p)</td>
<td align="center">一定为8(即指针的大小)</td>
<td align="center">一列的大小</td>
</tr>
<tr>
<td align="center">二级指针x</td>
<td align="center">有二级指针 int **x=p</td>
<td align="center">没有二级指针，<font color="red">不能 int **x=p</font></td>
</tr>
<tr>
<td align="center">**p</td>
<td align="center">=**x=*p[0]=*a[0]=a[0][0]</td>
<td align="center">=*a[0]=a[0][0]</td>
</tr>
</tbody></table>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>指针</tag>
        <tag>c语言</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>day14-c函数</title>
    <url>/2023/03/10/day14-c%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="day14-c函数"><a href="#day14-c函数" class="headerlink" title="day14-c函数"></a><font color="green">day14-c函数</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、函数定义"><a href="#1、函数定义" class="headerlink" title="1、函数定义"></a>1、函数定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; 函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    功能代码;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> 表达式;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数名：也代表函数的首地址</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="2、函数调用"><a href="#2、函数调用" class="headerlink" title="2、函数调用"></a>2、函数调用</h3><p>​    函数名(实际参数);</p>
<p>​    实际参数必须和形参的个数、类型、顺序一致</p>
<h3 id="3、函数声明"><a href="#3、函数声明" class="headerlink" title="3、函数声明"></a>3、函数声明</h3><p>​    &lt;数据类型&gt; 函数名(形式参数);</p>
<h3 id="4、函数的传参"><a href="#4、函数的传参" class="headerlink" title="4、函数的传参"></a>4、函数的传参</h3><p>​    (1)赋值传递</p>
<p>​    (2)地址传递：将数据的地址赋值给形参进行初始化</p>
<p>​    (3)全局变量传参</p>
<h3 id="5、数组传参"><a href="#5、数组传参" class="headerlink" title="5、数组传参"></a>5、数组传参</h3><p>​    (1)整型数组：要传入数组的首地址，还要传入数组的元素个数</p>
<p>​    (2)字符数组：只需要传入数组首地址</p>
<p>练习：定义一个函数，计算二维整型数组的所有元素的和</p>
<h2 id="二、函数和指针"><a href="#二、函数和指针" class="headerlink" title="二、函数和指针"></a>二、函数和指针</h2><h3 id="1、指针函数"><a href="#1、指针函数" class="headerlink" title="1、指针函数"></a>1、指针函数</h3><p>​        如果一个函数的返回值是一个地址值，那么该函数就称为指针函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; *函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    功能代码;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> 地址值; <span class="comment">//合法安全的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2、函数指针"><a href="#2、函数指针" class="headerlink" title="2、函数指针"></a>2、函数指针</h3><p>​    本质：指针，指向一个函数的首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义：</span><br><span class="line">    &lt;数据类型&gt; (*函数指针名)(形式参数);</span><br><span class="line">	数据类型：跟指向的函数的返回值一致</span><br><span class="line">    形式参数：跟指向函数的形参一致</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span> x, <span class="keyword">int</span> y); <span class="comment">//定义了一个函数指针，指向的函数--&gt;返回值为int，参数是两个int类型数据</span></span><br><span class="line">p = add; <span class="comment">//将函数add的首地址赋值给函数指针变量p</span></span><br><span class="line"></span><br><span class="line">调用函数方法：</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//通过函数名+实参 调用函数</span></span><br><span class="line">	(*p)(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//通过访问函数指针内容+实参 调用函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>















<p>​            </p>
<p>​                </p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c语言</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>day16-Linux基础</title>
    <url>/2023/03/13/day16-Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="day16-linux基础"><a href="#day16-linux基础" class="headerlink" title="day16-linux基础"></a><font color="green">day16-linux基础</font></h1><hr>
<h2 id="一、嵌入式："><a href="#一、嵌入式：" class="headerlink" title="一、嵌入式："></a>一、嵌入式：</h2><p>以应用为中心，以计算机为基础，软硬件可裁剪，适用于对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统</p>
<a id="more"></a>
<h3 id="1-linux系统："><a href="#1-linux系统：" class="headerlink" title="1.linux系统："></a>1.linux系统：</h3><p>特点：开源、安全性、可移植性</p>
<h3 id="2-linux体系结构："><a href="#2-linux体系结构：" class="headerlink" title="2.linux体系结构："></a>2.linux体系结构：</h3><p>文件结构：最大的为根目录（/），</p>
<blockquote>
<p>home：家目录，给用户工作的目录<br>（~）：权限没有开通完，需要权限需要加sudo<br>dev：设备文件<br>etc：配置文件</p>
</blockquote>
<h3 id="3-vi的配置："><a href="#3-vi的配置：" class="headerlink" title="3.vi的配置："></a>3.vi的配置：</h3><p>vi .vimrc（~下）配置vi的初始化</p>
<blockquote>
<p>boot：启动文件<br>root：权限文件<br>lib：库文件<br>mnt：挂载文件</p>
</blockquote>
<hr>
<br>
<br>

<h2 id="二、shell命令"><a href="#二、shell命令" class="headerlink" title="二、shell命令"></a>二、shell命令</h2><h3 id="1-文件的查看"><a href="#1-文件的查看" class="headerlink" title="1.文件的查看"></a>1.文件的查看</h3><blockquote>
<p>我是谁—whoami<br>我在哪儿—pwd<br>我有什么—-ls</p>
<blockquote>
<p>ls -a—显示所有文件，包括隐藏文件<br>ls -l—显示文件信息</p>
</blockquote>
</blockquote>
<br>

<blockquote>
<p><font color="blue">蓝色</font>：目录文件<br>白色：普通文件<br><font color="green">绿色</font>：可执行文件<br><font color="red">红色</font>：压缩文件<br><font color="#00FFFF">浅蓝</font>：链接文件</p>
</blockquote>
<p>文件的类型：</p>
<p>lsp-bcd</p>
<br>

<h3 id="2-文件的权限："><a href="#2-文件的权限：" class="headerlink" title="2.文件的权限："></a>2.文件的权限：</h3><p>rwxrwxrwx</p>
<p>前三个：用户自己的权限，中间三个，用户组的权限，最后三个，其他用户的权限</p>
<p>ls -R–以遍历的方式查看文件</p>
<br>

<h3 id="3-目录的移动"><a href="#3-目录的移动" class="headerlink" title="3.目录的移动"></a>3.目录的移动</h3><p>我要去哪儿—-cd</p>
<p>cd +路径  (如果直接加文件名，默认从当前路径下去进入)</p>
<p>./—当前路径</p>
<p>../—上一级路径</p>
<p>直接cd，回到家目录（~）<br><br></p>
<h3 id="4-文件的修改"><a href="#4-文件的修改" class="headerlink" title="4.文件的修改"></a>4.文件的修改</h3><blockquote>
<p>mkdir-rmdir：创建-删除目录（里面有文件时不行）<br>rm -r ：（删除目录下所有的文件）<br>touch：创建但不打开文件<br>vi、vim ：打开vim编辑器<br>cat：查看文件内容<br>head：默认查看前十行的内容<br>head -n 文件名：查看文件前n行的内容<br>tail：默认查看后十行的内容<br>tail -n 文件名：查看文件后n行的内容<br>mv：可以充当重命名文件名的作用<br>cp 1.c 2.c：如果没有后面的复制文件，会先创建文件再复制<br>man：查看帮助</p>
</blockquote>
<br>

<hr>
<h2 id="三、编辑器："><a href="#三、编辑器：" class="headerlink" title="三、编辑器："></a>三、编辑器：</h2><p>vi/vim编辑器</p>
<p>vi +文件名—打开这个文件，如果没有这个文件，先去创建再打开</p>
<p>1.命令行模式：yy，nyy，p，dd，ndd，u</p>
<p>2.插入模式：</p>
<blockquote>
<p>i：从光标当前位置开始插入<br>a：追加，从光标下一位开始插入<br>o：从光标下一行开始插入<br>esc：退出插入模式，回到的是命令行模式</p>
</blockquote>
<p>3.底行模式：</p>
<blockquote>
<p>wq，！q，x<br>s/字符串1/字符串2 ：只替换从光标当前所在行的第一个字符串1<br>%s/字符串1/字符串2:替换文件每一行的第一个字符串1<br>%s/字符串1/字符串2/g:替换文件所有的字符串1<br>vsp+文件名：在当前的vi编辑器打开另一个文件<br>ctrl+w—-切换光标的位置<br>退出vsp：wq<br>set mouse = a—让光标跟着鼠标移动<br>set mouse -= a—让光标不跟着鼠标移动<br>gedit编辑器：没有配置，操作起来相对简单一点，类似于word文档</p>
</blockquote>
<br>

<hr>
<h2 id="四、gcc编译器："><a href="#四、gcc编译器：" class="headerlink" title="四、gcc编译器："></a>四、gcc编译器：</h2><blockquote>
<p>四个步骤：<br>1、预处理—处理要用到的头文件和宏定义<br>gcc -E 1.c -o 1.i<br>2、编译—检查代码的错误<br>gcc -S 1.i -o 1.s<br>3、汇编—将文件变成计算机能够识别的二进制文件<br>gcc -c 1.s -o 1.o<br>4、链接—生成执行文件<br>gcc 1.o -o 1</p>
</blockquote>
<p>选项：</p>
<blockquote>
<p>-o：修改执行文件名<br>-Wall：显示所有警告<br>-w：隐藏所有警告</p>
</blockquote>
<br>

<hr>
<h2 id="五、快捷键："><a href="#五、快捷键：" class="headerlink" title="五、快捷键："></a>五、快捷键：</h2><blockquote>
<p>ctrl+l：清屏，翻页，鼠标往上滑还是能看到（clear–但是看不到之前的）<br>ctrl+shift+t：并列打开一个终端（ctrl+shift+n）<br>ctrl+c：结束当前进程回到终端<br>ctrl+z：暂停当前进程回到终端<br>ctrl+空格：切换中英文（可以修改）<br>上下键：翻找历史指令<br>alt+tab：切换终端</p>
</blockquote>
<br>

<hr>
<h2 id="六、文件管理"><a href="#六、文件管理" class="headerlink" title="六、文件管理"></a>六、文件管理</h2><h3 id="1-文件的类型："><a href="#1-文件的类型：" class="headerlink" title="1.文件的类型："></a>1.文件的类型：</h3><p>lsp-bcd</p>
<br>

<h3 id="2-文件的权限：-1"><a href="#2-文件的权限：-1" class="headerlink" title="2.文件的权限："></a>2.文件的权限：</h3><p>rwxrwxrwx</p>
<p>前三个：用户自己的权限，中间三个，用户组的权限，最后三个，其他用户的权限</p>
<br>

<h3 id="3-chmod–修改文件权限"><a href="#3-chmod–修改文件权限" class="headerlink" title="3.chmod–修改文件权限"></a>3.chmod–修改文件权限</h3><p>第一种方式：chmod u+x 文件名—-给当前用户增加执行权限</p>
<p>如果不加u，默认给所有用户加权限</p>
<blockquote>
<p>u–用户自己<br>g—用户组<br>o—其他用户</p>
</blockquote>
<p>第二种方式：chmod 0777 文件名</p>
<br>

<h3 id="4-链接文件–ln"><a href="#4-链接文件–ln" class="headerlink" title="4.链接文件–ln"></a>4.链接文件–ln</h3><p>（1）硬链接：</p>
<p>ln 文件名 硬链接文件名</p>
<p>硬链接如果把本体文件删掉，依旧可以单独使用，类型和原文件一模一样，移动原文件也依旧可以执行</p>
<p>（2）软链接：</p>
<p>ln -s 文件名 软链接文件名 </p>
<p>大大缩小了文件的大小，如果把本体文件删除或者移动，软链接失效</p>
<br>

<h3 id="5-文件的压缩与解压"><a href="#5-文件的压缩与解压" class="headerlink" title="5.文件的压缩与解压"></a>5.文件的压缩与解压</h3><blockquote>
<p>gzip—压缩文件，原文件被替换成压缩之后的文件，，会生成一个.gz的压缩文件，用vi能看到源文件内容，用cat在终端查看乱码<br>gunzip—解压文件<br>bzip2—压缩文件，原文件被替换成压缩之后的文件，，会生成一个.bz2的压缩文件，压缩功能相对于gzip较弱，但是压缩时间缩短<br>bunzip–解压文件<br>xz—压缩文件，原文件被替换成压缩之后的文件，，会生成一个.xz的压缩文件，压缩功能相对于gzip较弱，但是压缩时间缩短<br>unxz–解压文件</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day15-c函数，结构体</title>
    <url>/2023/03/12/day15-c%E5%87%BD%E6%95%B0%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="day15-c函数，结构体"><a href="#day15-c函数，结构体" class="headerlink" title=" day15-c函数，结构体"></a><font color="green"> day15-c函数，结构体</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><hr>
<h3 id="1、指针函数："><a href="#1、指针函数：" class="headerlink" title="1、指针函数："></a>1、指针函数：</h3><p>​    本质：是一个函数，指针函数的返回值是一个地址</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt;* 函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    代码模块;</span><br><span class="line">    <span class="keyword">return</span> 地址量; <span class="comment">//合法地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、函数指针："><a href="#2、函数指针：" class="headerlink" title="2、函数指针："></a>2、函数指针：</h3><p>​    本质：是一个指针，指向一个函数的首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义的一般形式：</span><br><span class="line">    &lt;数据类型&gt; (*函数指针变量名)(参数列表);</span><br><span class="line"></span><br><span class="line">	例：</span><br><span class="line">        <span class="keyword">int</span> (*p)(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">	数据类型：跟指针指向的函数的数据类型一致</span><br><span class="line">	参数列表：跟指针指向的函数的参数列表一致</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">p = add;  <span class="comment">//将函数add的首地址赋值给函数指针变量p</span></span><br><span class="line">(*p)(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//调用add函数传入实参为2和3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><h3 id="1、函数指针数组"><a href="#1、函数指针数组" class="headerlink" title="1、函数指针数组"></a>1、函数指针数组</h3><p>​    本质：是一个数组, 存放的全部都是函数指针类型的数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义的一般形式：</span><br><span class="line">    &lt;数据类型&gt; (*函数指针数组名[元素个数])(参数列表);</span><br><span class="line">	例：</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">		<span class="keyword">int</span> (*arr[<span class="number">2</span>])(<span class="keyword">int</span> x, <span class="keyword">int</span> y) = &#123;add, sub&#125;;</span><br><span class="line">        <span class="comment">//定义了一个名为arr的函数指针数组，数组中最多可以存放两个 int(* )(int, int)类型的数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、递归函数"><a href="#2、递归函数" class="headerlink" title="2、递归函数"></a>2、递归函数</h3><p>​    练习：计算一个正整数的阶乘，用函数封装功能</p>
<p>​    概念：在一个函数中直接或者间接调用函数本身</p>
<p>​    </p>
<p>​    递归函数的特点：</p>
<p>​            1：递推公式</p>
<p>​            2：设置有退出条件</p>
<p>​    优点：能够让代码整体更加简洁</p>
<p>​    缺点：需要消耗大量系统资源</p>
<p>​                必须要设置退出条件</p>
<h2 id="三、结构体"><a href="#三、结构体" class="headerlink" title="三、结构体"></a>三、结构体</h2><p>​    跟数组一样，是用户自定义的一种数据类型</p>
<p>​    结构体中可以存放多个不同数据类型的数据</p>
<h3 id="1、结构体的定义"><a href="#1、结构体的定义" class="headerlink" title="1、结构体的定义"></a>1、结构体的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> 结构体名</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">       数据类型 成员名<span class="number">1</span>;</span><br><span class="line">       数据类型 成员名<span class="number">2</span>;        	</span><br><span class="line">       数据类型 成员名<span class="number">3</span>; </span><br><span class="line">        ......</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	例：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">char</span> name[<span class="number">50</span>]; </span><br><span class="line">            <span class="keyword">int</span>	age;</span><br><span class="line">            <span class="keyword">char</span> sex;</span><br><span class="line">            <span class="keyword">double</span> height;</span><br><span class="line">            <span class="keyword">char</span> address[<span class="number">50</span>];</span><br><span class="line">            <span class="keyword">char</span> hobby[<span class="number">50</span>];</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2、结构体变量"><a href="#2、结构体变量" class="headerlink" title="2、结构体变量"></a>2、结构体变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> 结构体名 结构体变量名;</span></span><br><span class="line">	例：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu2</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、访问结构体成员"><a href="#3、访问结构体成员" class="headerlink" title="3、访问结构体成员"></a>3、访问结构体成员</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    结构体变量名.成员名;  </span><br><span class="line">	stu1.age = <span class="number">18</span>;  <span class="comment">//访问1号学生stu1中的年龄，赋值为18；	</span></span><br></pre></td></tr></table></figure>

<h3 id="4、结构体变量的初始化"><a href="#4、结构体变量的初始化" class="headerlink" title="4、结构体变量的初始化"></a>4、结构体变量的初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 结构体变量名 = &#123;</span>依次给每一个成员赋值&#125;;  <span class="comment">//成员之间用逗号隔开</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu2</span> = &#123;</span><span class="string">&quot;张三&quot;</span>, <span class="number">19</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">182.1</span>, <span class="string">&quot;成都&quot;</span>, <span class="string">&quot;sing and dance&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5、结构体指针"><a href="#5、结构体指针" class="headerlink" title="5、结构体指针"></a>5、结构体指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">p</span> = &amp;<span class="title">stu1</span>;</span></span><br><span class="line">(*p).name       <span class="comment">//stu1中的name成员</span></span><br><span class="line">p-&gt;name == (*p).name</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c语言</tag>
        <tag>函数</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>day17-Linux基础</title>
    <url>/2023/03/14/day17-Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="day17-linux基础"><a href="#day17-linux基础" class="headerlink" title="day17-linux基础"></a><font color="green">day17-linux基础</font></h1><hr>
<h2 id="一、复习补充："><a href="#一、复习补充：" class="headerlink" title="一、复习补充："></a>一、复习补充：</h2><p>缩进：</p>
<p>命令行模式：gg=G</p>
<p>可视化模式：v，上下键选中要对齐的代码，按=</p>
<p>底行模式：set nonumber  不显示行号，set number 显示行号</p>
<a id="more"></a>

<br>
<br>

<hr>
<h2 id="二、tar-归档和释放"><a href="#二、tar-归档和释放" class="headerlink" title="二、tar-归档和释放"></a>二、tar-归档和释放</h2><blockquote>
<p>tar<br>-c   创建归档文件<br>-v   显示归档或释放过程<br>-x   释放归档文件<br>-f   用户指定归档文件的文件名，否则使用默认名称<br>-j   以bzip2方式压缩<br>-z   以gzip方式压缩<br>    tar -czvf  要压缩或归档之后的文件名 目标文件名<br>    tar -xvf   目标文件名</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="三、diff"><a href="#三、diff" class="headerlink" title="三、diff"></a>三、diff</h2><p>比较文件的不同</p>
<br>
<br>

<hr>
<h2 id="四、grep–查询"><a href="#四、grep–查询" class="headerlink" title="四、grep–查询"></a>四、grep–查询</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grep  查询的字符串 查询文件名---查询特定文件的内容</span><br><span class="line">grep  -r 查询的字符串 路径----查询一个路径下所有文件的内容</span><br></pre></td></tr></table></figure>

<p> wc</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wc 文件名： 行数 单词个数 单个字符个数 文件名</span><br><span class="line"> -l：只查看行数</span><br><span class="line"> -w：只查看单词个数（看空格)</span><br><span class="line"> -c：只查看单个字符个数</span><br></pre></td></tr></table></figure>


<br>
<br>

<hr>
<h2 id="五、工具："><a href="#五、工具：" class="headerlink" title="五、工具："></a>五、工具：</h2><p>vi编辑器</p>
<p>gedit编辑器</p>
<p>gcc编译器</p>
<h2 id="1-下载工具："><a href="#1-下载工具：" class="headerlink" title="1.下载工具："></a>1.下载工具：</h2><blockquote>
<p>deb（常用的） —-Debian<br>rpm（小红帽）—-Redhat</p>
</blockquote>
<br>

<h3 id="（1）dpkg工具—-离线下载，没有依赖文件"><a href="#（1）dpkg工具—-离线下载，没有依赖文件" class="headerlink" title="（1）dpkg工具—-离线下载，没有依赖文件"></a>（1）dpkg工具—-离线下载，没有依赖文件</h3><p>sudo—-暂时赋予用户权限，密码初始都为1，但是不显示密码的输入，确保输出按回车就可以了</p>
<p>dpkg都要加sudo</p>
<blockquote>
<p>sudo dpkg -i 安装包—下载<br>sudo dpkg -r 软件名—卸载</p>
</blockquote>
<br>


<h3 id="（2）apt工具—在线下载"><a href="#（2）apt工具—在线下载" class="headerlink" title="（2）apt工具—在线下载"></a>（2）apt工具—在线下载</h3><p>下载：</p>
<blockquote>
<p>sudo apt-get install sl–跑火车<br>sudo apt-get install frozen-bubble–泡泡龙<br>sudo apt-get install cmatrix–代码雨<br>sudo  apt-get install fortune—-名人名言<br>sudo  apt-get install fortunes-zh—-名人名言（中文）<br>sudo  apt-get install lolcat—-有颜色显示<br>fortune | lolcat<br>卸载：sudo apt-get remove 软件名</p>
</blockquote>
<br>

<h3 id="（3）创建共享文件夹："><a href="#（3）创建共享文件夹：" class="headerlink" title="（3）创建共享文件夹："></a>（3）创建共享文件夹：</h3><ol>
<li>选择虚拟机左上菜单的虚拟机选项，点击设置</li>
<li>点击选项，找到共享文件夹，选择总是启用</li>
<li>点击添加，跟着下一步，选择主机（windows）的一个文件作为自己的共享文件夹</li>
<li>点击完成，点击确定，最后在<code>/mnt/hgfs</code>查看有没有</li>
</ol>
<h3 id="（4）网络配置："><a href="#（4）网络配置：" class="headerlink" title="（4）网络配置："></a>（4）网络配置：</h3><p>ping–能不能网络通信</p>
<p>ping +IP地址</p>
<ol>
<li>点击虚拟机菜单的编辑，选择虚拟网络编辑</li>
<li>点击更改设置（如果没有，直接选择桥接模式），选择桥接模式</li>
<li>在桥接模式下选择自己windos网络的描述名字，点击确定</li>
<li>点击虚拟机，选择设置，找到网络适配器，选择自定义模式，选择自己的网络名称(一般为VMnet0)，点击确定</li>
<li>进入linux系统，断开重连网络（重启网络）</li>
</ol>
<p>或者：在终端上输入：</p>
<p>sudo service network-manager restart</p>
<blockquote>
<p>ifconfig—查看linux系统的IP地址<br>ipconfig—查看windows系统的IP地址</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2.用户管理"></a>2.用户管理</h2><p>(1) 超级用户：</p>
<blockquote>
<p>su，开通了所有权限，我们一般不在这里工作，因为一旦删除，找不回来，也容易操作到内核上的东西<br>exit：退出超级用户</p>
</blockquote>
<p>(2)查看</p>
<blockquote>
<p>查看用户—vi /etc/passwd<br>查看用户组–vi /etc/group</p>
</blockquote>
<p>(3)添加用户：</p>
<blockquote>
<p>adduser 新添用户名<br>输入密码，不显示，确保输入按回车<br>su 用户名—-进入该用户</p>
</blockquote>
<p>(4)删除用户<br>deluser 用户名，但是我们一般进入passwd和group这两个文件去删除 <strong>（加sudo）</strong></p>
<p>(5)修改密码：passwd</p>
<br>
<br>

<hr>
<h2 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3.进程管理"></a>3.进程管理</h2><blockquote>
<p>ps   查看前台的进程<br>ps -aux  查看所有进程<br>pstree—以树的形式展示进程<br>top—查看进程（从占用cpu最大开始展示），类似于任务管理器<br>kill -9 进程号   —-杀死进程</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="4-shell的特殊字符"><a href="#4-shell的特殊字符" class="headerlink" title="4.shell的特殊字符"></a>4.shell的特殊字符</h2><p>（1）|—管道</p>
<p>指令1 | 指令2—-把指令1的输出作为指令2的输入</p>
<p>fortune | lolcat</p>
<p>（2）` &emsp; `—命令置换<br>指令1 ` &emsp; `    把命令置换里面的内容作为指令1的参数<br>    echo `ls`</p>
<p>（3）echo–终端的输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo hello    world---会自动缩进空格字符串之间保留一个空格</span><br><span class="line">echo &#x27;hello    world&#x27;---原样输出</span><br><span class="line">echo <span class="string">&quot;hello    world&quot;</span>---原样输出</span><br></pre></td></tr></table></figure>
<p>（4）输入输出重定向</p>
<blockquote>
<p>&gt;:<br>cat &gt;1.c（覆盖输入）<br> &gt;&gt;:<br>cat &gt;&gt;1.c（追加输入）</p>
</blockquote>
<p>注：输入都是读取的键盘输入</p>
<p>（5）通配符：</p>
<ul>
<li>*—匹配所有字符串</li>
<li>{起始..结束}–可以创建起始到结束的文件</li>
<li>touch {1..10}.c—-创建1到10的.c文件</li>
<li>rm 【13579】.c—-删除了1.c 3.c 5.c 7.c 9.c</li>
<li>rm [1-5].c—-删除了1.c2.c3.c4.c5.c</li>
<li>rm [^8].c—-删除除了8.c的文件,也只能通配一个</li>
<li>？—匹配一个字符串<br>rm h？llo.c—删除hello.c hrllo.c</li>
</ul>
<p>（6）其他</p>
<p>shutdown—关机</p>
<p>shutdown -r now—重启</p>
<p>vm上的快照–相当于备份</p>
<br>
<br>

<hr>
<h2 id="5-shell脚本："><a href="#5-shell脚本：" class="headerlink" title="5.shell脚本："></a>5.shell脚本：</h2><p>（1）本质：shell命令的有序集合</p>
<p>解释型语言（python，shell脚本）</p>
<p>不会检查错误，但是会显示出错误，出现错误会继续执行后面的语句</p>
<p>需要一个解释器（shell的是bash）</p>
<p>编译型语言（c语言，c++）</p>
<p>编译会报错，一旦错误会停止进程</p>
<p>（2）怎么去写一个shell脚本：</p>
<ol>
<li><p>创建一个.sh的文件（也可以没有后缀名）</p>
</li>
<li><p>写shell命令</p>
</li>
<li><p>执行:</p>
</li>
</ol>
<p>&emsp;&emsp;&emsp;&emsp;a. 通过bash这个解释器来执行，直接bash+要执行的文件</p>
<p>&emsp;&emsp;&emsp;&emsp;b. 通过chmod给shell文件添加执行权限，然后再执行</p>
<p><strong>注：第一行一般写：<code>#!/bin/bash</code>，我们解释器的路径</strong></p>
<p>练习：复制上一级目录的1.c 2.c到当前目录下，然后把hello world写入1.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> cd ../</span><br><span class="line">  <span class="number">4</span> touch <span class="number">1.</span>c <span class="number">2.</span>c</span><br><span class="line">  <span class="number">5</span> cp [<span class="number">12</span>].c day2</span><br><span class="line">  <span class="number">6</span> echo <span class="string">&quot;hello world&quot;</span> &gt;day2/<span class="number">1.</span>c</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）shell变量</p>
<ul>
<li>自定义变量</li>
</ul>
<p>没有数据类型，默认为字符串类型</p>
<p>赋值不能隔开</p>
<p>变量名=值</p>
<p>没有分号，换行就相当于分号</p>
<p>变量的调用需要加钱$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>位置变量</li>
</ul>
<p>命令行参数的变量，即命令即后面的参数作为变量 从bash后面的那个开始为0</p>
<p>从终端传递参数给shell脚本</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">从$<span class="number">0</span>开始到$<span class="number">9</span>如果要打印<span class="number">9</span>以后的变量需要加&#123;&#125;，例如$&#123;<span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>环境变量</li>
</ul>
<p>计算机定义好了的变量</p>
<p>env可以查看所有环境变量</p>
<p>调用需要加$</p>
<p><strong>注：shell中0是真，1是假</strong></p>
<h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>计算机给一些特殊变量赋予特殊意义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$*--打印的是命令行参数的所有变量，不包括$<span class="number">0</span></span><br><span class="line">$@--打印的是命令行参数的所有变量，不包括$<span class="number">0</span></span><br><span class="line">$#--打印的是命令行参数的个数，不包括$<span class="number">0</span></span><br><span class="line">$?--打印上一次的返回状态（<span class="number">0</span>代表真，<span class="number">1</span>代表假）</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day18-Linux基础,shell脚本</title>
    <url>/2023/03/15/day18-Linux%E5%9F%BA%E7%A1%80,shell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="day18-linux基础-shell脚本"><a href="#day18-linux基础-shell脚本" class="headerlink" title="day18-linux基础,shell脚本"></a><font color="green">day18-linux基础,shell脚本</font></h1><br>
<br>


<hr>
<h2 id="一、变量的四则运算："><a href="#一、变量的四则运算：" class="headerlink" title="一、变量的四则运算："></a>一、变量的四则运算：</h2><a id="more"></a>
<ol>
<li>（（ &emsp; ））</li>
</ol>
<p>不能进行浮点型的运算</p>
<p>调用的时候需要加钱$</p>
<p>可以进型幂数运算</p>
<p>可以进行自加自减</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> a=$(( <span class="number">3</span>**<span class="number">3</span>)) <span class="comment">//3的3次方</span></span><br><span class="line"> <span class="number">4</span> echo $a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>【&emsp;】</li>
</ol>
<p>不能进行浮点型的运算</p>
<p>调用的时候需要加钱$</p>
<p>可以进型幂数运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> a=$[ <span class="number">3</span>+<span class="number">3</span>]</span><br><span class="line"><span class="number">4</span> echo $a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>expr</li>
</ol>
<p>需要命令置换符置换出来结果` &emsp; `</p>
<p>算数之间需要空开</p>
<p>当进行乘法的时候需要用\区分</p>
<p>没有幂数运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=`expr <span class="number">1</span> \* <span class="number">2</span>`</span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>练习：运算出a=3的3次方的值，b=5*7的值，交换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=$((<span class="number">3</span>**<span class="number">3</span>))</span><br><span class="line">  <span class="number">4</span> b=`expr <span class="number">5</span> \* $((<span class="number">4</span>+<span class="number">2</span>))`</span><br><span class="line">  <span class="number">5</span> c=$a</span><br><span class="line">  <span class="number">6</span> a=$b</span><br><span class="line">  <span class="number">7</span> b=$c</span><br><span class="line">  <span class="number">8</span> echo a=$&#123;a&#125;b=$b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="二、shell-语句"><a href="#二、shell-语句" class="headerlink" title="二、shell 语句"></a>二、shell 语句</h2><h3 id="1-解释性语句"><a href="#1-解释性语句" class="headerlink" title="1. 解释性语句"></a>1. 解释性语句</h3><ul>
<li>#注释一行</li>
<li>:&lt;&lt;!注释多行<br>注释的shell语句<br>！</li>
<li>：&lt;&lt;EOF<br>注释的shell语句<br>EOF</li>
</ul>
<h3 id="2-功能性语句"><a href="#2-功能性语句" class="headerlink" title="2.功能性语句"></a>2.功能性语句</h3><h4 id="（1）test"><a href="#（1）test" class="headerlink" title="（1）test"></a>（1）test</h4><p>结构：字符串 整型 文件</p>
<ul>
<li>字符串的比较：</li>
</ul>
<blockquote>
<p>test 字符串1 = 字符串2    —-比较两个字符串是否相等<br>test 字符串1 ！= 字符串2    —-比较两个字符串是否不相等<br>test -z 字符串—判断字符串为不为空<br>test -n 字符串—判断字符串是否不为空</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=<span class="string">&quot;hello&quot;</span></span><br><span class="line">  <span class="number">4</span> b=<span class="string">&quot;hello&quot;</span></span><br><span class="line">  <span class="number">5</span> test $a != $b</span><br><span class="line">  <span class="number">6</span> test -z $a</span><br><span class="line">  <span class="number">7</span> test -n $a</span><br><span class="line">  <span class="number">8</span> echo $?</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>整型的比较</li>
</ul>
<blockquote>
<p>-eq—等于<br>-ne—不等于<br>-gt—大于<br>-lt–小于<br>-ge—大于等于<br>-le—小于等于</p>
</blockquote>
<ul>
<li>文件的比较</li>
</ul>
<blockquote>
<p>-e —判断文件是否存在<br>-f—判断文件是否是普通文件<br>-L—判断文件是否是链接文件<br>-S—判断文件是否是套接字文件<br>-b—判断文件是否是块文件<br>-c—判断文件是否是字符文件<br>-d—判断文件是否是目录文件<br>-p—判断文件是否为管道文件</p>
</blockquote>
<ul>
<li>文件的权限：</li>
</ul>
<blockquote>
<p>-r–判断文件是否有可读权限<br>-w—判断文件是否有可写权限<br>-x—判断文件是否有可执行权限<br>文件1  -nt  文件2–判断文件1是否比文件2新（时间戳）<br>文件1  -ot  文件2–判断文件1是否比文件2旧（时间戳）</p>
</blockquote>
<ul>
<li>逻辑<blockquote>
<p>-o—或<br>-a—与</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> test -d $<span class="number">1</span> -a -f $<span class="number">2</span></span><br><span class="line">  <span class="number">4</span> echo $?</span><br><span class="line">~           </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="（2）read"><a href="#（2）read" class="headerlink" title="（2）read"></a>（2）read</h4><p>把终端上的输入传给参数</p>
<p>read 变量1 变量2 </p>
<p>read -p “提示” 变量名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> read -p <span class="string">&quot;please input tow numbern:&quot;</span> a b</span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line">  <span class="number">5</span> echo $b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>read -t  时间 变量名—限制时间输入</p>
<p>超过时间会自动结束（以秒为单位）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> read -t <span class="number">5</span> a b</span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line">  <span class="number">5</span> echo $b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>read -n –限制输入的个数,超过个数也会自动结束</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> read -n <span class="number">1</span> a b</span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line">  <span class="number">5</span> echo $b</span><br><span class="line">~           </span><br></pre></td></tr></table></figure>

<p>read -s —隐藏输入</p>
<br>

<h3 id="3-shell的控制语句"><a href="#3-shell的控制语句" class="headerlink" title="3. shell的控制语句"></a>3. shell的控制语句</h3><h4 id="（1）if"><a href="#（1）if" class="headerlink" title="（1）if"></a>（1）if</h4><p>第一种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>[]</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">​    shell语句；</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong><font color="red">注意：if和【】之间要隔一个空，表达式和【】也要隔一个空</font></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=<span class="number">56</span></span><br><span class="line">  <span class="number">4</span> b=<span class="number">34</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">if</span> [ $a -gt $b ]</span><br><span class="line">  <span class="number">6</span> then</span><br><span class="line">  <span class="number">7</span>     echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line">  <span class="number">8</span> fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> test语句</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">​    shell语句；</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> a=<span class="number">56</span></span><br><span class="line"><span class="number">4</span> b=<span class="number">34</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">if</span> test $a -gt $b</span><br><span class="line"><span class="number">6</span> then</span><br><span class="line"><span class="number">7</span>     echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="number">8</span> fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>if - elif-else</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> read a b</span><br><span class="line">  <span class="number">4</span> <span class="keyword">if</span> test $a -gt $b</span><br><span class="line">  <span class="number">5</span> then</span><br><span class="line">  <span class="number">6</span>     echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line">  <span class="number">7</span> elif test $a -eq $b</span><br><span class="line">  <span class="number">8</span> then</span><br><span class="line">  <span class="number">9</span>     echo <span class="string">&quot;zhangcheng&quot;</span></span><br><span class="line"> <span class="number">10</span> <span class="keyword">else</span></span><br><span class="line"> <span class="number">11</span>     echo <span class="string">&quot;day3&quot;</span></span><br><span class="line"> <span class="number">12</span> fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>练习：输入一个文件名。判断这个文件是否存在，如果不存在，就创建，判断是否有可写权限，如果有，就把helloworld 写进去，如果没有，赋予可写权限，再写进去，如果存在就写入helloworld</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> read -p <span class="string">&quot;please input a filename:&quot;</span> file</span><br><span class="line"> <span class="number">4</span> <span class="keyword">if</span> test -e $file</span><br><span class="line"> <span class="number">5</span> then</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">if</span> test -w $file</span><br><span class="line"> <span class="number">7</span>     then</span><br><span class="line"> <span class="number">8</span>        echo <span class="string">&quot;hello world&quot;</span>&gt;&gt;$file <span class="comment">//注意别忘了echo</span></span><br><span class="line"> <span class="number">9</span>    <span class="keyword">else</span></span><br><span class="line"><span class="number">10</span>        chmod +w $file</span><br><span class="line"><span class="number">11</span>        echo <span class="string">&quot;hello world&quot;</span>&gt;&gt;$file</span><br><span class="line"><span class="number">12</span>     fi</span><br><span class="line"><span class="number">13</span> <span class="keyword">else</span></span><br><span class="line"><span class="number">14</span>     touch $file</span><br><span class="line"><span class="number">15</span>     echo <span class="string">&quot;hello world&quot;</span>&gt;&gt;$file</span><br><span class="line"><span class="number">16</span> fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 表达式 in</span><br><span class="line"></span><br><span class="line">​           表达式）</span><br><span class="line"></span><br><span class="line">​              shell语句</span><br><span class="line"></span><br><span class="line">​               ；；</span><br><span class="line"></span><br><span class="line">表达式）</span><br><span class="line"></span><br><span class="line">​      shell语句</span><br><span class="line"></span><br><span class="line">​      ；；</span><br><span class="line"></span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">3</span> read a</span><br><span class="line"> <span class="number">4</span> <span class="keyword">case</span>  $a in</span><br><span class="line"> <span class="number">5</span>     <span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>)</span><br><span class="line"> <span class="number">6</span>         echo <span class="string">&quot;星期一&quot;</span></span><br><span class="line"> <span class="number">7</span>         ;;</span><br><span class="line"> <span class="number">8</span>     <span class="number">2</span>)</span><br><span class="line"> <span class="number">9</span>         echo <span class="string">&quot;星期二&quot;</span></span><br><span class="line"><span class="number">10</span>         ;;</span><br><span class="line"><span class="number">11</span>     <span class="number">3</span>)</span><br><span class="line"><span class="number">12</span>         echo <span class="string">&quot;星期三&quot;</span></span><br><span class="line"><span class="number">13</span>         ;;</span><br><span class="line"><span class="number">14</span>     <span class="number">4</span>)</span><br><span class="line"><span class="number">15</span>         echo <span class="string">&quot;星期四&quot;</span></span><br><span class="line"><span class="number">16</span>         ;;</span><br><span class="line"><span class="number">17</span>     <span class="number">5</span>)</span><br><span class="line"><span class="number">18</span>         echo <span class="string">&quot;星期五&quot;</span></span><br><span class="line"><span class="number">19</span>         ;;</span><br><span class="line"><span class="number">20</span>     <span class="number">6</span>)</span><br><span class="line"><span class="number">21</span>         echo <span class="string">&quot;星期六&quot;</span></span><br><span class="line"><span class="number">22</span>         ;;</span><br><span class="line"><span class="number">23</span>     <span class="number">7</span>)</span><br><span class="line"><span class="number">24</span>         echo <span class="string">&quot;星期天&quot;</span></span><br><span class="line"><span class="number">25</span>         ;;</span><br><span class="line">       *)</span><br><span class="line"><span class="number">27</span>         echo <span class="string">&quot;asdads&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">26</span> esac</span><br></pre></td></tr></table></figure>

<p>用【】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read a</span><br><span class="line">  <span class="number">4</span> <span class="keyword">case</span>  $a in</span><br><span class="line">  <span class="number">5</span>     [a-zA-Z])</span><br><span class="line">  <span class="number">6</span>         echo <span class="string">&quot;星期一&quot;</span></span><br><span class="line">  <span class="number">7</span>         ;;</span><br><span class="line">  <span class="number">8</span>     [zbc])</span><br><span class="line">  <span class="number">9</span>         echo <span class="string">&quot;星期二&quot;</span></span><br><span class="line"> <span class="number">10</span>         ;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>练习：模拟一个应用下载</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> read -p <span class="string">&quot;请选择要下载的应用:&quot;</span> app</span><br><span class="line"> <span class="number">4</span> read -p <span class="string">&quot;请确认是否下载y|n|q)&quot;</span> chioce</span><br><span class="line"> <span class="number">5</span> <span class="keyword">case</span> $chioce in</span><br><span class="line"> <span class="number">6</span>     Y|y|yes)</span><br><span class="line"> <span class="number">7</span>         echo <span class="string">&quot;$app正在下载中.....&quot;</span></span><br><span class="line"> <span class="number">8</span>         ;;</span><br><span class="line"> <span class="number">9</span>     N|n|no)</span><br><span class="line"><span class="number">10</span>         echo <span class="string">&quot;取消下载$app&quot;</span></span><br><span class="line"><span class="number">11</span>         ;;</span><br><span class="line"><span class="number">12</span>     *)</span><br><span class="line"><span class="number">13</span>         echo <span class="string">&quot;退出&quot;</span></span><br><span class="line"><span class="number">14</span> esac</span><br><span class="line"><span class="number">15</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="（2）循环语句"><a href="#（2）循环语句" class="headerlink" title="（2）循环语句"></a>（2）循环语句</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 表达式</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">shell语句</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=<span class="number">5</span></span><br><span class="line">  <span class="number">4</span> <span class="keyword">while</span> test $a -gt <span class="number">0</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">  <span class="number">6</span>     ((a--))</span><br><span class="line">  <span class="number">7</span>     echo $a</span><br><span class="line">  <span class="number">8</span> done</span><br></pre></td></tr></table></figure>

<p>死循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">shell语句</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>for循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（（表达式<span class="number">1</span>；表达式<span class="number">2</span>；表达式<span class="number">3</span>））</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">shell语句</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> </span><br><span class="line">  <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++))</span><br><span class="line">  <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line">  <span class="number">7</span>     echo $i</span><br><span class="line">  <span class="number">8</span> done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二种</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 in 单词表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">shell语句</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> </span><br><span class="line">  <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">for</span> i in he li oi asda adsa ada ad</span><br><span class="line">  <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line">  <span class="number">7</span>     echo $i</span><br><span class="line">  <span class="number">8</span> done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>连续的</p>
<p>for 变量 in {起始..结束}</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">for</span> i in &#123;a..z&#125;</span><br><span class="line"> <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">7</span>     echo $i</span><br><span class="line"> <span class="number">8</span> done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>for 变量 in ``</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">for</span> i in `ls`</span><br><span class="line"> <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">7</span>     echo $i</span><br><span class="line"> <span class="number">8</span> done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>练习：求1到100的和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> sum=<span class="number">0</span></span><br><span class="line"> <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;<span class="number">101</span>;i++))</span><br><span class="line"> <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">7</span>     sum=$(($sum+$i))</span><br><span class="line"> <span class="number">8</span> done</span><br><span class="line"> <span class="number">9</span> echo <span class="string">&quot;sum=$sum&quot;</span></span><br><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> sum=<span class="number">0</span></span><br><span class="line"> <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;<span class="number">101</span>;i++))</span><br><span class="line"> <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">7</span>     sum=`expr $sum + $i`</span><br><span class="line"> <span class="number">8</span> done</span><br><span class="line"> <span class="number">9</span> echo <span class="string">&quot;sum=$sum&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="三、shell数组"><a href="#三、shell数组" class="headerlink" title="三、shell数组"></a>三、shell数组</h2><p>shell脚本里面只有一维数组</p>
<p>没有数据类型</p>
<h3 id="1-数组的初始化"><a href="#1-数组的初始化" class="headerlink" title="1. 数组的初始化"></a>1. 数组的初始化</h3><p>数组名=（元素1 元素2 元素3.。。。）</p>
<h3 id="2-数组的赋值："><a href="#2-数组的赋值：" class="headerlink" title="2. 数组的赋值："></a>2. 数组的赋值：</h3><p>数组名【下标】=内容</p>
<h3 id="3-数组的调用："><a href="#3-数组的调用：" class="headerlink" title="3. 数组的调用："></a>3. 数组的调用：</h3><p>${数组名【下标】}</p>
<h3 id="4-数组的遍历："><a href="#4-数组的遍历：" class="headerlink" title="4. 数组的遍历："></a>4. 数组的遍历：</h3><p>循环遍历</p>
<p>${arr[*]}</p>
<p>${arr[@]}</p>
<h3 id="5-求数组的长度："><a href="#5-求数组的长度：" class="headerlink" title="5. 求数组的长度："></a>5. 求数组的长度：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$&#123;<span class="meta">#arr[*]&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> arr=(hello world nihao shijie)</span><br><span class="line"> <span class="number">4</span> arr[<span class="number">0</span>]=<span class="string">&quot;zhangcheng&quot;</span></span><br><span class="line"> <span class="number">5</span> echo $&#123;arr[<span class="number">0</span>]&#125;</span><br><span class="line"> <span class="number">6</span> echo $&#123;arr[@]&#125;</span><br><span class="line"> <span class="number">7</span> echo $&#123;#arr[*]&#125;</span><br><span class="line">                     </span><br></pre></td></tr></table></figure>

<p>练习：</p>
<p>数组的逆序打印（用交换）</p>
<p>shijie nihao world hello</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> arr=(hello world nihao shijie)</span><br><span class="line">  <span class="number">4</span> arr[<span class="number">0</span>]=<span class="string">&quot;zhangcheng&quot;</span></span><br><span class="line">  <span class="number">5</span> echo $&#123;arr[<span class="number">0</span>]&#125;</span><br><span class="line">  <span class="number">6</span> echo $&#123;arr[@]&#125;</span><br><span class="line">  <span class="number">7</span> len=$&#123;#arr[*]&#125;</span><br><span class="line">  <span class="number">8</span> <span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;$len/<span class="number">2</span>;i++))</span><br><span class="line">  <span class="number">9</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">10</span>     temp=$&#123;arr[$i]&#125;</span><br><span class="line"> <span class="number">11</span>     arr[$i]=$&#123;arr[$(($len-$i<span class="number">-1</span>))]&#125;</span><br><span class="line"> <span class="number">12</span>     arr[$(($len-$i<span class="number">-1</span>))]=$temp</span><br><span class="line"> <span class="number">13</span> done</span><br><span class="line"> <span class="number">14</span> </span><br><span class="line"> <span class="number">15</span> echo $&#123;arr[@]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-shell函数"><a href="#4-shell函数" class="headerlink" title="4. shell函数"></a>4. shell函数</h3><p>没有数据类型</p>
<p>没有写形参，但可以传参</p>
<p>只有调用函数之后，函数里面的变量才会生效</p>
<p>函数里面定义的都是全局变量，如果要定义局部变量，加local</p>
<p>（1）函数的一般形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">function 函数名（）</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line"></span><br><span class="line">函数名（）</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）函数的调用，直接函数名</p>
<p>（3）返回值return，可以通过$?来打印函数的返回值,如果有返回值，返回在0~256</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> add()</span><br><span class="line"> <span class="number">4</span> &#123;</span><br><span class="line"> <span class="number">5</span>     a=<span class="number">12</span></span><br><span class="line"> <span class="number">6</span>     <span class="keyword">return</span> $a</span><br><span class="line"> <span class="number">7</span> &#125;</span><br><span class="line"> <span class="number">8</span> add</span><br><span class="line"> <span class="number">9</span> echo $?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（4）函数的传参</p>
<p>函数名 实参1 实参2.。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数体中用$<span class="number">1</span>,$<span class="number">2</span>$<span class="number">3.</span>....来接受传递的实参</span><br><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> add()</span><br><span class="line">  <span class="number">4</span> &#123;</span><br><span class="line">  <span class="number">5</span>     a=<span class="number">12</span></span><br><span class="line">  <span class="number">6</span>     echo $<span class="number">1</span></span><br><span class="line">  <span class="number">7</span>     echo $<span class="number">2</span></span><br><span class="line">  <span class="number">8</span>     echo $<span class="number">3</span></span><br><span class="line">  <span class="number">9</span>     <span class="keyword">return</span> $a</span><br><span class="line"> <span class="number">10</span> &#125;</span><br><span class="line"> <span class="number">11</span> add <span class="number">34</span> <span class="number">56</span> <span class="number">78</span></span><br><span class="line"> <span class="number">12</span> echo $?</span><br></pre></td></tr></table></figure>

<p>练习：写一个求和函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> read m n</span><br><span class="line"> <span class="number">3</span> add()</span><br><span class="line"> <span class="number">4</span> &#123;</span><br><span class="line"> <span class="number">5</span>     sum=<span class="number">0</span></span><br><span class="line"> <span class="number">6</span>     <span class="keyword">for</span>((i=$<span class="number">1</span>;i&lt;=$<span class="number">2</span>;i++))</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">do</span></span><br><span class="line"> <span class="number">8</span>         sum=$(($sum+$i))</span><br><span class="line"> <span class="number">9</span>     done</span><br><span class="line"><span class="number">10</span> &#125;</span><br><span class="line"><span class="number">11</span> add m n</span><br><span class="line"><span class="number">12</span> echo $sum</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="三、c高级："><a href="#三、c高级：" class="headerlink" title="三、c高级："></a>三、c高级：</h2><h3 id="1-指针："><a href="#1-指针：" class="headerlink" title="1. 指针："></a>1. 指针：</h3><p>（1）指针的定义：</p>
<p>存储类型 数据类型 *指针变量名；</p>
<p>（2）指针的初始化：</p>
<p>存储类型 数据类型 *指针变量名=地址；</p>
<p>（3）指针的赋值：</p>
<p>1、把一个已知变量的地址赋值给指针</p>
<p>2、把已知数组首地址赋值给指针</p>
<p>3、把已有同级别指针赋值给指针</p>
<p>4、把NULL赋值给指针</p>
<p>（4）数组指针</p>
<p>本质是一个指针，只是这个指向了每个元素都是一维数组的一维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">10  </span>&#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">int</span> (*p)[<span class="number">3</span>]=a;</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">&quot;a[1][0]=%d\n&quot;</span>,a[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">&quot;*(*(p+1))]=%d\n&quot;</span>,*(*(p+<span class="number">1</span>)));</span><br><span class="line"><span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">&quot;p[1][0]=%d\n&quot;</span>,p[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="number">17</span>     <span class="built_in">printf</span>(<span class="string">&quot;*p[1]=%d\n&quot;</span>,*p[<span class="number">1</span>]);</span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">20</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><font color="red">注意：用指针数组创建的字符串(char *p[]={“hello”,”nihao”,”konnichiwa”})是字符串常量,而用二维字符串数组写的字符串才算变量。</font></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">写博客时有&#123;#的地方必须要放在代码里否则会渲染错误</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
        <tag>Linux基础</tag>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>day19-c函数，结构体</title>
    <url>/2023/03/17/day19-c%E5%87%BD%E6%95%B0%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="day19-c函数，结构体"><a href="#day19-c函数，结构体" class="headerlink" title="day19-c函数，结构体"></a><font color="green">day19-c函数，结构体</font></h1><br>
<br>

<hr>
<h2 id="一、函数："><a href="#一、函数：" class="headerlink" title="一、函数："></a>一、函数：</h2><p>完成特定功能的程序模块</p>
<a id="more"></a>

<h3 id="1-函数的分类："><a href="#1-函数的分类：" class="headerlink" title="1. 函数的分类："></a>1. 函数的分类：</h3><p>库函数，给用户直接调用的函数（调用时要加对应的头文件）</p>
<p>自定义函数：用户自己写的函数</p>
<h3 id="2-怎么去写一个函数："><a href="#2-怎么去写一个函数：" class="headerlink" title="2. 怎么去写一个函数："></a>2. 怎么去写一个函数：</h3><p>（1）函数的声明：定义在头文件下，主函数上，提前告诉计算机，我后面有这个，要给这个函数开辟空间，如果函数的功能写在主函数前面，可以不要声明</p>
<p>一般形式：存储类型 数据类型 函数名（数据类型 形参1，数据类型 形参2.。。。）；（一定要加分号）</p>
<p>（2）函数的功能：</p>
<blockquote>
<p>存储类型 数据类型 函数名（数据类型 形参1，数据类型 形参2.。。。）<br>{<br>功能模块；<br>返回值；返回值可以没有，根据功能来定，如果有返回值，返回值的数据类型要和函数的数据类型保持一致<br>}</p>
</blockquote>
<p>（3）函数的调用</p>
<p>函数名（实参1，实参2.。。。）</p>
<p>实参的数据类型和个数和顺序要和形参保持一致</p>
<h3 id="3-函数的传参："><a href="#3-函数的传参：" class="headerlink" title="3. 函数的传参："></a>3. 函数的传参：</h3><ul>
<li>值传递：</li>
<li>地址传递–地址具有唯一性</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> t;</span><br><span class="line"><span class="number">11</span>     t=*a;</span><br><span class="line"><span class="number">12</span>     *a=*b;</span><br><span class="line"><span class="number">13</span>     *b=t;</span><br><span class="line"><span class="number">14</span>     </span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">17 </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">int</span> x=<span class="number">12</span>,y=<span class="number">34</span>;</span><br><span class="line"><span class="number">19</span>     swap(&amp;x,&amp;y);</span><br><span class="line"><span class="number">20</span>     <span class="built_in">printf</span>(<span class="string">&quot;x=%d----y=%d\n&quot;</span>,x,y);</span><br><span class="line"><span class="number">21</span>     </span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">23</span> &#125;   </span><br></pre></td></tr></table></figure>

<ul>
<li>数组传递–数组传数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="number">9</span> <span class="function"><span class="keyword">char</span> *<span class="title">mystrcat</span><span class="params">(<span class="keyword">char</span> p[<span class="number">32</span>],<span class="keyword">char</span> q[<span class="number">32</span>])</span></span>;<span class="comment">//函数的声明</span></span><br><span class="line"><span class="number">10</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">11 </span>&#123;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">char</span> a[<span class="number">32</span>]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="number">13</span>     <span class="keyword">char</span> b[<span class="number">32</span>]=<span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="number">14</span>     <span class="built_in">puts</span>(mystrcat(a,b));<span class="comment">//函数的调用</span></span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">17</span> &#125;</span><br><span class="line"><span class="number">18</span> <span class="function"><span class="keyword">char</span> *<span class="title">mystrcat</span><span class="params">(<span class="keyword">char</span> p[<span class="number">32</span>],<span class="keyword">char</span> q[<span class="number">32</span>])</span><span class="comment">//函数的功能</span></span></span><br><span class="line"><span class="function">19 </span>&#123;</span><br><span class="line"><span class="number">20</span>     <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">int</span> len=<span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="number">22</span>     <span class="keyword">for</span>(i=<span class="number">0</span>;p[i];i++)</span><br><span class="line"><span class="number">23</span>     &#123;</span><br><span class="line"><span class="number">24</span>         p[len]=q[i];</span><br><span class="line"><span class="number">25</span>         len++;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span>     <span class="keyword">return</span> p;</span><br><span class="line"><span class="number">28</span> &#125;</span><br><span class="line"><span class="number">29</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-指针函数"><a href="#4-指针函数" class="headerlink" title="4.指针函数"></a>4.指针函数</h3><p>本质是一个函数，特殊之处返回值必定是一个地址</p>
<p>一般形式：存储类型 数据类型 *函数名（数据类型 形参1，数据类型 形参2.。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mystrcat</span><span class="params">(<span class="keyword">char</span> p[<span class="number">32</span>],<span class="keyword">char</span> q[<span class="number">32</span>])</span><span class="comment">//函数的功能</span></span></span><br><span class="line"><span class="function"> 19 </span>&#123;</span><br><span class="line"> <span class="number">20</span>     <span class="keyword">int</span> i;</span><br><span class="line"> <span class="number">21</span>     <span class="keyword">int</span> len=<span class="built_in">strlen</span>(p);</span><br><span class="line"> <span class="number">22</span>     <span class="keyword">for</span>(i=<span class="number">0</span>;p[i];i++)</span><br><span class="line"> <span class="number">23</span>     &#123;</span><br><span class="line"> <span class="number">24</span>         p[len]=q[i];</span><br><span class="line"> <span class="number">25</span>         len++;</span><br><span class="line"> <span class="number">26</span>     &#125;</span><br><span class="line"> <span class="number">27</span>     <span class="keyword">return</span> p;</span><br><span class="line"> <span class="number">28</span> &#125;</span><br><span class="line"> <span class="number">29</span> </span><br></pre></td></tr></table></figure>

<h3 id="5-函数指针："><a href="#5-函数指针：" class="headerlink" title="5.函数指针："></a>5.函数指针：</h3><p>本质是一个函数，只是这个指针指向的是函数的入口地址，就是函数名</p>
<p>一般形式：存储类型 数据类型 （*指针变量名）（数据类型 形参1，数据类型 形参2.。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> t;</span><br><span class="line"><span class="number">11</span>     t=*a;</span><br><span class="line"><span class="number">12</span>     *a=*b;</span><br><span class="line"><span class="number">13</span>     *b=t;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function">17 </span>&#123;   </span><br><span class="line"><span class="number">18</span>     <span class="keyword">return</span> *a + *b;</span><br><span class="line"><span class="number">19</span> &#125;   </span><br><span class="line"><span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">21 </span>&#123;</span><br><span class="line"><span class="number">22</span>     <span class="keyword">int</span> x=<span class="number">12</span>,y=<span class="number">34</span>;</span><br><span class="line"><span class="number">23</span>     <span class="keyword">int</span> (*p)(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)=swap; <span class="comment">//把swap赋给p函数指针</span></span><br><span class="line"><span class="number">24</span>     p(&amp;x,&amp;y);<span class="comment">//调用p</span></span><br><span class="line"><span class="number">25</span>     p=add;</span><br><span class="line"><span class="number">26</span>     <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,p(&amp;x,&amp;y));</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">29</span> &#125;</span><br></pre></td></tr></table></figure>




<h3 id="6-函数指针数组"><a href="#6-函数指针数组" class="headerlink" title="6. 函数指针数组"></a>6. 函数指针数组</h3><p>本质是一个数组，只是这个数组里面放的是指向函数的指针</p>
<p>一般形式：存储类型 数据类型 （*数组名【下标】）（数据类型 形参1，数据类型 形参2.。。。）</p>
<p>例如：int （*p【3】）（int ，int）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*===============================================</span></span><br><span class="line"><span class="comment">*   文件名称：jisuan.c</span></span><br><span class="line"><span class="comment">*   创 建 者：  张城   </span></span><br><span class="line"><span class="comment">*   创建日期：2023年03月16日</span></span><br><span class="line"><span class="comment">*   描    述：</span></span><br><span class="line"><span class="comment">================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jian</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cheng</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chu</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> (*p[<span class="number">4</span>])(<span class="keyword">int</span> a,<span class="keyword">int</span> b)=&#123;add,jian,cheng,chu&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>,&amp;i,&amp;c,&amp;j);</span><br><span class="line">    <span class="keyword">switch</span>(c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">0</span>](i,j));<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">1</span>](i,j));<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">2</span>](i,j));<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">3</span>](i,j));<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="7-函数的多文件封装"><a href="#7-函数的多文件封装" class="headerlink" title="7. 函数的多文件封装"></a>7. 函数的多文件封装</h3><p>（1）头文件–可以放库头文件和所有功能函数的声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __JISUAN_H__---防止头文件重复包含</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> __JISUAN_H__</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;--库头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;--函数的声明</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jian</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cheng</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chu</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>（2）功能文件–自定义的头文件和所有功能函数代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;jisuan.h&quot;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">return</span> a+b;</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span> <span class="function"><span class="keyword">int</span> <span class="title">jian</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">13 </span>&#123;</span><br><span class="line"><span class="number">14</span>     <span class="keyword">return</span> a-b;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">cheng</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">17 </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">return</span> a*b;</span><br><span class="line"><span class="number">19</span> &#125;</span><br><span class="line"><span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">chu</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">21 </span>&#123;</span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> a/b;</span><br><span class="line"><span class="number">23</span> &#125;</span><br><span class="line"><span class="number">24</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>（3）主函数文件—自定义头文件和函数的调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;jisuan.h&quot;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">  9 </span>&#123;</span><br><span class="line"> <span class="number">10</span>     <span class="keyword">int</span> x=<span class="number">12</span>,y=<span class="number">34</span>;</span><br><span class="line"> <span class="number">11</span>     <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,add(x,y));</span><br><span class="line"> <span class="number">12</span> </span><br><span class="line"> <span class="number">13</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">14</span> &#125;</span><br><span class="line">编译：至少编译两个.c文件，头文件默认在当前目录下去找</span><br><span class="line">    调用外部头文件：-I</span><br></pre></td></tr></table></figure>


<h3 id="8-递归函数："><a href="#8-递归函数：" class="headerlink" title="8. 递归函数："></a>8. 递归函数：</h3><p>直接或间接调用函数本身的函数</p>
<p>两个条件：调用自己，要有结束标志</p>
<p>每次调用自己都会给函数开辟空间，所以每次调用的变量都被会保留在当前函数内，没有到结束标志回归不会被释放</p>
<p>循环能做的，递归函数都能做，但是递归函数能做的，循环不一定能做，所以我们能用循环就用循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line"><span class="number">11</span>     &#123;</span><br><span class="line"><span class="number">12</span>        <span class="keyword">return</span> n+add(n<span class="number">-1</span>);</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">17 </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">int</span> n;</span><br><span class="line"><span class="number">19</span>     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="number">20</span>     <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,add(n));</span><br><span class="line"><span class="number">21</span> </span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">23</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-回调函数"><a href="#9-回调函数" class="headerlink" title="9. 回调函数"></a>9. 回调函数</h3><p>把一个函数作为一个参数，用函数指针来接受的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">return</span> a+b;</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span> <span class="function"><span class="keyword">int</span> <span class="title">gohome</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> (*p)())</span></span></span><br><span class="line"><span class="function">13 </span>&#123;</span><br><span class="line"><span class="number">14</span>     <span class="keyword">return</span> p(a,b);</span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">18 </span>&#123;</span><br><span class="line"><span class="number">19</span>     <span class="keyword">int</span> x=<span class="number">12</span>,y=<span class="number">34</span>;</span><br><span class="line"><span class="number">20</span>     <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,gohome(x,y,callback));</span><br><span class="line"><span class="number">21</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">22</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-动态开辟空间函数"><a href="#10-动态开辟空间函数" class="headerlink" title="10. 动态开辟空间函数"></a>10. 动态开辟空间函数</h3><p>malloc</p>
<p>在堆区开辟空间，需要我们手动开辟，<strong>也需要我们手动释放</strong></p>
<p>头文件：#include &lt;stdlib.h&gt;</p>
<p>函数原型：void *malloc(size_t size);</p>
<p>参数：size：需要开辟空间的大小</p>
<p>返回值：开辟成功返回开辟的首地址，失败返回NULL</p>
<p>释放空间地址：</p>
<p>void free(void *ptr);</p>
<p>参数：ptr：要释放的首地址</p>
<p><strong>释放的是开辟的空间地址，而我们的指针还在，此时没有指向，变成野指针，需要给它赋值为NULL</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">10 </span>&#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="number">12</span>     <span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line"><span class="number">13</span>     &#123;</span><br><span class="line"><span class="number">14</span>         <span class="built_in">printf</span>(<span class="string">&quot;create error\n&quot;</span>);</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span>     *p=<span class="number">12</span>;</span><br><span class="line"><span class="number">17</span>     <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>,*p);</span><br><span class="line"><span class="number">18</span>     <span class="built_in">free</span>(p);</span><br><span class="line"><span class="number">19</span>     p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">21</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">22</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="二、关键字："><a href="#二、关键字：" class="headerlink" title="二、关键字："></a>二、关键字：</h2><h3 id="1-const–变量常量化"><a href="#1-const–变量常量化" class="headerlink" title="1. const–变量常量化"></a>1. const–变量常量化</h3><p>const修饰指针：</p>
<p>int const *p=&amp;a—-p的内容不能改</p>
<p>int *const p=&amp;a;—-p的指向不能改</p>
<h3 id="2-typedef—重命名"><a href="#2-typedef—重命名" class="headerlink" title="2. typedef—重命名"></a>2. typedef—重命名</h3><p>已知数据类型的重命名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="keyword">typedef</span> <span class="keyword">int</span> A;</span><br><span class="line">  <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 10 </span>&#123;</span><br><span class="line"> <span class="number">11</span>     A a=<span class="number">12</span>;</span><br><span class="line"> <span class="number">12</span>     <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);    </span><br><span class="line"> <span class="number">13</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">14</span> &#125; </span><br><span class="line">~     </span><br></pre></td></tr></table></figure>

<h3 id="3-define—-宏定义"><a href="#3-define—-宏定义" class="headerlink" title="3. define—-宏定义"></a>3. define—-宏定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="meta">#<span class="meta-keyword">define</span> A char *</span></span><br><span class="line">  <span class="number">9</span> <span class="keyword">typedef</span>  <span class="keyword">char</span> * B;</span><br><span class="line"> <span class="number">10</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 11 </span>&#123;</span><br><span class="line"> <span class="number">12</span>     A a,b; <span class="comment">//这样定义后会发现b是char类型而不是char*</span></span><br><span class="line"> <span class="number">13</span>     B c,d; <span class="comment">// a=8,b=1,c=8,d=8</span></span><br><span class="line"> <span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">&quot;a=%ld\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"> <span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">&quot;b=%ld\n&quot;</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line"> <span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">&quot;c=%ld\n&quot;</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line"> <span class="number">17</span>     <span class="built_in">printf</span>(<span class="string">&quot;d=%ld\n&quot;</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line"> <span class="number">18</span>     </span><br><span class="line"> <span class="number">19</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">20</span> &#125; </span><br></pre></td></tr></table></figure>

<p>练习：利用宏定义求出两个数之间的最大值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="meta">#<span class="meta-keyword">define</span> MAX (5&gt;3)?5:3</span></span><br><span class="line">  <span class="number">9</span> <span class="keyword">typedef</span>  <span class="keyword">char</span> * B; </span><br><span class="line"> <span class="number">10</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 11 </span>&#123;   </span><br><span class="line"> <span class="number">12</span>     <span class="built_in">printf</span>(<span class="string">&quot;MAX=%d\n&quot;</span>,MAX);</span><br><span class="line"> <span class="number">13</span>     </span><br><span class="line"> <span class="number">14</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">15</span> &#125;   </span><br><span class="line">~     </span><br></pre></td></tr></table></figure>

<h3 id="4-static—静态区域存储"><a href="#4-static—静态区域存储" class="headerlink" title="4. static—静态区域存储"></a>4. static—静态区域存储</h3><blockquote>
<p>修饰全局变量，限制作用域<br>修饰局部变量，延长声明周期（只会被初始化一次）<br>修饰函数，限制作用域</p>
</blockquote>
<h3 id="5-extern—调用外部文件变量"><a href="#5-extern—调用外部文件变量" class="headerlink" title="5. extern—调用外部文件变量"></a>5. extern—调用外部文件变量</h3><p>只能调用全局变量</p>
<blockquote>
<p>定义: int extern a;</p>
</blockquote>
<p>编译的时候要和调用的文件一起编译</p>
<h3 id="6-struct—结构体"><a href="#6-struct—结构体" class="headerlink" title="6. struct—结构体"></a>6. struct—结构体</h3><p>本质还是一个数据类型，只是里面可以放很多成员，这些成员数据类型可以一样，也可以不一样，可以是已知的数据类型，也可以是构造类型</p>
<p>一般形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct 结构体名&#123;</span><br><span class="line">数据类型 成员1；</span><br><span class="line">数据类型 成员2；</span><br><span class="line">......</span><br><span class="line">&#125;；--分号不能省略</span><br></pre></td></tr></table></figure>
<p>结构体的初始化：（按照顺序初始化）</p>
<p>全局变量初始化：在头文件下，主函数上，就是在构造完这个结构体立马定义一个变量</p>
<p>局部变量初始化，在主函数里面定义一个结构体变量</p>
<p>结构体的成员的调用：变量名.成员</p>
<p>结构体的赋值：</p>
<p>1、结构体赋结构体</p>
<p>2、每个成员单独赋值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="number">9</span> <span class="class"><span class="keyword">struct</span> <span class="title">zc</span>&#123;</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> age;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"><span class="number">12</span>     <span class="keyword">char</span> sex[<span class="number">32</span>];</span><br><span class="line"><span class="number">13</span> &#125;a=&#123;<span class="number">18</span>,<span class="string">&quot;zhangcheng&quot;</span>,<span class="string">&quot;man&quot;</span>&#125;;<span class="comment">//全局变量初始化</span></span><br><span class="line"><span class="number">14</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">15 </span>&#123;   </span><br><span class="line"><span class="number">16</span>     <span class="class"><span class="keyword">struct</span> <span class="title">zc</span> <span class="title">b</span>=&#123;</span><span class="number">20</span>,<span class="string">&quot;cheng&quot;</span>,<span class="string">&quot;man&quot;</span>&#125;;<span class="comment">//局部变量初始化</span></span><br><span class="line"><span class="number">17</span>     <span class="class"><span class="keyword">struct</span> <span class="title">zc</span> <span class="title">c</span>;</span></span><br><span class="line"><span class="number">18</span>     c.age=<span class="number">22</span>;</span><br><span class="line"><span class="number">19</span>     <span class="built_in">strcpy</span>(c.name,<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line"><span class="number">20</span>     <span class="built_in">strcpy</span>(c.sex,<span class="string">&quot;women&quot;</span>);</span><br><span class="line"><span class="number">21</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.age=%d\n&quot;</span>,a.age);<span class="comment">//成员的调用</span></span><br><span class="line"><span class="number">22</span>     <span class="built_in">printf</span>(<span class="string">&quot;b.age=%d\n&quot;</span>,b.age);</span><br><span class="line"><span class="number">23</span>     <span class="built_in">printf</span>(<span class="string">&quot;c.sex=%s\n&quot;</span>,c.sex);</span><br><span class="line"><span class="number">24</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">25</span> &#125;</span><br><span class="line">     </span><br></pre></td></tr></table></figure>


<ul>
<li>结构体的大小：</li>
</ul>
<p>规则：</p>
<p>&emsp;&emsp;如果是64位操作系统默认按照8byte对齐，但是如果最大的数据类型小于8byte，就按照最大数据类型大小对齐（就是最大成员数据类型的倍数）</p>
<p>&emsp;&emsp;如果是32位操作系统默认按照4byte对齐，但是如果最大的数据类型小于4byte，就按照最大数据类型大小对齐（就是最大成员数据类型的倍数）</p>
<p>&emsp;&emsp;如果对齐字节能够放下后面的成员，就会在当前字节放</p>
<p>&emsp;&emsp;并且存储遵循偶数存储原则</p>
<blockquote>
<p>例：<br>struct temp{char a；short b;char c;int d}<br>结构体大小为12字节。因为以里面最大的int开辟空间为4字节<br>第一个4字节有<code>a,b</code>,因为偶数原则，a占1，b占3，4<br>第二个4字节有<code>c</code>，占1<br>第三个4字节有<code>d</code>占1，2，3，4</p>
</blockquote>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>函数</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>day20-c特殊类型和gbd,makefile</title>
    <url>/2023/03/17/day20-c%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E5%92%8Cgbd-makefile/</url>
    <content><![CDATA[<h1 id="day20-linux基础和c"><a href="#day20-linux基础和c" class="headerlink" title="day20-linux基础和c"></a><font color="green">day20-linux基础和c</font></h1><br>
<br>

<hr>
<h2 id="一、结构体："><a href="#一、结构体：" class="headerlink" title="一、结构体："></a>一、结构体：</h2><a id="more"></a>

<h3 id="1-结构体的嵌套："><a href="#1-结构体的嵌套：" class="headerlink" title="1. 结构体的嵌套："></a>1. 结构体的嵌套：</h3><p>结构体里面再放结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">  <span class="number">9</span>     <span class="keyword">int</span> age;</span><br><span class="line"> <span class="number">10</span>     <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"> <span class="number">11</span>     <span class="keyword">int</span> id;</span><br><span class="line"> <span class="number">12</span> &#125;STU;</span><br><span class="line"> <span class="number">13</span> </span><br><span class="line"> <span class="number">14</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tea</span>&#123;</span></span><br><span class="line"> <span class="number">15</span>     <span class="keyword">int</span> age;</span><br><span class="line"> <span class="number">16</span>     <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"> <span class="number">17</span>     <span class="keyword">char</span> sex[<span class="number">32</span>];</span><br><span class="line"> <span class="number">18</span>     STU zc;</span><br><span class="line"> <span class="number">19</span> &#125;TEA;</span><br><span class="line"> <span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 21 </span>&#123;   </span><br><span class="line"> <span class="number">22</span>     STU a=&#123;<span class="number">12</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">45</span>&#125;;</span><br><span class="line"> <span class="number">23</span>     TEA b=&#123;<span class="number">30</span>,<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;man&quot;</span>,a&#125;;</span><br><span class="line"> <span class="number">24</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.age=%d\n&quot;</span>,a.age);</span><br><span class="line"> <span class="number">25</span>     <span class="built_in">printf</span>(<span class="string">&quot;b.zc.age=%d\n&quot;</span>,b.zc.age);</span><br><span class="line"> <span class="number">26</span> </span><br><span class="line"> <span class="number">27</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">28</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-结构体指针"><a href="#2-结构体指针" class="headerlink" title="2. 结构体指针"></a>2. 结构体指针</h3><p>本质是一个指针，只是这个指针指向了一个结构体</p>
<p>一般形式：struct 结构提名 * 指针变量名；</p>
<p>初始化：struct 结构提名 * 指针变量名=结构体地址；</p>
<p>指针访问结构体内容：</p>
<p>两种方式：</p>
<p>1、（*p）.成员—用的少</p>
<p>2、p-&gt;成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">21 </span>&#123;   </span><br><span class="line"><span class="number">22</span>     STU a=&#123;<span class="number">12</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">45</span>&#125;;</span><br><span class="line"><span class="number">23</span>     STU *p=&amp;a;<span class="comment">//初始化</span></span><br><span class="line"><span class="number">24</span>     <span class="built_in">printf</span>(<span class="string">&quot;(*p).age=%d\n&quot;</span>,(*p).age);</span><br><span class="line"><span class="number">25</span>     <span class="built_in">printf</span>(<span class="string">&quot;p-&gt;age=%d\n&quot;</span>,p-&gt;age);</span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">28</span> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-结构体数组："><a href="#3-结构体数组：" class="headerlink" title="3. 结构体数组："></a>3. 结构体数组：</h3><p>本质是一个数组，只是这个数组里面的元素都是结构体</p>
<p>一般形式：struct 结构提名 数组名【下标】；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 21 </span>&#123;   </span><br><span class="line"> <span class="number">22</span>     STU a=&#123;<span class="number">12</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">45</span>&#125;;</span><br><span class="line"> <span class="number">23</span>     STU b=&#123;<span class="number">13</span>,<span class="string">&quot;lisi&quot;</span>,<span class="number">47</span>&#125;;</span><br><span class="line"> <span class="number">24</span>     STU c=&#123;<span class="number">15</span>,<span class="string">&quot;wangwu&quot;</span>,<span class="number">50</span>&#125;;</span><br><span class="line"> <span class="number">25</span>     STU s[<span class="number">3</span>]=&#123;a,b,c&#125;;<span class="comment">//初始化</span></span><br><span class="line"> <span class="number">26</span>     <span class="built_in">printf</span>(<span class="string">&quot;s[1].name=%s\n&quot;</span>,s[<span class="number">1</span>].name);</span><br><span class="line"> <span class="number">27</span>     </span><br><span class="line"> <span class="number">28</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">29</span> &#125; </span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="二、共用体—union"><a href="#二、共用体—union" class="headerlink" title="二、共用体—union"></a>二、共用体—union</h2><p>也叫联合体</p>
<p>成员们一起用一片空间地址</p>
<p>共用体不允许初始化</p>
<p>STU a={12,”zhangsan”,45};//错误</p>
<p>赋值只能成员赋值，而且每次只能赋值一个，前面赋值的都会被覆盖</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="number">9</span> <span class="keyword">typedef</span> <span class="keyword">union</span> stu&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> age;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"><span class="number">12</span>     <span class="keyword">int</span> id;</span><br><span class="line"><span class="number">13</span> &#125;STU;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">16 </span>&#123;   </span><br><span class="line"><span class="number">17</span>     STU a;</span><br><span class="line"><span class="number">18</span>     a.age=<span class="number">12</span>;</span><br><span class="line"><span class="number">19</span>     <span class="built_in">strcpy</span>(a.name,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"><span class="number">20</span>     a.id=<span class="number">45</span>;</span><br><span class="line"><span class="number">21</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.age=%d\n&quot;</span>,a.age); <span class="comment">//a.age=45</span></span><br><span class="line"><span class="number">22</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.name=%s\n&quot;</span>,a.name); <span class="comment">//a.name=-</span></span><br><span class="line"><span class="number">23</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.id=%d\n&quot;</span>,a.id); <span class="comment">//a.id=45</span></span><br><span class="line"><span class="number">24</span>     </span><br><span class="line"><span class="number">25</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">26</span> &#125; </span><br></pre></td></tr></table></figure>

<p>共用体的大小：</p>
<p>也要遵循结构体大小的规则，但是只会给最大成员开辟对应的空间地址</p>
<br>
<br>

<hr>
<h2 id="三、枚举型–enum"><a href="#三、枚举型–enum" class="headerlink" title="三、枚举型–enum"></a>三、枚举型–enum</h2><p>成员没有初始化，从0开始往后赋值</p>
<p>如果有成员赋值，成员后面依次递增+1</p>
<p>enum里面的成员都是常量，不能修改它们的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">10 </span>&#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">enum</span> &#123;A,E,B=<span class="number">2</span>,C,D=<span class="number">8</span>,F&#125;;</span><br><span class="line"><span class="number">12</span>     <span class="built_in">printf</span>(<span class="string">&quot;A=%d\n&quot;</span>,A);<span class="comment">//0</span></span><br><span class="line"><span class="number">13</span>     <span class="built_in">printf</span>(<span class="string">&quot;E=%d\n&quot;</span>,E);<span class="comment">//1</span></span><br><span class="line"><span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">&quot;B=%d\n&quot;</span>,B);<span class="comment">//2</span></span><br><span class="line"><span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">&quot;C=%d\n&quot;</span>,C);<span class="comment">//3</span></span><br><span class="line"><span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">&quot;F=%d\n&quot;</span>,F);<span class="comment">//9</span></span><br><span class="line"><span class="number">17</span>     </span><br><span class="line"><span class="number">18</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">19</span> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="四、gdb调试工具："><a href="#四、gdb调试工具：" class="headerlink" title="四、gdb调试工具："></a>四、gdb调试工具：</h2><p>帮助我们找出代码的问题</p>
<p>gcc -g 编译的文件名，会生成一个a.out的执行文件，这个执行文件就可以调试</p>
<p>gdb 执行文件名</p>
<blockquote>
<p>r—运行我们的程序<br>l—查看我们的程序代码<br>b—设置断点，让程序跑到我们断点的那一行<br>c–继续运行我们的程序，直到下一个断点，如果没有直接运行完<br>p+变量===查看变量的值<br>n—按行运行，但是不进入函数<br>s—按行运行，会进入函数<br>delete—删除所有断点<br>q—退出dgb调试</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="五、makefile"><a href="#五、makefile" class="headerlink" title="五、makefile"></a>五、makefile</h2><p>makefile是一个文件，里面放的是编译的规则，可以管理多个文件</p>
<p>make是一个工具，用来解析我们的makefile</p>
<p>make会根据文件的时间戳进行编译，如果文件的时间戳没有改变，不会编译该文件，节省大量的编译时间</p>
<p>makefile的逻辑：</p>
<p>目标文件：依赖文件</p>
<p>​     （tab）编译语句</p>
<p>目标文件就是我们最终会生成的文件，要生成这个文件，会去找生成它需要的文件，就叫依赖文件，如果这个依赖文件有需要其他文件来生成，继续找它的依赖文件，直到不需要为止</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> app:<span class="built_in">list</span>.o main.o</span><br><span class="line"> <span class="number">2</span>     gcc  <span class="built_in">list</span>.o main.o -o app</span><br><span class="line"> <span class="number">3</span> <span class="built_in">list</span>.o:<span class="built_in">list</span>.c</span><br><span class="line"> <span class="number">4</span>     gcc -c <span class="built_in">list</span>.c -o <span class="built_in">list</span>.o</span><br><span class="line"> <span class="number">5</span> main.o:main.c</span><br><span class="line"> <span class="number">6</span>     gcc -c main.c -o main.o</span><br><span class="line"> <span class="number">7</span> clean:</span><br><span class="line"> <span class="number">8</span>     rm main.o <span class="built_in">list</span>.o app </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>make clean  删除生成的文件（执行clean后面的语句）</p>
<p>make，默认解析当前目录下的makefile或者Makefile</p>
<p>make -f 指定的makefile</p>
<p>调用外部头文件-I 加头文件的路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> app:<span class="built_in">list</span>.o main.o</span><br><span class="line"> <span class="number">2</span>     gcc  <span class="built_in">list</span>.o main.o -I ./include -o app</span><br><span class="line"> <span class="number">3</span> <span class="built_in">list</span>.o:<span class="built_in">list</span>.c</span><br><span class="line"> <span class="number">4</span>     gcc -c <span class="built_in">list</span>.c -I ./include -o <span class="built_in">list</span>.o</span><br><span class="line"> <span class="number">5</span> main.o:main.c</span><br><span class="line"> <span class="number">6</span>     gcc -c main.c -I ./include -o main.o</span><br><span class="line"> <span class="number">7</span> clean:</span><br><span class="line"> <span class="number">8</span>     rm main.o <span class="built_in">list</span>.o app </span><br></pre></td></tr></table></figure>

<h3 id="makefile的变量"><a href="#makefile的变量" class="headerlink" title="makefile的变量"></a>makefile的变量</h3><p>变量的赋值：</p>
<ul>
<li>=：给当前变量赋值，但是如果后面有新的赋值，把新的赋值给变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">2</span> b=$(a)</span><br><span class="line">  <span class="number">3</span> a=<span class="number">34</span></span><br><span class="line">  <span class="number">4</span> all:</span><br><span class="line">  <span class="number">5</span>     @echo $(b)</span><br><span class="line">b=<span class="number">34</span></span><br></pre></td></tr></table></figure>

<ul>
<li>:=—立即赋值,和平时的赋值一样，后面新的赋值不会改变当前值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">2</span> b:=$(a)</span><br><span class="line">  <span class="number">3</span> a=<span class="number">34</span></span><br><span class="line">  <span class="number">4</span> all:</span><br><span class="line">  <span class="number">5</span>     @echo $(b)</span><br><span class="line">      b=<span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>？=—询问赋值,询问前面有没有赋值，如果有，此次赋值无效</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">2</span> b:=$(a)</span><br><span class="line">  <span class="number">3</span> a?=<span class="number">34</span></span><br><span class="line">  <span class="number">4</span> all:</span><br><span class="line">  <span class="number">5</span>     @echo $(b)</span><br><span class="line">  <span class="number">6</span>     echo $(a)</span><br><span class="line">a=<span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>+=：追加赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">2</span> b:=$(a)</span><br><span class="line">  <span class="number">3</span> a+=hello</span><br><span class="line">  <span class="number">4</span> all:</span><br><span class="line">  <span class="number">5</span>     @echo $(b)</span><br><span class="line">  <span class="number">6</span>     echo $(a)</span><br><span class="line">a=<span class="number">12</span> hello</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在语句前加@隐藏显示语句</p>
</blockquote>
<p>利用变量写makefile：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> TARGET=app <span class="comment">//相当于代替</span></span><br><span class="line">  <span class="number">2</span> OBJS=<span class="built_in">list</span>.o main.o </span><br><span class="line">  <span class="number">3</span> CC=gcc</span><br><span class="line">  <span class="number">4</span> OBJS2=<span class="built_in">list</span>.c</span><br><span class="line">  <span class="number">5</span> OBJS3=main.c</span><br><span class="line">  <span class="number">6</span> PATH=-I ./include</span><br><span class="line">  <span class="number">7</span> </span><br><span class="line">  <span class="number">8</span> $(TARGET):$(OBJS)</span><br><span class="line">  <span class="number">9</span>     $(CC)  $(OBJS) $(PATH) -o $(TARGET)</span><br><span class="line"> <span class="number">10</span> <span class="built_in">list</span>.o:$(OBJS2)</span><br><span class="line"> <span class="number">11</span>     $(CC) -c $(OBJS2) $(PATH) -o <span class="built_in">list</span>.o</span><br><span class="line"> <span class="number">12</span> main.o:$(OBJS3)</span><br><span class="line"> <span class="number">13</span>     $(CC) -c $(OBJS3) $(PATH) -o main.o</span><br><span class="line"> <span class="number">14</span> clean:</span><br><span class="line"> <span class="number">15</span>     rm $(OBJS) $(TARGET) </span><br><span class="line">~                            </span><br></pre></td></tr></table></figure>

<p>特殊的变量：</p>
<blockquote>
<p>$@—目标文件<br>$^—所有依赖文件<br>$&lt;:第一个依赖文件<br>通配符：%</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TARGET=app</span><br><span class="line"> <span class="number">2</span> OBJS=<span class="built_in">list</span>.o main.o</span><br><span class="line"> <span class="number">3</span> CC=gcc</span><br><span class="line"> <span class="number">4</span> OBJS2=<span class="built_in">list</span>.c</span><br><span class="line"> <span class="number">5</span> OBJS3=main.c</span><br><span class="line"> <span class="number">6</span> path=-I ./include</span><br><span class="line"> <span class="number">7</span> $(TARGET):$(OBJS)</span><br><span class="line"> <span class="number">8</span>     $(CC)  $^ $(path) -o $@</span><br><span class="line"> <span class="number">9</span> %.o:%.c</span><br><span class="line"><span class="number">10</span>     $(CC) -c $^ $(path) -o $@</span><br><span class="line"><span class="number">11</span> clean:</span><br><span class="line"><span class="number">12</span>     rm $(TARGET) $(OBJS)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>c语言</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>结构体</tag>
        <tag>gbd</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>day22-数据结构和算法简介，顺序表</title>
    <url>/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="day22-数据结构和算法简介，顺序表"><a href="#day22-数据结构和算法简介，顺序表" class="headerlink" title="day22-数据结构和算法简介，顺序表"></a><font color="green">day22-数据结构和算法简介，顺序表</font></h1><h2 id="一、课程大纲"><a href="#一、课程大纲" class="headerlink" title="一、课程大纲"></a>一、课程大纲</h2><ol>
<li>数据结构基础及算法基础+ 顺序表</li>
<li>链表</li>
<li>双向链表、双向循环链表 、栈、队列</li>
<li>树、图</li>
<li>常见的算法</li>
</ol>
<a id="more"></a>
<br>
<br>

<hr>
<h2 id="二、数据结构和算法简介"><a href="#二、数据结构和算法简介" class="headerlink" title="二、数据结构和算法简介"></a>二、数据结构和算法简介</h2><h3 id="1-数据结构基础"><a href="#1-数据结构基础" class="headerlink" title="1.数据结构基础"></a>1.数据结构基础</h3><ol>
<li><p>了解数据的基本概念和术语：</p>
<ul>
<li><p>数据：</p>
<pre><code>  (1)数据即信息的载体，是能够输入到计算机中且能被计算机识别、存储和处理的符号总称。
  (2)数据不仅包括:
 a. 数值型数据：整型、实型、字符型数值型数据
 b. 非数值型数据：图片、视频、声音等</code></pre>
</li>
<li><p>数据项：<br> 数据元素由若干数据项组成，数据项是数据中的最小单位。</p>
<p> 数据由多种数据项组成：</p>
<p> 正比如：我们在讨论一个电影角色等时候，我们讨论的是该角色的姓名、性别、住址、等</p>
<p> 注意：数据项是数据不可分隔的最小组成单位</p>
</li>
<li><p>数据结构（DS）：</p>
<p> (1)可用形式化语言描述，即DS是一个二元组：</p>
<pre><code>       DS =（D,R）其中，D为数据元素的集合，R为D上关系的集合。 </code></pre>
<p> (2)数据结构的逻辑关系</p>
<p> <img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321104451784.png" alt="image-20230321104451784"></p>
</li>
</ul>
<ul>
<li>存储结构：</li>
</ul>
<blockquote>
<p>a. 顺序存储<br>b. 链式存储<br>c. 索引存储<br>d. 散列存储</p>
</blockquote>
<ul>
<li>运算：增、删、改、查、排</li>
</ul>
<p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321105735324.png" alt="image-20230321105735324"></p>
</li>
</ol>
<h3 id="2-算法"><a href="#2-算法" class="headerlink" title="2.算法"></a>2.算法</h3><p>(1)什么是算法？</p>
<pre><code>    1. 算法（Algorithm）是一个有穷规则（或语句、指令）的有序集合。它确定了解决某一问题的一个运算序列。对于问题的初始输入，通过算法有限步的运行，产生一个或多个输出。

    2. 算法的特性：

        (1)  有穷性 —— 算法执行的步骤（或规则）是有限的

        (2)  确定性 —— 每个计算步骤无二义性

        (3)  可行性 —— 每个计算步骤能够在有限的时间内完成

        (4)  输入  —— 算法有零个或多个外部输入

        (5)  输出  —— 算法有一个或多个输出

    3. 算法和程序的区别：

        共同点：二者都是为完成某个任务，或解决某个问题而编制的规则（或语句）的有序集合，这是它们的。
        不同点：
            * 算法与计算机无关，但程序依赖于具体的计算机语言。
            * 算法必须是有穷尽的，但程序可能是无穷尽的。
            * 算法可忽略一些语法细节问题，重点放在解决问题的思路上，但程序必须严格遵循相应语言工具的语法。算法转换成程序后才能在计算机上运行。另外，在设计算法时，一定要考虑它的确定性，即算法的每个步骤都是无二义性的（即一条规则不能有两种以上的解释）

    4. 程序的基本概念：

        1. 可执行的有序二进制指令、存放在磁盘、不占用系统资源（ cpu、内存等）

    5. 算法的优劣：

        消耗时间的多少 ：

        消耗存储空间的多少 ：

        容易理解、容易编程和调试、容易维护。时间复杂度的概念介绍 ：

        问题的规模 ：输入数据量的大小，用n来表示。

        算法的时间复杂度 ：算法消耗时间，它是问题规模的函数 T(n)。

        其中好算法代表了：

            算法对应的程序所耗时间少；

            算法对应的程序所耗存储空间少；

            算法结构性好、易读、易移植和调试等等。

        3. 时间复杂度：算法的时间复杂度定义为算法中可执行语句的频度之和，记为T(n)</code></pre>
<p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321141217272.png" alt="image-20230321141217272"><br><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321141200570.png" alt="image-20230321141200570"></p>
<h3 id="3-数据结构常见的结构"><a href="#3-数据结构常见的结构" class="headerlink" title="3.数据结构常见的结构-"></a>3.数据结构常见的结构-</h3><p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321142133548.png" alt="image-20230321142133548"></p>
<br>
<br>

<hr>
<h2 id="三、数据结构之顺序表"><a href="#三、数据结构之顺序表" class="headerlink" title="三、数据结构之顺序表"></a>三、数据结构之顺序表</h2><ol>
<li>线性表：</li>
</ol>
<p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321144943972.png" alt="image-20230321144943972"></p>
<ol start="2">
<li>线性表特征：</li>
</ol>
<p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321145052751.png" alt="image-20230321145052751"></p>
<ol start="3">
<li>顺序表的代码实现：</li>
</ol>
<p>（1）memset(&emsp;)函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">功能：<span class="built_in">memset</span> - fill memory with a constant byte</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">函数原型：</span><br><span class="line">       <span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">参数说明：</span><br><span class="line">	<span class="keyword">void</span> *s：要清空的目标数组或指针所指空间  buf</span><br><span class="line">	<span class="keyword">int</span> c：给定的填充的数据   <span class="number">0</span> <span class="number">1</span> 等</span><br><span class="line">    <span class="keyword">size_t</span> n： 大小     <span class="keyword">sizeof</span>（buf）；</span><br><span class="line">返回值</span><br><span class="line">	无返回值：</span><br></pre></td></tr></table></figure>



<p>（2）bzero(&emsp;)函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">功能： bzero - write zero-valued bytes</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line">函数原型：</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">参数说明：</span><br><span class="line">	<span class="keyword">void</span> *s：要清空的目标数组或指针所指空间  buf</span><br><span class="line">    <span class="keyword">size_t</span> n： 大小     <span class="keyword">sizeof</span>（buf）；</span><br><span class="line">返回值</span><br><span class="line">	无返回值：</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>（3）printf 变色打印(Linux)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    字背景颜色范围:<span class="number">40</span> - <span class="number">49</span></span><br><span class="line">    <span class="number">40</span>:黑</span><br><span class="line">    <span class="number">41</span>:深红</span><br><span class="line">    <span class="number">42</span>:绿</span><br><span class="line">    <span class="number">43</span>:黄色</span><br><span class="line">    <span class="number">44</span>:蓝色</span><br><span class="line">    <span class="number">45</span>:紫色</span><br><span class="line">    <span class="number">46</span>:深绿</span><br><span class="line">    <span class="number">47</span>:白色</span><br><span class="line">     </span><br><span class="line">    字颜色:<span class="number">30</span> - <span class="number">39</span></span><br><span class="line">    <span class="number">30</span>:黑</span><br><span class="line">    <span class="number">31</span>:红</span><br><span class="line">    <span class="number">32</span>:绿</span><br><span class="line">    <span class="number">33</span>:黄</span><br><span class="line">    <span class="number">34</span>:蓝色</span><br><span class="line">    <span class="number">35</span>:紫色</span><br><span class="line">    <span class="number">36</span>:深绿</span><br><span class="line">    <span class="number">37</span>:白色</span><br><span class="line">    \<span class="number">33</span>[<span class="number">0</span>m 关闭所有属性</span><br><span class="line">    \<span class="number">33</span>[<span class="number">1</span>m 设置高亮度</span><br><span class="line">    \<span class="number">33</span>[<span class="number">4</span>m 下划线</span><br><span class="line">    \<span class="number">33</span>[<span class="number">5</span>m 闪烁</span><br><span class="line">    \<span class="number">33</span>[<span class="number">7</span>m 反显</span><br><span class="line">    \<span class="number">33</span>[<span class="number">8</span>m 消隐</span><br><span class="line">    \<span class="number">33</span>[<span class="number">30</span>m -- \<span class="number">33</span>[<span class="number">37</span>m 设置前景色</span><br><span class="line">    \<span class="number">33</span>[<span class="number">40</span>m -- \<span class="number">33</span>[<span class="number">47</span>m 设置背景色</span><br><span class="line">    \<span class="number">33</span>[nA 光标上移n行</span><br><span class="line">    \<span class="number">33</span>[nB 光标下移n行</span><br><span class="line">    \<span class="number">33</span>[nC 光标右移n行</span><br><span class="line">    \<span class="number">33</span>[nD 光标左移n行</span><br><span class="line">    \<span class="number">33</span>[y;xH设置光标位置</span><br><span class="line">    \<span class="number">33</span>[<span class="number">2</span>J 清屏</span><br><span class="line">    \<span class="number">33</span>[K 清除从光标到行尾的内容</span><br><span class="line">    \<span class="number">33</span>[s 保存光标位置</span><br><span class="line">    \<span class="number">33</span>[u 恢复光标位置</span><br><span class="line">    \<span class="number">33</span>[?<span class="number">25l</span> 隐藏光标</span><br><span class="line">    \<span class="number">33</span>[?<span class="number">25</span>h 显示光标</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;hello world\n&quot;); </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[40;32;5m hello world\033[1m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;\033[40;31;5m hello world\033[0m\n&quot;);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（3）printf 变色打印(Windows)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HANDLE hConsole= GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">    SetConsoleTextAttribute(hConsole,FOREGROUND_RED);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*1. 引入Windows.h头文件。</span></span><br><span class="line"><span class="comment">2. 使用SetConsoleTextAttribute函数设置控制台输出的字体颜色。该函数的第一个参数是控制台输出的句柄，可以使用GetStdHandle函数获取标准输出句柄；第二个参数是字体颜色，可以使用预定义的常量或自定义的颜色值。</span></span><br><span class="line"><span class="comment">   例如，以下代码将控制台输出的字体颜色设置为红色预定义的颜色常量包括：</span></span><br><span class="line"><span class="comment">- FOREGROUND_BLUE：蓝色</span></span><br><span class="line"><span class="comment">- FOREGROUND_GREEN：绿色</span></span><br><span class="line"><span class="comment">- FOREGROUND_RED：红色</span></span><br><span class="line"><span class="comment">- FOREGROUND_INTENSITY：高亮</span></span><br><span class="line"><span class="comment">- BACKGROUND_BLUE：背景色为蓝色</span></span><br><span class="line"><span class="comment">- BACKGROUND_GREEN：背景色为绿色</span></span><br><span class="line"><span class="comment">- BACKGROUND_RED：背景色为红色</span></span><br><span class="line"><span class="comment">- BACKGROUND_INTENSITY：背景色高亮</span></span><br><span class="line"><span class="comment">可以使用位运算符|和&amp;来组合多个颜色常量，</span></span><br><span class="line"><span class="comment">例如：</span></span><br><span class="line"><span class="comment">SetConsoleTextAttribute(hConsole, FOREGROUND_RED | BACKGROUND_GREEN | FOREGROUND_INTENSITY);</span></span><br><span class="line"><span class="comment">该代码将字体颜色设置为红色、背景色设置为绿色、高亮显示。*/</span></span><br></pre></td></tr></table></figure>

<p>（4）线性表c的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造顺序表结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">data_t</span> data[SIZE]; <span class="comment">//保存元素</span></span><br><span class="line">    <span class="keyword">int</span> last;        <span class="comment">//保存尾元素下标</span></span><br><span class="line">&#125;seqlist; </span><br><span class="line"><span class="comment">//创建表头及初始化表</span></span><br><span class="line"><span class="function">seqlist *<span class="title">create_seqlite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    seqlist* head =(seqlist*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(seqlist)); <span class="comment">//创建表头 head </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;last = <span class="number">-1</span>;   <span class="comment">//初始化 last为-1  表示空表</span></span><br><span class="line">    <span class="built_in">memset</span>(head-&gt;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(head-&gt;data)); <span class="comment">//清空 表</span></span><br><span class="line">    <span class="keyword">return</span> head; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求表长</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">get_leng_seqlist</span><span class="params">(seqlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;last+<span class="number">1</span>;  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">seqlist_is_empty</span><span class="params">(seqlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((head-&gt;last == <span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>);  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">seqlist_is_full</span><span class="params">(seqlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((head-&gt;last+<span class="number">1</span> == SIZE)?<span class="number">1</span>:<span class="number">0</span>);  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_by_pos_seqlist</span><span class="params">(seqlist* head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) perr_exit(<span class="string">&quot;insert_by_pos_seqlist:&quot;</span>);  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_full(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; head-&gt;last+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//挪位置</span></span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i=head-&gt;last+<span class="number">1</span>; i&gt;pos; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;data[i] = head-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    head-&gt;data[pos] = value;</span><br><span class="line">    <span class="comment">//更新 last </span></span><br><span class="line">        head-&gt;last++; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置 查询</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">find_by_pos_seqlist</span><span class="params">(seqlist *head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_empty(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt;head-&gt;last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;data[pos]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按值 查询</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_by_data_seqlist</span><span class="params">(seqlist *head, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_empty(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;= head-&gt;last; i++) <span class="comment">// 0-5 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;data[i] == val)</span><br><span class="line">            <span class="keyword">return</span> i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置 修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change_by_pos_seqlist</span><span class="params">(seqlist* head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_empty(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt;head-&gt;last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    head-&gt;data[pos] = new_val; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置 删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_by_pos_seqlist</span><span class="params">(seqlist *head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;;  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_empty(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; head-&gt;last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//挪位置 并覆盖删除</span></span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i=pos; i&lt;head-&gt;last; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;data[i] = head-&gt;data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新 last </span></span><br><span class="line">        head-&gt;last--; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_seqlist</span><span class="params">(seqlist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==head) <span class="keyword">return</span> ;</span><br><span class="line">    head-&gt;last = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">destory_seqlist</span><span class="params">(seqlist **head)</span> <span class="comment">// 为什么要用2级指针 看 3_getmem_point.c</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(*head);</span><br><span class="line">    *head = <span class="literal">NULL</span>; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印看结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prn</span><span class="params">(seqlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[40;32;5m\033[1m\n&quot;</span>);   <span class="comment">//开启打印颜色</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> len = get_leng_seqlist(head); </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, head-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\033[40;32;5m\033[0m\n&quot;</span>);   <span class="comment">//关闭打印颜色</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误打印</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    seqlist* head = create_seqlite();</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert_by_pos_seqlist(head, i, i+<span class="number">1</span>); <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    prn(head); </span><br><span class="line">    change_by_pos_seqlist(head, <span class="number">4</span>, <span class="number">666</span>);</span><br><span class="line">    prn(head); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find_by_data_seqlist(head, <span class="number">666</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete_by_pos_seqlist(head, <span class="number">5</span>); </span><br><span class="line">    prn(head); </span><br><span class="line">clear_seqlist(head); </span><br><span class="line">    destory_seqlist(&amp;head);  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<br>
<br>

<hr>
<h2 id="四、指针，函数和空间的关系"><a href="#四、指针，函数和空间的关系" class="headerlink" title="四、指针，函数和空间的关系"></a>四、指针，函数和空间的关系</h2><p>总的来说，就是指针在作为函数的参数进行传参的时候是用的是值传参。也就是说指针之间的传参只是在函数中得到了主函数指针的样本，两个不同的指针指向了同一个地址。<br>先来看一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *create（）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *p=（<span class="keyword">int</span> *）<span class="built_in">malloc</span>（<span class="keyword">sizeof</span>（<span class="keyword">int</span>））；</span><br><span class="line">    <span class="keyword">return</span> p；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> destory(<span class="keyword">int</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">free</span>(p);</span><br><span class="line">     P=<span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = create();</span><br><span class="line">    destory(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这一段代码有个问题，就是在destory()中创建一个指针，这个指针指向的是和main()中的p指针指向的同一个空间。在释放了空间后，destory()中的指针空了，但是mian()中的指针还在，并且因为空间被释放了所以变成了野指针。</p>
<p>再来看另一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">&#125;st; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmem</span><span class="params">(<span class="keyword">int</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *s = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmem_2</span><span class="params">(<span class="keyword">int</span> **s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *s = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *(<span class="keyword">int</span> *)*s = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st *p = (st*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="comment">//getmem(p-&gt;a); //指针变量名 不能改变实参</span></span><br><span class="line">    getmem_2(&amp;(p-&gt;a)); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(p-&gt;a)); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>getmem()函数是错误的，因为是在getmem()函数中创建了一个指针，然后让该指针指向了一个开辟的空间，但是主函数的指针并没有指向该空间而处于未初始化的状态。</p>
<p>要想用主函数里的指针开辟空间，就要在函数中用到二级指针来传递主函数指针的地址</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>day23-链表</title>
    <url>/2023/03/23/day23-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="day23-链表"><a href="#day23-链表" class="headerlink" title="day23-链表"></a><font color="green">day23-链表</font></h1><h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><p>链表是一种常见的数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。</p>
<p>链表可以分为单向链表和双向链表两种类型。在单向链表中，每个节点只包含一个指向下一个节点的指针，而在双向链表中，每个节点同时包含指向上一个节点和下一个节点的指针。</p>
<p>相比于数组，链表的一个重要优势是可以动态地增加和删除节点，而不需要移动整个数据结构中的其他元素。但是，链表的访问效率较低，因为需要遍历整个链表才能找到所需节点。</p>
<a id="more"></a>
<br>
<br>

<hr>
<h2 id="二、链表图解"><a href="#二、链表图解" class="headerlink" title="二、链表图解"></a>二、链表图解</h2><h3 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h3><p><img src="/2023/03/23/day23-%E9%93%BE%E8%A1%A8/lianbiao.jpg" alt="链表"></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><img src="/2023/03/23/day23-%E9%93%BE%E8%A1%A8/charu.jpg" alt="链表"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="/2023/03/23/day23-%E9%93%BE%E8%A1%A8/shanchu.jpg" alt="链表"></p>
<br>
<br>

<hr>
<h2 id="三、链表的代码实现"><a href="#三、链表的代码实现" class="headerlink" title="三、链表的代码实现"></a>三、链表的代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linklist.h&quot;</span></span></span><br><span class="line"><span class="comment">//创建链表的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">data_t</span> data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">next</span>;</span> <span class="comment">//next 域</span></span><br><span class="line">&#125;linklist; </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表头节点</span></span><br><span class="line"><span class="function">linklist* <span class="title">create_linklist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    linklist* head = (linklist*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;data = <span class="number">-1</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linklist_is_empty</span><span class="params">(linklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((head-&gt;next == <span class="literal">NULL</span>) ?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求有效节点个数(求长度)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num_linklist</span><span class="params">(linklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    linklist *p = head-&gt;next; <span class="comment">//定义p指针指向第一个有效节点</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)  <span class="comment">//循环遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        num++;              <span class="comment">//统计节点数</span></span><br><span class="line">        p = p-&gt;next;        <span class="comment">//p指针向后偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_head_linklist</span><span class="params">(linklist* head, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备new 节点</span></span><br><span class="line">    linklist *<span class="keyword">new</span>  = (linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = val; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//头插法 插入</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = head-&gt;next; </span><br><span class="line">    head-&gt;next = <span class="keyword">new</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_by_pos_linklist</span><span class="params">(linklist *head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_linklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备new 节点 和p 指针 </span></span><br><span class="line">    linklist* p = head; </span><br><span class="line">    linklist* <span class="keyword">new</span> = (linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = val;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将p 找到pos-1的位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="comment">//将新节点插入pos 位置</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next   = <span class="keyword">new</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change_by_pos_linklist</span><span class="params">(linklist*head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(linklist_is_empty(head)== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_linklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    linklist* p = head-&gt;next; </span><br><span class="line">    <span class="comment">//找到pos 位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--)  </span><br><span class="line">        p   = p-&gt;next;</span><br><span class="line">    p-&gt;data = new_val;  <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//按位置查询</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">find_by_pos_linklist</span><span class="params">(linklist*head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(linklist_is_empty(head)== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_linklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    linklist* p = head-&gt;next; </span><br><span class="line">    <span class="comment">//找到pos 位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--)  </span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;data; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_by_pos_linklist</span><span class="params">(linklist* head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(linklist_is_empty(head)== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_linklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备p 指向pos-1， q 指向要删除的pos 节点</span></span><br><span class="line">    linklist* p = head;</span><br><span class="line">    linklist* q = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//找到pos -1位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--) </span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    p-&gt;next = q-&gt;next; </span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="built_in">free</span>(q); </span><br><span class="line">    q = <span class="literal">NULL</span>; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印有效节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(linklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span>;</span><br><span class="line">    linklist *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-4d&quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clear_linklist</span><span class="params">(linklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    linklist *p = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    linklist* q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next; <span class="comment">//q 偏移</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;  <span class="comment">//p 向后偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">destory_linklist</span><span class="params">(linklist** head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(*head);</span><br><span class="line">    head = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命令行模式下：gg=GG 自动缩进</span></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="四、单向循环链表"><a href="#四、单向循环链表" class="headerlink" title="四、单向循环链表"></a>四、单向循环链表</h2><p>即把链表代码中表示的最后一位的NULL都改为head就行。</p>
<br>
<br>

<hr>
<h2 id="五、双向链表"><a href="#五、双向链表" class="headerlink" title="五、双向链表"></a>五、双向链表</h2><p>双向链表的主要不同点便是</p>
<ol>
<li>头插法插入时要判断后面是否是NULL，按位置插入和删除时要判断是否是尾部</li>
<li>插入的顺序主要分四部：(先右后左，先赋值给new再把原数据指向new)<blockquote>
<p>new-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;piror=new;<br>new-&gt;prior=p;<br>p-&gt;next=new;</p>
</blockquote>
</li>
</ol>
<p>下面是双向链表的c的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dlinklist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表头节点</span></span><br><span class="line"><span class="function">dlinklist* <span class="title">create_dlinklist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dlinklist* head = (dlinklist*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dlinklist));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;data = <span class="number">-1</span>;</span><br><span class="line">    head-&gt;prior = head-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//head-&gt;prior = NULL; </span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlinklist_is_empty</span><span class="params">(dlinklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((head-&gt;next == head-&gt;prior) ?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求有效节点个数(求长度)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num_dlinklist</span><span class="params">(dlinklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    dlinklist *p = head-&gt;next; <span class="comment">//定义p指针指向第一个有效节点</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)  <span class="comment">//循环遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        num++;              <span class="comment">//统计节点数</span></span><br><span class="line">        p = p-&gt;next;        <span class="comment">//p指针向后偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_head_dlinklist</span><span class="params">(dlinklist* head, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备new 节点</span></span><br><span class="line">    dlinklist *<span class="keyword">new</span>  = (dlinklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dlinklist));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = val; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//头插法 插入</span></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next   == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = head-&gt;next;</span><br><span class="line">        <span class="keyword">new</span>-&gt;prior = head;</span><br><span class="line">        head-&gt;next = <span class="keyword">new</span>; </span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prior = <span class="keyword">new</span>; </span><br><span class="line">        <span class="keyword">new</span>-&gt;prior = head;</span><br><span class="line">        head-&gt;next = <span class="keyword">new</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印有效节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(dlinklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span>;</span><br><span class="line">    dlinklist *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-4d&quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_by_pos_dlinklist</span><span class="params">(dlinklist *head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_dlinklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备new 节点 和p 指针 </span></span><br><span class="line">    dlinklist* p = head; </span><br><span class="line">    dlinklist* <span class="keyword">new</span> = (dlinklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dlinklist));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = val;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将p 找到pos-1的位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="comment">//将新节点插入pos 位置</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>) <span class="comment">//尾插</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">        <span class="keyword">new</span>-&gt;prior = p;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;prior = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;prior = p;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_by_pos_dlinklist</span><span class="params">(dlinklist* head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dlinklist_is_empty(head)== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_dlinklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备p 指向pos-1， q 指向要删除的pos 节点</span></span><br><span class="line">    dlinklist* p = head;</span><br><span class="line">    dlinklist* q = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//找到pos -1位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--) <span class="comment">// pos -1</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    <span class="comment">//q = p-&gt;next ; </span></span><br><span class="line">    <span class="comment">//if(q-&gt;next == NULL) //尾删</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next-&gt;next == <span class="literal">NULL</span>) <span class="comment">//尾删</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        q = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        q-&gt;next-&gt;prior = p; </span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        q = <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>day24-栈与队列</title>
    <url>/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="day24-栈与队列"><a href="#day24-栈与队列" class="headerlink" title="day24-栈与队列"></a><font color="green">day24-栈与队列</font></h1><h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>&emsp;&emsp;栈和队列是两种常见的数据结构。它们都是线性结构，但它们的操作方式不同。栈是一种后进先出（LIFO）的数据结构，即最后进入的元素最先被访问。而队列是一种先进先出（FIFO）的数据结构，即最先进入的元素最先被访问。</p>
<p>&emsp;&emsp;在具体实现时，栈和队列也有所不同。栈只在一端进行插入和删除操作，这一端称为栈顶。而队列则在两端进行插入和删除操作，分别称为队头和队尾。</p>
<a id="more"></a>
<h3 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2. 实现方式"></a>2. 实现方式</h3><p>栈和队列的实现方式有很多种，这里我提供一些常见的实现方式。</p>
<p>栈的实现方式：</p>
<ol>
<li>用数组来模拟栈，用top变量表示栈顶元素的下标，用push()方法向栈顶添加元素，用pop()方法弹出栈顶元素。</li>
<li>用链表来模拟栈，用head指针表示栈顶元素，用push()方法向栈顶添加元素，用pop()方法弹出栈顶元素。</li>
<li>用双端队列（deque）来模拟栈，用append()方法向栈顶添加元素，用pop()方法弹出栈顶元素。</li>
</ol>
<p>队列的实现方式：</p>
<ol>
<li>用数组来模拟队列，用front和rear变量分别表示队头和队尾的下标，用push()方法向队尾添加元素，用pop()方法弹出队头元素。为了节省空间，常用循环队列来存放数据。循环队列的核心在于<code>求余%</code></li>
<li>用链表来模拟队列，用head和tail指针分别表示队头和队尾元素，用push()方法向队尾添加元素，用pop()方法弹出队头元素。</li>
<li>用两个栈来模拟队列，一个栈作为输入栈，一个栈作为输出栈。当需要弹出队头元素时，如果输出栈为空，则将输入栈中的所有元素依次弹出并压入输出栈中；否则直接从输出栈中弹出。</li>
</ol>
<blockquote>
<p>注：队列可以分为两种模式：</p>
<blockquote>
<ol>
<li>front存第一个数据，rear指向最后一个数据的下一个位置。数据是从0开始存的。</li>
<li>fornt指向第一个数据的上一个位置，rear存最后一个数据。数据是从1开始存的。</li>
</ol>
</blockquote>
</blockquote>
<h3 id="3-结构图解"><a href="#3-结构图解" class="headerlink" title="3. 结构图解"></a>3. 结构图解</h3><h4 id="栈的实现图解"><a href="#栈的实现图解" class="headerlink" title="栈的实现图解"></a>栈的实现图解</h4><ol>
<li>数组栈</li>
</ol>
<p><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/zhan.jpg" alt="数组栈"></p>
<ol start="2">
<li>链表栈   </li>
</ol>
<p>入栈<br><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/jinzhan_lian.gif" alt="链表入栈">  </p>
<p>出栈<br><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/chuzhan_lian.gif" alt="链表入栈"></p>
<h4 id="队列的实现图解"><a href="#队列的实现图解" class="headerlink" title="队列的实现图解"></a>队列的实现图解</h4><ol>
<li>数组队列(用的1的模式)</li>
</ol>
<p><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/duilie_shuzu.jpg" alt="数组队列">  </p>
<ol start="2">
<li>链表队列</li>
</ol>
<p><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/duilie_lianbiao.jpg" alt="数组队列"></p>
<br>
<br>

<hr>
<h2 id="二、栈与队列的c语言实现"><a href="#二、栈与队列的c语言实现" class="headerlink" title="二、栈与队列的c语言实现"></a>二、栈与队列的c语言实现</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造顺序栈类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">data_t</span> data[SIZE];<span class="comment">//顺序栈</span></span><br><span class="line">	<span class="keyword">int</span> top;<span class="comment">//保存栈顶元素的下标</span></span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空栈</span></span><br><span class="line"><span class="function"><span class="built_in">stack</span> *<span class="title">createSeqstack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span> *sq = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));<span class="comment">//给顺序栈开空间</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">memset</span>(sq-&gt;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(sq-&gt;data));<span class="comment">//清空顺序栈</span></span><br><span class="line">	sq-&gt;top = <span class="number">-1</span>;<span class="comment">//说明栈中无元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqstack_is_empty</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ((sq-&gt;top == <span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqstack_is_full</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ((sq-&gt;top == SIZE<span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求栈中元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLengthStack</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sq == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> (sq-&gt;top+<span class="number">1</span>);</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pushStack</span><span class="params">(<span class="built_in">stack</span> *sq, <span class="keyword">data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(seqstack_is_full(sq))<span class="comment">//判满</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	sq-&gt;data[sq-&gt;top+<span class="number">1</span>] = data;</span><br><span class="line">	sq-&gt;top++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">popStack</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sq == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(seqstack_is_empty(sq))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">data_t</span> data = sq-&gt;data[sq-&gt;top];<span class="comment">//data变量保存栈顶元素的值</span></span><br><span class="line">	sq-&gt;top--;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印栈中元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(seqstack_is_empty(sq))</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=sq-&gt;top;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sq-&gt;data[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>
<br>

<h3 id="链表栈"><a href="#链表栈" class="headerlink" title="链表栈"></a>链表栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造链式栈节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">data_t</span> data;<span class="comment">//节点的数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span><span class="comment">//保存下一个节点的地址</span></span><br><span class="line">&#125;lstack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空链式栈</span></span><br><span class="line"><span class="function">lstack *<span class="title">createLstack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lstack *top = (lstack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lstack));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	top-&gt;data = <span class="number">-1</span>;</span><br><span class="line">	top-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstack_is_empty</span><span class="params">(lstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ((top-&gt;next == <span class="literal">NULL</span>)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求栈中节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLengthLstack</span><span class="params">(lstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	lstack *p = top-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pushLstack</span><span class="params">(lstack *top, <span class="keyword">data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	lstack *<span class="keyword">new</span> = (lstack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lstack));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;data = data;</span><br><span class="line">	<span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将 new节点插入到栈顶位置，即  pos=0 位置处</span></span><br><span class="line">	<span class="keyword">new</span>-&gt;next = top-&gt;next;</span><br><span class="line">	top-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">popLstack</span><span class="params">(lstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(lstack_is_empty(top))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	lstack *p = top-&gt;next;<span class="comment">//p指针保存的是栈顶元素的地址</span></span><br><span class="line">	<span class="keyword">data_t</span> data = p-&gt;data;<span class="comment">//data变量保存的是栈顶节点的值</span></span><br><span class="line">	top-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印栈中各个节点的data值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfLstack</span><span class="params">(lstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(lstack_is_empty(top))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	lstack *p = top-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>
<br>

<h3 id="数组队列-求余思想"><a href="#数组队列-求余思想" class="headerlink" title="数组队列(求余思想)"></a>数组队列(求余思想)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">data_t</span> data[SIZE];</span><br><span class="line">	<span class="keyword">int</span> front; <span class="comment">//对头元素的位置</span></span><br><span class="line">	<span class="keyword">int</span> rear; <span class="comment">//队尾元素的下一个位置</span></span><br><span class="line">&#125;squeue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="function">squeue *<span class="title">createSqueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	squeue *sq = (squeue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(squeue));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(sq-&gt;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(sq-&gt;data));</span><br><span class="line"></span><br><span class="line">	sq-&gt;front = sq-&gt;rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squeue_is_empty</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ((sq-&gt;front == sq-&gt;rear)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squeue_is_full</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (sq-&gt;front == (sq-&gt;rear+<span class="number">1</span>)%SIZE )?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squeue_length</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	int num= 0;</span></span><br><span class="line"><span class="comment">	int temp = sq-&gt;front;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	while(temp != sq-&gt;rear)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		num++;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">		temp = (temp+1)%SIZE;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	return num;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">return</span> (sq-&gt;rear  + SIZE  -  sq-&gt;front)%SIZE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队, 在队尾进行入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squeue_in</span><span class="params">(squeue *sq, <span class="keyword">data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(sq-&gt;rear != <span class="number">0</span> &amp;&amp; sq-&gt;rear%(SIZE<span class="number">-1</span>)==<span class="number">0</span>)</span><br><span class="line">		sq-&gt;rear = (sq-&gt;rear+<span class="number">1</span>)%SIZE;</span><br><span class="line"></span><br><span class="line">	sq-&gt;data[sq-&gt;rear] = data;</span><br><span class="line"></span><br><span class="line">	sq-&gt;rear = (sq-&gt;rear+<span class="number">1</span>)%SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">squeue_out</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(squeue_is_empty(sq) == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">data_t</span> data = sq-&gt;data[sq-&gt;front];</span><br><span class="line"></span><br><span class="line">	sq-&gt;front = (sq-&gt;front+<span class="number">1</span>)%SIZE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispalySqueue</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> temp = sq-&gt;front;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(temp != sq-&gt;rear)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sq-&gt;data[temp]);</span><br><span class="line">	</span><br><span class="line">		temp = (temp+<span class="number">1</span>)%SIZE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<br>
<br>
<br>

<h3 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">data_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;linklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	linklist *front; <span class="comment">//指向对头元素的前一个位置</span></span><br><span class="line">	linklist *rear; <span class="comment">//指向队尾元素的位置</span></span><br><span class="line">&#125;lqueue;</span><br><span class="line"></span><br><span class="line"><span class="function">lqueue *<span class="title">createLqueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lqueue *lq = (lqueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lqueue));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	lq-&gt;front = (linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist)); <span class="comment">//返回头结点的地址</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq-&gt;front)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	lq-&gt;rear = lq-&gt;front;</span><br><span class="line"></span><br><span class="line">	lq-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> lq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lqueue_is_empty</span><span class="params">(lqueue *lq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (lq-&gt;front == lq-&gt;rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lqueue_length</span><span class="params">(lqueue *lq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	linklist *p = lq-&gt;front-&gt;next; <span class="comment">//p指向第一个有效结点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lqueue_in</span><span class="params">(lqueue *lq, <span class="keyword">data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	linklist *<span class="keyword">new</span> = (linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span>-&gt;data = data;</span><br><span class="line">	<span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	lq-&gt;rear-&gt;next = <span class="keyword">new</span>; </span><br><span class="line"></span><br><span class="line">	lq-&gt;rear = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">lqueue_out</span><span class="params">(lqueue *lq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lqueue_is_empty(lq))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	linklist *p = lq-&gt;front-&gt;next; <span class="comment">//指向对头元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">data_t</span> data = p-&gt;data;</span><br><span class="line"></span><br><span class="line">	lq-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lq-&gt;front-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">		lq-&gt;front == lq-&gt;rear;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayLqueue</span><span class="params">(lqueue *lq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	linklist *p = lq-&gt;front-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line"></span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>栈，队列</tag>
      </tags>
  </entry>
  <entry>
    <title>day25-二叉树</title>
    <url>/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="day25-二叉树"><a href="#day25-二叉树" class="headerlink" title="day25-二叉树"></a><font color="green">day25-二叉树</font></h1><h2 id="一、树的概念"><a href="#一、树的概念" class="headerlink" title="一、树的概念"></a>一、树的概念</h2><h3 id="1-树形结构的形式化"><a href="#1-树形结构的形式化" class="headerlink" title="1. 树形结构的形式化"></a>1. 树形结构的形式化</h3><h4 id="1-1-序偶"><a href="#1-1-序偶" class="headerlink" title="1.1 序偶"></a>1.1 序偶</h4><p>定义：设有两个元素x和y，由x和y构成的序偶记为&lt;x,y&gt;。  </p>
<blockquote>
<p>序偶可以描述有先后顺序要求的一对元素之间的关系，顺序很重要&lt;x,y&gt; $\not =$ &lt;y,x&gt;  </p>
</blockquote>
<h4 id="1-2-树的直接定义"><a href="#1-2-树的直接定义" class="headerlink" title="1.2 树的直接定义"></a>1.2 树的直接定义</h4><p>&emsp;&emsp;树是包括n（n$\geq$0）个元素的集合D，R是D中元素的序偶集合，若D为空，R也为空，此时为空树，否则R满足以下要求：</p>
<ul>
<li>有且仅有一个结点a $\in$ D，不存在任何节点v $\in$ D,v $\not =$ a，使得&lt;v,a&gt; $\in$ R,该结点为树的根。<font color="blue">如果树不为空，则树的根节点是唯一的</font></li>
<li>对于除根结点a以外任一结点u $\in$ D而言，都有且仅有一个结点 v $\in$ D，v $\not =$ u，使得&lt;v,u&gt; $\in$ R成立。<font color="blue">根节点没有前驱，其他结点均有唯一前驱</font></li>
</ul>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AE%9A%E4%B9%89.jpg" alt="树的直接定义"></p>
<h4 id="1-3-树的递归定义"><a href="#1-3-树的递归定义" class="headerlink" title="1.3 树的递归定义"></a>1.3 树的递归定义</h4><p>&emsp;&emsp;树是包括n个结点的有限集T，若n=0，则该数为空树；否则为非空树，在该非空树中，有且仅有一个特定的称为根的结点（r），其余结点(T-{r})划分成m(m$\geq$0)个互不相交的子集 $ T_1,T_2,…T_m $,其中，每个子集 $T_i$都是树，也称为树根节点r的子树。</p>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89.jpg" alt="树的递归定义"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>day26-图</title>
    <url>/2023/04/01/day26-%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="day26-图"><a href="#day26-图" class="headerlink" title="day26-图"></a><font color="green">day26-图</font></h1>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>day27-文件与系统IO</title>
    <url>/2023/04/01/day27-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9FIO/</url>
    <content><![CDATA[<h1 id="day27-文件与系统IO"><a href="#day27-文件与系统IO" class="headerlink" title="day27-文件与系统IO"></a><font color="green">day27-文件与系统IO</font></h1>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>LINUX</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式学习-Linux基础</title>
    <url>/2023/02/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一、linux系统基础"><a href="#一、linux系统基础" class="headerlink" title="一、linux系统基础"></a><font color="green">一、linux系统基础</font></h1><h2 id="1、linux和windows"><a href="#1、linux和windows" class="headerlink" title="1、linux和windows"></a>1、linux和windows</h2><p>​    linux：开源、免费、安全性高、稳定性强、可移植性高</p>
<a id="more"></a>

<h2 id="2、linux操作系统的基本使用"><a href="#2、linux操作系统的基本使用" class="headerlink" title="2、linux操作系统的基本使用"></a>2、linux操作系统的基本使用</h2><h3 id="0-、linux的文件的系统结构"><a href="#0-、linux的文件的系统结构" class="headerlink" title="(0)、linux的文件的系统结构"></a>(0)、linux的文件的系统结构</h3><blockquote>
<ul>
<li>windows：所有文件有分盘(C,D,E,F….)，每个盘中都有子文件或者子目录，对文件存放没有要求，可以放在任意位置</li>
<li>linux：没有分盘，只有一个大的目录–根目录（’/‘），根目录下的文件夹每一个都有其固定作用</li>
<li>bin：存放二进制文件或者可执行程序</li>
<li>dev：存放设备文件</li>
<li>etc：系统相关的配置文件</li>
<li>home：用户目录，用户所有操作都在该目录下进行     /home/hqyj 可以用符号(~)表示</li>
</ul>
</blockquote>
<br>
<br>

<hr>
<h3 id="1-、基本的shell命令"><a href="#1-、基本的shell命令" class="headerlink" title="(1)、基本的shell命令"></a>(1)、基本的shell命令</h3><p>​        shell本质：命令行解释器，将用户输入的特定指令转换为系统能够识别的语言</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    绝对路径：从根目录出发所表示的一个路径</span><br><span class="line">    相对路径：相对于用户当前位置所表示的一个路径</span><br><span class="line"></span><br><span class="line">pwd:显示当前用户在文件系统中的绝对路径</span><br><span class="line">    用法：</span><br><span class="line">    	pwd + 回车</span><br><span class="line">ls:显示当前用户所在路径下的所有文件(不包含隐藏文件)</span><br><span class="line">    用法：</span><br><span class="line">    	ls + 回车</span><br><span class="line">ls -a：显示当前用户所在路径下的所有文件(包含隐藏文件)</span><br><span class="line">    <span class="string">&#x27;.&#x27;</span> == 用户当前目录</span><br><span class="line">    &#x27;..&#x27; == 当前目录的上一级目录</span><br><span class="line">    </span><br><span class="line">ls -l:显示当前用户所在路径下的所有文件的详细信息</span><br><span class="line">    - rw- rw- r--</span><br><span class="line">    第一位代表文件类型：</span><br><span class="line">    	<span class="string">&#x27;-&#x27;</span> :普通文件</span><br><span class="line">    	<span class="string">&#x27;d&#x27;</span> :目录文件</span><br><span class="line">    	<span class="string">&#x27;c&#x27;</span> :字符设备文件</span><br><span class="line">    	<span class="string">&#x27;b&#x27;</span> :块设备文件</span><br><span class="line">    	<span class="string">&#x27;p&#x27;</span> :管道文件</span><br><span class="line">    	<span class="string">&#x27;l&#x27;</span> :符号链接文件</span><br><span class="line">    	<span class="string">&#x27;s&#x27;</span> :套接字文件</span><br><span class="line">            不同操作系统下支持使用的文件类型不同</span><br><span class="line">    	</span><br><span class="line">    后<span class="number">9</span>位代表文件存取权限</span><br><span class="line">         rw-rw-r--  == <span class="number">110</span> <span class="number">110</span> <span class="number">100</span> == <span class="number">0664</span></span><br><span class="line">         权限的前<span class="number">3</span>位表示用户自己的使用权限，如果当前位上没有对应权限用<span class="string">&#x27;-&#x27;</span>表示                      </span><br><span class="line">		 权限的中间<span class="number">3</span>位代表用户组的使用权限        </span><br><span class="line">         权限的最后<span class="number">3</span>位代表其他用户的使用权限</span><br><span class="line">         r -- 具有读权限  w -- 具有写权限  x -- 具有可执行权限</span><br><span class="line">    改变文件权限的命令入下:</span><br><span class="line">         chmod [-R]  xyz  文件或目录</span><br><span class="line">         -R ： 以递归方式进行修改，比如修改某个目录下所有文件的属性。</span><br><span class="line"></span><br><span class="line">cd: 目录跳转	</span><br><span class="line">    用法：</span><br><span class="line">    	cd + 指定路径    </span><br><span class="line"></span><br><span class="line">touch:以不打开的方式创建一个文件，如果文件存在，则修改时间戳</span><br><span class="line">    用法：</span><br><span class="line">    	touch + 文件名</span><br><span class="line">    </span><br><span class="line">rm:删除指定文件</span><br><span class="line">    用法：</span><br><span class="line">    	rm + 文件名</span><br><span class="line">    </span><br><span class="line">cat：显示文件内容</span><br><span class="line">    用法：</span><br><span class="line">    	cat + 文件名</span><br><span class="line">    </span><br><span class="line">cp: 复制文件</span><br><span class="line">    用法：</span><br><span class="line">    	cp + 源文件名 + 路径名</span><br><span class="line">    	cp + 源文件名 + 目标文件名</span><br><span class="line">mv：移动文件</span><br><span class="line">    用法：</span><br><span class="line">    	mv + 源文件名 + 路径名</span><br><span class="line">    	mv + 源文件名 + 目标文件名    </span><br><span class="line"></span><br><span class="line">mkdir: 创建目录</span><br><span class="line">    用法：</span><br><span class="line">    	mkdir + 目录名</span><br><span class="line">    </span><br><span class="line">rmdir: 删除指定目录(空目录)   </span><br><span class="line">    用法：</span><br><span class="line">    	rmdir + 目录名</span><br><span class="line">    </span><br><span class="line">  	删除非空目录：rm -r 目录名</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">clear:清屏    ctrl + l快捷方式也可以清屏</span><br><span class="line">Tab: 命令补全</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h3 id="2-、vim编辑器"><a href="#2-、vim编辑器" class="headerlink" title="(2)、vim编辑器"></a>(2)、vim编辑器</h3><p>shell命令：vi 或者 vim + 文件名  </p>
<p>如果文件不存在，则会先创建再进行编辑</p>
<h4 id="vim编辑器中的三种工作模式："><a href="#vim编辑器中的三种工作模式：" class="headerlink" title="vim编辑器中的三种工作模式："></a>vim编辑器中的三种工作模式：</h4><p>​命令行模式：用户在进入编辑器后默认处于的工作模式</p>
<p>​        在命令行模式下不能直接输入数据，但是可以对文本进行复制、粘贴、剪切、撤销等操作：</p>
<p>​            在命令行模式下输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ngg: 光标跳到某一行首</span><br><span class="line"></span><br><span class="line">nyy：将光标以及光标以下的n行数据进行复制</span><br><span class="line"></span><br><span class="line">ndd：将光标以及光标以下的n行数据进行剪切或删除</span><br><span class="line"></span><br><span class="line">p：将复制或者剪切的内容粘贴到光标的下一行</span><br><span class="line"></span><br><span class="line">u：撤回到上一步操作</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>：当前行首</span><br><span class="line"></span><br><span class="line">$：当前行尾</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    编辑模式：可以对文本进行编辑操作</p>
<p>​        在命令行模式下输入：a, i, o都可以进入编辑模式</p>
<p>​        按Esc退回到命令行模式</p>
<p>​    </p>
<p>​    底行模式：对文本进行保存、退出等操作</p>
<p>​        在命令行模式下输入冒号进入底行模式</p>
<p>​            在底行模式下输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">w：保存文件</span><br><span class="line">q：退出文件</span><br><span class="line">wq：保存并且退出</span><br><span class="line">q！：强制不保存退出</span><br><span class="line">x：保存并且退出</span><br></pre></td></tr></table></figure>

<br>

<h4 id="vim文本查找和替换"><a href="#vim文本查找和替换" class="headerlink" title="vim文本查找和替换"></a>vim文本查找和替换</h4><p>在一般模式下，可以执行以下命令。</p>
<ol>
<li>查找<br>pattern  从光标开始处向文件尾搜索pattern，后按下n或N</li>
</ol>
<p>注意：</p>
<blockquote>
<p>n    在同一个方向重复上一次搜索命令<br>N    在反方向重复上一次搜索命令</p>
</blockquote>
<p>注意：<br>在/pattern之前先跳到第一行则进行全文件搜索。</p>
<ol start="2">
<li>替换<blockquote>
<p>:%s/p1/p2/g   //将文件中所有的p1均用p2替换<br>:%s/p1/p2/gc  //替换时需要确认<br>“s“ 全称：substitute替换；<br>“g“ 全称：global全局；<br>“c“ 全称：confirm，确认</p>
</blockquote>
</li>
</ol>
<h3 id="3-、gcc编译工具"><a href="#3-、gcc编译工具" class="headerlink" title="(3)、gcc编译工具"></a>(3)、gcc编译工具</h3><p>​    shell指令：</p>
<p>​        gcc + c文件名</p>
<p>​        编译成功之后会在当前目录下产生一个名为a.out的二进制可执行程序</p>
<p>​            </p>
<p>​       gcc c文件名 -o 新的二进制可执行文件名</p>
<p>​    </p>
<h3 id="4-、执行程序"><a href="#4-、执行程序" class="headerlink" title="(4)、执行程序"></a>(4)、执行程序</h3><p>​    shell命令：</p>
<p>​        ./可执行的二进制文件名</p>
<p>​        </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>day28-进程线程</title>
    <url>/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="day28-进程线程"><a href="#day28-进程线程" class="headerlink" title="day28-进程线程"></a><font color="green">day28-进程线程</font></h1>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>进程线程</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析</title>
    <url>/2020/04/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><font color="green">概述</font></h1><p>算法分析是关于计算机程序和资源利用的研究</p>
<h2 id><a href="#" class="headerlink" title></a><a id="more"></a></h2><h1 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a><font color="green">数学模型</font></h1><p>大多数程序得到数学模型所需步骤：</p>
<ol>
<li>确定输入模型，定义问题规模（n）</li>
<li>识别循环与递归</li>
<li>根据内循环或每部递归的操作确定成本模型</li>
<li>对于给定的输入，判断这些操作的执行频率</li>
</ol>
<hr>
<h1 id="两种常见讨论情况"><a href="#两种常见讨论情况" class="headerlink" title="两种常见讨论情况"></a><font color="green">两种常见讨论情况</font></h1><blockquote>
<p>最坏情况：T(n)定义为输入规模为 n 时的最长运行时间<br>平均情况：T(n)定义为输入规模为 n 时所有可能输入的期望值(通常是均匀分布时的情况)</p>
</blockquote>
<p>为了不被硬件因素所影响，对算法的分析采用了 <font color="red">渐进分析</font></p>
<blockquote>
<p>渐进分析：</p>
<ol>
<li>忽略依赖于机器性能的常量</li>
<li>只关注运行时间的增长</li>
</ol>
</blockquote>
<hr>
<br>
<br>

<h1 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a><font color="green">渐进符号</font></h1><h2 id="大-O-记号法：-上界"><a href="#大-O-记号法：-上界" class="headerlink" title="大$O$记号法：(上界)"></a>大$O$记号法：(上界)</h2><p>f(n) = $O$(g(n)) 表示存在适当常数 (c&gt;0 $n_0$&gt;0) 使得 0 &lt;= f(n) &lt;= c*g(n) 其中 n &gt;= $n_0$<br><strong>注：这里的=不是等于的意思，更多是指 f(n) 属于 $O$(g(n)) 集合。 即$O$(g(n))是一个函数集，集合内有 f(n)</strong></p>
<blockquote>
<p>例：$2n^2 = O(n^3)$</p>
</blockquote>
<p>宏展开：<br>&nbsp;&nbsp;&nbsp; 当等式左右两边都存在$O$( )时，这时=相当于$\epsilon$</p>
<blockquote>
<p>例：$n^2+O(n) = O(n^2)$ &gt; &nbsp;&nbsp;&nbsp;对于任意 f(n)$\epsilon O(n)$，都有对应的 h(n)$\epsilon O(n)$<br>注：不能反推</p>
</blockquote>
<h2 id="大-Omega-记号法：-下界"><a href="#大-Omega-记号法：-下界" class="headerlink" title="大 $\Omega$记号法：(下界)"></a>大 $\Omega$记号法：(下界)</h2><p>f(n) = $O$(g(n)) 表示存在适当常数 (c&gt;0 $n_0$&gt;0) 使得 0 &lt;= c*g(n) &lt;= f(n) 其中 n &gt;= $n_0$</p>
<blockquote>
<p>例：$\sqrt{n}=\Omega(\lg n)$</p>
</blockquote>
<h2 id="大-Theta-记号法："><a href="#大-Theta-记号法：" class="headerlink" title="大 $\Theta$记号法："></a>大 $\Theta$记号法：</h2><p>$\Theta(g(n)) = O(g(n)) \bigcap \Omega(g(n))$</p>
<p>理解：左右两边增长速率一样</p>
<p>用法：写个公式，去掉它的低阶项，并忽略前面的常数因子(系数)</p>
<h2 id="严格符号："><a href="#严格符号：" class="headerlink" title="严格符号："></a>严格符号：</h2><p>与渐进符号的区别在于：</p>
<ul>
<li>渐进符号表示渐进符号内的函数在经过某一点后便大于或小于原函数</li>
<li>严格符号表示严格符号内的函数是完全大于或小于原函数</li>
</ul>
<h3 id="o-记号"><a href="#o-记号" class="headerlink" title="o 记号"></a>o 记号</h3><p>f(n)完全小于 o(g(n)),与$O$对应</p>
<h3 id="omega-记号"><a href="#omega-记号" class="headerlink" title="$\omega$记号"></a>$\omega$记号</h3><p>f(n)完全大于$\omega$(g(n))，与$O$对应</p>
<hr>
<br>
<br>

<h1 id="递归式的三种解法"><a href="#递归式的三种解法" class="headerlink" title="递归式的三种解法"></a><font color="green">递归式的三种解法</font></h1><h2 id="补充知识：数学归纳法"><a href="#补充知识：数学归纳法" class="headerlink" title="补充知识：数学归纳法"></a>补充知识：数学归纳法</h2><p>用来证明一个命题在问题规模为 n 时成立</p>
<ol>
<li>证明 n=1 时成立</li>
<li>假设 n=n-1 时成立，如求出(n-1)+1 时成立</li>
<li>则命题成立</li>
</ol>
<h2 id="1-代换法"><a href="#1-代换法" class="headerlink" title="1. 代换法"></a>1. 代换法</h2><ol>
<li>先猜答案得到最高阶</li>
<li>验证这个递归式是否按照数学归纳法满足条件</li>
</ol>
<blockquote>
<p>例：T(n)=4T(n/2)+n</p>
<ol>
<li>(猜)忽略常数 n，由 T(n)=4T(n/2) 可看出当 n 减 2 倍，系数增加 4 倍。$n^2$符合这一标准,假定 T(n)=$O(n^2)$</li>
<li>(证)将递归式展开得 T(n)=$4T(n/2)+n$ &lt;= $cn^2$+n = $cn^2$-(-n)<blockquote>
<p>$O(n^2)$=$c(n)^2$</p>
</blockquote>
</li>
<li>因为要证明的是 T(n)=$O(n^2)$ 所以 T(n) &lt;= $cn^2$-(-n) 中(-n)大于等于 0</li>
</ol>
</blockquote>
<p>但这里发现了因为 n&gt;=1 所以上式不成立。是我们做错了吗，让我们想想有什么办法可以改变这个常数。<br>当我们对 $O(n^2)$ 进行展开时，我们是忽略了常数项的，因为它对 n 为无穷大时作用很小，但作用小就表明还是有一定的作用，我们试着把常数项带进来，即改进 T(n)=$O(n^2)$ 时的条件</p>
<blockquote>
<p>改进：<br>T(n) =$O(n^2)$ &lt;=$c_1n^2-c_2n$ (多了常数项)<br>T(n)=$4T(n/2)+n$ &lt;= $4(c_1(n/2)^2-c_2(n/2))+n=c_1n^2-c_2n-(c_2-1)n$<br>要使 T(n)=$O(n^2)$则要满足$(c_2-1)n$ &gt;= 0 (当$c_2$ &gt;= 1 时成立)<br>并且 T(1) &lt;=$c_1-c_2$ 成立<br>可以得出 T(n+1) &lt;= $c_1(n+1)^2-c_2(n+1)$ (当$c_1&gt;&gt;c_2$时成立)(算一下就出来了)<br>这时条件 T(1)，T(n)和 T(1)推出 T(n+1)都有了<br>最后得出 T(n) = $O(n^2)$</p>
</blockquote>
<h2 id="2-递归树法"><a href="#2-递归树法" class="headerlink" title="2. 递归树法"></a>2. 递归树法</h2><ol>
<li>将递归式按树的形式展开(不用全画出来)(并且每次递归时 n 的和都要减少而不是增大)</li>
<li>根据每层的和的规律，求出总子叶节点<ul>
<li>如果每层和一样，用每层的和乘以树的高度就行<blockquote>
<p>树要对称，高用每次递归式减少的数(每层为等差)或除以的数(每层为等比)来求<br>等差的话 h=n-k+1 (k 为每层 n 减少的数)<br>等比的话 h=$log_kn$ (k 为每层 n 除的数)</p>
</blockquote>
</li>
<li>如果树不对称或者每层和成等比排列，不用求具体值，都是有规律相加的，求其上界就行</li>
</ul>
</li>
<li>判断总子叶节点小于等于某个相近的值，便可求出其最高阶</li>
</ol>
<p>例：<br><img src="/2020/04/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/diGuiShuFa.jpg" alt="递归树"></p>
<h2 id="3-主方法"><a href="#3-主方法" class="headerlink" title="3.主方法"></a>3.主方法</h2><p>相当于套公式，且适用情况少<br>原理是递归树，可以自己去推导下,这三个主要区别是总子叶节点数的判断不同。（1 是因为每层和在增加，最后一层和占主导。2 是因为每层和一样，和乘以高。3 是因为每层和在减少，第一层和占主导）<br>限制：递归式要满足于 $T(n)=aT(n/b)+f(n)$ &nbsp;&nbsp;&nbsp;a&gt;=1,b&gt;1,f(n)渐进趋正<br>主思路：比较 f(n)和$n^{\log_ba}$</p>
<p>1.</p>
<p>若对某个常数 $\varepsilon&gt;0有$<br>$f(n)= \omicron (n^{\log_b{a-\varepsilon} })$<br>那么<br>$T(n)= \theta (n^{log_ba})$</p>
<p>2.</p>
<p>若<br>$f(n)=\theta(n^{log_ba})f(n)$<br>则<br>$T(n)=\theta(n^{log_ba}\lg n)T(n)$</p>
<p>3.</p>
<p>若对某个常数 $\varepsilon&gt;0有$<br>$f(n) = \Omega(n^{\log_b{a+\varepsilon} })f(n)$<br>且对于某个常数 c&lt;1 和所有足够大的 n 有<br>$af(\frac nb)\le cf(n)$<br>则<br>$T(n)=\theta(f(n))T(n)$</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>算法</tag>
        <tag>概念</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2020/05/05/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><font color="green">简介</font></h1><p>我们关注的主要对象是重新排列数组元素的算法，其中每个元素都有一个主键，排序算法的目的就是将所有的元素的主键按照某种方式排列（通常是按照大小或是字母顺序） </p>
<a id="more"></a> 
<p>常见的十大算法：<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588689912090&di=3d31e8a2f7ab8a74d03f295e5a2c6f25&imgtype=0&src=http://img.mp.itc.cn/upload/20160925/6689ac6a8e954126aefebaf492994cfc_th.jpeg" alt="排序算法"></p>
<blockquote>
<p>稳定：指如果有相同的数，排序后本来在前面的还是在前面<br>out-place：指用了额外的空间</p>
</blockquote>
<hr>
<br>

<p>下面我们在介绍排序算法时将从这几个方向入手：</p>
<ul>
<li>算法思路</li>
<li>算法图解</li>
<li>基本代码实现</li>
<li>易踩坑点</li>
<li>优化思路</li>
</ul>
<p><strong>如未特别说明，下面的变量都是从0开始的</strong></p>
<hr>
<br>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><font color="green">冒泡排序</font></h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>从头开始遍历数据，当前者的主键(值)大于后者时，两者交换位置，直到最后一位</li>
<li>此时数据的最大值一定排在了最后一位，排好的最大值便固定，无需再排</li>
<li>重复1的操作，直到最后两个数排序完成</li>
</ol>
<p>总结：外部循环<code>数据个数-1</code>次，内部循环<code>数组长度-n-1</code>次，每次内部循环比较当前位和后一位的值的大小，判断是否交换</p>
<h2 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3438712239,3527372442&fm=26&gp=0.jpg" alt="冒泡排序"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp; <span class="comment">//帮助交换</span></span><br><span class="line">            <span class="keyword">boolean</span> falg = <span class="keyword">false</span>; <span class="comment">//检查是否已经排好</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                falg = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123; <span class="comment">//每次排序后的最大位可以忽略</span></span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        falg =<span class="keyword">true</span>;</span><br><span class="line">                        temp=arr[j+<span class="number">1</span>];</span><br><span class="line">                        arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                        arr[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!falg) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点"><a href="#易踩坑点" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>一共循环 <code>数据个数-1</code> 次 ，因为最后一次确定第二个值的同时也把最小值确定了</li>
<li>每次遍历后的最大值要忽略，所以每次内部循环时循环次数要-1次</li>
<li>因为比较是和后面的数比较，所以当后面的数到最大值即当前数到倒数第二个时就说明内部循环完，否则数组越界</li>
</ol>
<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>如果有次内循环中没有发生交换，说明已经有序</p>
<hr>
<br>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><font color="green">选择排序</font></h1><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>先把第一个数记成最小值，遍历整个数组，记录遍历时遇见的最小值</li>
<li>遍历完一次后将最小值和第一个数交换位置，下一次遍历从第二个数开始</li>
<li>重复上述操作，直到最后两个数遍历完成</li>
</ol>
<h2 id="算法图解-1"><a href="#算法图解-1" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="http://www.west.cn/cms/images/2019-01-10/q5dlczui1fw.gif" alt="选择排序"></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min;<span class="comment">//记录最小数</span></span><br><span class="line">        <span class="keyword">int</span> temp; <span class="comment">//帮助交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length;i++)&#123;</span><br><span class="line">            min = i; <span class="comment">//将最小值初始化为遍历的第一个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;arr[min])&#123; <span class="comment">//*当某数小于当前最小数(别写成i)时，将最小数的索引改成该数的索引</span></span><br><span class="line">                    min =j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行交换</span></span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-1"><a href="#易踩坑点-1" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>开始时我们是把第一个数当成最小值的，所以是从第二个数开始遍历的</li>
<li>i值的含义有两个，一个是遍历次数，一个是当前遍历最小时应所处的位置</li>
</ol>
<hr>
<br>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><font color="green">插入排序</font></h1><h2 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>遍历数组，将当前数组插入左边已排好数据中</li>
<li>插入方法：先记录当前值，遍历左边，将当前数左边的数向右移动，直到遇见比当前数小的数，此时空白部分便是要插入的地方</li>
</ol>
<h2 id="算法图解-2"><a href="#算法图解-2" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;    </span><br><span class="line">        <span class="comment">//插入法</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            temp=arr[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j];j--)&#123; <span class="comment">//别忘了j要大于0</span></span><br><span class="line">                arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-2"><a href="#易踩坑点-2" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>i是从第二个数开始的</li>
<li>为了插入而进行的遍历一定别忘了j要大于0，(因为每次都是j和j+1比较)如果当前值正好是最小值，则数组会越界</li>
<li>这里j的含义是当前值最后插入的位置的左边</li>
</ol>
<hr>
<br>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><font color="green">希尔排序</font></h1><h2 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>先将数据分成间隔为h的许多小组，先让小组进行排序(插入排序法)</li>
<li>在把间隔缩短（小组变少，每个组中数变多）再进行插入排序</li>
<li>重复上述步骤，直到最后间隔为1时排序(即整个数据排序)</li>
</ol>
<blockquote>
<p>注：h也称为增量序列，对于最优增量序列目前还没有结论，主要的增量序列有Shell 增量序列，Hibbard 增量序列，Knuth 增量序列</p>
</blockquote>
<h2 id="算法图解-3"><a href="#算法图解-3" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" alt="希尔排序"></p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = arr.length; <span class="comment">//总数</span></span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">1</span>;<span class="comment">//增量序列</span></span><br><span class="line">        <span class="keyword">while</span>(h&lt;N/<span class="number">3</span>) h= h*<span class="number">3</span>+<span class="number">1</span>; <span class="comment">//Knuth 增量序列计算得来的h</span></span><br><span class="line">        <span class="comment">//插入法</span></span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;N;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i]; <span class="comment">//因为arr[i]的值可能会变，保存插入值</span></span><br><span class="line">                <span class="keyword">for</span>(;j-h&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j-h];j=j-h)&#123;</span><br><span class="line">                    arr[j] = arr[j-h];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            h=h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-3"><a href="#易踩坑点-3" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>和插入排序一样，i是从h而不是0开始的(h代表的是第一个小组的第二个数)</li>
<li>这里j的含义是当前数再小组中该插入的位置(和插入排序j的含义不同)，所以不是要 j&gt;=0而是要 j-h&gt;=0 (因为每次都是j和j-h比较)</li>
<li>这里是从h开始遍历到结束，效果是先让每个小组的第二个数和前面比较后再让每个小组的第三个数和前面比较，如此循环</li>
</ol>
<h2 id="优化思路-1"><a href="#优化思路-1" class="headerlink" title="优化思路"></a>优化思路</h2><p>增量序列的不同会影响排序算法效率</p>
<hr>
<br>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><font color="green">归并排序</font></h1><h2 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>将数组分成两部分</li>
<li>左部分和右部分分别排序，直到左部分或右部分只有一个数时返回</li>
<li>将两部分合并起来</li>
</ol>
<p>合并方法：</p>
<ul>
<li>传入需要合并的部分的开头，中间和结尾数，将该部分数组放入辅助数组对应位置中</li>
<li>左部分开头和右部分开头创建指针分别遍历：</li>
<li>当左边遍历完时，将右边的数传入原数组</li>
<li>当右边遍历完时，将左边的数传入原数组</li>
<li>当左边小于右边时，将左边的数传入原数组</li>
<li>当右边小于左边时，将右边的数传入原数组</li>
</ul>
<h2 id="算法图解-4"><a href="#算法图解-4" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=4070550482,2402998767&fm=26&gp=0.jpg" alt="归并算法"></p>
<p>合并步骤：</p>
<p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1120323612,2379483011&fm=15&gp=0.jpg" alt="归并算法2"></p>
<h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux; <span class="comment">//归并时所用的辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并两个有序子数据：先将要归并的数据保存到辅助数组中，用两个指针指向辅助数组的前面和中间+1分成两数组</span></span><br><span class="line">    <span class="comment">//两数组依次比较，将较小的数放进原数组对应位置，然后较小数所在的数组指针上移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并子数组，先将数据存入辅助数组中，用两指针二分辅助数组并遍历</span></span><br><span class="line">    <span class="comment">//mid为左边数组的最右边，即最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//辅助指针</span></span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将要归并的数据保存到辅助数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;=hi;k++)&#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;=hi;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;mid) a[k] = aux[j++];<span class="comment">//左边数组遍历完时，直接加右边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;hi) a[k] = aux[i++];<span class="comment">//右边数组遍历完时，直接加左边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aux[i]&gt;aux[j]) a[k] = aux [j++]; <span class="comment">//当右边的比左边的小时，加右边</span></span><br><span class="line">            <span class="keyword">else</span> a[k] = aux [i++]; <span class="comment">//当左边的比右边的小时，加左边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自顶向下的归并排序,将数组不断地二分直到直到只有一个数，再向上合并返回</span></span><br><span class="line">    <span class="comment">//将数组分成左右两部分，每个部分进行排序，排完后再合并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        mergeSort1(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo ,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span>; <span class="comment">//如果最前面和最后面一样说明已经分成最小单位</span></span><br><span class="line">        <span class="keyword">int</span> mid = (hi-lo)/<span class="number">2</span>+lo;</span><br><span class="line">        mergeSort1(a,lo,mid);</span><br><span class="line">        mergeSort1(a,mid+<span class="number">1</span>,hi);</span><br><span class="line">        <span class="keyword">if</span>(a[mid+<span class="number">1</span>]&gt;=a[mid]) <span class="keyword">return</span>; <span class="comment">//优化，如果排好序的右边最小值已经大于左边最大值，说明已经有序</span></span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-4"><a href="#易踩坑点-4" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>合并时传入的 mid (中间值)含义是左部分的最后一个数，算 mid 时记得要加 lo，写右边排序时记得传入的是 mid+1</li>
<li>合并中，将数据存入辅助数组是记得要&lt;=最后一位数而不是&lt;</li>
<li>判断是否左部分或右部分只含有一个数(传入的最左边的索引<code>lo</code> &gt;= 最右边的索引<code>hi</code>)</li>
</ol>
<h2 id="优化思路-2"><a href="#优化思路-2" class="headerlink" title="优化思路"></a>优化思路</h2><p>左右两边排好了之后，如果这时左部分的最大值&lt;=右部分的最小值的，说明已经有序，不用再合并</p>
<h3 id="自下向顶的归并"><a href="#自下向顶的归并" class="headerlink" title="自下向顶的归并"></a>自下向顶的归并</h3><p>除了上面的自顶向下的归并方法，还存在自下向顶的归并的方法：</p>
<ul>
<li><p>每个子数组长度为1开始，2个一组归并，再4个一组归并，直到整个归并</p>
<p>图解：<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E8%87%AA%E4%B8%8B%E5%90%91%E9%A1%B6.jpg" alt="自顶向下"></p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i*=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//因为归并是两个归并，所以每次指针k要移动2个子数组长度</span></span><br><span class="line">            <span class="comment">//可以把一个子数组的i个 数看成一个整体，k的循环就要小于a.length - i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.length - i; k=k+i*<span class="number">2</span>)&#123;</span><br><span class="line">                merge(a,k,k+i-<span class="number">1</span>,Math.min(k+i*<span class="number">2</span>-<span class="number">1</span>,a.length-<span class="number">1</span>)); <span class="comment">//有可能最后一组数不够，要判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>易踩坑点：</p>
<ol>
<li>因为k的作用是指向两个子数组合并的开头，如果最后的个数连一个子数组都没达到的话，那在合并时传入的中间值k+i-1就会发生数组出界问题，所以 k&lt;a.length-i</li>
<li>如果最后只剩一个不全数组，则放到下一轮，如果最后剩一个好的左部分和一个不全的右部分，两者可以合并，但要注意此时传入的最右边的值就不是 k+i*2-1 而是 a.length-1</li>
</ol>
<hr>
<br>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><font color="green">快速排序</font></h1><h2 id="算法思路-5"><a href="#算法思路-5" class="headerlink" title="算法思路"></a>算法思路</h2><p>和归并排序有异曲同工之妙，都采用分治法，但不同点是归并是先分别排序后归并，快速是分开时先排序再分别排序</p>
<ol>
<li>确定一位中间值(一般取第一个数),遍历数组，小于等于中间值的放左边，大于等于中间值的放右边</li>
<li>对中间值左边的数组排序</li>
<li>对中间值右边的数组排序</li>
</ol>
<p>上面 1 的具体步骤：</p>
<ol>
<li>将左边第一个数设为中间值</li>
<li>左边第二个和最右边分别设置两指针向中间遍历，直到左边的指针大于等于右边的指针</li>
<li>当左边遍历时遇见大于中间值的数停下，当右边遍历时遇见小于中间值的数停下</li>
<li>当两指针停下后交换两指针所值的数</li>
<li>遍历完后j所指的一定是小于等于中间值的，将j所在的数与第一个数交换，返回j(中间值所在位置)</li>
</ol>
<h2 id="算法图解-5"><a href="#算法图解-5" class="headerlink" title="算法图解"></a>算法图解</h2><p>整体思路：</p>
<p><img src="https://img-blog.csdnimg.cn/20200318212047646.png" alt="快速排序"></p>
<p>左右排序：</p>
<p>i和j最后一次交换时<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F2.jpg" alt="快速排序2"></p>
<p>i和j最后一次没有交换时<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F3.jpg" alt="快速排序3"></p>
<h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将数组有序二分并返回切分元素位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建两个辅助指针和切分元素</span></span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = hi+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i,j指针向中间遍历，直到遇见不符合的数或边界停下，两者都停下时将两数进行交换</span></span><br><span class="line">        <span class="comment">//当遍历完时i的位置可能会比j大(最后两个数发生交换时，i，j同时移动)可能相等(最后两个数没发生交换时，i，j其中一个移动)</span></span><br><span class="line">        <span class="comment">//遍历完时j的位置一定在小于等于切分元素的数的索引上，将这两个数交换，j所指的便是切分元素索引</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[++i] &lt; v) <span class="keyword">if</span>(i==hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (a[--j] &gt; v) ;<span class="comment">//这里本来还有个判断j是否跑到了最左边(当切分元素是该数据中最小值时)，但因为v在最左边，j一定会停在lo上</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        a[lo] = a[j];</span><br><span class="line">        a[j] = v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        quick(a , <span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span>;  <span class="comment">//可以在某个情况后改成插入排序</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        quick(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        quick(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="易踩坑点-5"><a href="#易踩坑点-5" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>数组切分时创建并初始化 i 与 j 是让 i ，j 等于第一个数和最后一个数的后一位，并且先加减再操作。如果是让 i ，j 等于第二个数和最后一个数并且先操作在加减时会很麻烦，不仅要在内循环中写i++，j–，在arr[i]和arr[j]交换后也要写i++，j– <strong>最好是先移动指针再操作</strong></li>
<li>返回中间值后，中间值是不再参与排序的</li>
<li>小心i和j出界的问题，当i到最右边或j到左边时，也要停止指针移动(j比较特殊，因为j到最左边时一定是等于v的，不可能越界)</li>
</ol>
<h2 id="优化思路-3"><a href="#优化思路-3" class="headerlink" title="优化思路"></a>优化思路</h2><p>防止特殊情况，可以先把数据打乱再排</p>
<h3 id="三切分法："><a href="#三切分法：" class="headerlink" title="三切分法："></a>三切分法：</h3><p>思路：</p>
<ul>
<li>对于有大量的重复数而言，可以使用三分切法，将数据分成大于v，等于，小于iv三部分，v代表中间值<ul>
<li>三个辅助指针i,lt,gt，i来遍历数组，直到大于gt(等于gt时还要再判断一次)</li>
<li>如果i遇见小的数，和lt交换并两者++，如果遇见大的数，和gt交换，gt–，i不动(因为无法保证gt所在的值，lt一定为v)</li>
<li>最后lt，gt都在中间段的最左边和最右边</li>
</ul>
</li>
</ul>
<p>图示：<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B8%89%E5%90%91%E5%88%87%E5%88%86.jpg" alt="快速排序三向切分"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">quick3way</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        quick(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick3way</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi&lt;=lo) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lt = lo;</span><br><span class="line">        <span class="keyword">int</span> gt = hi;</span><br><span class="line">        <span class="keyword">int</span> i  = lo+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v  = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=gt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;v) exchange(a,i++,lt++); <span class="comment">//lt一定为v，交换后i为v，可以移动</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;v) exchange(a,i,gt--); <span class="comment">//无法确定gt处的值，交换后不能动i</span></span><br><span class="line">            <span class="keyword">else</span> i++; <span class="comment">//i处等于v</span></span><br><span class="line">            &#125;</span><br><span class="line">        quick3way(a,lo,lt-<span class="number">1</span>);</span><br><span class="line">        quick3way(a,gt+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[x];</span><br><span class="line">        a[x] = a[y];</span><br><span class="line">        a[y] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>易踩坑点：</p>
<ol>
<li>因为lt是一定等于v的并且在等于v数组的最左边，所以和i所在值交换后两者可以一起++，但由于不知道gt所在的值，所以和i所在值交换后只能让gt–，i不动</li>
<li>记得当i=gt时还要再判断一次</li>
</ol>
<hr>
<br>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><font color="green">计数排序</font></h1><h2 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h2><ol>
<li>找到数组中最大的值</li>
<li>创建一个长度为最大值+1的数组，遍历原数组把数放在值相同的辅助数组下(如遍历到5，则让辅助数组temp[5]++)</li>
<li>遍历辅助数组，将不等于0的索引依次返回给原数组</li>
</ol>
<h2 id="算法图解-6"><a href="#算法图解-6" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="计数排序"></p>
<h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">counting</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = findMax(a);</span><br><span class="line">        counting(a,max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">counting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//用作a的指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:a)&#123;</span><br><span class="line">            temp[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                a[k++] = i;</span><br><span class="line">                temp[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;max) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="易踩坑点-6"><a href="#易踩坑点-6" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>数组计数是从0开始的，记得创建数组时长度为 max+1 这样数组的最后一位才是max</li>
<li>当取出一个数后，该数上的计数(即 temp[ i ] )要-1</li>
<li>注意当前给的代码中因为是用的<code>temp[i]--</code>所以不稳定，可以改成一个从0开始小于temp[i]的循环</li>
</ol>
<hr>
<br>

<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><font color="green">桶排序</font></h1><h2 id="算法思路-6"><a href="#算法思路-6" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>找到数组最大值</li>
<li>根据最大值创建n个桶，每个桶中存放一定范围的数</li>
<li>将每个桶中的数据排序</li>
<li>遍历桶，返回桶中的数</li>
</ol>
<p><strong>因为这个算法本身比较麻烦且用得不多，就不再演示了</strong></p>
<hr>
<br>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><font color="green">基数排序</font></h1><h2 id="算法思路-7"><a href="#算法思路-7" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>找到数据中 位数最高的数（即最大数有多少位）</li>
<li>创建一个二维数组，第一维 0~9 代表某位上可能出现的数，第二维用来存某位相同的数（如12，42都放在arr[2][n]中）</li>
<li>从个位数开始，遍历数组，将个位上相同的数存入相同一维的二维数组中（这里需要一个辅助一维数组来记录二维数组的一维上有多少存储的数）</li>
<li>遍历二维数组，依次返回给原数组</li>
<li>再从十位开始，重复上述操作，如果没十位则补0.循环最高位数次</li>
</ol>
<blockquote>
<p>二维数组可以这样理解：一共有0<del>9的桶，某位上值和桶的索引一样时放进桶中，从下到上放入桶中。一维数组也是0</del>9，每个位置的值就代表桶中有多少存入的值以及下一个该存入该桶的数的位置</p>
</blockquote>
<h2 id="算法图解-7"><a href="#算法图解-7" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="基数排序"></p>
<h2 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> high = findHigh(a);</span><br><span class="line">        radix(a,high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][a.length]; <span class="comment">//放数据的桶，一共要有10个桶(0~9),桶中最多存a中所有的数</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>; <span class="comment">//用于计算某位上的数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一共循环的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=high;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] bucketContent = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//记录每个桶有多少数已经下一个数应该存放在桶的哪里</span></span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>; <span class="comment">//用于将桶中数据返回给数组时对数组的指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算某位上的数进行分组,放入桶里</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : a) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (value / m) % <span class="number">10</span>; <span class="comment">//如果该数没有更高位，temp就为0</span></span><br><span class="line">                bucket[temp][bucketContent[temp]] = value;<span class="comment">//bucketContent[temp]可以表示该存入该桶的数的位置</span></span><br><span class="line">                bucketContent[temp]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将桶中数据返回数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;bucket.length;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bucketContent[k]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bucketContent[k];j++)&#123;</span><br><span class="line">                        a[n++] = bucket[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m=m*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findHigh</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;max)&#123;</span><br><span class="line">                max = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String temp = Integer.toString(max);</span><br><span class="line">        <span class="keyword">return</span> temp.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-7"><a href="#易踩坑点-7" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>每循环完一次后辅助一维数组要清0，即要放入循环中</li>
<li>用m计算位时，没有该位的运算结果就为0</li>
<li>每次记得m*10</li>
</ol>
<hr>
<br>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><font color="green">堆排序</font></h1><p><del>还没学到二叉树呢，以后补</del></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法，排序算法，基础</tag>
      </tags>
  </entry>
</search>
