<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言基础-存储类别</title>
    <url>/2020/05/09/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB/</url>
    <content><![CDATA[<h1 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a><font color="green">存储类别</font></h1><p>在理解存储类别前，先要复习一些概念和术语。</p>
<ul>
<li>对象：对于储存在内存中的数据，被储存的每个值都占用一定的物理内存。这样的一块内存成为对象(和面向对象的对象概念不同)</li>
<li>存储期：对象在内存中保留了多长的时间。</li>
<li>标识符用于访问对象，可以用<strong>作用域</strong>和<strong>链接</strong>描述标识符，表明了程序的哪些部分可以使用它。</li>
</ul>
<p>我们先介绍`作用域、链接和储存期的含义，再介绍具体的存储类别</p>
<a id="more"></a>

<h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h2><p>作用域描述程序中可访问标识符的区域。<br>一个C变量的作用域可以是:</p>
<ul>
<li>块作用域：花括号内的代码，if语句或循环所控制的代码</li>
<li>函数作用域：仅用于goto语句的标签。再块中定义但作用域是整个函数</li>
<li>函数原型作用域：从形参定义处到原型声明结束</li>
<li>文件作用域：定义在函数外面，从它的定义到该定义所在的文件的末尾均可见</li>
</ul>
<blockquote>
<p>注意：当一个源代码中包含一个或多个头文件时，会把所有头文件和编译器源代码文件都看成是一个包含信息的单独文件，文件作用域的实际可见范围是整个翻译单元</p>
</blockquote>
<h2 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h2><p>链接指该变量访问范围<br>C变量有3种链接属性：<strong>外部链接，内部链接或无链接</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;具有块作用域、函数作用域和函数原型作用域的变量都是无链接变量<br>&nbsp;&nbsp;&nbsp;&nbsp;文件作用域的变量可以是外部链接和内部链接，<br>&nbsp;&nbsp;&nbsp;&nbsp;内部链接变量比外部链接变量前面多了个static ，内部链接变量只能在翻译单元中使用，外部链接变量可以在多文件程序中使用</p>
<h2 id="3-存储期"><a href="#3-存储期" class="headerlink" title="3.存储期"></a>3.存储期</h2><p>作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。<br>C对象有4种存储期：</p>
<ol>
<li>静态存储期：关键字static，如果对象具有静态储存期，那么它在程序的执行期间一直存在   <font color="red">注意：文件作用域变量都具有静态存储期，但它的static表示的是其链接属性</font></li>
<li>线程存储期: _Thread_local</li>
<li>自动存储期: 通常是块作用域的变量所具有</li>
<li>动态分配存储期： 从声明处到块末尾而不是块头到末尾</li>
</ol>
<h2 id="5种存储类别"><a href="#5种存储类别" class="headerlink" title="5种存储类别"></a>5种存储类别</h2><table>
<thead>
<tr>
<th>存储类别</th>
<th>存储期</th>
<th>作用域</th>
<th>链接</th>
<th>声明方式</th>
</tr>
</thead>
<tbody><tr>
<td>自动(局部变量)</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内</td>
</tr>
<tr>
<td>寄存器</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内，使用关键字<code>register</code></td>
</tr>
<tr>
<td>静态外部链接(全局变量)</td>
<td>静态</td>
<td>文件</td>
<td>外部</td>
<td>所有函数外</td>
</tr>
<tr>
<td>静态内部链接(static全局变量)</td>
<td>静态</td>
<td>文件</td>
<td>内部</td>
<td>所有函数外，翻译单元中，使用关键字<code>static</code></td>
</tr>
<tr>
<td>静态无链接(静态局部变量)</td>
<td>静态</td>
<td>块</td>
<td>无</td>
<td>块内，使用关键字<code>static</code></td>
</tr>
</tbody></table>
<ul>
<li>如果内层块种声明的变量和外层块的变量同名时，优先内层块的变量</li>
<li>寄存器变量储存在寄存器中，所以无法获取其地址</li>
<li>局部静态变量在程序的执行时间一直存在但只能在块内部使用，其值有继承性（就像Java里面的成员变量）</li>
<li>要在外部使用全局变量或在块中使用全局变量或static全局变量。也必须先声明，而且声明前面要加关键字extern</li>
<li>局部变量和静态局部变量在本文件中只能在声明后使用</li>
</ul>
<h3 id="存储类别的初始化"><a href="#存储类别的初始化" class="headerlink" title="存储类别的初始化"></a>存储类别的初始化</h3><ul>
<li>局部变量不会初始化，但其变量值是分配空间范围中的任意值</li>
<li>静态变量如未人为初始化，则自动初始化为0</li>
</ul>
<h3 id="存储类别说明符"><a href="#存储类别说明符" class="headerlink" title="存储类别说明符"></a>存储类别说明符</h3><ul>
<li>auto:声明局部变量，可忽略</li>
<li>register:声明寄存器变量</li>
<li>static:声明静态类型</li>
<li>extern:  声明时调用（全局/static全局） 变量</li>
<li>_Thread_local：声明线程存储期，可以和 static或extern一起使用</li>
</ul>
<hr>
<br>

<h2 id="存储类别与函数"><a href="#存储类别与函数" class="headerlink" title="存储类别与函数"></a>存储类别与函数</h2><p>函数也有存储类别。</p>
<ul>
<li>外部函数<blockquote>
<p>double a(int i)</p>
</blockquote>
</li>
<li>静态函数<blockquote>
<p>static double a(int i)</p>
</blockquote>
</li>
<li>内联函数<blockquote>
<p>extern double a(int i)</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>c</tag>
        <tag>基础</tag>
        <tag>存储类别</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础-递归</title>
    <url>/2020/04/28/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><font color="#7CFC00">基本概念</font></h1><p>C 语言允许函数调用它自己，这种调用的过程称为递归</p>
<a id="more"></a>

<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><blockquote>
<p>栈：一种数据结构，其特点为先进后出</p>
<blockquote>
<p>C 语言在执行代码时会从 main()开始依次将调用的函数放入栈中<br>放完后便将栈中的方法，从栈顶一个个取出并执行</p>
</blockquote>
</blockquote>
<p>如图( 计算 3! )：</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/diguis.jpg" alt="递归原理图"></p>
<p>解释：</p>
<ol>
<li>开始执行，先将<code>main( )</code>函数放入栈底并执行</li>
<li>遇到了<code>fun(3)</code>后把 <code>mian( )</code>函数暂时放在栈中，去调用<code>fun(3)</code>函数</li>
<li>执行<code>fun(3)</code>时又发现调用了<code>fun(2)</code>，又把<code>fun(2)</code>放入栈中去掉<code>fun(1)</code></li>
<li><code>fun(1)</code>时发现没有调用了( 此时<code>fun(1)</code>在栈顶 )，便开始返回，把返回值给了<code>fun(2)</code>，<code>fun(2)</code>也继续下面的语句，返回给了<code>fun(3)</code></li>
<li>最后<code>fun(3)</code>返回给<code>main( )</code>，<code>main( )</code>继续执行下面的语句</li>
</ol>
<p>由此可以看成递归的形成至少需要两个条件：</p>
<ol>
<li>变化的参数</li>
<li>递归终止条件</li>
</ol>
<blockquote>
<p>栈溢出：内存空间是有限的，分配给 C 程序的栈空间也是有限的，如果递归没有结束条件的话就会导致无限的调用，形成栈溢出</p>
</blockquote>
<hr>
<br>
<br>

<h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a><font color="#7CFC00">尾递归</font></h1><p>最简单的递归形式就是把递归调用置于函数的末尾，即正好在 <code>return</code> 语句之前。这种形式的递归被称为 <u>尾递归</u> (如上图所示)，它相当于循环。</p>
<p><strong>如果效果和循环差不多时最好使用循环</strong></p>
<hr>
<br>
<br>

<h1 id="递归的优缺点"><a href="#递归的优缺点" class="headerlink" title="递归的优缺点"></a><font color="#7CFC00">递归的优缺点</font></h1><p>递归的语法易被人理解，但空间成本消耗太大。所以在使用递归时要特别注意，尤其是<font color="red">效率优先</font>的程序</p>
<br>

<blockquote>
<p>注：main( )函数可以调用自己，且两函数间不可以相互调用</p>
</blockquote>
<hr>
<br>
<br>

<h1 id="递归算法实战-汉诺塔问题"><a href="#递归算法实战-汉诺塔问题" class="headerlink" title="递归算法实战-汉诺塔问题"></a><font color="#7CFC00">递归算法实战-汉诺塔问题</font></h1><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p>
<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>
<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1159565693,4014945639&fm=26&gp=0.jpg" alt="汉诺塔"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们倒着的开始，假如要移动 64 个</p>
<ol>
<li>我们要把上面的 63 个移动到 B</li>
<li>把第 64 个移动到 C</li>
<li>把 B 上的 63 个移动到 C</li>
</ol>
<p>那么就会产生问题了：怎么移动那 63 个呢<br>和上面的思路一样</p>
<ol>
<li>我们要把上面的 62 个移动到 B</li>
<li>把第 63 个移动到 C</li>
<li>把 B 上的 62 个移动到 C</li>
</ol>
<p>直到问题变为：怎么移动上面的那 1 个呢，这时我们就会了，移动了 1 个后，我们就会移动 2 个，移动 2 个后，我们就会第 3 个，依次下去，就能把 64 个都移动完了</p>
<p>所以整个过程是</p>
<ol>
<li>我们要把上面的<code>n-1</code>个移动到 B</li>
<li>把第<code>n</code>个移动到 C</li>
<li>把 B 上的<code>n-1</code>个移动到 C</li>
</ol>
<blockquote>
<p>其中移动 n-1 个盘子的操作是递归操作<br>1，3 步分别用了递归</p>
</blockquote>
<p>下面是 java 语言代码实现部分( <del>用 C 表达出来的效果不好啊，还是 java 的看着舒服</del> ，其实基本都是一样的):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        move(A.size(),A,B,C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从这开始看</span></span><br><span class="line">    <span class="comment">//盘子用数字代替，n代表需要移动的盘子数，List是盘子的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当需要移动的盘子数只有1个时，此时这个盘子就是最下面的，其它的都移动到B上(第一步)或者A(第三步)上了了</span></span><br><span class="line">        <span class="comment">// 把A的盘子直接移动到C就行了</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            C.add(A.remove(A.size()-<span class="number">1</span>)); <span class="comment">//注意这里是最下面的盘子数最大</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没到最上面时，则一直重复123步骤</span></span><br><span class="line">        move(n-<span class="number">1</span>,A,C,B); <span class="comment">//对应第一步</span></span><br><span class="line">        C.add(A.remove(A.size()-<span class="number">1</span>));  <span class="comment">//对应第二步</span></span><br><span class="line">        move(n-<span class="number">1</span>,B,A,C);  <span class="comment">//对应第三步</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<br>
<br>

<h1 id="递归总结"><a href="#递归总结" class="headerlink" title="递归总结"></a><font color="#7CFC00">递归总结</font></h1><p>要运用递归的地方都有以下的共同点</p>
<ol>
<li>拥有大量重复的步骤，或者说可将复杂的步骤转换为计算大但容易理解的重复步骤</li>
<li>拥有当达到某种条件时，可返回一个确定值，即遇见某种情况时可向前推导</li>
</ol>
<p>这样便可以将代表条件的变量设为函数参数，把步骤设为函数具体代码</p>
<hr>
<br>
<br>

<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a><font color="#7CFC00">推荐阅读</font></h1><p>知乎-<a href="https://www.zhihu.com/question/24385418">如何理解汉诺塔的递推</a><br><a href="https://leetcode-cn.com/explore/featured/card/recursion-i/">leetcode-递推</a>(有点难度)</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>c</tag>
        <tag>递归</tag>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day12-c指针</title>
    <url>/2023/03/08/day12-c%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="day12-c指针"><a href="#day12-c指针" class="headerlink" title="day12-c指针"></a><font color="green">day12-c指针</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、指针变量的赋值"><a href="#1、指针变量的赋值" class="headerlink" title="1、指针变量的赋值"></a>1、指针变量的赋值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> *q = p;   <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">char</span> *m = <span class="literal">NULL</span>; <span class="comment">//空指针 3</span></span><br><span class="line"><span class="keyword">int</span> *n = b; <span class="comment">// n == &amp;b[0] //4</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>


<h3 id="2、指针变量的运算"><a href="#2、指针变量的运算" class="headerlink" title="2、指针变量的运算"></a>2、指针变量的运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p+n --&gt; 向高地址位偏移n个元素的字节数</span><br><span class="line">p-n --&gt; 向低地址位偏移n个元素的字节数</span><br><span class="line">    </span><br><span class="line">指针-指针：计算两个相同类型的指针之间相差的元素个数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、指针和一维数组"><a href="#3、指针和一维数组" class="headerlink" title="3、指针和一维数组"></a>3、指针和一维数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line">*p == a[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4、指针和二维数组"><a href="#4、指针和二维数组" class="headerlink" title="4、指针和二维数组"></a>4、指针和二维数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">二维数组的数组名也表示整个二维数组的首地址。但是是一个行地址</span><br><span class="line"></span><br><span class="line">    数组指针定义的一般形式：</span><br><span class="line">    	&lt;存储类型&gt; &lt;数据类型&gt; (*数组指针名)[列数];</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	a == &amp;a[<span class="number">0</span>] </span><br><span class="line">	a+<span class="number">1</span> == &amp;a[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line">	*(*(p+<span class="number">1</span>)+<span class="number">1</span>) --&gt; 二维数组中第二行第二个元素</span><br></pre></td></tr></table></figure>

<hr>
<br>
<br>

<h2 id="二、指针"><a href="#二、指针" class="headerlink" title="二、指针"></a>二、指针</h2><h3 id="1、指针数组"><a href="#1、指针数组" class="headerlink" title="1、指针数组"></a>1、指针数组</h3><p>​        数组指针(行指针)：本质是指针，存放地址值，指向的内容是一个一维数组的地址</p>
<p>​        指针数组：本质是数组。如果一个数组中所有元素都是地址，那么该数组称为指针数组</p>
<h3 id="2、指针数组的定义"><a href="#2、指针数组的定义" class="headerlink" title="2、指针数组的定义"></a>2、指针数组的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; *数组名[元素个数];</span><br><span class="line">	例：</span><br><span class="line">    	<span class="keyword">int</span> a, b, c;</span><br><span class="line">		<span class="keyword">int</span> *addr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;</span><br><span class="line">		addr[<span class="number">0</span>] == &amp;a;</span><br><span class="line">		addr[<span class="number">1</span>] == &amp;b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、多级指针–二级指针-难点"><a href="#3、多级指针–二级指针-难点" class="headerlink" title="3、多级指针–二级指针(难点)"></a>3、多级指针–二级指针(<strong>难点</strong>)</h3><p>​    定义一个指针变量，有几个星号就是几级指针</p>
<p>​    二级指针的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; **指针变量名;</span><br><span class="line">例：</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">	<span class="keyword">int</span> **q = &amp;p;</span><br><span class="line">	</span><br><span class="line">	*q == p == &amp;a</span><br><span class="line">	**q == *p == *&amp;a == a == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>注意</strong>：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line"><span class="keyword">int</span> *q[<span class="number">2</span>] = &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;;</span><br><span class="line"></span><br><span class="line">p:数组指针名，p+<span class="number">1</span>偏移一行数据大小</span><br><span class="line">q:指针数组名，q+<span class="number">1</span>偏移一个指针大小</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **x = p; <span class="comment">//error****</span></span><br><span class="line"><span class="keyword">int</span> **x = q;  <span class="comment">//right</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4、const指针"><a href="#4、const指针" class="headerlink" title="4、const指针"></a>4、const指针</h3><p>​    const修饰的变量为只读属性，不能直接修改该变量的值</p>
<p>​    const指针</p>
<p>​    (1)const 数据类型 *指针变量名;</p>
<p>​         数据类型 const *指针变量名;    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//right</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error  *p被修饰为只读</span></span><br></pre></td></tr></table></figure>

<p>​        const修饰是指针指向的内容，不能修改指针指向的数据，但是可以修改指针变量中的地址值</p>
<p>​    </p>
<p>​    (2)数据类型 *  const  指针变量名；   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error p被修饰为只读</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//right</span></span><br></pre></td></tr></table></figure>

<p>​    const修饰的指针变量p，不能修改指针变量的值，但是可以修改指针指向内容的值</p>
<p>（3）const 数据类型 *  const  指针变量名；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error p被修饰为只读</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error *p被修饰为只读</span></span><br></pre></td></tr></table></figure>

<p>​    const同时修饰指针变量和指针指向内容，两者都不能修改</p>
<h3 id="5、void指针"><a href="#5、void指针" class="headerlink" title="5、void指针"></a>5、void指针</h3><p>​        void – 空类型，不确定类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br><span class="line">指针p中可以存放任意类型的地址值</span><br><span class="line">*p = <span class="number">2</span>;  <span class="comment">//error  void指针在使用之前需要将void类型指针强制转换为需要的类型</span></span><br><span class="line">*(<span class="keyword">int</span> *)p = <span class="number">2</span>; <span class="comment">//right</span></span><br></pre></td></tr></table></figure>



<h3 id="6、字符指针和字符串"><a href="#6、字符指针和字符串" class="headerlink" title="6、字符指针和字符串"></a>6、字符指针和字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">50</span>] = &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">&quot;hello&quot;</span>; <span class="comment">//right</span></span><br><span class="line">如果将一个字符串赋值给一个字符指针，相当于把该字符串的首地址赋值给字符指针变量</span><br><span class="line"></span><br><span class="line">注意：如果将一个字符串常量赋值给一个指针变量，那么通过该指针不能修改字符串每一个字符的值</span><br></pre></td></tr></table></figure>


<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>若有以下定义，且0≤i＜4，则不正确的赋值语句是<u>&emsp;B&emsp;</u>.<br>int b[4][6], *p, *q[4];<br>（A）q[i] = b[i];           （B） p = b;<br>（C）p = b[i]               （D） q[i] = &amp;b[0][0];</p>
<p>解：表示b的话要用二次指针来表示二维数组的地址。这样的话*p仅代表所对应的行地址</p>
<p>​    </p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c语言</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown笔记-基础</title>
    <url>/2020/04/26/Markdown%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Markdown-概述"><a href="#Markdown-概述" class="headerlink" title="Markdown 概述"></a>Markdown 概述</h1><p>Markdown 是一种轻量级标记语言，与 2004 年创建。<br>后缀为<code>.md</code>或<code>.maekdown</code>，可导出 HTML，Word，pdf 等多种格式文档</p>
<a id="more"></a>

<hr>
<br>

<h1 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h1><h2 id="1-使用-和-标记一级和二级标题"><a href="#1-使用-和-标记一级和二级标题" class="headerlink" title="1.使用=和-标记一级和二级标题"></a>1.使用=和-标记一级和二级标题</h2><blockquote>
<p>这是一级标题<br>==========<br>这是二级标题<br>-—————–</p>
</blockquote>
<h2 id="2-使用-号标记标题"><a href="#2-使用-号标记标题" class="headerlink" title="2.使用#号标记标题"></a>2.使用#号标记标题</h2><blockquote>
<p># 一级标题<br>## 二级标题<br>### 三级标题<br>…<br>###### 六级标题</p>
</blockquote>
<p><strong>注：#后要加空格</strong></p>
<hr>
<br>
<br>

<h1 id="Markdown-段落与字体格式"><a href="#Markdown-段落与字体格式" class="headerlink" title="Markdown 段落与字体格式"></a>Markdown 段落与字体格式</h1><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>1.在段落末尾使用两个以上空格加回车为换行</p>
<p>2.在段落与段落之间留出一个空行为换段落</p>
<h2 id="字体格式"><a href="#字体格式" class="headerlink" title="字体格式"></a>字体格式</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><blockquote>
<p>*斜体文本* &gt; _斜体文本_ &gt; **粗体文本** &gt;__粗体文本__ &gt; ***粗斜体文本*** &gt;___粗斜体文本___</p>
</blockquote>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>&nbsp; 在一行内用三个以上的星号，减号，下划线，在建立一个分割线<br>&nbsp; 注意：行内不能有其他东西</p>
<blockquote>
<p>***<br> -–<br>_ _ _<br>-———–</p>
</blockquote>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a><del>删除线</del></h3><p>&nbsp; 如果要在文字上添加删除线，则在文字两端加上两个波浪线~~</p>
<blockquote>
<p>~~要删除线的文字~~</p>
</blockquote>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>&nbsp; <u>下划线</u>可以通过 HTML 的<code>&lt;u&gt;</code>标签来实现</p>
<blockquote>
<p>&lt;u&gt;带下划线的文本&lt;/u&gt;</p>
</blockquote>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>&nbsp; 在需要脚注<a href="%E6%97%A0%E8%AE%BA%E5%86%99%E4%BB%80%E4%B9%88%E8%84%9A%E6%B3%A8%E5%90%8D%EF%BC%8C%E6%9C%80%E5%90%8E%E9%83%BD%E4%BC%9A%E5%8F%98%E6%88%90%E6%95%B0%E5%AD%97%E6%8E%92%E5%88%97%E6%96%B9%E5%BC%8F">^像这样</a>的文字后写[^脚注名]，并在后面的某个地方用[^要注明的文本]: 内容 来使用脚注。<u>且无论写什么脚注名，最后都会变成数字排列方式</u></p>
<blockquote>
<p>[^脚注名]</p>
<p>[^脚注名]: 脚注内容</p>
</blockquote>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;将选中的文字用灰色背景加重（<code>像这样</code>）,就在文字的两旁加`</p>
<blockquote>
<p>`文字`</p>
</blockquote>
<h3 id="特殊符号失效"><a href="#特殊符号失效" class="headerlink" title="特殊符号失效"></a>特殊符号失效</h3><p>&nbsp; 如果想让特殊符号失效，即打出原有符号样子(如#),则在特殊符号前加反切线\</p>
<blockquote>
<p>\<br> \&lt;\u&gt;…&lt;/u&gt;</p>
</blockquote>
<hr>
<br>
<br>

<h1 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h1><p>&nbsp; Markdown 支持有序列表和无序列表（在标记后面要有空格）</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记</p>
<blockquote>
<p>* 第一项<br>* 第二项<br>* 第三项</p>
<p>+ 第一项<br>+ 第二项<br>+ 第三项</p>
<p>- 第一项<br>- 第二项<br>- 第三项</p>
</blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<br>

<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表使用数字加上<code>.</code>号来表示，如：</p>
<blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
</blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<hr>
<br>
<br>

<h1 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h1><p>Markdown 区块引用时在段落开头使用&gt;号，后面要跟个空格符号</p>
<blockquote>
<p>&gt;区块内文字,效果就是这像一行一样出现阴影</p>
<blockquote>
<p>打多个&gt;还可以还可以内嵌(如这行的&gt;&gt;)</p>
</blockquote>
</blockquote>
<ol>
<li>区块中使用列表的话，就在&gt;后面用列表语法就行<blockquote>
<p>&gt; 1. 第一项<br>&gt; 2. 第二项<br>&gt; 3. 第三项</p>
<p>&gt; + 第一项<br>&gt; + 第二项<br>&gt; + 第三项</p>
</blockquote>
</li>
</ol>
<br>

<ol start="2">
<li>列表中使用区块，则要在&gt;前添加四个空格的缩进</li>
</ol>
<blockquote>
<p>* 第一项<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;区块内容<br>* 第二项</p>
</blockquote>
<p>效果如下：</p>
<ul>
<li>第一项<blockquote>
<p>区块内容</p>
</blockquote>
</li>
<li>第二项</li>
</ul>
<hr>
<br>
<br>

<h1 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h1><ul>
<li>如果是段落上的一个函数或片段的代码可以用反引号(`)将内容包起来</li>
</ul>
<blockquote>
<p>`printf()`函数</p>
</blockquote>
<p><code>printf()</code>函数<br><br></p>
<ul>
<li>如果是代码区块，则使用 4 个空格或者一个制表符(Tab 键)</li>
</ul>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 代码内容</p>
</blockquote>
<pre><code>public static void main(String[] args)&#123;
    System.out.println(&quot;hello,world&quot;)
&#125;</code></pre>
<br>

<ul>
<li>也可以用 ``` …. ``` 来包裹一段代码，还可以在```后面指定一种语言</li>
</ul>
<blockquote>
<p>```java<br>public static void main(String[] args){<br>System.out.println(“hello,world”)<br>}<br>```</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<br>
<br>

<h1 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h1><ul>
<li>普通方式</li>
</ul>
<blockquote>
<p>[链接名称](链接地址)<br>或者&lt;链接地址&gt;</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/3b638180e42c">技术文档书写规范</a></p>
<p><a href="https://www.jianshu.com/p/3b638180e42c">https://www.jianshu.com/p/3b638180e42c</a><br><br></p>
<ul>
<li>高级链接<br>如果链接太长时，可在[连接名称]后面设置一个[标签名],则可在后面的任意位置写[标签名]: 链接<br><strong>注意：<code>[标签名]:</code> 冒号前面以及两个中括号之间[][]不要留空格</strong></li>
</ul>
<blockquote>
<p>[技术文档书写规范][1]<br>[csdn 官网][csdn]</p>
<p>[1]: <a href="https://www.jianshu.com/p/3b638180e42c">https://www.jianshu.com/p/3b638180e42c</a> &gt;[csdn]: <a href="https://www.csdn.net/">https://www.csdn.net/</a></p>
</blockquote>
<p><a href="https://www.jianshu.com/p/3b638180e42c">技术文档书写规范</a><br><a href="https://www.csdn.net/">csdn 官网</a></p>
<hr>
<br>
<br>

<h1 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote>
<p>![alt 属性文本](图片地址)</p>
<p>![alt 属性文本](图片地址 “title 属性文本”)</p>
</blockquote>
<p>alt 为图片加载出错时的代替文本<br>title 为鼠标放在图片上时所显示的文字</p>
<h2 id="图片地址的传入方法"><a href="#图片地址的传入方法" class="headerlink" title="图片地址的传入方法"></a>图片地址的传入方法</h2><ol>
<li>通过图床将图上传到网上后使用图片的链接<blockquote>
<p>![图片加载出错](<a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg">https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http%3A%2F%2Fgss0.baidu.com%2F-4o3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2F810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg</a> “这是 title 属性”)</p>
</blockquote>
</li>
</ol>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587895752391&di=e2f0ba8e2108ab4f04b19700233f121f&imgtype=0&src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg" alt="图片加载出错" title="这是title属性"><br><br></p>
<ol start="2">
<li>将图片存入本地，通过 <a href="https://blog.csdn.net/chudelong1/article/details/90697409">绝对路径/相对路径</a> 来加载图片(相对路径是以当前的 md 文件所在目录为起点)</li>
</ol>
<blockquote>
<p>![图片出不来了](./mdphoto/markdownlearn/0.jpg)</p>
</blockquote>
<p><img src="/2020/04/26/Markdown%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/0.jpg" alt="图片出不来了"></p>
<p>当然，当地址过长时也可以像链接那样将(…)变成变量名</p>
<blockquote>
<p>![图片加载出错][photo 1]</p>
<p>[photo 1]: <a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg">https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http%3A%2F%2Fgss0.baidu.com%2F-4o3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2F810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg</a></p>
</blockquote>
<p><strong><u>注意：如果是想将本地连接的图片通过 hexo 传到远端时，直接使用是无效的,要实现下列步骤</u></strong></p>
<ol>
<li>配置 hexo 根下的<code>_config.yml</code>里面的<code>post_asset_folder:false</code>这个选项设置为<code>true</code>。</li>
<li>git bash 安装插件：<code>npm install https://github.com/7ym0n/hexo-asset-image --save</code> , 安装之后再生成新 md 文件时同目录下会出现同名的文件夹，图片可放进那里</li>
<li>这时再使用上面的语法便能成功</li>
</ol>
<hr>
<br>
<br>

<h1 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h1><p>&nbsp; Markdown 中制作表格用<code>|</code>来分割不同的单元格，用<code>-</code>在分割表头和其它行</p>
<blockquote>
<p>|表头 1|表头 2|表头 3|<br>| :&nbsp;—&nbsp;&nbsp; &nbsp;|:&nbsp;&nbsp; —&nbsp;&nbsp;: |&nbsp;&nbsp;&nbsp;—&nbsp;&nbsp;: |<br>|左对齐|中对齐|右对齐|<br>|左对齐效果|中对齐效果|右对齐效果|</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">表头 1</th>
<th align="center">表头 2</th>
<th align="right">表头 3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">左对齐</td>
<td align="center">中对齐</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td align="left">左对齐效果</td>
<td align="center">中对齐效果</td>
<td align="right">右对齐效果</td>
</tr>
</tbody></table>
<br>
<br>

<p>还能设置表格的对齐方式(默认向左对齐)：</p>
<ul>
<li><strong><code>-:</code></strong> 设置内容和标题栏右对齐</li>
<li><strong><code>:-:</code></strong> 设置内容和标题栏中对齐</li>
<li><strong><code>:-</code></strong> 设置内容和标题栏左对齐</li>
</ul>
<p><strong>注：最右边的<code>|</code>可以省略</strong></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Markdown基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day13-c指针，函数</title>
    <url>/2023/03/08/day13-c%E6%8C%87%E9%92%88%EF%BC%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="day13-c指针，函数"><a href="#day13-c指针，函数" class="headerlink" title="day13-c指针，函数"></a><font color="green">day13-c指针，函数</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、指针数组"><a href="#1、指针数组" class="headerlink" title="1、指针数组"></a>1、指针数组</h3><p>​    本质：数组</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt;*指针数组名[元素个数];</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> b[<span class="number">50</span>] = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">50</span>] = <span class="string">&quot;qwe&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> *p[<span class="number">3</span>] = &#123;a, b, c&#125;;</span><br><span class="line">	p[<span class="number">0</span>] == a;</span><br><span class="line">	p[<span class="number">2</span>] == b;</span><br><span class="line">	p[<span class="number">3</span>] <span class="comment">//error</span></span><br><span class="line">    *(p[<span class="number">0</span>]) == <span class="string">&#x27;h&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">char</span> **q = p = &amp;a;</span><br><span class="line">	q+<span class="number">1</span> = p+<span class="number">1</span> = &amp;b;</span><br><span class="line">	*q = *p = *(&amp;a) == a;</span><br><span class="line">	**q = *a = <span class="string">&#x27;h&#x27;</span>     </span><br><span class="line">        </span><br><span class="line">    p == &amp;p[<span class="number">0</span>];    </span><br><span class="line">        </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> *p[<span class="number">2</span>] = &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;;</span><br><span class="line">	*(p[<span class="number">0</span>]) == **p == p[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、二级指针"><a href="#2、二级指针" class="headerlink" title="2、二级指针"></a>2、二级指针</h3><p>​     将一级指针的地址称为二级指针</p>
<p>​        int a = 2;</p>
<p>​        int *p = &a;</p>
<p>​        int **q = &p;  //q就是定义的一个二级指针，地址中存放一级指针的值</p>
<h3 id="3、const指针"><a href="#3、const指针" class="headerlink" title="3、const指针"></a>3、const指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//right</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<h3 id="4、void指针"><a href="#4、void指针" class="headerlink" title="4、void指针"></a>4、void指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br><span class="line">p+<span class="number">1</span> <span class="comment">// error  void类型指针在使用时需要类型强转</span></span><br><span class="line">(<span class="keyword">int</span> *)p+<span class="number">1</span> <span class="comment">// 偏移4字节</span></span><br><span class="line">(<span class="keyword">char</span> *)p+<span class="number">1</span> <span class="comment">// 偏移1字节</span></span><br><span class="line"></span><br><span class="line">注意：<span class="keyword">void</span>类型的指针不能使用递增递减运算符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、字符指针和字符串"><a href="#5、字符指针和字符串" class="headerlink" title="5、字符指针和字符串"></a>5、字符指针和字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">6</span>] = <span class="string">&quot;haha&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">&quot;hello&quot;</span>; <span class="comment">//将字符串hello的首地址赋值给指针变量p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *p); <span class="comment">//right</span></span><br><span class="line">*p = <span class="string">&#x27;z&#x27;</span>; <span class="comment">//error hello是一个字符串常量，不能修改里面的字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;asd&quot;</span>); <span class="comment">//error</span></span><br><span class="line"><span class="built_in">strcpy</span>(a, <span class="string">&quot;asd&quot;</span>); <span class="comment">//right	</span></span><br></pre></td></tr></table></figure>



<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><p>概念：函数是一个实现特定功能的代码模块，函数有返回值，也可能没有</p>
<p>​            返回值：函数的结果</p>
<h3 id="1、函数的封装-定义"><a href="#1、函数的封装-定义" class="headerlink" title="1、函数的封装(定义)"></a>1、函数的封装(定义)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">	&lt;数据类型&gt; 函数名(形式参数)</span><br><span class="line">	&#123;</span><br><span class="line">    	功能代码模块;  <span class="comment">//语句块</span></span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">return</span> 表达式; </span><br><span class="line">	&#125;</span><br><span class="line">	数据类型：跟函数返回值的类型一致，如果一个函数没有返回值，则填<span class="keyword">void</span></span><br><span class="line">    函数名：遵循标识符标识符的命名规范，函数命名一般和功能相关。函数名也代表函数的起始地址</span><br><span class="line">    形式参数：形式参数决定了，函数调用时需要传入的实参的个数、类型、顺序，多个形式参数之间用逗号隔开。</span><br><span class="line">    如果函数不需要形式参数，可以省略不写，或者填<span class="keyword">void</span></span><br><span class="line">    <span class="keyword">return</span>：函数结束的标志，后面的表达式的值为函数的结果。如果没有返回值，可以选择不填或者只填<span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="2、函数的调用"><a href="#2、函数的调用" class="headerlink" title="2、函数的调用"></a>2、函数的调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    函数名(实际参数);</span><br><span class="line">	实际参数必须跟形式参数的个数、类型、顺序一致。如果没有形式参数，那么实际参数可以省略</span><br></pre></td></tr></table></figure>

<h3 id="3、函数的声明"><a href="#3、函数的声明" class="headerlink" title="3、函数的声明"></a>3、函数的声明</h3><p>​    在使用函数之前需要对函数进行函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">声明的一般形式：</span><br><span class="line">   &lt;数据类型&gt; 函数名(形式参数); 	</span><br><span class="line"></span><br><span class="line">	函数的声明中变量名是可以省略的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在add.h中声明了#include &lt;stdio.h&gt;后，在其他要用到#include &lt;stdio.h&gt;的函数中可以直接声明#include”add.h”就行。</p>
</blockquote>
<h3 id="4、头文件一般格式"><a href="#4、头文件一般格式" class="headerlink" title="4、头文件一般格式"></a>4、头文件一般格式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ADD_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ADD_H__</span></span><br><span class="line"></span><br><span class="line">头文件声明</span><br><span class="line"></span><br><span class="line">函数声明</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、函数的传参"><a href="#5、函数的传参" class="headerlink" title="5、函数的传参"></a>5、函数的传参</h3><p>(1)赋值传递</p>
<p>&emsp;&emsp;在调用函数时，将普通变量的值直接赋值给形参。因为形式参数和实际参数在内存中存储的地址不同，所以        在函数中无论怎样改变形式参数的值，对实际参数是没有任何影响的</p>
<p>(2)地址传递</p>
<p>&emsp;&emsp;在调用函数时，将普通变量的地址直接赋值给形参。可以通过修改形式参数，间接修改实参的值</p>
<p>(3)全局变量</p>
<p>&emsp;&emsp;因为全局变量的作用域在整个文件中有效，所有在当前文件的任何一个函数中都可以当作参数使用</p>
<h3 id="6、数组传参"><a href="#6、数组传参" class="headerlink" title="6、数组传参"></a>6、数组传参</h3><p>&emsp;&emsp;数组传参需要传入指定数组的首地址，如果该数组是一个整型数组，那么在传入数组首地址的同时，还需要传入数组元素的个数</p>
<hr>
   <br>
   <br>

<h2 id="7、易错点"><a href="#7、易错点" class="headerlink" title="7、易错点"></a>7、易错点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>]=a; <span class="comment">//error</span></span><br><span class="line"><span class="keyword">int</span> *p=a;<span class="comment">//error</span></span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]);<span class="comment">//error一定为8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row=a[<span class="number">1</span>]-a[<span class="number">0</span>];   <span class="comment">//二维数组列数计算，用下一行的地址减去第一行的地址。即使二维数组只有一列也行</span></span><br><span class="line"><span class="keyword">int</span> line=<span class="keyword">sizeof</span>(a)/(row*<span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));​   <span class="comment">//二维数组行数计算</span></span><br></pre></td></tr></table></figure>

<h3 id="指针数组与数组指针的区别"><a href="#指针数组与数组指针的区别" class="headerlink" title="指针数组与数组指针的区别"></a>指针数组与数组指针的区别</h3><p>例：<br>int a[2][3]={1,2,3,4,5,6};<br>int (*p)[3]=a;<br>int *p[2]={a[0],a[1]};</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">指针数组</th>
<th align="center">数组指针</th>
</tr>
</thead>
<tbody><tr>
<td align="center">本质</td>
<td align="center">元素是指针的数组</td>
<td align="center">指向数组的行指针</td>
</tr>
<tr>
<td align="center">形式</td>
<td align="center">int *p[3]={a[0],a[1]};</td>
<td align="center">int (*p)[3]=a;</td>
</tr>
<tr>
<td align="center">p+1</td>
<td align="center">=&amp;p[1]=&amp;a[1]=&amp;&amp;a[1][0]</td>
<td align="center">=&amp;p[1]=&amp;a[1]=&amp;&amp;a[1][0]</td>
</tr>
<tr>
<td align="center">sizeof(p)</td>
<td align="center">整个数组的大小</td>
<td align="center">一定为8(即指针的大小)</td>
</tr>
<tr>
<td align="center">*(p+1)<strong>值一样但形式不一样</strong></td>
<td align="center">p[1]=a[1]=&amp;a[1][0]</td>
<td align="center">=a[1]=&amp;a[1][0]</td>
</tr>
<tr>
<td align="center">sizeof(*p)</td>
<td align="center">一定为8(即指针的大小)</td>
<td align="center">一列的大小</td>
</tr>
<tr>
<td align="center">二级指针x</td>
<td align="center">有二级指针 int **x=p</td>
<td align="center">没有二级指针，<font color="red">不能 int **x=p</font></td>
</tr>
<tr>
<td align="center">**p</td>
<td align="center">=**x=*p[0]=*a[0]=a[0][0]</td>
<td align="center">=*a[0]=a[0][0]</td>
</tr>
</tbody></table>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c语言</tag>
        <tag>指针</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>day11-c数组与指针</title>
    <url>/2023/03/08/day11-c%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="day11-c数组与指针"><a href="#day11-c数组与指针" class="headerlink" title="day11-c数组与指针"></a><font color="green">day11-c数组与指针</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><p>​    字符数组和字符串</p>
<p>​        字符数组：存放的数据是字符数据</p>
<p>​        字符串：由一个或者多个字符组成，在字符串的末尾有一个隐藏的空字符 – ‘\0’</p>
<p>​        char a[50] = “hello”;    </p>
<a id="more"></a>

<h3 id="2-字符串函数："><a href="#2-字符串函数：" class="headerlink" title="2.字符串函数："></a>2.字符串函数：</h3><blockquote>
<p>字符串长度函数 – strlen()<br>字符串连接函数– strcat()<br>字符串拷贝函数 – strcpy()<br>字符串比较函数– strcmp()</p>
</blockquote>
<p><strong>注：<code>int a[10]=&#123;0&#125;</code>相当于把数组a中的所有元素给赋值成’\0’，但是<font color="red">int a[arr]={0}</font>则错误，因为在数组长度为变量时不能同时进行赋值</strong><br><strong>同时也不能把字符串常量赋值给一个字符数组，因为字符数组本身也是个常量 <font color="red">char s[10];s=”abcdefg”</font>是错误的。</strong></p>
<br>
<br>

<hr>
<h2 id="二、指针"><a href="#二、指针" class="headerlink" title="二、指针"></a>二、指针</h2><h3 id="1、指针相关运算符"><a href="#1、指针相关运算符" class="headerlink" title="1、指针相关运算符"></a>1、指针相关运算符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;:获取内容的地址</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">	&amp;a --&gt; 获取到a的地址</span><br><span class="line">    </span><br><span class="line">*：获取地址中的内容</span><br><span class="line">    *(&amp;a) == a == <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、指针变量"><a href="#2、指针变量" class="headerlink" title="2、指针变量"></a>2、指针变量</h3><p>​    指针变量就是用于存放地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; *指针变量名;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">//将a的地址存放在了一个名为p的指针变量中</span></span><br><span class="line">p == &amp;a;</span><br><span class="line">*p = *(&amp;a) == a == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="3、指针变量的赋值"><a href="#3、指针变量的赋值" class="headerlink" title="3、指针变量的赋值"></a>3、指针变量的赋值</h3><p>赋值运算符的左值和右值类型一定要相同</p>
<p>(1)将一个变量的地址赋值给一个具有相同数据类型的指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>(2)将一个已有的指针赋值给一个 具有相同数据类型的指针变量</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *q = p;</span><br><span class="line"></span><br><span class="line">q == p == &amp;a;</span><br></pre></td></tr></table></figure>

<p>(3)将0值赋值给一个指针变量 – 空指针</p>
<p>野指针：定义一个指针，没有明确指向，不能访问野指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>(4)将一个数组的数组名赋值给一个具有相同数据类型的指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a; <span class="comment">// a == &amp;a[0]</span></span><br></pre></td></tr></table></figure>

<p>(5)把一个复合形式的表达式的值赋给一个具有相同数据类型的指针变量</p>
<h3 id="4、指针的运算"><a href="#4、指针的运算" class="headerlink" title="4、指针的运算"></a>4、指针的运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">// &amp;a == 0x2000</span></span><br><span class="line">p+n --&gt; p向高地址位偏移n个元素大小的字节数  <span class="comment">//元素指，该指针指向的内容</span></span><br><span class="line">p-n --&gt; p向低地址位偏移n个元素大小的字节数</span><br><span class="line"></span><br><span class="line">p+n == p+n*<span class="keyword">sizeof</span>(元素类型)  <span class="comment">//在该例中元素类型为int</span></span><br><span class="line">    </span><br><span class="line">注意：指针运算中没有 指针 + 指针、指针 * 指针、 指针 / 指针，因为没有任何实际意义 </span><br><span class="line">    但是有指针 - 指针</span><br><span class="line">    </span><br><span class="line">    指针-指针表示相同类型的两个指针之间相差多少个元素,结果的正负，仅代表地址高低</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">	<span class="keyword">int</span> *q = &amp;b;</span><br><span class="line">	q - p ==  (q-p)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="5、指针和一维数组"><a href="#5、指针和一维数组" class="headerlink" title="5、指针和一维数组"></a>5、指针和一维数组</h3><p>将一个一维数组的数组名赋值给一个具有相同数据类型的指针变量, 我们就可以通过该指针访问数组中所有元素</p>
<blockquote>
<p><strong>注：数组名不能递增递减</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line">*p == a[<span class="number">0</span>];</span><br><span class="line">*(p+<span class="number">1</span>) == a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p++; <span class="comment">// p = p+1; right</span></span><br><span class="line">a++; <span class="comment">// a = a+1; error  数组名不能递增递减</span></span><br><span class="line"></span><br><span class="line">数组a中的第三个元素的表达方式:</span><br><span class="line">	a[<span class="number">2</span>]、 *(p+<span class="number">2</span>)、 *(&amp;a[<span class="number">2</span>])、p[<span class="number">2</span>]、 *(a+<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h3 id="6、指针和二维数组-–-行指针（数组指针）"><a href="#6、指针和二维数组-–-行指针（数组指针）" class="headerlink" title="6、指针和二维数组 – 行指针（数组指针）"></a>6、指针和二维数组 – 行指针（数组指针）</h3><p>​    本质：数组指针是一个指针，存放的内容是地址，指针指向的内容是一个一维数组</p>
<p>​    二维数组的数组名是一个行指针，指向二维数组的首地址，行指针+n相当于地址偏移n行元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//行指针的定义一般形式</span></span><br><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; (*指针变量名)[列数];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line"></span><br><span class="line">*(*(p+<span class="number">1</span>)+<span class="number">2</span>) == 第二行第三个元素</span><br><span class="line">*(*(p+<span class="number">0</span>)+<span class="number">1</span>) == 第一行第二个元素</span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">258</span>;                                                      </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)&amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(++p));</span><br><span class="line">  &#125;</span><br><span class="line">  ````</span><br><span class="line">程序运行结果是  &lt;u&gt;2,1&lt;/u&gt;  </span><br><span class="line"></span><br><span class="line">解：<span class="number">258</span>的<span class="number">16</span>进制为<span class="number">102</span>，按照<span class="keyword">int</span>的存储方式为 <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span>，p指针先到<span class="number">02</span>，因为转移到<span class="keyword">char</span>后+<span class="number">1</span>为前进一个字符，则p指针跳到了<span class="number">01.</span>  </span><br><span class="line"></span><br><span class="line">### <span class="number">2.</span> </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *arr[<span class="number">3</span>]=&#123;a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>]&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<p>程序运行结果是  <u>8</u></p>
<p>解：arr数组里的都是指针，sizeof指向第一个元素即指针，所以大小为8，不是a[0][3]中的12.</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>&emsp;若有以下说明和语句，int c[4][5],(*p)[5];p=c;能正确引用c数组元素的是<u> D</u>.<br>(A) p+1      (B) *(p+3)     　(C) *(p+1)+3   (D) *(p[0]+2) </p>
<p>解：b错误原因是p+3仅代表地址，加个*只能表示p[3].</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>c</tag>
        <tag>指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>day14-c函数</title>
    <url>/2023/03/10/day14-c%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="day14-c函数"><a href="#day14-c函数" class="headerlink" title="day14-c函数"></a><font color="green">day14-c函数</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、函数定义"><a href="#1、函数定义" class="headerlink" title="1、函数定义"></a>1、函数定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; 函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    功能代码;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> 表达式;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数名：也代表函数的首地址</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="2、函数调用"><a href="#2、函数调用" class="headerlink" title="2、函数调用"></a>2、函数调用</h3><p>​    函数名(实际参数);</p>
<p>​    实际参数必须和形参的个数、类型、顺序一致</p>
<h3 id="3、函数声明"><a href="#3、函数声明" class="headerlink" title="3、函数声明"></a>3、函数声明</h3><p>​    &lt;数据类型&gt; 函数名(形式参数);</p>
<h3 id="4、函数的传参"><a href="#4、函数的传参" class="headerlink" title="4、函数的传参"></a>4、函数的传参</h3><p>​    (1)赋值传递</p>
<p>​    (2)地址传递：将数据的地址赋值给形参进行初始化</p>
<p>​    (3)全局变量传参</p>
<h3 id="5、数组传参"><a href="#5、数组传参" class="headerlink" title="5、数组传参"></a>5、数组传参</h3><p>​    (1)整型数组：要传入数组的首地址，还要传入数组的元素个数</p>
<p>​    (2)字符数组：只需要传入数组首地址</p>
<p>练习：定义一个函数，计算二维整型数组的所有元素的和</p>
<h2 id="二、函数和指针"><a href="#二、函数和指针" class="headerlink" title="二、函数和指针"></a>二、函数和指针</h2><h3 id="1、指针函数"><a href="#1、指针函数" class="headerlink" title="1、指针函数"></a>1、指针函数</h3><p>​        如果一个函数的返回值是一个地址值，那么该函数就称为指针函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; *函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    功能代码;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> 地址值; <span class="comment">//合法安全的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2、函数指针"><a href="#2、函数指针" class="headerlink" title="2、函数指针"></a>2、函数指针</h3><p>​    本质：指针，指向一个函数的首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义：</span><br><span class="line">    &lt;数据类型&gt; (*函数指针名)(形式参数);</span><br><span class="line">	数据类型：跟指向的函数的返回值一致</span><br><span class="line">    形式参数：跟指向函数的形参一致</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span> x, <span class="keyword">int</span> y); <span class="comment">//定义了一个函数指针，指向的函数--&gt;返回值为int，参数是两个int类型数据</span></span><br><span class="line">p = add; <span class="comment">//将函数add的首地址赋值给函数指针变量p</span></span><br><span class="line"></span><br><span class="line">调用函数方法：</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//通过函数名+实参 调用函数</span></span><br><span class="line">	(*p)(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//通过访问函数指针内容+实参 调用函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>















<p>​            </p>
<p>​                </p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c语言</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>day15-c函数，结构体</title>
    <url>/2023/03/12/day15-c%E5%87%BD%E6%95%B0%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="day15-c函数，结构体"><a href="#day15-c函数，结构体" class="headerlink" title=" day15-c函数，结构体"></a><font color="green"> day15-c函数，结构体</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><hr>
<h3 id="1、指针函数："><a href="#1、指针函数：" class="headerlink" title="1、指针函数："></a>1、指针函数：</h3><p>​    本质：是一个函数，指针函数的返回值是一个地址</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt;* 函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    代码模块;</span><br><span class="line">    <span class="keyword">return</span> 地址量; <span class="comment">//合法地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、函数指针："><a href="#2、函数指针：" class="headerlink" title="2、函数指针："></a>2、函数指针：</h3><p>​    本质：是一个指针，指向一个函数的首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义的一般形式：</span><br><span class="line">    &lt;数据类型&gt; (*函数指针变量名)(参数列表);</span><br><span class="line"></span><br><span class="line">	例：</span><br><span class="line">        <span class="keyword">int</span> (*p)(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">	数据类型：跟指针指向的函数的数据类型一致</span><br><span class="line">	参数列表：跟指针指向的函数的参数列表一致</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">p = add;  <span class="comment">//将函数add的首地址赋值给函数指针变量p</span></span><br><span class="line">(*p)(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//调用add函数传入实参为2和3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><h3 id="1、函数指针数组"><a href="#1、函数指针数组" class="headerlink" title="1、函数指针数组"></a>1、函数指针数组</h3><p>​    本质：是一个数组, 存放的全部都是函数指针类型的数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义的一般形式：</span><br><span class="line">    &lt;数据类型&gt; (*函数指针数组名[元素个数])(参数列表);</span><br><span class="line">	例：</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">		<span class="keyword">int</span> (*arr[<span class="number">2</span>])(<span class="keyword">int</span> x, <span class="keyword">int</span> y) = &#123;add, sub&#125;;</span><br><span class="line">        <span class="comment">//定义了一个名为arr的函数指针数组，数组中最多可以存放两个 int(* )(int, int)类型的数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、递归函数"><a href="#2、递归函数" class="headerlink" title="2、递归函数"></a>2、递归函数</h3><p>​    练习：计算一个正整数的阶乘，用函数封装功能</p>
<p>​    概念：在一个函数中直接或者间接调用函数本身</p>
<p>​    </p>
<p>​    递归函数的特点：</p>
<p>​            1：递推公式</p>
<p>​            2：设置有退出条件</p>
<p>​    优点：能够让代码整体更加简洁</p>
<p>​    缺点：需要消耗大量系统资源</p>
<p>​                必须要设置退出条件</p>
<h2 id="三、结构体"><a href="#三、结构体" class="headerlink" title="三、结构体"></a>三、结构体</h2><p>​    跟数组一样，是用户自定义的一种数据类型</p>
<p>​    结构体中可以存放多个不同数据类型的数据</p>
<h3 id="1、结构体的定义"><a href="#1、结构体的定义" class="headerlink" title="1、结构体的定义"></a>1、结构体的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> 结构体名</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">       数据类型 成员名<span class="number">1</span>;</span><br><span class="line">       数据类型 成员名<span class="number">2</span>;        	</span><br><span class="line">       数据类型 成员名<span class="number">3</span>; </span><br><span class="line">        ......</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	例：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">char</span> name[<span class="number">50</span>]; </span><br><span class="line">            <span class="keyword">int</span>	age;</span><br><span class="line">            <span class="keyword">char</span> sex;</span><br><span class="line">            <span class="keyword">double</span> height;</span><br><span class="line">            <span class="keyword">char</span> address[<span class="number">50</span>];</span><br><span class="line">            <span class="keyword">char</span> hobby[<span class="number">50</span>];</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2、结构体变量"><a href="#2、结构体变量" class="headerlink" title="2、结构体变量"></a>2、结构体变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> 结构体名 结构体变量名;</span></span><br><span class="line">	例：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu2</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、访问结构体成员"><a href="#3、访问结构体成员" class="headerlink" title="3、访问结构体成员"></a>3、访问结构体成员</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    结构体变量名.成员名;  </span><br><span class="line">	stu1.age = <span class="number">18</span>;  <span class="comment">//访问1号学生stu1中的年龄，赋值为18；	</span></span><br></pre></td></tr></table></figure>

<h3 id="4、结构体变量的初始化"><a href="#4、结构体变量的初始化" class="headerlink" title="4、结构体变量的初始化"></a>4、结构体变量的初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 结构体变量名 = &#123;</span>依次给每一个成员赋值&#125;;  <span class="comment">//成员之间用逗号隔开</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu2</span> = &#123;</span><span class="string">&quot;张三&quot;</span>, <span class="number">19</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">182.1</span>, <span class="string">&quot;成都&quot;</span>, <span class="string">&quot;sing and dance&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5、结构体指针"><a href="#5、结构体指针" class="headerlink" title="5、结构体指针"></a>5、结构体指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">p</span> = &amp;<span class="title">stu1</span>;</span></span><br><span class="line">(*p).name       <span class="comment">//stu1中的name成员</span></span><br><span class="line">p-&gt;name == (*p).name</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c语言</tag>
        <tag>函数</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>day16-Linux基础</title>
    <url>/2023/03/13/day16-Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="day16-linux基础"><a href="#day16-linux基础" class="headerlink" title="day16-linux基础"></a><font color="green">day16-linux基础</font></h1><hr>
<h2 id="一、嵌入式："><a href="#一、嵌入式：" class="headerlink" title="一、嵌入式："></a>一、嵌入式：</h2><p>以应用为中心，以计算机为基础，软硬件可裁剪，适用于对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统</p>
<a id="more"></a>
<h3 id="1-linux系统："><a href="#1-linux系统：" class="headerlink" title="1.linux系统："></a>1.linux系统：</h3><p>特点：开源、安全性、可移植性</p>
<h3 id="2-linux体系结构："><a href="#2-linux体系结构：" class="headerlink" title="2.linux体系结构："></a>2.linux体系结构：</h3><p>文件结构：最大的为根目录（/），</p>
<blockquote>
<p>home：家目录，给用户工作的目录<br>（~）：权限没有开通完，需要权限需要加sudo<br>dev：设备文件<br>etc：配置文件</p>
</blockquote>
<h3 id="3-vi的配置："><a href="#3-vi的配置：" class="headerlink" title="3.vi的配置："></a>3.vi的配置：</h3><p>vi .vimrc（~下）配置vi的初始化</p>
<blockquote>
<p>boot：启动文件<br>root：权限文件<br>lib：库文件<br>mnt：挂载文件</p>
</blockquote>
<hr>
<br>
<br>

<h2 id="二、shell命令"><a href="#二、shell命令" class="headerlink" title="二、shell命令"></a>二、shell命令</h2><h3 id="1-文件的查看"><a href="#1-文件的查看" class="headerlink" title="1.文件的查看"></a>1.文件的查看</h3><blockquote>
<p>我是谁—whoami<br>我在哪儿—pwd<br>我有什么—-ls</p>
<blockquote>
<p>ls -a—显示所有文件，包括隐藏文件<br>ls -l—显示文件信息</p>
</blockquote>
</blockquote>
<br>

<blockquote>
<p><font color="blue">蓝色</font>：目录文件<br>白色：普通文件<br><font color="green">绿色</font>：可执行文件<br><font color="red">红色</font>：压缩文件<br><font color="#00FFFF">浅蓝</font>：链接文件</p>
</blockquote>
<p>文件的类型：</p>
<p>lsp-bcd</p>
<br>

<h3 id="2-文件的权限："><a href="#2-文件的权限：" class="headerlink" title="2.文件的权限："></a>2.文件的权限：</h3><p>rwxrwxrwx</p>
<p>前三个：用户自己的权限，中间三个，用户组的权限，最后三个，其他用户的权限</p>
<p>ls -R–以遍历的方式查看文件</p>
<br>

<h3 id="3-目录的移动"><a href="#3-目录的移动" class="headerlink" title="3.目录的移动"></a>3.目录的移动</h3><p>我要去哪儿—-cd</p>
<p>cd +路径  (如果直接加文件名，默认从当前路径下去进入)</p>
<p>./—当前路径</p>
<p>../—上一级路径</p>
<p>直接cd，回到家目录（~）<br><br></p>
<h3 id="4-文件的修改"><a href="#4-文件的修改" class="headerlink" title="4.文件的修改"></a>4.文件的修改</h3><blockquote>
<p>mkdir-rmdir：创建-删除目录（里面有文件时不行）<br>rm -r ：（删除目录下所有的文件）<br>touch：创建但不打开文件<br>vi、vim ：打开vim编辑器<br>cat：查看文件内容<br>head：默认查看前十行的内容<br>head -n 文件名：查看文件前n行的内容<br>tail：默认查看后十行的内容<br>tail -n 文件名：查看文件后n行的内容<br>mv：可以充当重命名文件名的作用<br>cp 1.c 2.c：如果没有后面的复制文件，会先创建文件再复制<br>man：查看帮助</p>
</blockquote>
<br>

<hr>
<h2 id="三、编辑器："><a href="#三、编辑器：" class="headerlink" title="三、编辑器："></a>三、编辑器：</h2><p>vi/vim编辑器</p>
<p>vi +文件名—打开这个文件，如果没有这个文件，先去创建再打开</p>
<p>1.命令行模式：yy，nyy，p，dd，ndd，u</p>
<p>2.插入模式：</p>
<blockquote>
<p>i：从光标当前位置开始插入<br>a：追加，从光标下一位开始插入<br>o：从光标下一行开始插入<br>esc：退出插入模式，回到的是命令行模式</p>
</blockquote>
<p>3.底行模式：</p>
<blockquote>
<p>wq，！q，x<br>s/字符串1/字符串2 ：只替换从光标当前所在行的第一个字符串1<br>%s/字符串1/字符串2:替换文件每一行的第一个字符串1<br>%s/字符串1/字符串2/g:替换文件所有的字符串1<br>vsp+文件名：在当前的vi编辑器打开另一个文件<br>ctrl+w—-切换光标的位置<br>退出vsp：wq<br>set mouse = a—让光标跟着鼠标移动<br>set mouse -= a—让光标不跟着鼠标移动<br>gedit编辑器：没有配置，操作起来相对简单一点，类似于word文档</p>
</blockquote>
<br>

<hr>
<h2 id="四、gcc编译器："><a href="#四、gcc编译器：" class="headerlink" title="四、gcc编译器："></a>四、gcc编译器：</h2><blockquote>
<p>四个步骤：<br>1、预处理—处理要用到的头文件和宏定义<br>gcc -E 1.c -o 1.i<br>2、编译—检查代码的错误<br>gcc -S 1.i -o 1.s<br>3、汇编—将文件变成计算机能够识别的二进制文件<br>gcc -c 1.s -o 1.o<br>4、链接—生成执行文件<br>gcc 1.o -o 1</p>
</blockquote>
<p>选项：</p>
<blockquote>
<p>-o：修改执行文件名<br>-Wall：显示所有警告<br>-w：隐藏所有警告</p>
</blockquote>
<br>

<hr>
<h2 id="五、快捷键："><a href="#五、快捷键：" class="headerlink" title="五、快捷键："></a>五、快捷键：</h2><blockquote>
<p>ctrl+l：清屏，翻页，鼠标往上滑还是能看到（clear–但是看不到之前的）<br>ctrl+shift+t：并列打开一个终端（ctrl+shift+n）<br>ctrl+c：结束当前进程回到终端<br>ctrl+z：暂停当前进程回到终端<br>ctrl+空格：切换中英文（可以修改）<br>上下键：翻找历史指令<br>alt+tab：切换终端</p>
</blockquote>
<br>

<hr>
<h2 id="六、文件管理"><a href="#六、文件管理" class="headerlink" title="六、文件管理"></a>六、文件管理</h2><h3 id="1-文件的类型："><a href="#1-文件的类型：" class="headerlink" title="1.文件的类型："></a>1.文件的类型：</h3><p>lsp-bcd</p>
<br>

<h3 id="2-文件的权限：-1"><a href="#2-文件的权限：-1" class="headerlink" title="2.文件的权限："></a>2.文件的权限：</h3><p>rwxrwxrwx</p>
<p>前三个：用户自己的权限，中间三个，用户组的权限，最后三个，其他用户的权限</p>
<br>

<h3 id="3-chmod–修改文件权限"><a href="#3-chmod–修改文件权限" class="headerlink" title="3.chmod–修改文件权限"></a>3.chmod–修改文件权限</h3><p>第一种方式：chmod u+x 文件名—-给当前用户增加执行权限</p>
<p>如果不加u，默认给所有用户加权限</p>
<blockquote>
<p>u–用户自己<br>g—用户组<br>o—其他用户</p>
</blockquote>
<p>第二种方式：chmod 0777 文件名</p>
<br>

<h3 id="4-链接文件–ln"><a href="#4-链接文件–ln" class="headerlink" title="4.链接文件–ln"></a>4.链接文件–ln</h3><p>（1）硬链接：</p>
<p>ln 文件名 硬链接文件名</p>
<p>硬链接如果把本体文件删掉，依旧可以单独使用，类型和原文件一模一样，移动原文件也依旧可以执行</p>
<p>（2）软链接：</p>
<p>ln -s 文件名 软链接文件名 </p>
<p>大大缩小了文件的大小，如果把本体文件删除或者移动，软链接失效</p>
<br>

<h3 id="5-文件的压缩与解压"><a href="#5-文件的压缩与解压" class="headerlink" title="5.文件的压缩与解压"></a>5.文件的压缩与解压</h3><blockquote>
<p>gzip—压缩文件，原文件被替换成压缩之后的文件，，会生成一个.gz的压缩文件，用vi能看到源文件内容，用cat在终端查看乱码<br>gunzip—解压文件<br>bzip2—压缩文件，原文件被替换成压缩之后的文件，，会生成一个.bz2的压缩文件，压缩功能相对于gzip较弱，但是压缩时间缩短<br>bunzip–解压文件<br>xz—压缩文件，原文件被替换成压缩之后的文件，，会生成一个.xz的压缩文件，压缩功能相对于gzip较弱，但是压缩时间缩短<br>unxz–解压文件</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day17-Linux基础</title>
    <url>/2023/03/14/day17-Linux%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="day17-linux基础"><a href="#day17-linux基础" class="headerlink" title="day17-linux基础"></a><font color="green">day17-linux基础</font></h1><hr>
<h2 id="一、复习补充："><a href="#一、复习补充：" class="headerlink" title="一、复习补充："></a>一、复习补充：</h2><p>缩进：</p>
<p>命令行模式：gg=G</p>
<p>可视化模式：v，上下键选中要对齐的代码，按=</p>
<p>底行模式：set nonumber  不显示行号，set number 显示行号</p>
<a id="more"></a>

<br>
<br>

<hr>
<h2 id="二、tar-归档和释放"><a href="#二、tar-归档和释放" class="headerlink" title="二、tar-归档和释放"></a>二、tar-归档和释放</h2><blockquote>
<p>tar<br>-c   创建归档文件<br>-v   显示归档或释放过程<br>-x   释放归档文件<br>-f   用户指定归档文件的文件名，否则使用默认名称<br>-j   以bzip2方式压缩<br>-z   以gzip方式压缩<br>    tar -czvf  要压缩或归档之后的文件名 目标文件名<br>    tar -xvf   目标文件名</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="三、diff"><a href="#三、diff" class="headerlink" title="三、diff"></a>三、diff</h2><p>比较文件的不同</p>
<br>
<br>

<hr>
<h2 id="四、grep–查询"><a href="#四、grep–查询" class="headerlink" title="四、grep–查询"></a>四、grep–查询</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">grep  查询的字符串 查询文件名---查询特定文件的内容</span><br><span class="line">grep  -r 查询的字符串 路径----查询一个路径下所有文件的内容</span><br></pre></td></tr></table></figure>

<p> wc</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wc 文件名： 行数 单词个数 单个字符个数 文件名</span><br><span class="line"> -l：只查看行数</span><br><span class="line"> -w：只查看单词个数（看空格)</span><br><span class="line"> -c：只查看单个字符个数</span><br></pre></td></tr></table></figure>


<br>
<br>

<hr>
<h2 id="五、工具："><a href="#五、工具：" class="headerlink" title="五、工具："></a>五、工具：</h2><p>vi编辑器</p>
<p>gedit编辑器</p>
<p>gcc编译器</p>
<h2 id="1-下载工具："><a href="#1-下载工具：" class="headerlink" title="1.下载工具："></a>1.下载工具：</h2><blockquote>
<p>deb（常用的） —-Debian<br>rpm（小红帽）—-Redhat</p>
</blockquote>
<br>

<h3 id="（1）dpkg工具—-离线下载，没有依赖文件"><a href="#（1）dpkg工具—-离线下载，没有依赖文件" class="headerlink" title="（1）dpkg工具—-离线下载，没有依赖文件"></a>（1）dpkg工具—-离线下载，没有依赖文件</h3><p>sudo—-暂时赋予用户权限，密码初始都为1，但是不显示密码的输入，确保输出按回车就可以了</p>
<p>dpkg都要加sudo</p>
<blockquote>
<p>sudo dpkg -i 安装包—下载<br>sudo dpkg -r 软件名—卸载</p>
</blockquote>
<br>


<h3 id="（2）apt工具—在线下载"><a href="#（2）apt工具—在线下载" class="headerlink" title="（2）apt工具—在线下载"></a>（2）apt工具—在线下载</h3><p>下载：</p>
<blockquote>
<p>sudo apt-get install sl–跑火车<br>sudo apt-get install frozen-bubble–泡泡龙<br>sudo apt-get install cmatrix–代码雨<br>sudo  apt-get install fortune—-名人名言<br>sudo  apt-get install fortunes-zh—-名人名言（中文）<br>sudo  apt-get install lolcat—-有颜色显示<br>fortune | lolcat<br>卸载：sudo apt-get remove 软件名</p>
</blockquote>
<br>

<h3 id="（3）创建共享文件夹："><a href="#（3）创建共享文件夹：" class="headerlink" title="（3）创建共享文件夹："></a>（3）创建共享文件夹：</h3><ol>
<li>选择虚拟机左上菜单的虚拟机选项，点击设置</li>
<li>点击选项，找到共享文件夹，选择总是启用</li>
<li>点击添加，跟着下一步，选择主机（windows）的一个文件作为自己的共享文件夹</li>
<li>点击完成，点击确定，最后在<code>/mnt/hgfs</code>查看有没有</li>
</ol>
<h3 id="（4）网络配置："><a href="#（4）网络配置：" class="headerlink" title="（4）网络配置："></a>（4）网络配置：</h3><p>ping–能不能网络通信</p>
<p>ping +IP地址</p>
<ol>
<li>点击虚拟机菜单的编辑，选择虚拟网络编辑</li>
<li>点击更改设置（如果没有，直接选择桥接模式），选择桥接模式</li>
<li>在桥接模式下选择自己windos网络的描述名字，点击确定</li>
<li>点击虚拟机，选择设置，找到网络适配器，选择自定义模式，选择自己的网络名称(一般为VMnet0)，点击确定</li>
<li>进入linux系统，断开重连网络（重启网络）</li>
</ol>
<p>或者：在终端上输入：</p>
<p>sudo service network-manager restart</p>
<blockquote>
<p>ifconfig—查看linux系统的IP地址<br>ipconfig—查看windows系统的IP地址</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2.用户管理"></a>2.用户管理</h2><p>(1) 超级用户：</p>
<blockquote>
<p>su，开通了所有权限，我们一般不在这里工作，因为一旦删除，找不回来，也容易操作到内核上的东西<br>exit：退出超级用户</p>
</blockquote>
<p>(2)查看</p>
<blockquote>
<p>查看用户—vi /etc/passwd<br>查看用户组–vi /etc/group</p>
</blockquote>
<p>(3)添加用户：</p>
<blockquote>
<p>adduser 新添用户名<br>输入密码，不显示，确保输入按回车<br>su 用户名—-进入该用户</p>
</blockquote>
<p>(4)删除用户<br>deluser 用户名，但是我们一般进入passwd和group这两个文件去删除 <strong>（加sudo）</strong></p>
<p>(5)修改密码：passwd</p>
<br>
<br>

<hr>
<h2 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3.进程管理"></a>3.进程管理</h2><blockquote>
<p>ps   查看前台的进程<br>ps -aux  查看所有进程<br>pstree—以树的形式展示进程<br>top—查看进程（从占用cpu最大开始展示），类似于任务管理器<br>kill -9 进程号   —-杀死进程</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="4-shell的特殊字符"><a href="#4-shell的特殊字符" class="headerlink" title="4.shell的特殊字符"></a>4.shell的特殊字符</h2><p>（1）|—管道</p>
<p>指令1 | 指令2—-把指令1的输出作为指令2的输入</p>
<p>fortune | lolcat</p>
<p>（2）` &emsp; `—命令置换<br>指令1 ` &emsp; `    把命令置换里面的内容作为指令1的参数<br>    echo `ls`</p>
<p>（3）echo–终端的输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo hello    world---会自动缩进空格字符串之间保留一个空格</span><br><span class="line">echo &#x27;hello    world&#x27;---原样输出</span><br><span class="line">echo <span class="string">&quot;hello    world&quot;</span>---原样输出</span><br></pre></td></tr></table></figure>
<p>（4）输入输出重定向</p>
<blockquote>
<p>&gt;:<br>cat &gt;1.c（覆盖输入）<br> &gt;&gt;:<br>cat &gt;&gt;1.c（追加输入）</p>
</blockquote>
<p>注：输入都是读取的键盘输入</p>
<p>（5）通配符：</p>
<ul>
<li>*—匹配所有字符串</li>
<li>{起始..结束}–可以创建起始到结束的文件</li>
<li>touch {1..10}.c—-创建1到10的.c文件</li>
<li>rm 【13579】.c—-删除了1.c 3.c 5.c 7.c 9.c</li>
<li>rm [1-5].c—-删除了1.c2.c3.c4.c5.c</li>
<li>rm [^8].c—-删除除了8.c的文件,也只能通配一个</li>
<li>？—匹配一个字符串<br>rm h？llo.c—删除hello.c hrllo.c</li>
</ul>
<p>（6）其他</p>
<p>shutdown—关机</p>
<p>shutdown -r now—重启</p>
<p>vm上的快照–相当于备份</p>
<br>
<br>

<hr>
<h2 id="5-shell脚本："><a href="#5-shell脚本：" class="headerlink" title="5.shell脚本："></a>5.shell脚本：</h2><p>（1）本质：shell命令的有序集合</p>
<p>解释型语言（python，shell脚本）</p>
<p>不会检查错误，但是会显示出错误，出现错误会继续执行后面的语句</p>
<p>需要一个解释器（shell的是bash）</p>
<p>编译型语言（c语言，c++）</p>
<p>编译会报错，一旦错误会停止进程</p>
<p>（2）怎么去写一个shell脚本：</p>
<ol>
<li><p>创建一个.sh的文件（也可以没有后缀名）</p>
</li>
<li><p>写shell命令</p>
</li>
<li><p>执行:</p>
</li>
</ol>
<p>&emsp;&emsp;&emsp;&emsp;a. 通过bash这个解释器来执行，直接bash+要执行的文件</p>
<p>&emsp;&emsp;&emsp;&emsp;b. 通过chmod给shell文件添加执行权限，然后再执行</p>
<p><strong>注：第一行一般写：<code>#!/bin/bash</code>，我们解释器的路径</strong></p>
<p>练习：复制上一级目录的1.c 2.c到当前目录下，然后把hello world写入1.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> cd ../</span><br><span class="line">  <span class="number">4</span> touch <span class="number">1.</span>c <span class="number">2.</span>c</span><br><span class="line">  <span class="number">5</span> cp [<span class="number">12</span>].c day2</span><br><span class="line">  <span class="number">6</span> echo <span class="string">&quot;hello world&quot;</span> &gt;day2/<span class="number">1.</span>c</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）shell变量</p>
<ul>
<li>自定义变量</li>
</ul>
<p>没有数据类型，默认为字符串类型</p>
<p>赋值不能隔开</p>
<p>变量名=值</p>
<p>没有分号，换行就相当于分号</p>
<p>变量的调用需要加钱$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>位置变量</li>
</ul>
<p>命令行参数的变量，即命令即后面的参数作为变量 从bash后面的那个开始为0</p>
<p>从终端传递参数给shell脚本</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">从$<span class="number">0</span>开始到$<span class="number">9</span>如果要打印<span class="number">9</span>以后的变量需要加&#123;&#125;，例如$&#123;<span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>环境变量</li>
</ul>
<p>计算机定义好了的变量</p>
<p>env可以查看所有环境变量</p>
<p>调用需要加$</p>
<p><strong>注：shell中0是真，1是假</strong></p>
<h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>计算机给一些特殊变量赋予特殊意义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$*--打印的是命令行参数的所有变量，不包括$<span class="number">0</span></span><br><span class="line">$@--打印的是命令行参数的所有变量，不包括$<span class="number">0</span></span><br><span class="line">$#--打印的是命令行参数的个数，不包括$<span class="number">0</span></span><br><span class="line">$?--打印上一次的返回状态（<span class="number">0</span>代表真，<span class="number">1</span>代表假）</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day18-Linux基础,shell脚本</title>
    <url>/2023/03/15/day18-Linux%E5%9F%BA%E7%A1%80,shell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="day18-linux基础-shell脚本"><a href="#day18-linux基础-shell脚本" class="headerlink" title="day18-linux基础,shell脚本"></a><font color="green">day18-linux基础,shell脚本</font></h1><br>
<br>


<hr>
<h2 id="一、变量的四则运算："><a href="#一、变量的四则运算：" class="headerlink" title="一、变量的四则运算："></a>一、变量的四则运算：</h2><a id="more"></a>
<ol>
<li>（（ &emsp; ））</li>
</ol>
<p>不能进行浮点型的运算</p>
<p>调用的时候需要加钱$</p>
<p>可以进型幂数运算</p>
<p>可以进行自加自减</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> a=$(( <span class="number">3</span>**<span class="number">3</span>)) <span class="comment">//3的3次方</span></span><br><span class="line"> <span class="number">4</span> echo $a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>【&emsp;】</li>
</ol>
<p>不能进行浮点型的运算</p>
<p>调用的时候需要加钱$</p>
<p>可以进型幂数运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> a=$[ <span class="number">3</span>+<span class="number">3</span>]</span><br><span class="line"><span class="number">4</span> echo $a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>expr</li>
</ol>
<p>需要命令置换符置换出来结果` &emsp; `</p>
<p>算数之间需要空开</p>
<p>当进行乘法的时候需要用\区分</p>
<p>没有幂数运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=`expr <span class="number">1</span> \* <span class="number">2</span>`</span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>练习：运算出a=3的3次方的值，b=5*7的值，交换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=$((<span class="number">3</span>**<span class="number">3</span>))</span><br><span class="line">  <span class="number">4</span> b=`expr <span class="number">5</span> \* $((<span class="number">4</span>+<span class="number">2</span>))`</span><br><span class="line">  <span class="number">5</span> c=$a</span><br><span class="line">  <span class="number">6</span> a=$b</span><br><span class="line">  <span class="number">7</span> b=$c</span><br><span class="line">  <span class="number">8</span> echo a=$&#123;a&#125;b=$b</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="二、shell-语句"><a href="#二、shell-语句" class="headerlink" title="二、shell 语句"></a>二、shell 语句</h2><h3 id="1-解释性语句"><a href="#1-解释性语句" class="headerlink" title="1. 解释性语句"></a>1. 解释性语句</h3><ul>
<li>#注释一行</li>
<li>:&lt;&lt;!注释多行<br>注释的shell语句<br>！</li>
<li>：&lt;&lt;EOF<br>注释的shell语句<br>EOF</li>
</ul>
<h3 id="2-功能性语句"><a href="#2-功能性语句" class="headerlink" title="2.功能性语句"></a>2.功能性语句</h3><h4 id="（1）test"><a href="#（1）test" class="headerlink" title="（1）test"></a>（1）test</h4><p>结构：字符串 整型 文件</p>
<ul>
<li>字符串的比较：</li>
</ul>
<blockquote>
<p>test 字符串1 = 字符串2    —-比较两个字符串是否相等<br>test 字符串1 ！= 字符串2    —-比较两个字符串是否不相等<br>test -z 字符串—判断字符串为不为空<br>test -n 字符串—判断字符串是否不为空</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=<span class="string">&quot;hello&quot;</span></span><br><span class="line">  <span class="number">4</span> b=<span class="string">&quot;hello&quot;</span></span><br><span class="line">  <span class="number">5</span> test $a != $b</span><br><span class="line">  <span class="number">6</span> test -z $a</span><br><span class="line">  <span class="number">7</span> test -n $a</span><br><span class="line">  <span class="number">8</span> echo $?</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>整型的比较</li>
</ul>
<blockquote>
<p>-eq—等于<br>-ne—不等于<br>-gt—大于<br>-lt–小于<br>-ge—大于等于<br>-le—小于等于</p>
</blockquote>
<ul>
<li>文件的比较</li>
</ul>
<blockquote>
<p>-e —判断文件是否存在<br>-f—判断文件是否是普通文件<br>-L—判断文件是否是链接文件<br>-S—判断文件是否是套接字文件<br>-b—判断文件是否是块文件<br>-c—判断文件是否是字符文件<br>-d—判断文件是否是目录文件<br>-p—判断文件是否为管道文件</p>
</blockquote>
<ul>
<li>文件的权限：</li>
</ul>
<blockquote>
<p>-r–判断文件是否有可读权限<br>-w—判断文件是否有可写权限<br>-x—判断文件是否有可执行权限<br>文件1  -nt  文件2–判断文件1是否比文件2新（时间戳）<br>文件1  -ot  文件2–判断文件1是否比文件2旧（时间戳）</p>
</blockquote>
<ul>
<li>逻辑<blockquote>
<p>-o—或<br>-a—与</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> test -d $<span class="number">1</span> -a -f $<span class="number">2</span></span><br><span class="line">  <span class="number">4</span> echo $?</span><br><span class="line">~           </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<h4 id="（2）read"><a href="#（2）read" class="headerlink" title="（2）read"></a>（2）read</h4><p>把终端上的输入传给参数</p>
<p>read 变量1 变量2 </p>
<p>read -p “提示” 变量名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> read -p <span class="string">&quot;please input tow numbern:&quot;</span> a b</span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line">  <span class="number">5</span> echo $b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>read -t  时间 变量名—限制时间输入</p>
<p>超过时间会自动结束（以秒为单位）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> read -t <span class="number">5</span> a b</span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line">  <span class="number">5</span> echo $b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>read -n –限制输入的个数,超过个数也会自动结束</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> read -n <span class="number">1</span> a b</span><br><span class="line">  <span class="number">4</span> echo $a</span><br><span class="line">  <span class="number">5</span> echo $b</span><br><span class="line">~           </span><br></pre></td></tr></table></figure>

<p>read -s —隐藏输入</p>
<br>

<h3 id="3-shell的控制语句"><a href="#3-shell的控制语句" class="headerlink" title="3. shell的控制语句"></a>3. shell的控制语句</h3><h4 id="（1）if"><a href="#（1）if" class="headerlink" title="（1）if"></a>（1）if</h4><p>第一种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>[]</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">​    shell语句；</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><strong><font color="red">注意：if和【】之间要隔一个空，表达式和【】也要隔一个空</font></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=<span class="number">56</span></span><br><span class="line">  <span class="number">4</span> b=<span class="number">34</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">if</span> [ $a -gt $b ]</span><br><span class="line">  <span class="number">6</span> then</span><br><span class="line">  <span class="number">7</span>     echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line">  <span class="number">8</span> fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> test语句</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">​    shell语句；</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> a=<span class="number">56</span></span><br><span class="line"><span class="number">4</span> b=<span class="number">34</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">if</span> test $a -gt $b</span><br><span class="line"><span class="number">6</span> then</span><br><span class="line"><span class="number">7</span>     echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="number">8</span> fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>if - elif-else</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> read a b</span><br><span class="line">  <span class="number">4</span> <span class="keyword">if</span> test $a -gt $b</span><br><span class="line">  <span class="number">5</span> then</span><br><span class="line">  <span class="number">6</span>     echo <span class="string">&quot;hello world&quot;</span></span><br><span class="line">  <span class="number">7</span> elif test $a -eq $b</span><br><span class="line">  <span class="number">8</span> then</span><br><span class="line">  <span class="number">9</span>     echo <span class="string">&quot;zhangcheng&quot;</span></span><br><span class="line"> <span class="number">10</span> <span class="keyword">else</span></span><br><span class="line"> <span class="number">11</span>     echo <span class="string">&quot;day3&quot;</span></span><br><span class="line"> <span class="number">12</span> fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>练习：输入一个文件名。判断这个文件是否存在，如果不存在，就创建，判断是否有可写权限，如果有，就把helloworld 写进去，如果没有，赋予可写权限，再写进去，如果存在就写入helloworld</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> read -p <span class="string">&quot;please input a filename:&quot;</span> file</span><br><span class="line"> <span class="number">4</span> <span class="keyword">if</span> test -e $file</span><br><span class="line"> <span class="number">5</span> then</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">if</span> test -w $file</span><br><span class="line"> <span class="number">7</span>     then</span><br><span class="line"> <span class="number">8</span>        echo <span class="string">&quot;hello world&quot;</span>&gt;&gt;$file <span class="comment">//注意别忘了echo</span></span><br><span class="line"> <span class="number">9</span>    <span class="keyword">else</span></span><br><span class="line"><span class="number">10</span>        chmod +w $file</span><br><span class="line"><span class="number">11</span>        echo <span class="string">&quot;hello world&quot;</span>&gt;&gt;$file</span><br><span class="line"><span class="number">12</span>     fi</span><br><span class="line"><span class="number">13</span> <span class="keyword">else</span></span><br><span class="line"><span class="number">14</span>     touch $file</span><br><span class="line"><span class="number">15</span>     echo <span class="string">&quot;hello world&quot;</span>&gt;&gt;$file</span><br><span class="line"><span class="number">16</span> fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 表达式 in</span><br><span class="line"></span><br><span class="line">​           表达式）</span><br><span class="line"></span><br><span class="line">​              shell语句</span><br><span class="line"></span><br><span class="line">​               ；；</span><br><span class="line"></span><br><span class="line">表达式）</span><br><span class="line"></span><br><span class="line">​      shell语句</span><br><span class="line"></span><br><span class="line">​      ；；</span><br><span class="line"></span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">3</span> read a</span><br><span class="line"> <span class="number">4</span> <span class="keyword">case</span>  $a in</span><br><span class="line"> <span class="number">5</span>     <span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>)</span><br><span class="line"> <span class="number">6</span>         echo <span class="string">&quot;星期一&quot;</span></span><br><span class="line"> <span class="number">7</span>         ;;</span><br><span class="line"> <span class="number">8</span>     <span class="number">2</span>)</span><br><span class="line"> <span class="number">9</span>         echo <span class="string">&quot;星期二&quot;</span></span><br><span class="line"><span class="number">10</span>         ;;</span><br><span class="line"><span class="number">11</span>     <span class="number">3</span>)</span><br><span class="line"><span class="number">12</span>         echo <span class="string">&quot;星期三&quot;</span></span><br><span class="line"><span class="number">13</span>         ;;</span><br><span class="line"><span class="number">14</span>     <span class="number">4</span>)</span><br><span class="line"><span class="number">15</span>         echo <span class="string">&quot;星期四&quot;</span></span><br><span class="line"><span class="number">16</span>         ;;</span><br><span class="line"><span class="number">17</span>     <span class="number">5</span>)</span><br><span class="line"><span class="number">18</span>         echo <span class="string">&quot;星期五&quot;</span></span><br><span class="line"><span class="number">19</span>         ;;</span><br><span class="line"><span class="number">20</span>     <span class="number">6</span>)</span><br><span class="line"><span class="number">21</span>         echo <span class="string">&quot;星期六&quot;</span></span><br><span class="line"><span class="number">22</span>         ;;</span><br><span class="line"><span class="number">23</span>     <span class="number">7</span>)</span><br><span class="line"><span class="number">24</span>         echo <span class="string">&quot;星期天&quot;</span></span><br><span class="line"><span class="number">25</span>         ;;</span><br><span class="line">       *)</span><br><span class="line"><span class="number">27</span>         echo <span class="string">&quot;asdads&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">26</span> esac</span><br></pre></td></tr></table></figure>

<p>用【】</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read a</span><br><span class="line">  <span class="number">4</span> <span class="keyword">case</span>  $a in</span><br><span class="line">  <span class="number">5</span>     [a-zA-Z])</span><br><span class="line">  <span class="number">6</span>         echo <span class="string">&quot;星期一&quot;</span></span><br><span class="line">  <span class="number">7</span>         ;;</span><br><span class="line">  <span class="number">8</span>     [zbc])</span><br><span class="line">  <span class="number">9</span>         echo <span class="string">&quot;星期二&quot;</span></span><br><span class="line"> <span class="number">10</span>         ;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>练习：模拟一个应用下载</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> read -p <span class="string">&quot;请选择要下载的应用:&quot;</span> app</span><br><span class="line"> <span class="number">4</span> read -p <span class="string">&quot;请确认是否下载y|n|q)&quot;</span> chioce</span><br><span class="line"> <span class="number">5</span> <span class="keyword">case</span> $chioce in</span><br><span class="line"> <span class="number">6</span>     Y|y|yes)</span><br><span class="line"> <span class="number">7</span>         echo <span class="string">&quot;$app正在下载中.....&quot;</span></span><br><span class="line"> <span class="number">8</span>         ;;</span><br><span class="line"> <span class="number">9</span>     N|n|no)</span><br><span class="line"><span class="number">10</span>         echo <span class="string">&quot;取消下载$app&quot;</span></span><br><span class="line"><span class="number">11</span>         ;;</span><br><span class="line"><span class="number">12</span>     *)</span><br><span class="line"><span class="number">13</span>         echo <span class="string">&quot;退出&quot;</span></span><br><span class="line"><span class="number">14</span> esac</span><br><span class="line"><span class="number">15</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="（2）循环语句"><a href="#（2）循环语句" class="headerlink" title="（2）循环语句"></a>（2）循环语句</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 表达式</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">shell语句</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> a=<span class="number">5</span></span><br><span class="line">  <span class="number">4</span> <span class="keyword">while</span> test $a -gt <span class="number">0</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">  <span class="number">6</span>     ((a--))</span><br><span class="line">  <span class="number">7</span>     echo $a</span><br><span class="line">  <span class="number">8</span> done</span><br></pre></td></tr></table></figure>

<p>死循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">shell语句</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>for循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>（（表达式<span class="number">1</span>；表达式<span class="number">2</span>；表达式<span class="number">3</span>））</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">shell语句</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> </span><br><span class="line">  <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++))</span><br><span class="line">  <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line">  <span class="number">7</span>     echo $i</span><br><span class="line">  <span class="number">8</span> done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二种</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 in 单词表</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">shell语句</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> </span><br><span class="line">  <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">for</span> i in he li oi asda adsa ada ad</span><br><span class="line">  <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line">  <span class="number">7</span>     echo $i</span><br><span class="line">  <span class="number">8</span> done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>连续的</p>
<p>for 变量 in {起始..结束}</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">for</span> i in &#123;a..z&#125;</span><br><span class="line"> <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">7</span>     echo $i</span><br><span class="line"> <span class="number">8</span> done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>for 变量 in ``</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">for</span> i in `ls`</span><br><span class="line"> <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">7</span>     echo $i</span><br><span class="line"> <span class="number">8</span> done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>练习：求1到100的和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> sum=<span class="number">0</span></span><br><span class="line"> <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;<span class="number">101</span>;i++))</span><br><span class="line"> <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">7</span>     sum=$(($sum+$i))</span><br><span class="line"> <span class="number">8</span> done</span><br><span class="line"> <span class="number">9</span> echo <span class="string">&quot;sum=$sum&quot;</span></span><br><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> sum=<span class="number">0</span></span><br><span class="line"> <span class="number">4</span> i=<span class="number">5</span></span><br><span class="line"> <span class="number">5</span> <span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;<span class="number">101</span>;i++))</span><br><span class="line"> <span class="number">6</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">7</span>     sum=`expr $sum + $i`</span><br><span class="line"> <span class="number">8</span> done</span><br><span class="line"> <span class="number">9</span> echo <span class="string">&quot;sum=$sum&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="三、shell数组"><a href="#三、shell数组" class="headerlink" title="三、shell数组"></a>三、shell数组</h2><p>shell脚本里面只有一维数组</p>
<p>没有数据类型</p>
<h3 id="1-数组的初始化"><a href="#1-数组的初始化" class="headerlink" title="1. 数组的初始化"></a>1. 数组的初始化</h3><p>数组名=（元素1 元素2 元素3.。。。）</p>
<h3 id="2-数组的赋值："><a href="#2-数组的赋值：" class="headerlink" title="2. 数组的赋值："></a>2. 数组的赋值：</h3><p>数组名【下标】=内容</p>
<h3 id="3-数组的调用："><a href="#3-数组的调用：" class="headerlink" title="3. 数组的调用："></a>3. 数组的调用：</h3><p>${数组名【下标】}</p>
<h3 id="4-数组的遍历："><a href="#4-数组的遍历：" class="headerlink" title="4. 数组的遍历："></a>4. 数组的遍历：</h3><p>循环遍历</p>
<p>${arr[*]}</p>
<p>${arr[@]}</p>
<h3 id="5-求数组的长度："><a href="#5-求数组的长度：" class="headerlink" title="5. 求数组的长度："></a>5. 求数组的长度：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$&#123;<span class="meta">#arr[*]&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> arr=(hello world nihao shijie)</span><br><span class="line"> <span class="number">4</span> arr[<span class="number">0</span>]=<span class="string">&quot;zhangcheng&quot;</span></span><br><span class="line"> <span class="number">5</span> echo $&#123;arr[<span class="number">0</span>]&#125;</span><br><span class="line"> <span class="number">6</span> echo $&#123;arr[@]&#125;</span><br><span class="line"> <span class="number">7</span> echo $&#123;#arr[*]&#125;</span><br><span class="line">                     </span><br></pre></td></tr></table></figure>

<p>练习：</p>
<p>数组的逆序打印（用交换）</p>
<p>shijie nihao world hello</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> arr=(hello world nihao shijie)</span><br><span class="line">  <span class="number">4</span> arr[<span class="number">0</span>]=<span class="string">&quot;zhangcheng&quot;</span></span><br><span class="line">  <span class="number">5</span> echo $&#123;arr[<span class="number">0</span>]&#125;</span><br><span class="line">  <span class="number">6</span> echo $&#123;arr[@]&#125;</span><br><span class="line">  <span class="number">7</span> len=$&#123;#arr[*]&#125;</span><br><span class="line">  <span class="number">8</span> <span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;$len/<span class="number">2</span>;i++))</span><br><span class="line">  <span class="number">9</span> <span class="keyword">do</span></span><br><span class="line"> <span class="number">10</span>     temp=$&#123;arr[$i]&#125;</span><br><span class="line"> <span class="number">11</span>     arr[$i]=$&#123;arr[$(($len-$i<span class="number">-1</span>))]&#125;</span><br><span class="line"> <span class="number">12</span>     arr[$(($len-$i<span class="number">-1</span>))]=$temp</span><br><span class="line"> <span class="number">13</span> done</span><br><span class="line"> <span class="number">14</span> </span><br><span class="line"> <span class="number">15</span> echo $&#123;arr[@]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-shell函数"><a href="#4-shell函数" class="headerlink" title="4. shell函数"></a>4. shell函数</h3><p>没有数据类型</p>
<p>没有写形参，但可以传参</p>
<p>只有调用函数之后，函数里面的变量才会生效</p>
<p>函数里面定义的都是全局变量，如果要定义局部变量，加local</p>
<p>（1）函数的一般形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">function 函数名（）</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line"></span><br><span class="line">函数名（）</span><br><span class="line">&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）函数的调用，直接函数名</p>
<p>（3）返回值return，可以通过$?来打印函数的返回值,如果有返回值，返回在0~256</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> </span><br><span class="line"> <span class="number">3</span> add()</span><br><span class="line"> <span class="number">4</span> &#123;</span><br><span class="line"> <span class="number">5</span>     a=<span class="number">12</span></span><br><span class="line"> <span class="number">6</span>     <span class="keyword">return</span> $a</span><br><span class="line"> <span class="number">7</span> &#125;</span><br><span class="line"> <span class="number">8</span> add</span><br><span class="line"> <span class="number">9</span> echo $?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（4）函数的传参</p>
<p>函数名 实参1 实参2.。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数体中用$<span class="number">1</span>,$<span class="number">2</span>$<span class="number">3.</span>....来接受传递的实参</span><br><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line">  <span class="number">2</span> </span><br><span class="line">  <span class="number">3</span> add()</span><br><span class="line">  <span class="number">4</span> &#123;</span><br><span class="line">  <span class="number">5</span>     a=<span class="number">12</span></span><br><span class="line">  <span class="number">6</span>     echo $<span class="number">1</span></span><br><span class="line">  <span class="number">7</span>     echo $<span class="number">2</span></span><br><span class="line">  <span class="number">8</span>     echo $<span class="number">3</span></span><br><span class="line">  <span class="number">9</span>     <span class="keyword">return</span> $a</span><br><span class="line"> <span class="number">10</span> &#125;</span><br><span class="line"> <span class="number">11</span> add <span class="number">34</span> <span class="number">56</span> <span class="number">78</span></span><br><span class="line"> <span class="number">12</span> echo $?</span><br></pre></td></tr></table></figure>

<p>练习：写一个求和函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> #!/bin/bash</span><br><span class="line"> <span class="number">2</span> read m n</span><br><span class="line"> <span class="number">3</span> add()</span><br><span class="line"> <span class="number">4</span> &#123;</span><br><span class="line"> <span class="number">5</span>     sum=<span class="number">0</span></span><br><span class="line"> <span class="number">6</span>     <span class="keyword">for</span>((i=$<span class="number">1</span>;i&lt;=$<span class="number">2</span>;i++))</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">do</span></span><br><span class="line"> <span class="number">8</span>         sum=$(($sum+$i))</span><br><span class="line"> <span class="number">9</span>     done</span><br><span class="line"><span class="number">10</span> &#125;</span><br><span class="line"><span class="number">11</span> add m n</span><br><span class="line"><span class="number">12</span> echo $sum</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="三、c高级："><a href="#三、c高级：" class="headerlink" title="三、c高级："></a>三、c高级：</h2><h3 id="1-指针："><a href="#1-指针：" class="headerlink" title="1. 指针："></a>1. 指针：</h3><p>（1）指针的定义：</p>
<p>存储类型 数据类型 *指针变量名；</p>
<p>（2）指针的初始化：</p>
<p>存储类型 数据类型 *指针变量名=地址；</p>
<p>（3）指针的赋值：</p>
<p>1、把一个已知变量的地址赋值给指针</p>
<p>2、把已知数组首地址赋值给指针</p>
<p>3、把已有同级别指针赋值给指针</p>
<p>4、把NULL赋值给指针</p>
<p>（4）数组指针</p>
<p>本质是一个指针，只是这个指向了每个元素都是一维数组的一维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">10  </span>&#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">int</span> (*p)[<span class="number">3</span>]=a;</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">&quot;a[1][0]=%d\n&quot;</span>,a[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">&quot;*(*(p+1))]=%d\n&quot;</span>,*(*(p+<span class="number">1</span>)));</span><br><span class="line"><span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">&quot;p[1][0]=%d\n&quot;</span>,p[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="number">17</span>     <span class="built_in">printf</span>(<span class="string">&quot;*p[1]=%d\n&quot;</span>,*p[<span class="number">1</span>]);</span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">20</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><font color="red">注意：用指针数组创建的字符串(char *p[]={“hello”,”nihao”,”konnichiwa”})是字符串常量,而用二维字符串数组写的字符串才算变量。</font></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">写博客时有&#123;#的地方必须要放在代码里否则会渲染错误</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
        <tag>Linux基础</tag>
        <tag>shell脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>day19-c函数，结构体</title>
    <url>/2023/03/17/day19-c%E5%87%BD%E6%95%B0%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="day19-c函数，结构体"><a href="#day19-c函数，结构体" class="headerlink" title="day19-c函数，结构体"></a><font color="green">day19-c函数，结构体</font></h1><br>
<br>

<hr>
<h2 id="一、函数："><a href="#一、函数：" class="headerlink" title="一、函数："></a>一、函数：</h2><p>完成特定功能的程序模块</p>
<a id="more"></a>

<h3 id="1-函数的分类："><a href="#1-函数的分类：" class="headerlink" title="1. 函数的分类："></a>1. 函数的分类：</h3><p>库函数，给用户直接调用的函数（调用时要加对应的头文件）</p>
<p>自定义函数：用户自己写的函数</p>
<h3 id="2-怎么去写一个函数："><a href="#2-怎么去写一个函数：" class="headerlink" title="2. 怎么去写一个函数："></a>2. 怎么去写一个函数：</h3><p>（1）函数的声明：定义在头文件下，主函数上，提前告诉计算机，我后面有这个，要给这个函数开辟空间，如果函数的功能写在主函数前面，可以不要声明</p>
<p>一般形式：存储类型 数据类型 函数名（数据类型 形参1，数据类型 形参2.。。。）；（一定要加分号）</p>
<p>（2）函数的功能：</p>
<blockquote>
<p>存储类型 数据类型 函数名（数据类型 形参1，数据类型 形参2.。。。）<br>{<br>功能模块；<br>返回值；返回值可以没有，根据功能来定，如果有返回值，返回值的数据类型要和函数的数据类型保持一致<br>}</p>
</blockquote>
<p>（3）函数的调用</p>
<p>函数名（实参1，实参2.。。。）</p>
<p>实参的数据类型和个数和顺序要和形参保持一致</p>
<h3 id="3-函数的传参："><a href="#3-函数的传参：" class="headerlink" title="3. 函数的传参："></a>3. 函数的传参：</h3><ul>
<li>值传递：</li>
<li>地址传递–地址具有唯一性</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> t;</span><br><span class="line"><span class="number">11</span>     t=*a;</span><br><span class="line"><span class="number">12</span>     *a=*b;</span><br><span class="line"><span class="number">13</span>     *b=t;</span><br><span class="line"><span class="number">14</span>     </span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">17 </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">int</span> x=<span class="number">12</span>,y=<span class="number">34</span>;</span><br><span class="line"><span class="number">19</span>     swap(&amp;x,&amp;y);</span><br><span class="line"><span class="number">20</span>     <span class="built_in">printf</span>(<span class="string">&quot;x=%d----y=%d\n&quot;</span>,x,y);</span><br><span class="line"><span class="number">21</span>     </span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">23</span> &#125;   </span><br></pre></td></tr></table></figure>

<ul>
<li>数组传递–数组传数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="number">9</span> <span class="function"><span class="keyword">char</span> *<span class="title">mystrcat</span><span class="params">(<span class="keyword">char</span> p[<span class="number">32</span>],<span class="keyword">char</span> q[<span class="number">32</span>])</span></span>;<span class="comment">//函数的声明</span></span><br><span class="line"><span class="number">10</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">11 </span>&#123;</span><br><span class="line"><span class="number">12</span>     <span class="keyword">char</span> a[<span class="number">32</span>]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="number">13</span>     <span class="keyword">char</span> b[<span class="number">32</span>]=<span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="number">14</span>     <span class="built_in">puts</span>(mystrcat(a,b));<span class="comment">//函数的调用</span></span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">17</span> &#125;</span><br><span class="line"><span class="number">18</span> <span class="function"><span class="keyword">char</span> *<span class="title">mystrcat</span><span class="params">(<span class="keyword">char</span> p[<span class="number">32</span>],<span class="keyword">char</span> q[<span class="number">32</span>])</span><span class="comment">//函数的功能</span></span></span><br><span class="line"><span class="function">19 </span>&#123;</span><br><span class="line"><span class="number">20</span>     <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">21</span>     <span class="keyword">int</span> len=<span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="number">22</span>     <span class="keyword">for</span>(i=<span class="number">0</span>;p[i];i++)</span><br><span class="line"><span class="number">23</span>     &#123;</span><br><span class="line"><span class="number">24</span>         p[len]=q[i];</span><br><span class="line"><span class="number">25</span>         len++;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span>     <span class="keyword">return</span> p;</span><br><span class="line"><span class="number">28</span> &#125;</span><br><span class="line"><span class="number">29</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-指针函数"><a href="#4-指针函数" class="headerlink" title="4.指针函数"></a>4.指针函数</h3><p>本质是一个函数，特殊之处返回值必定是一个地址</p>
<p>一般形式：存储类型 数据类型 *函数名（数据类型 形参1，数据类型 形参2.。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mystrcat</span><span class="params">(<span class="keyword">char</span> p[<span class="number">32</span>],<span class="keyword">char</span> q[<span class="number">32</span>])</span><span class="comment">//函数的功能</span></span></span><br><span class="line"><span class="function"> 19 </span>&#123;</span><br><span class="line"> <span class="number">20</span>     <span class="keyword">int</span> i;</span><br><span class="line"> <span class="number">21</span>     <span class="keyword">int</span> len=<span class="built_in">strlen</span>(p);</span><br><span class="line"> <span class="number">22</span>     <span class="keyword">for</span>(i=<span class="number">0</span>;p[i];i++)</span><br><span class="line"> <span class="number">23</span>     &#123;</span><br><span class="line"> <span class="number">24</span>         p[len]=q[i];</span><br><span class="line"> <span class="number">25</span>         len++;</span><br><span class="line"> <span class="number">26</span>     &#125;</span><br><span class="line"> <span class="number">27</span>     <span class="keyword">return</span> p;</span><br><span class="line"> <span class="number">28</span> &#125;</span><br><span class="line"> <span class="number">29</span> </span><br></pre></td></tr></table></figure>

<h3 id="5-函数指针："><a href="#5-函数指针：" class="headerlink" title="5.函数指针："></a>5.函数指针：</h3><p>本质是一个函数，只是这个指针指向的是函数的入口地址，就是函数名</p>
<p>一般形式：存储类型 数据类型 （*指针变量名）（数据类型 形参1，数据类型 形参2.。。。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> t;</span><br><span class="line"><span class="number">11</span>     t=*a;</span><br><span class="line"><span class="number">12</span>     *a=*b;</span><br><span class="line"><span class="number">13</span>     *b=t;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function">17 </span>&#123;   </span><br><span class="line"><span class="number">18</span>     <span class="keyword">return</span> *a + *b;</span><br><span class="line"><span class="number">19</span> &#125;   </span><br><span class="line"><span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">21 </span>&#123;</span><br><span class="line"><span class="number">22</span>     <span class="keyword">int</span> x=<span class="number">12</span>,y=<span class="number">34</span>;</span><br><span class="line"><span class="number">23</span>     <span class="keyword">int</span> (*p)(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)=swap; <span class="comment">//把swap赋给p函数指针</span></span><br><span class="line"><span class="number">24</span>     p(&amp;x,&amp;y);<span class="comment">//调用p</span></span><br><span class="line"><span class="number">25</span>     p=add;</span><br><span class="line"><span class="number">26</span>     <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,p(&amp;x,&amp;y));</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">29</span> &#125;</span><br></pre></td></tr></table></figure>




<h3 id="6-函数指针数组"><a href="#6-函数指针数组" class="headerlink" title="6. 函数指针数组"></a>6. 函数指针数组</h3><p>本质是一个数组，只是这个数组里面放的是指向函数的指针</p>
<p>一般形式：存储类型 数据类型 （*数组名【下标】）（数据类型 形参1，数据类型 形参2.。。。）</p>
<p>例如：int （*p【3】）（int ，int）；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*===============================================</span></span><br><span class="line"><span class="comment">*   文件名称：jisuan.c</span></span><br><span class="line"><span class="comment">*   创 建 者：  张城   </span></span><br><span class="line"><span class="comment">*   创建日期：2023年03月16日</span></span><br><span class="line"><span class="comment">*   描    述：</span></span><br><span class="line"><span class="comment">================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jian</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cheng</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chu</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> (*p[<span class="number">4</span>])(<span class="keyword">int</span> a,<span class="keyword">int</span> b)=&#123;add,jian,cheng,chu&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>,&amp;i,&amp;c,&amp;j);</span><br><span class="line">    <span class="keyword">switch</span>(c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">0</span>](i,j));<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">1</span>](i,j));<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">2</span>](i,j));<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,p[<span class="number">3</span>](i,j));<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="7-函数的多文件封装"><a href="#7-函数的多文件封装" class="headerlink" title="7. 函数的多文件封装"></a>7. 函数的多文件封装</h3><p>（1）头文件–可以放库头文件和所有功能函数的声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __JISUAN_H__---防止头文件重复包含</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> __JISUAN_H__</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;--库头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;--函数的声明</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jian</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cheng</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chu</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>（2）功能文件–自定义的头文件和所有功能函数代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;jisuan.h&quot;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">return</span> a+b;</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span> <span class="function"><span class="keyword">int</span> <span class="title">jian</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">13 </span>&#123;</span><br><span class="line"><span class="number">14</span>     <span class="keyword">return</span> a-b;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">cheng</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">17 </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">return</span> a*b;</span><br><span class="line"><span class="number">19</span> &#125;</span><br><span class="line"><span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">chu</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">21 </span>&#123;</span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> a/b;</span><br><span class="line"><span class="number">23</span> &#125;</span><br><span class="line"><span class="number">24</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>（3）主函数文件—自定义头文件和函数的调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;jisuan.h&quot;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">  9 </span>&#123;</span><br><span class="line"> <span class="number">10</span>     <span class="keyword">int</span> x=<span class="number">12</span>,y=<span class="number">34</span>;</span><br><span class="line"> <span class="number">11</span>     <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,add(x,y));</span><br><span class="line"> <span class="number">12</span> </span><br><span class="line"> <span class="number">13</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">14</span> &#125;</span><br><span class="line">编译：至少编译两个.c文件，头文件默认在当前目录下去找</span><br><span class="line">    调用外部头文件：-I</span><br></pre></td></tr></table></figure>


<h3 id="8-递归函数："><a href="#8-递归函数：" class="headerlink" title="8. 递归函数："></a>8. 递归函数：</h3><p>直接或间接调用函数本身的函数</p>
<p>两个条件：调用自己，要有结束标志</p>
<p>每次调用自己都会给函数开辟空间，所以每次调用的变量都被会保留在当前函数内，没有到结束标志回归不会被释放</p>
<p>循环能做的，递归函数都能做，但是递归函数能做的，循环不一定能做，所以我们能用循环就用循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line"><span class="number">11</span>     &#123;</span><br><span class="line"><span class="number">12</span>        <span class="keyword">return</span> n+add(n<span class="number">-1</span>);</span><br><span class="line"><span class="number">13</span>     &#125;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">17 </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">int</span> n;</span><br><span class="line"><span class="number">19</span>     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="number">20</span>     <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,add(n));</span><br><span class="line"><span class="number">21</span> </span><br><span class="line"><span class="number">22</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">23</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-回调函数"><a href="#9-回调函数" class="headerlink" title="9. 回调函数"></a>9. 回调函数</h3><p>把一个函数作为一个参数，用函数指针来接受的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="function"><span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"> 9 </span>&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">return</span> a+b;</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span> <span class="function"><span class="keyword">int</span> <span class="title">gohome</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> (*p)())</span></span></span><br><span class="line"><span class="function">13 </span>&#123;</span><br><span class="line"><span class="number">14</span>     <span class="keyword">return</span> p(a,b);</span><br><span class="line"><span class="number">15</span> </span><br><span class="line"><span class="number">16</span> &#125;</span><br><span class="line"><span class="number">17</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">18 </span>&#123;</span><br><span class="line"><span class="number">19</span>     <span class="keyword">int</span> x=<span class="number">12</span>,y=<span class="number">34</span>;</span><br><span class="line"><span class="number">20</span>     <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,gohome(x,y,callback));</span><br><span class="line"><span class="number">21</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">22</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10-动态开辟空间函数"><a href="#10-动态开辟空间函数" class="headerlink" title="10. 动态开辟空间函数"></a>10. 动态开辟空间函数</h3><p>malloc</p>
<p>在堆区开辟空间，需要我们手动开辟，<strong>也需要我们手动释放</strong></p>
<p>头文件：#include &lt;stdlib.h&gt;</p>
<p>函数原型：void *malloc(size_t size);</p>
<p>参数：size：需要开辟空间的大小</p>
<p>返回值：开辟成功返回开辟的首地址，失败返回NULL</p>
<p>释放空间地址：</p>
<p>void free(void *ptr);</p>
<p>参数：ptr：要释放的首地址</p>
<p><strong>释放的是开辟的空间地址，而我们的指针还在，此时没有指向，变成野指针，需要给它赋值为NULL</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">10 </span>&#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="number">12</span>     <span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line"><span class="number">13</span>     &#123;</span><br><span class="line"><span class="number">14</span>         <span class="built_in">printf</span>(<span class="string">&quot;create error\n&quot;</span>);</span><br><span class="line"><span class="number">15</span>     &#125;</span><br><span class="line"><span class="number">16</span>     *p=<span class="number">12</span>;</span><br><span class="line"><span class="number">17</span>     <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>,*p);</span><br><span class="line"><span class="number">18</span>     <span class="built_in">free</span>(p);</span><br><span class="line"><span class="number">19</span>     p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">21</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">22</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="二、关键字："><a href="#二、关键字：" class="headerlink" title="二、关键字："></a>二、关键字：</h2><h3 id="1-const–变量常量化"><a href="#1-const–变量常量化" class="headerlink" title="1. const–变量常量化"></a>1. const–变量常量化</h3><p>const修饰指针：</p>
<p>int const *p=&amp;a—-p的内容不能改</p>
<p>int *const p=&amp;a;—-p的指向不能改</p>
<h3 id="2-typedef—重命名"><a href="#2-typedef—重命名" class="headerlink" title="2. typedef—重命名"></a>2. typedef—重命名</h3><p>已知数据类型的重命名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="keyword">typedef</span> <span class="keyword">int</span> A;</span><br><span class="line">  <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 10 </span>&#123;</span><br><span class="line"> <span class="number">11</span>     A a=<span class="number">12</span>;</span><br><span class="line"> <span class="number">12</span>     <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);    </span><br><span class="line"> <span class="number">13</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">14</span> &#125; </span><br><span class="line">~     </span><br></pre></td></tr></table></figure>

<h3 id="3-define—-宏定义"><a href="#3-define—-宏定义" class="headerlink" title="3. define—-宏定义"></a>3. define—-宏定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="meta">#<span class="meta-keyword">define</span> A char *</span></span><br><span class="line">  <span class="number">9</span> <span class="keyword">typedef</span>  <span class="keyword">char</span> * B;</span><br><span class="line"> <span class="number">10</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 11 </span>&#123;</span><br><span class="line"> <span class="number">12</span>     A a,b; <span class="comment">//这样定义后会发现b是char类型而不是char*</span></span><br><span class="line"> <span class="number">13</span>     B c,d; <span class="comment">// a=8,b=1,c=8,d=8</span></span><br><span class="line"> <span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">&quot;a=%ld\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"> <span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">&quot;b=%ld\n&quot;</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line"> <span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">&quot;c=%ld\n&quot;</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line"> <span class="number">17</span>     <span class="built_in">printf</span>(<span class="string">&quot;d=%ld\n&quot;</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line"> <span class="number">18</span>     </span><br><span class="line"> <span class="number">19</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">20</span> &#125; </span><br></pre></td></tr></table></figure>

<p>练习：利用宏定义求出两个数之间的最大值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="meta">#<span class="meta-keyword">define</span> MAX (5&gt;3)?5:3</span></span><br><span class="line">  <span class="number">9</span> <span class="keyword">typedef</span>  <span class="keyword">char</span> * B; </span><br><span class="line"> <span class="number">10</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 11 </span>&#123;   </span><br><span class="line"> <span class="number">12</span>     <span class="built_in">printf</span>(<span class="string">&quot;MAX=%d\n&quot;</span>,MAX);</span><br><span class="line"> <span class="number">13</span>     </span><br><span class="line"> <span class="number">14</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">15</span> &#125;   </span><br><span class="line">~     </span><br></pre></td></tr></table></figure>

<h3 id="4-static—静态区域存储"><a href="#4-static—静态区域存储" class="headerlink" title="4. static—静态区域存储"></a>4. static—静态区域存储</h3><blockquote>
<p>修饰全局变量，限制作用域<br>修饰局部变量，延长声明周期（只会被初始化一次）<br>修饰函数，限制作用域</p>
</blockquote>
<h3 id="5-extern—调用外部文件变量"><a href="#5-extern—调用外部文件变量" class="headerlink" title="5. extern—调用外部文件变量"></a>5. extern—调用外部文件变量</h3><p>只能调用全局变量</p>
<blockquote>
<p>定义: int extern a;</p>
</blockquote>
<p>编译的时候要和调用的文件一起编译</p>
<h3 id="6-struct—结构体"><a href="#6-struct—结构体" class="headerlink" title="6. struct—结构体"></a>6. struct—结构体</h3><p>本质还是一个数据类型，只是里面可以放很多成员，这些成员数据类型可以一样，也可以不一样，可以是已知的数据类型，也可以是构造类型</p>
<p>一般形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct 结构体名&#123;</span><br><span class="line">数据类型 成员1；</span><br><span class="line">数据类型 成员2；</span><br><span class="line">......</span><br><span class="line">&#125;；--分号不能省略</span><br></pre></td></tr></table></figure>
<p>结构体的初始化：（按照顺序初始化）</p>
<p>全局变量初始化：在头文件下，主函数上，就是在构造完这个结构体立马定义一个变量</p>
<p>局部变量初始化，在主函数里面定义一个结构体变量</p>
<p>结构体的成员的调用：变量名.成员</p>
<p>结构体的赋值：</p>
<p>1、结构体赋结构体</p>
<p>2、每个成员单独赋值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="number">9</span> <span class="class"><span class="keyword">struct</span> <span class="title">zc</span>&#123;</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> age;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"><span class="number">12</span>     <span class="keyword">char</span> sex[<span class="number">32</span>];</span><br><span class="line"><span class="number">13</span> &#125;a=&#123;<span class="number">18</span>,<span class="string">&quot;zhangcheng&quot;</span>,<span class="string">&quot;man&quot;</span>&#125;;<span class="comment">//全局变量初始化</span></span><br><span class="line"><span class="number">14</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">15 </span>&#123;   </span><br><span class="line"><span class="number">16</span>     <span class="class"><span class="keyword">struct</span> <span class="title">zc</span> <span class="title">b</span>=&#123;</span><span class="number">20</span>,<span class="string">&quot;cheng&quot;</span>,<span class="string">&quot;man&quot;</span>&#125;;<span class="comment">//局部变量初始化</span></span><br><span class="line"><span class="number">17</span>     <span class="class"><span class="keyword">struct</span> <span class="title">zc</span> <span class="title">c</span>;</span></span><br><span class="line"><span class="number">18</span>     c.age=<span class="number">22</span>;</span><br><span class="line"><span class="number">19</span>     <span class="built_in">strcpy</span>(c.name,<span class="string">&quot;zhang&quot;</span>);</span><br><span class="line"><span class="number">20</span>     <span class="built_in">strcpy</span>(c.sex,<span class="string">&quot;women&quot;</span>);</span><br><span class="line"><span class="number">21</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.age=%d\n&quot;</span>,a.age);<span class="comment">//成员的调用</span></span><br><span class="line"><span class="number">22</span>     <span class="built_in">printf</span>(<span class="string">&quot;b.age=%d\n&quot;</span>,b.age);</span><br><span class="line"><span class="number">23</span>     <span class="built_in">printf</span>(<span class="string">&quot;c.sex=%s\n&quot;</span>,c.sex);</span><br><span class="line"><span class="number">24</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">25</span> &#125;</span><br><span class="line">     </span><br></pre></td></tr></table></figure>


<ul>
<li>结构体的大小：</li>
</ul>
<p>规则：</p>
<p>&emsp;&emsp;如果是64位操作系统默认按照8byte对齐，但是如果最大的数据类型小于8byte，就按照最大数据类型大小对齐（就是最大成员数据类型的倍数）</p>
<p>&emsp;&emsp;如果是32位操作系统默认按照4byte对齐，但是如果最大的数据类型小于4byte，就按照最大数据类型大小对齐（就是最大成员数据类型的倍数）</p>
<p>&emsp;&emsp;如果对齐字节能够放下后面的成员，就会在当前字节放</p>
<p>&emsp;&emsp;并且存储遵循偶数存储原则</p>
<blockquote>
<p>例：<br>struct temp{char a；short b;char c;int d}<br>结构体大小为12字节。因为以里面最大的int开辟空间为4字节<br>第一个4字节有<code>a,b</code>,因为偶数原则，a占1，b占3，4<br>第二个4字节有<code>c</code>，占1<br>第三个4字节有<code>d</code>占1，2，3，4</p>
</blockquote>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>函数</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>day20-c特殊类型和gbd,makefile</title>
    <url>/2023/03/17/day20-c%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E5%92%8Cgbd-makefile/</url>
    <content><![CDATA[<h1 id="day20-linux基础和c"><a href="#day20-linux基础和c" class="headerlink" title="day20-linux基础和c"></a><font color="green">day20-linux基础和c</font></h1><br>
<br>

<hr>
<h2 id="一、结构体："><a href="#一、结构体：" class="headerlink" title="一、结构体："></a>一、结构体：</h2><a id="more"></a>

<h3 id="1-结构体的嵌套："><a href="#1-结构体的嵌套：" class="headerlink" title="1. 结构体的嵌套："></a>1. 结构体的嵌套：</h3><p>结构体里面再放结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="number">8</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">  <span class="number">9</span>     <span class="keyword">int</span> age;</span><br><span class="line"> <span class="number">10</span>     <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"> <span class="number">11</span>     <span class="keyword">int</span> id;</span><br><span class="line"> <span class="number">12</span> &#125;STU;</span><br><span class="line"> <span class="number">13</span> </span><br><span class="line"> <span class="number">14</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tea</span>&#123;</span></span><br><span class="line"> <span class="number">15</span>     <span class="keyword">int</span> age;</span><br><span class="line"> <span class="number">16</span>     <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"> <span class="number">17</span>     <span class="keyword">char</span> sex[<span class="number">32</span>];</span><br><span class="line"> <span class="number">18</span>     STU zc;</span><br><span class="line"> <span class="number">19</span> &#125;TEA;</span><br><span class="line"> <span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 21 </span>&#123;   </span><br><span class="line"> <span class="number">22</span>     STU a=&#123;<span class="number">12</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">45</span>&#125;;</span><br><span class="line"> <span class="number">23</span>     TEA b=&#123;<span class="number">30</span>,<span class="string">&quot;lisi&quot;</span>,<span class="string">&quot;man&quot;</span>,a&#125;;</span><br><span class="line"> <span class="number">24</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.age=%d\n&quot;</span>,a.age);</span><br><span class="line"> <span class="number">25</span>     <span class="built_in">printf</span>(<span class="string">&quot;b.zc.age=%d\n&quot;</span>,b.zc.age);</span><br><span class="line"> <span class="number">26</span> </span><br><span class="line"> <span class="number">27</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">28</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-结构体指针"><a href="#2-结构体指针" class="headerlink" title="2. 结构体指针"></a>2. 结构体指针</h3><p>本质是一个指针，只是这个指针指向了一个结构体</p>
<p>一般形式：struct 结构提名 * 指针变量名；</p>
<p>初始化：struct 结构提名 * 指针变量名=结构体地址；</p>
<p>指针访问结构体内容：</p>
<p>两种方式：</p>
<p>1、（*p）.成员—用的少</p>
<p>2、p-&gt;成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">21 </span>&#123;   </span><br><span class="line"><span class="number">22</span>     STU a=&#123;<span class="number">12</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">45</span>&#125;;</span><br><span class="line"><span class="number">23</span>     STU *p=&amp;a;<span class="comment">//初始化</span></span><br><span class="line"><span class="number">24</span>     <span class="built_in">printf</span>(<span class="string">&quot;(*p).age=%d\n&quot;</span>,(*p).age);</span><br><span class="line"><span class="number">25</span>     <span class="built_in">printf</span>(<span class="string">&quot;p-&gt;age=%d\n&quot;</span>,p-&gt;age);</span><br><span class="line"><span class="number">26</span> </span><br><span class="line"><span class="number">27</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">28</span> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-结构体数组："><a href="#3-结构体数组：" class="headerlink" title="3. 结构体数组："></a>3. 结构体数组：</h3><p>本质是一个数组，只是这个数组里面的元素都是结构体</p>
<p>一般形式：struct 结构提名 数组名【下标】；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> 21 </span>&#123;   </span><br><span class="line"> <span class="number">22</span>     STU a=&#123;<span class="number">12</span>,<span class="string">&quot;zhangsan&quot;</span>,<span class="number">45</span>&#125;;</span><br><span class="line"> <span class="number">23</span>     STU b=&#123;<span class="number">13</span>,<span class="string">&quot;lisi&quot;</span>,<span class="number">47</span>&#125;;</span><br><span class="line"> <span class="number">24</span>     STU c=&#123;<span class="number">15</span>,<span class="string">&quot;wangwu&quot;</span>,<span class="number">50</span>&#125;;</span><br><span class="line"> <span class="number">25</span>     STU s[<span class="number">3</span>]=&#123;a,b,c&#125;;<span class="comment">//初始化</span></span><br><span class="line"> <span class="number">26</span>     <span class="built_in">printf</span>(<span class="string">&quot;s[1].name=%s\n&quot;</span>,s[<span class="number">1</span>].name);</span><br><span class="line"> <span class="number">27</span>     </span><br><span class="line"> <span class="number">28</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="number">29</span> &#125; </span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="二、共用体—union"><a href="#二、共用体—union" class="headerlink" title="二、共用体—union"></a>二、共用体—union</h2><p>也叫联合体</p>
<p>成员们一起用一片空间地址</p>
<p>共用体不允许初始化</p>
<p>STU a={12,”zhangsan”,45};//错误</p>
<p>赋值只能成员赋值，而且每次只能赋值一个，前面赋值的都会被覆盖</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="number">9</span> <span class="keyword">typedef</span> <span class="keyword">union</span> stu&#123;</span><br><span class="line"><span class="number">10</span>     <span class="keyword">int</span> age;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line"><span class="number">12</span>     <span class="keyword">int</span> id;</span><br><span class="line"><span class="number">13</span> &#125;STU;</span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">16 </span>&#123;   </span><br><span class="line"><span class="number">17</span>     STU a;</span><br><span class="line"><span class="number">18</span>     a.age=<span class="number">12</span>;</span><br><span class="line"><span class="number">19</span>     <span class="built_in">strcpy</span>(a.name,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"><span class="number">20</span>     a.id=<span class="number">45</span>;</span><br><span class="line"><span class="number">21</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.age=%d\n&quot;</span>,a.age); <span class="comment">//a.age=45</span></span><br><span class="line"><span class="number">22</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.name=%s\n&quot;</span>,a.name); <span class="comment">//a.name=-</span></span><br><span class="line"><span class="number">23</span>     <span class="built_in">printf</span>(<span class="string">&quot;a.id=%d\n&quot;</span>,a.id); <span class="comment">//a.id=45</span></span><br><span class="line"><span class="number">24</span>     </span><br><span class="line"><span class="number">25</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">26</span> &#125; </span><br></pre></td></tr></table></figure>

<p>共用体的大小：</p>
<p>也要遵循结构体大小的规则，但是只会给最大成员开辟对应的空间地址</p>
<br>
<br>

<hr>
<h2 id="三、枚举型–enum"><a href="#三、枚举型–enum" class="headerlink" title="三、枚举型–enum"></a>三、枚举型–enum</h2><p>成员没有初始化，从0开始往后赋值</p>
<p>如果有成员赋值，成员后面依次递增+1</p>
<p>enum里面的成员都是常量，不能修改它们的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">8</span> </span><br><span class="line"> <span class="number">9</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">10 </span>&#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">enum</span> &#123;A,E,B=<span class="number">2</span>,C,D=<span class="number">8</span>,F&#125;;</span><br><span class="line"><span class="number">12</span>     <span class="built_in">printf</span>(<span class="string">&quot;A=%d\n&quot;</span>,A);<span class="comment">//0</span></span><br><span class="line"><span class="number">13</span>     <span class="built_in">printf</span>(<span class="string">&quot;E=%d\n&quot;</span>,E);<span class="comment">//1</span></span><br><span class="line"><span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">&quot;B=%d\n&quot;</span>,B);<span class="comment">//2</span></span><br><span class="line"><span class="number">15</span>     <span class="built_in">printf</span>(<span class="string">&quot;C=%d\n&quot;</span>,C);<span class="comment">//3</span></span><br><span class="line"><span class="number">16</span>     <span class="built_in">printf</span>(<span class="string">&quot;F=%d\n&quot;</span>,F);<span class="comment">//9</span></span><br><span class="line"><span class="number">17</span>     </span><br><span class="line"><span class="number">18</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">19</span> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="四、gdb调试工具："><a href="#四、gdb调试工具：" class="headerlink" title="四、gdb调试工具："></a>四、gdb调试工具：</h2><p>帮助我们找出代码的问题</p>
<p>gcc -g 编译的文件名，会生成一个a.out的执行文件，这个执行文件就可以调试</p>
<p>gdb 执行文件名</p>
<blockquote>
<p>r—运行我们的程序<br>l—查看我们的程序代码<br>b—设置断点，让程序跑到我们断点的那一行<br>c–继续运行我们的程序，直到下一个断点，如果没有直接运行完<br>p+变量===查看变量的值<br>n—按行运行，但是不进入函数<br>s—按行运行，会进入函数<br>delete—删除所有断点<br>q—退出dgb调试</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="五、makefile"><a href="#五、makefile" class="headerlink" title="五、makefile"></a>五、makefile</h2><p>makefile是一个文件，里面放的是编译的规则，可以管理多个文件</p>
<p>make是一个工具，用来解析我们的makefile</p>
<p>make会根据文件的时间戳进行编译，如果文件的时间戳没有改变，不会编译该文件，节省大量的编译时间</p>
<p>makefile的逻辑：</p>
<p>目标文件：依赖文件</p>
<p>​     （tab）编译语句</p>
<p>目标文件就是我们最终会生成的文件，要生成这个文件，会去找生成它需要的文件，就叫依赖文件，如果这个依赖文件有需要其他文件来生成，继续找它的依赖文件，直到不需要为止</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> app:<span class="built_in">list</span>.o main.o</span><br><span class="line"> <span class="number">2</span>     gcc  <span class="built_in">list</span>.o main.o -o app</span><br><span class="line"> <span class="number">3</span> <span class="built_in">list</span>.o:<span class="built_in">list</span>.c</span><br><span class="line"> <span class="number">4</span>     gcc -c <span class="built_in">list</span>.c -o <span class="built_in">list</span>.o</span><br><span class="line"> <span class="number">5</span> main.o:main.c</span><br><span class="line"> <span class="number">6</span>     gcc -c main.c -o main.o</span><br><span class="line"> <span class="number">7</span> clean:</span><br><span class="line"> <span class="number">8</span>     rm main.o <span class="built_in">list</span>.o app </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>make clean  删除生成的文件（执行clean后面的语句）</p>
<p>make，默认解析当前目录下的makefile或者Makefile</p>
<p>make -f 指定的makefile</p>
<p>调用外部头文件-I 加头文件的路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> app:<span class="built_in">list</span>.o main.o</span><br><span class="line"> <span class="number">2</span>     gcc  <span class="built_in">list</span>.o main.o -I ./include -o app</span><br><span class="line"> <span class="number">3</span> <span class="built_in">list</span>.o:<span class="built_in">list</span>.c</span><br><span class="line"> <span class="number">4</span>     gcc -c <span class="built_in">list</span>.c -I ./include -o <span class="built_in">list</span>.o</span><br><span class="line"> <span class="number">5</span> main.o:main.c</span><br><span class="line"> <span class="number">6</span>     gcc -c main.c -I ./include -o main.o</span><br><span class="line"> <span class="number">7</span> clean:</span><br><span class="line"> <span class="number">8</span>     rm main.o <span class="built_in">list</span>.o app </span><br></pre></td></tr></table></figure>

<h3 id="makefile的变量"><a href="#makefile的变量" class="headerlink" title="makefile的变量"></a>makefile的变量</h3><p>变量的赋值：</p>
<ul>
<li>=：给当前变量赋值，但是如果后面有新的赋值，把新的赋值给变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">2</span> b=$(a)</span><br><span class="line">  <span class="number">3</span> a=<span class="number">34</span></span><br><span class="line">  <span class="number">4</span> all:</span><br><span class="line">  <span class="number">5</span>     @echo $(b)</span><br><span class="line">b=<span class="number">34</span></span><br></pre></td></tr></table></figure>

<ul>
<li>:=—立即赋值,和平时的赋值一样，后面新的赋值不会改变当前值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">2</span> b:=$(a)</span><br><span class="line">  <span class="number">3</span> a=<span class="number">34</span></span><br><span class="line">  <span class="number">4</span> all:</span><br><span class="line">  <span class="number">5</span>     @echo $(b)</span><br><span class="line">      b=<span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>？=—询问赋值,询问前面有没有赋值，如果有，此次赋值无效</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">2</span> b:=$(a)</span><br><span class="line">  <span class="number">3</span> a?=<span class="number">34</span></span><br><span class="line">  <span class="number">4</span> all:</span><br><span class="line">  <span class="number">5</span>     @echo $(b)</span><br><span class="line">  <span class="number">6</span>     echo $(a)</span><br><span class="line">a=<span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>+=：追加赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> a=<span class="number">12</span></span><br><span class="line">  <span class="number">2</span> b:=$(a)</span><br><span class="line">  <span class="number">3</span> a+=hello</span><br><span class="line">  <span class="number">4</span> all:</span><br><span class="line">  <span class="number">5</span>     @echo $(b)</span><br><span class="line">  <span class="number">6</span>     echo $(a)</span><br><span class="line">a=<span class="number">12</span> hello</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在语句前加@隐藏显示语句</p>
</blockquote>
<p>利用变量写makefile：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> TARGET=app <span class="comment">//相当于代替</span></span><br><span class="line">  <span class="number">2</span> OBJS=<span class="built_in">list</span>.o main.o </span><br><span class="line">  <span class="number">3</span> CC=gcc</span><br><span class="line">  <span class="number">4</span> OBJS2=<span class="built_in">list</span>.c</span><br><span class="line">  <span class="number">5</span> OBJS3=main.c</span><br><span class="line">  <span class="number">6</span> PATH=-I ./include</span><br><span class="line">  <span class="number">7</span> </span><br><span class="line">  <span class="number">8</span> $(TARGET):$(OBJS)</span><br><span class="line">  <span class="number">9</span>     $(CC)  $(OBJS) $(PATH) -o $(TARGET)</span><br><span class="line"> <span class="number">10</span> <span class="built_in">list</span>.o:$(OBJS2)</span><br><span class="line"> <span class="number">11</span>     $(CC) -c $(OBJS2) $(PATH) -o <span class="built_in">list</span>.o</span><br><span class="line"> <span class="number">12</span> main.o:$(OBJS3)</span><br><span class="line"> <span class="number">13</span>     $(CC) -c $(OBJS3) $(PATH) -o main.o</span><br><span class="line"> <span class="number">14</span> clean:</span><br><span class="line"> <span class="number">15</span>     rm $(OBJS) $(TARGET) </span><br><span class="line">~                            </span><br></pre></td></tr></table></figure>

<p>特殊的变量：</p>
<blockquote>
<p>$@—目标文件<br>$^—所有依赖文件<br>$&lt;:第一个依赖文件<br>通配符：%</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TARGET=app</span><br><span class="line"> <span class="number">2</span> OBJS=<span class="built_in">list</span>.o main.o</span><br><span class="line"> <span class="number">3</span> CC=gcc</span><br><span class="line"> <span class="number">4</span> OBJS2=<span class="built_in">list</span>.c</span><br><span class="line"> <span class="number">5</span> OBJS3=main.c</span><br><span class="line"> <span class="number">6</span> path=-I ./include</span><br><span class="line"> <span class="number">7</span> $(TARGET):$(OBJS)</span><br><span class="line"> <span class="number">8</span>     $(CC)  $^ $(path) -o $@</span><br><span class="line"> <span class="number">9</span> %.o:%.c</span><br><span class="line"><span class="number">10</span>     $(CC) -c $^ $(path) -o $@</span><br><span class="line"><span class="number">11</span> clean:</span><br><span class="line"><span class="number">12</span>     rm $(TARGET) $(OBJS)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>c语言</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>结构体</tag>
        <tag>gbd</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>day22-数据结构和算法简介，顺序表</title>
    <url>/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="day22-数据结构和算法简介，顺序表"><a href="#day22-数据结构和算法简介，顺序表" class="headerlink" title="day22-数据结构和算法简介，顺序表"></a><font color="green">day22-数据结构和算法简介，顺序表</font></h1><h2 id="一、课程大纲"><a href="#一、课程大纲" class="headerlink" title="一、课程大纲"></a>一、课程大纲</h2><ol>
<li>数据结构基础及算法基础+ 顺序表</li>
<li>链表</li>
<li>双向链表、双向循环链表 、栈、队列</li>
<li>树、图</li>
<li>常见的算法</li>
</ol>
<a id="more"></a>
<br>
<br>

<hr>
<h2 id="二、数据结构和算法简介"><a href="#二、数据结构和算法简介" class="headerlink" title="二、数据结构和算法简介"></a>二、数据结构和算法简介</h2><h3 id="1-数据结构基础"><a href="#1-数据结构基础" class="headerlink" title="1.数据结构基础"></a>1.数据结构基础</h3><ol>
<li><p>了解数据的基本概念和术语：</p>
<ul>
<li><p>数据：</p>
<pre><code>  (1)数据即信息的载体，是能够输入到计算机中且能被计算机识别、存储和处理的符号总称。
  (2)数据不仅包括:
 a. 数值型数据：整型、实型、字符型数值型数据
 b. 非数值型数据：图片、视频、声音等</code></pre>
</li>
<li><p>数据项：<br> 数据元素由若干数据项组成，数据项是数据中的最小单位。</p>
<p> 数据由多种数据项组成：</p>
<p> 正比如：我们在讨论一个电影角色等时候，我们讨论的是该角色的姓名、性别、住址、等</p>
<p> 注意：数据项是数据不可分隔的最小组成单位</p>
</li>
<li><p>数据结构（DS）：</p>
<p> (1)可用形式化语言描述，即DS是一个二元组：</p>
<pre><code>       DS =（D,R）其中，D为数据元素的集合，R为D上关系的集合。 </code></pre>
<p> (2)数据结构的逻辑关系</p>
<p> <img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321104451784.png" alt="image-20230321104451784"></p>
</li>
</ul>
<ul>
<li>存储结构：</li>
</ul>
<blockquote>
<p>a. 顺序存储<br>b. 链式存储<br>c. 索引存储<br>d. 散列存储</p>
</blockquote>
<ul>
<li>运算：增、删、改、查、排</li>
</ul>
<p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321105735324.png" alt="image-20230321105735324"></p>
</li>
</ol>
<h3 id="2-算法"><a href="#2-算法" class="headerlink" title="2.算法"></a>2.算法</h3><p>(1)什么是算法？</p>
<pre><code>    1. 算法（Algorithm）是一个有穷规则（或语句、指令）的有序集合。它确定了解决某一问题的一个运算序列。对于问题的初始输入，通过算法有限步的运行，产生一个或多个输出。

    2. 算法的特性：

        (1)  有穷性 —— 算法执行的步骤（或规则）是有限的

        (2)  确定性 —— 每个计算步骤无二义性

        (3)  可行性 —— 每个计算步骤能够在有限的时间内完成

        (4)  输入  —— 算法有零个或多个外部输入

        (5)  输出  —— 算法有一个或多个输出

    3. 算法和程序的区别：

        共同点：二者都是为完成某个任务，或解决某个问题而编制的规则（或语句）的有序集合，这是它们的。
        不同点：
            * 算法与计算机无关，但程序依赖于具体的计算机语言。
            * 算法必须是有穷尽的，但程序可能是无穷尽的。
            * 算法可忽略一些语法细节问题，重点放在解决问题的思路上，但程序必须严格遵循相应语言工具的语法。算法转换成程序后才能在计算机上运行。另外，在设计算法时，一定要考虑它的确定性，即算法的每个步骤都是无二义性的（即一条规则不能有两种以上的解释）

    4. 程序的基本概念：

        1. 可执行的有序二进制指令、存放在磁盘、不占用系统资源（ cpu、内存等）

    5. 算法的优劣：

        消耗时间的多少 ：

        消耗存储空间的多少 ：

        容易理解、容易编程和调试、容易维护。时间复杂度的概念介绍 ：

        问题的规模 ：输入数据量的大小，用n来表示。

        算法的时间复杂度 ：算法消耗时间，它是问题规模的函数 T(n)。

        其中好算法代表了：

            算法对应的程序所耗时间少；

            算法对应的程序所耗存储空间少；

            算法结构性好、易读、易移植和调试等等。

        3. 时间复杂度：算法的时间复杂度定义为算法中可执行语句的频度之和，记为T(n)</code></pre>
<p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321141217272.png" alt="image-20230321141217272"><br><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321141200570.png" alt="image-20230321141200570"></p>
<h3 id="3-数据结构常见的结构"><a href="#3-数据结构常见的结构" class="headerlink" title="3.数据结构常见的结构-"></a>3.数据结构常见的结构-</h3><p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321142133548.png" alt="image-20230321142133548"></p>
<br>
<br>

<hr>
<h2 id="三、数据结构之顺序表"><a href="#三、数据结构之顺序表" class="headerlink" title="三、数据结构之顺序表"></a>三、数据结构之顺序表</h2><ol>
<li>线性表：</li>
</ol>
<p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321144943972.png" alt="image-20230321144943972"></p>
<ol start="2">
<li>线性表特征：</li>
</ol>
<p><img src="/2023/03/21/day22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%EF%BC%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/image-20230321145052751.png" alt="image-20230321145052751"></p>
<ol start="3">
<li>顺序表的代码实现：</li>
</ol>
<p>（1）memset(&emsp;)函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">功能：<span class="built_in">memset</span> - fill memory with a constant byte</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">函数原型：</span><br><span class="line">       <span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> c, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">参数说明：</span><br><span class="line">	<span class="keyword">void</span> *s：要清空的目标数组或指针所指空间  buf</span><br><span class="line">	<span class="keyword">int</span> c：给定的填充的数据   <span class="number">0</span> <span class="number">1</span> 等</span><br><span class="line">    <span class="keyword">size_t</span> n： 大小     <span class="keyword">sizeof</span>（buf）；</span><br><span class="line">返回值</span><br><span class="line">	无返回值：</span><br></pre></td></tr></table></figure>



<p>（2）bzero(&emsp;)函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">功能： bzero - write zero-valued bytes</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line">函数原型：</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">bzero</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">参数说明：</span><br><span class="line">	<span class="keyword">void</span> *s：要清空的目标数组或指针所指空间  buf</span><br><span class="line">    <span class="keyword">size_t</span> n： 大小     <span class="keyword">sizeof</span>（buf）；</span><br><span class="line">返回值</span><br><span class="line">	无返回值：</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>（3）printf 变色打印(Linux)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    字背景颜色范围:<span class="number">40</span> - <span class="number">49</span></span><br><span class="line">    <span class="number">40</span>:黑</span><br><span class="line">    <span class="number">41</span>:深红</span><br><span class="line">    <span class="number">42</span>:绿</span><br><span class="line">    <span class="number">43</span>:黄色</span><br><span class="line">    <span class="number">44</span>:蓝色</span><br><span class="line">    <span class="number">45</span>:紫色</span><br><span class="line">    <span class="number">46</span>:深绿</span><br><span class="line">    <span class="number">47</span>:白色</span><br><span class="line">     </span><br><span class="line">    字颜色:<span class="number">30</span> - <span class="number">39</span></span><br><span class="line">    <span class="number">30</span>:黑</span><br><span class="line">    <span class="number">31</span>:红</span><br><span class="line">    <span class="number">32</span>:绿</span><br><span class="line">    <span class="number">33</span>:黄</span><br><span class="line">    <span class="number">34</span>:蓝色</span><br><span class="line">    <span class="number">35</span>:紫色</span><br><span class="line">    <span class="number">36</span>:深绿</span><br><span class="line">    <span class="number">37</span>:白色</span><br><span class="line">    \<span class="number">33</span>[<span class="number">0</span>m 关闭所有属性</span><br><span class="line">    \<span class="number">33</span>[<span class="number">1</span>m 设置高亮度</span><br><span class="line">    \<span class="number">33</span>[<span class="number">4</span>m 下划线</span><br><span class="line">    \<span class="number">33</span>[<span class="number">5</span>m 闪烁</span><br><span class="line">    \<span class="number">33</span>[<span class="number">7</span>m 反显</span><br><span class="line">    \<span class="number">33</span>[<span class="number">8</span>m 消隐</span><br><span class="line">    \<span class="number">33</span>[<span class="number">30</span>m -- \<span class="number">33</span>[<span class="number">37</span>m 设置前景色</span><br><span class="line">    \<span class="number">33</span>[<span class="number">40</span>m -- \<span class="number">33</span>[<span class="number">47</span>m 设置背景色</span><br><span class="line">    \<span class="number">33</span>[nA 光标上移n行</span><br><span class="line">    \<span class="number">33</span>[nB 光标下移n行</span><br><span class="line">    \<span class="number">33</span>[nC 光标右移n行</span><br><span class="line">    \<span class="number">33</span>[nD 光标左移n行</span><br><span class="line">    \<span class="number">33</span>[y;xH设置光标位置</span><br><span class="line">    \<span class="number">33</span>[<span class="number">2</span>J 清屏</span><br><span class="line">    \<span class="number">33</span>[K 清除从光标到行尾的内容</span><br><span class="line">    \<span class="number">33</span>[s 保存光标位置</span><br><span class="line">    \<span class="number">33</span>[u 恢复光标位置</span><br><span class="line">    \<span class="number">33</span>[?<span class="number">25l</span> 隐藏光标</span><br><span class="line">    \<span class="number">33</span>[?<span class="number">25</span>h 显示光标</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;hello world\n&quot;); </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[40;32;5m hello world\033[1m\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;\033[40;31;5m hello world\033[0m\n&quot;);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（3）printf 变色打印(Windows)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HANDLE hConsole= GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">    SetConsoleTextAttribute(hConsole,FOREGROUND_RED);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*1. 引入Windows.h头文件。</span></span><br><span class="line"><span class="comment">2. 使用SetConsoleTextAttribute函数设置控制台输出的字体颜色。该函数的第一个参数是控制台输出的句柄，可以使用GetStdHandle函数获取标准输出句柄；第二个参数是字体颜色，可以使用预定义的常量或自定义的颜色值。</span></span><br><span class="line"><span class="comment">   例如，以下代码将控制台输出的字体颜色设置为红色预定义的颜色常量包括：</span></span><br><span class="line"><span class="comment">- FOREGROUND_BLUE：蓝色</span></span><br><span class="line"><span class="comment">- FOREGROUND_GREEN：绿色</span></span><br><span class="line"><span class="comment">- FOREGROUND_RED：红色</span></span><br><span class="line"><span class="comment">- FOREGROUND_INTENSITY：高亮</span></span><br><span class="line"><span class="comment">- BACKGROUND_BLUE：背景色为蓝色</span></span><br><span class="line"><span class="comment">- BACKGROUND_GREEN：背景色为绿色</span></span><br><span class="line"><span class="comment">- BACKGROUND_RED：背景色为红色</span></span><br><span class="line"><span class="comment">- BACKGROUND_INTENSITY：背景色高亮</span></span><br><span class="line"><span class="comment">可以使用位运算符|和&amp;来组合多个颜色常量，</span></span><br><span class="line"><span class="comment">例如：</span></span><br><span class="line"><span class="comment">SetConsoleTextAttribute(hConsole, FOREGROUND_RED | BACKGROUND_GREEN | FOREGROUND_INTENSITY);</span></span><br><span class="line"><span class="comment">该代码将字体颜色设置为红色、背景色设置为绿色、高亮显示。*/</span></span><br></pre></td></tr></table></figure>

<p>（4）线性表c的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">perr_exit</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造顺序表结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">data_t</span> data[SIZE]; <span class="comment">//保存元素</span></span><br><span class="line">    <span class="keyword">int</span> last;        <span class="comment">//保存尾元素下标</span></span><br><span class="line">&#125;seqlist; </span><br><span class="line"><span class="comment">//创建表头及初始化表</span></span><br><span class="line"><span class="function">seqlist *<span class="title">create_seqlite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    seqlist* head =(seqlist*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(seqlist)); <span class="comment">//创建表头 head </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;last = <span class="number">-1</span>;   <span class="comment">//初始化 last为-1  表示空表</span></span><br><span class="line">    <span class="built_in">memset</span>(head-&gt;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(head-&gt;data)); <span class="comment">//清空 表</span></span><br><span class="line">    <span class="keyword">return</span> head; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求表长</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">get_leng_seqlist</span><span class="params">(seqlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;last+<span class="number">1</span>;  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">seqlist_is_empty</span><span class="params">(seqlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((head-&gt;last == <span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>);  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">seqlist_is_full</span><span class="params">(seqlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((head-&gt;last+<span class="number">1</span> == SIZE)?<span class="number">1</span>:<span class="number">0</span>);  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_by_pos_seqlist</span><span class="params">(seqlist* head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) perr_exit(<span class="string">&quot;insert_by_pos_seqlist:&quot;</span>);  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_full(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; head-&gt;last+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//挪位置</span></span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i=head-&gt;last+<span class="number">1</span>; i&gt;pos; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;data[i] = head-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    head-&gt;data[pos] = value;</span><br><span class="line">    <span class="comment">//更新 last </span></span><br><span class="line">        head-&gt;last++; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置 查询</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">find_by_pos_seqlist</span><span class="params">(seqlist *head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_empty(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt;head-&gt;last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;data[pos]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按值 查询</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_by_data_seqlist</span><span class="params">(seqlist *head, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_empty(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;= head-&gt;last; i++) <span class="comment">// 0-5 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;data[i] == val)</span><br><span class="line">            <span class="keyword">return</span> i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置 修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change_by_pos_seqlist</span><span class="params">(seqlist* head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_empty(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt;head-&gt;last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    head-&gt;data[pos] = new_val; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置 删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_by_pos_seqlist</span><span class="params">(seqlist *head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;;  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(seqlist_is_empty(head) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; head-&gt;last) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//挪位置 并覆盖删除</span></span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i=pos; i&lt;head-&gt;last; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;data[i] = head-&gt;data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新 last </span></span><br><span class="line">        head-&gt;last--; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_seqlist</span><span class="params">(seqlist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==head) <span class="keyword">return</span> ;</span><br><span class="line">    head-&gt;last = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">destory_seqlist</span><span class="params">(seqlist **head)</span> <span class="comment">// 为什么要用2级指针 看 3_getmem_point.c</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(*head);</span><br><span class="line">    *head = <span class="literal">NULL</span>; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印看结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prn</span><span class="params">(seqlist *head)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[40;32;5m\033[1m\n&quot;</span>);   <span class="comment">//开启打印颜色</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> len = get_leng_seqlist(head); </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>, head-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\033[40;32;5m\033[0m\n&quot;</span>);   <span class="comment">//关闭打印颜色</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误打印</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    seqlist* head = create_seqlite();</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert_by_pos_seqlist(head, i, i+<span class="number">1</span>); <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    prn(head); </span><br><span class="line">    change_by_pos_seqlist(head, <span class="number">4</span>, <span class="number">666</span>);</span><br><span class="line">    prn(head); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find_by_data_seqlist(head, <span class="number">666</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete_by_pos_seqlist(head, <span class="number">5</span>); </span><br><span class="line">    prn(head); </span><br><span class="line">clear_seqlist(head); </span><br><span class="line">    destory_seqlist(&amp;head);  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<br>
<br>

<hr>
<h2 id="四、指针，函数和空间的关系"><a href="#四、指针，函数和空间的关系" class="headerlink" title="四、指针，函数和空间的关系"></a>四、指针，函数和空间的关系</h2><p>总的来说，就是指针在作为函数的参数进行传参的时候是用的是值传参。也就是说指针之间的传参只是在函数中得到了主函数指针的样本，两个不同的指针指向了同一个地址。<br>先来看一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *create（）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> *p=（<span class="keyword">int</span> *）<span class="built_in">malloc</span>（<span class="keyword">sizeof</span>（<span class="keyword">int</span>））；</span><br><span class="line">    <span class="keyword">return</span> p；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> destory(<span class="keyword">int</span> *p)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">free</span>(p);</span><br><span class="line">     P=<span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = create();</span><br><span class="line">    destory(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这一段代码有个问题，就是在destory()中创建一个指针，这个指针指向的是和main()中的p指针指向的同一个空间。在释放了空间后，destory()中的指针空了，但是mian()中的指针还在，并且因为空间被释放了所以变成了野指针。</p>
<p>再来看另一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">&#125;st; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmem</span><span class="params">(<span class="keyword">int</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *s = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getmem_2</span><span class="params">(<span class="keyword">int</span> **s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *s = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *(<span class="keyword">int</span> *)*s = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st *p = (st*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="comment">//getmem(p-&gt;a); //指针变量名 不能改变实参</span></span><br><span class="line">    getmem_2(&amp;(p-&gt;a)); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(p-&gt;a)); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>getmem()函数是错误的，因为是在getmem()函数中创建了一个指针，然后让该指针指向了一个开辟的空间，但是主函数的指针并没有指向该空间而处于未初始化的状态。</p>
<p>要想用主函数里的指针开辟空间，就要在函数中用到二级指针来传递主函数指针的地址</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>day23-链表</title>
    <url>/2023/03/23/day23-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="day23-链表"><a href="#day23-链表" class="headerlink" title="day23-链表"></a><font color="green">day23-链表</font></h1><h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><p>链表是一种常见的数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。</p>
<p>链表可以分为单向链表和双向链表两种类型。在单向链表中，每个节点只包含一个指向下一个节点的指针，而在双向链表中，每个节点同时包含指向上一个节点和下一个节点的指针。</p>
<p>相比于数组，链表的一个重要优势是可以动态地增加和删除节点，而不需要移动整个数据结构中的其他元素。但是，链表的访问效率较低，因为需要遍历整个链表才能找到所需节点。</p>
<a id="more"></a>
<br>
<br>

<hr>
<h2 id="二、链表图解"><a href="#二、链表图解" class="headerlink" title="二、链表图解"></a>二、链表图解</h2><h3 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h3><p><img src="/2023/03/23/day23-%E9%93%BE%E8%A1%A8/lianbiao.jpg" alt="链表"></p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><img src="/2023/03/23/day23-%E9%93%BE%E8%A1%A8/charu.jpg" alt="链表"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><img src="/2023/03/23/day23-%E9%93%BE%E8%A1%A8/shanchu.jpg" alt="链表"></p>
<br>
<br>

<hr>
<h2 id="三、链表的代码实现"><a href="#三、链表的代码实现" class="headerlink" title="三、链表的代码实现"></a>三、链表的代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;linklist.h&quot;</span></span></span><br><span class="line"><span class="comment">//创建链表的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">data_t</span> data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">next</span>;</span> <span class="comment">//next 域</span></span><br><span class="line">&#125;linklist; </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表头节点</span></span><br><span class="line"><span class="function">linklist* <span class="title">create_linklist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    linklist* head = (linklist*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;data = <span class="number">-1</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linklist_is_empty</span><span class="params">(linklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((head-&gt;next == <span class="literal">NULL</span>) ?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求有效节点个数(求长度)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num_linklist</span><span class="params">(linklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    linklist *p = head-&gt;next; <span class="comment">//定义p指针指向第一个有效节点</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)  <span class="comment">//循环遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        num++;              <span class="comment">//统计节点数</span></span><br><span class="line">        p = p-&gt;next;        <span class="comment">//p指针向后偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_head_linklist</span><span class="params">(linklist* head, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备new 节点</span></span><br><span class="line">    linklist *<span class="keyword">new</span>  = (linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = val; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//头插法 插入</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = head-&gt;next; </span><br><span class="line">    head-&gt;next = <span class="keyword">new</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_by_pos_linklist</span><span class="params">(linklist *head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_linklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备new 节点 和p 指针 </span></span><br><span class="line">    linklist* p = head; </span><br><span class="line">    linklist* <span class="keyword">new</span> = (linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = val;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将p 找到pos-1的位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="comment">//将新节点插入pos 位置</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next   = <span class="keyword">new</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change_by_pos_linklist</span><span class="params">(linklist*head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> new_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(linklist_is_empty(head)== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_linklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    linklist* p = head-&gt;next; </span><br><span class="line">    <span class="comment">//找到pos 位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--)  </span><br><span class="line">        p   = p-&gt;next;</span><br><span class="line">    p-&gt;data = new_val;  <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//按位置查询</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">find_by_pos_linklist</span><span class="params">(linklist*head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(linklist_is_empty(head)== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_linklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    linklist* p = head-&gt;next; </span><br><span class="line">    <span class="comment">//找到pos 位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--)  </span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;data; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_by_pos_linklist</span><span class="params">(linklist* head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(linklist_is_empty(head)== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_linklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备p 指向pos-1， q 指向要删除的pos 节点</span></span><br><span class="line">    linklist* p = head;</span><br><span class="line">    linklist* q = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//找到pos -1位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--) </span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    p-&gt;next = q-&gt;next; </span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="built_in">free</span>(q); </span><br><span class="line">    q = <span class="literal">NULL</span>; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印有效节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(linklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span>;</span><br><span class="line">    linklist *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-4d&quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clear_linklist</span><span class="params">(linklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    linklist *p = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    linklist* q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next; <span class="comment">//q 偏移</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;  <span class="comment">//p 向后偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">destory_linklist</span><span class="params">(linklist** head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(*head);</span><br><span class="line">    head = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命令行模式下：gg=GG 自动缩进</span></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="四、单向循环链表"><a href="#四、单向循环链表" class="headerlink" title="四、单向循环链表"></a>四、单向循环链表</h2><p>即把链表代码中表示的最后一位的NULL都改为head就行。</p>
<br>
<br>

<hr>
<h2 id="五、双向链表"><a href="#五、双向链表" class="headerlink" title="五、双向链表"></a>五、双向链表</h2><p>双向链表的主要不同点便是</p>
<ol>
<li>头插法插入时要判断后面是否是NULL，按位置插入和删除时要判断是否是尾部</li>
<li>插入的顺序主要分四部：(先右后左，先赋值给new再把原数据指向new)<blockquote>
<p>new-&gt;next=p-&gt;next;<br>p-&gt;next-&gt;piror=new;<br>new-&gt;prior=p;<br>p-&gt;next=new;</p>
</blockquote>
</li>
</ol>
<p>下面是双向链表的c的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dlinklist.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表头节点</span></span><br><span class="line"><span class="function">dlinklist* <span class="title">create_dlinklist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dlinklist* head = (dlinklist*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dlinklist));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;data = <span class="number">-1</span>;</span><br><span class="line">    head-&gt;prior = head-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//head-&gt;prior = NULL; </span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlinklist_is_empty</span><span class="params">(dlinklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ((head-&gt;next == head-&gt;prior) ?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求有效节点个数(求长度)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num_dlinklist</span><span class="params">(dlinklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    dlinklist *p = head-&gt;next; <span class="comment">//定义p指针指向第一个有效节点</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)  <span class="comment">//循环遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        num++;              <span class="comment">//统计节点数</span></span><br><span class="line">        p = p-&gt;next;        <span class="comment">//p指针向后偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_head_dlinklist</span><span class="params">(dlinklist* head, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备new 节点</span></span><br><span class="line">    dlinklist *<span class="keyword">new</span>  = (dlinklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dlinklist));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = val; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//头插法 插入</span></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next   == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = head-&gt;next;</span><br><span class="line">        <span class="keyword">new</span>-&gt;prior = head;</span><br><span class="line">        head-&gt;next = <span class="keyword">new</span>; </span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prior = <span class="keyword">new</span>; </span><br><span class="line">        <span class="keyword">new</span>-&gt;prior = head;</span><br><span class="line">        head-&gt;next = <span class="keyword">new</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印有效节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(dlinklist* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span>;</span><br><span class="line">    dlinklist *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-4d&quot;</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_by_pos_dlinklist</span><span class="params">(dlinklist *head, <span class="keyword">int</span> pos, <span class="keyword">data_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_dlinklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备new 节点 和p 指针 </span></span><br><span class="line">    dlinklist* p = head; </span><br><span class="line">    dlinklist* <span class="keyword">new</span> = (dlinklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dlinklist));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = val;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将p 找到pos-1的位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="comment">//将新节点插入pos 位置</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>) <span class="comment">//尾插</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">        <span class="keyword">new</span>-&gt;prior = p;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">new</span>-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;prior = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">new</span>-&gt;prior = p;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按位置删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_by_pos_dlinklist</span><span class="params">(dlinklist* head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == head) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dlinklist_is_empty(head)== <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//判断位置合法性</span></span><br><span class="line">    <span class="keyword">int</span> len = get_num_dlinklist(head); </span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; len<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//准备p 指向pos-1， q 指向要删除的pos 节点</span></span><br><span class="line">    dlinklist* p = head;</span><br><span class="line">    dlinklist* q = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//找到pos -1位置</span></span><br><span class="line">    <span class="keyword">while</span>(pos--) <span class="comment">// pos -1</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    <span class="comment">//q = p-&gt;next ; </span></span><br><span class="line">    <span class="comment">//if(q-&gt;next == NULL) //尾删</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next-&gt;next == <span class="literal">NULL</span>) <span class="comment">//尾删</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        q = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        q-&gt;next-&gt;prior = p; </span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        q = <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>day25-二叉树</title>
    <url>/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="day25-树"><a href="#day25-树" class="headerlink" title="day25-树"></a><font color="green">day25-树</font></h1><h2 id="一、树的概念"><a href="#一、树的概念" class="headerlink" title="一、树的概念"></a>一、树的概念</h2><h3 id="1-树形结构的形式化"><a href="#1-树形结构的形式化" class="headerlink" title="1. 树形结构的形式化"></a>1. 树形结构的形式化</h3><h4 id="1-1-序偶"><a href="#1-1-序偶" class="headerlink" title="1.1 序偶"></a>1.1 序偶</h4><p>定义：设有两个元素x和y，由x和y构成的序偶记为&lt;x,y&gt;。  </p>
<blockquote>
<p>序偶可以描述有先后顺序要求的一对元素之间的关系，顺序很重要&lt;x,y&gt; $\not =$ &lt;y,x&gt;  </p>
</blockquote>
<h4 id="1-2-树的直接定义"><a href="#1-2-树的直接定义" class="headerlink" title="1.2 树的直接定义"></a>1.2 树的直接定义</h4><p>&emsp;&emsp;树是包括n（n$\geq$0）个元素的集合D，R是D中元素的序偶集合，若D为空，R也为空，此时为空树，否则R满足以下要求：</p>
<ul>
<li>有且仅有一个结点a $\in$ D，不存在任何节点v $\in$ D,v $\not =$ a，使得&lt;v,a&gt; $\in$ R,该结点为树的根。<font color="blue">如果树不为空，则树的根节点是唯一的</font></li>
<li>对于除根结点a以外任一结点u $\in$ D而言，都有且仅有一个结点 v $\in$ D，v $\not =$ u，使得&lt;v,u&gt; $\in$ R成立。<font color="blue">根节点没有前驱，其他结点均有唯一前驱</font></li>
</ul>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AE%9A%E4%B9%89.jpg" alt="树的直接定义"></p>
<a id="more"></a>
<h4 id="1-3-树的递归定义"><a href="#1-3-树的递归定义" class="headerlink" title="1.3 树的递归定义"></a>1.3 树的递归定义</h4><p>&emsp;&emsp;树是包括n个结点的有限集T，若n=0，则该数为空树；否则为非空树，在该非空树中，有且仅有一个特定的称为根的结点（r），其余结点(T-{r})划分成m(m$\geq$0)个互不相交的子集 $ T_1,T_2,…T_m $,其中，每个子集 $T_i$都是树，也称为树根节点r的子树。</p>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89.jpg" alt="树的递归定义"></p>
<h3 id="2-树的基本术语"><a href="#2-树的基本术语" class="headerlink" title="2. 树的基本术语"></a>2. 树的基本术语</h3><p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD1.jpg" alt="树的基本术语"></p>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD4.jpg" alt="树的基本术语"></p>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD5.jpg" alt="树的基本术语"></p>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD6.jpg" alt="树的基本术语"></p>
<p><img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD7.jpg" alt="树的基本术语"></p>
<p>森林：树的集合，0棵或多棵不相交的树组成森林</p>
 <br>
 <br>

<hr>
<h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><p> &emsp;&emsp;定义:二叉树是结点的有限集合，该集合或者为空集，或者是由一个根和两个互不相交的、称为该根的左子树和右子树的二叉树组成。</p>
<ul>
<li>二叉树要分左右顺序</li>
<li>二叉树的每个结点最多只能有2棵子树</li>
</ul>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ol>
<li>性质1：二叉树的第i（i $\geq$ 1）层上至多有 $2^{i-1}$ 个结点。（数学归纳法证明）</li>
<li>性质2：高度为h的二叉树上至多有 $2^h-1$ 个结点</li>
<li>性质3：包含n个节点的二叉树的高度最矮为 $log_2(n+1)$(向上取整) ,最高为n</li>
<li>任一棵二叉树中,若叶节点数量为 $n_0$ ,度为2的节点数量为 $n_2$ ,则有 $n_0=n_2+1$ </li>
</ol>
<h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3><ul>
<li><p>满二叉树:所有结点饱和  </p>
</li>
<li><p>完全二叉树:只有最下面两层结点的度可以小于2,且最下一层的叶节点均依次集中在靠左的位置上,<font color="blue">即除了最后一层结点其它结点都是满的,最后一层可以满也可以只有一个结点,但度为1的结点的子结点必须在左边</font></p>
<blockquote>
<p>设有n个节点的完全二叉树,按照从上到下,从左到右依次编号0-n-1. 则:</p>
<ol>
<li>i&gt;0,则该结点的双亲编号为(i-1)/2向下取整</li>
<li>若2i+1 &lt; n,则该节点的左孩子编号为2i+1,否则该节点无左孩子 </li>
<li>若2i+2 &lt; n,则该节点的右孩子编号为2i+2,否则该节点无右孩子</li>
</ol>
</blockquote>
</li>
<li><p>扩充二叉树:除叶子节点外,其余节点的度必须为2</p>
</li>
</ul>
<h3 id="二叉树ADT"><a href="#二叉树ADT" class="headerlink" title="二叉树ADT"></a>二叉树ADT</h3><ol>
<li>数组存储<br>用完全二叉树的顺序方式存储倒数组对应下标中. 不是完全二叉树就通过添加空结点改造成完全二叉树<br>缺点:可能会存在较大的空间浪费</li>
<li>链表存储<br>创建一个节点的结构体,其中包含该点数据,和该点的左子节点和右子节点<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BtBode</span>&#123;</span></span><br><span class="line">  ElemType element;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span> *<span class="title">lChild</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BtNode</span> *<span class="title">rChild</span>;</span></span><br><span class="line">  <span class="comment">//struct btNode *parent</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">binarytree</span>&#123;</span></span><br><span class="line">  BtNode *root;</span><br><span class="line">&#125;Binary Tree;</span><br></pre></td></tr></table></figure>
<img src="/2023/03/27/day25-%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E8%A1%A8.jpg" alt="二叉树ADT"></li>
</ol>
<p>扩展:在链表结点中增加一个parent指针,令它指向该节点的双亲结点,就可以实现二叉树的双向链表结构</p>
<h3 id="二叉树的基本运算"><a href="#二叉树的基本运算" class="headerlink" title="二叉树的基本运算"></a>二叉树的基本运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造一棵空二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">(BinaryTree *bt)</span></span>&#123;</span><br><span class="line">  bt-&gt;root=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新节点,该节点的数据为x,ln和m为该节点的左右孩子</span></span><br><span class="line"><span class="function">BtNode* <span class="title">NewNode</span><span class="params">(ElemType x,BtNode *ln,BtNode *m)</span></span>&#123;</span><br><span class="line">  BtNode *p=(BtNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Btnode));</span><br><span class="line">  p-&gt;element=x;</span><br><span class="line">  p-&gt;lChild=ln;</span><br><span class="line">  p-&gt;rChild=m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给空的二叉树赋值x,并返回true,如果不是空的二叉树返回false</span></span><br><span class="line"><span class="function">BOOL <span class="title">Root</span><span class="params">(Binary Tree *bt,ElemType x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(bt-&gt;root)&#123;</span><br><span class="line">    x=&amp;bt-&gt;root-&gt;element;<span class="comment">//将root节点的数值的地址赋给x</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造二叉树bt,根节点的值为e,left和right为根的左右子树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeTree</span><span class="params">(BinaryTree *bt,ElemType e,BinaryTree *left,BinaryTree *right)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(bt-&gt;root||left==right) <span class="keyword">return</span>; <span class="comment">//判断bt是否为空树以及左子树和右子树是否相同</span></span><br><span class="line">  bt-&gt;root=NewNode(e,left-&gt;root,right-&gt;root);</span><br><span class="line">  left-&gt;root=right-&gt;root=<span class="literal">NULL</span>; <span class="comment">//左右子树的root已经失去作用,置为NULL.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>day24-栈与队列</title>
    <url>/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="day24-栈与队列"><a href="#day24-栈与队列" class="headerlink" title="day24-栈与队列"></a><font color="green">day24-栈与队列</font></h1><h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>&emsp;&emsp;栈和队列是两种常见的数据结构。它们都是线性结构，但它们的操作方式不同。栈是一种后进先出（LIFO）的数据结构，即最后进入的元素最先被访问。而队列是一种先进先出（FIFO）的数据结构，即最先进入的元素最先被访问。</p>
<p>&emsp;&emsp;在具体实现时，栈和队列也有所不同。栈只在一端进行插入和删除操作，这一端称为栈顶。而队列则在两端进行插入和删除操作，分别称为队头和队尾。</p>
<a id="more"></a>
<h3 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2. 实现方式"></a>2. 实现方式</h3><p>栈和队列的实现方式有很多种，这里我提供一些常见的实现方式。</p>
<p>栈的实现方式：</p>
<ol>
<li>用数组来模拟栈，用top变量表示栈顶元素的下标，用push()方法向栈顶添加元素，用pop()方法弹出栈顶元素。</li>
<li>用链表来模拟栈，用head指针表示栈顶元素，用push()方法向栈顶添加元素，用pop()方法弹出栈顶元素。</li>
<li>用双端队列（deque）来模拟栈，用append()方法向栈顶添加元素，用pop()方法弹出栈顶元素。</li>
</ol>
<p>队列的实现方式：</p>
<ol>
<li>用数组来模拟队列，用front和rear变量分别表示队头和队尾的下标，用push()方法向队尾添加元素，用pop()方法弹出队头元素。为了节省空间，常用循环队列来存放数据。循环队列的核心在于<code>求余%</code></li>
<li>用链表来模拟队列，用head和tail指针分别表示队头和队尾元素，用push()方法向队尾添加元素，用pop()方法弹出队头元素。</li>
<li>用两个栈来模拟队列，一个栈作为输入栈，一个栈作为输出栈。当需要弹出队头元素时，如果输出栈为空，则将输入栈中的所有元素依次弹出并压入输出栈中；否则直接从输出栈中弹出。</li>
</ol>
<blockquote>
<p>注：队列可以分为两种模式：</p>
<blockquote>
<ol>
<li>front存第一个数据，rear指向最后一个数据的下一个位置。数据是从0开始存的。</li>
<li>fornt指向第一个数据的上一个位置，rear存最后一个数据。数据是从1开始存的。</li>
</ol>
</blockquote>
</blockquote>
<h3 id="3-结构图解"><a href="#3-结构图解" class="headerlink" title="3. 结构图解"></a>3. 结构图解</h3><h4 id="栈的实现图解"><a href="#栈的实现图解" class="headerlink" title="栈的实现图解"></a>栈的实现图解</h4><ol>
<li>数组栈</li>
</ol>
<p><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/zhan.jpg" alt="数组栈"></p>
<ol start="2">
<li>链表栈   </li>
</ol>
<p>入栈<br><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/jinzhan_lian.gif" alt="链表入栈">  </p>
<p>出栈<br><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/chuzhan_lian.gif" alt="链表入栈"></p>
<h4 id="队列的实现图解"><a href="#队列的实现图解" class="headerlink" title="队列的实现图解"></a>队列的实现图解</h4><ol>
<li>数组队列(用的1的模式)</li>
</ol>
<p><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/duilie_shuzu.jpg" alt="数组队列">  </p>
<ol start="2">
<li>链表队列</li>
</ol>
<p><img src="/2023/03/27/day24-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/duilie_lianbiao.jpg" alt="数组队列"></p>
<br>
<br>

<hr>
<h2 id="二、栈与队列的c语言实现"><a href="#二、栈与队列的c语言实现" class="headerlink" title="二、栈与队列的c语言实现"></a>二、栈与队列的c语言实现</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造顺序栈类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">data_t</span> data[SIZE];<span class="comment">//顺序栈</span></span><br><span class="line">	<span class="keyword">int</span> top;<span class="comment">//保存栈顶元素的下标</span></span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空栈</span></span><br><span class="line"><span class="function"><span class="built_in">stack</span> *<span class="title">createSeqstack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">stack</span> *sq = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));<span class="comment">//给顺序栈开空间</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">memset</span>(sq-&gt;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(sq-&gt;data));<span class="comment">//清空顺序栈</span></span><br><span class="line">	sq-&gt;top = <span class="number">-1</span>;<span class="comment">//说明栈中无元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqstack_is_empty</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ((sq-&gt;top == <span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seqstack_is_full</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ((sq-&gt;top == SIZE<span class="number">-1</span>)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求栈中元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLengthStack</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sq == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> (sq-&gt;top+<span class="number">1</span>);</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pushStack</span><span class="params">(<span class="built_in">stack</span> *sq, <span class="keyword">data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(seqstack_is_full(sq))<span class="comment">//判满</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	sq-&gt;data[sq-&gt;top+<span class="number">1</span>] = data;</span><br><span class="line">	sq-&gt;top++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">popStack</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sq == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(seqstack_is_empty(sq))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">data_t</span> data = sq-&gt;data[sq-&gt;top];<span class="comment">//data变量保存栈顶元素的值</span></span><br><span class="line">	sq-&gt;top--;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印栈中元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(<span class="built_in">stack</span> *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(seqstack_is_empty(sq))</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=sq-&gt;top;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sq-&gt;data[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>
<br>

<h3 id="链表栈"><a href="#链表栈" class="headerlink" title="链表栈"></a>链表栈</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造链式栈节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">data_t</span> data;<span class="comment">//节点的数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span><span class="comment">//保存下一个节点的地址</span></span><br><span class="line">&#125;lstack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空链式栈</span></span><br><span class="line"><span class="function">lstack *<span class="title">createLstack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lstack *top = (lstack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lstack));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	top-&gt;data = <span class="number">-1</span>;</span><br><span class="line">	top-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstack_is_empty</span><span class="params">(lstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ((top-&gt;next == <span class="literal">NULL</span>)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求栈中节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLengthLstack</span><span class="params">(lstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	lstack *p = top-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pushLstack</span><span class="params">(lstack *top, <span class="keyword">data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	lstack *<span class="keyword">new</span> = (lstack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lstack));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">new</span>-&gt;data = data;</span><br><span class="line">	<span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将 new节点插入到栈顶位置，即  pos=0 位置处</span></span><br><span class="line">	<span class="keyword">new</span>-&gt;next = top-&gt;next;</span><br><span class="line">	top-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">popLstack</span><span class="params">(lstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(lstack_is_empty(top))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	lstack *p = top-&gt;next;<span class="comment">//p指针保存的是栈顶元素的地址</span></span><br><span class="line">	<span class="keyword">data_t</span> data = p-&gt;data;<span class="comment">//data变量保存的是栈顶节点的值</span></span><br><span class="line">	top-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印栈中各个节点的data值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfLstack</span><span class="params">(lstack *top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == top)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(lstack_is_empty(top))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	lstack *p = top-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>
<br>
<br>

<h3 id="数组队列-求余思想"><a href="#数组队列-求余思想" class="headerlink" title="数组队列(求余思想)"></a>数组队列(求余思想)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">data_t</span> data[SIZE];</span><br><span class="line">	<span class="keyword">int</span> front; <span class="comment">//对头元素的位置</span></span><br><span class="line">	<span class="keyword">int</span> rear; <span class="comment">//队尾元素的下一个位置</span></span><br><span class="line">&#125;squeue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="function">squeue *<span class="title">createSqueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	squeue *sq = (squeue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(squeue));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(sq-&gt;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(sq-&gt;data));</span><br><span class="line"></span><br><span class="line">	sq-&gt;front = sq-&gt;rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squeue_is_empty</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ((sq-&gt;front == sq-&gt;rear)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判满</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squeue_is_full</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (sq-&gt;front == (sq-&gt;rear+<span class="number">1</span>)%SIZE )?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squeue_length</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	int num= 0;</span></span><br><span class="line"><span class="comment">	int temp = sq-&gt;front;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	while(temp != sq-&gt;rear)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		num++;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">		temp = (temp+1)%SIZE;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	return num;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">return</span> (sq-&gt;rear  + SIZE  -  sq-&gt;front)%SIZE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队, 在队尾进行入队操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">squeue_in</span><span class="params">(squeue *sq, <span class="keyword">data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(sq-&gt;rear != <span class="number">0</span> &amp;&amp; sq-&gt;rear%(SIZE<span class="number">-1</span>)==<span class="number">0</span>)</span><br><span class="line">		sq-&gt;rear = (sq-&gt;rear+<span class="number">1</span>)%SIZE;</span><br><span class="line"></span><br><span class="line">	sq-&gt;data[sq-&gt;rear] = data;</span><br><span class="line"></span><br><span class="line">	sq-&gt;rear = (sq-&gt;rear+<span class="number">1</span>)%SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">squeue_out</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(squeue_is_empty(sq) == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">data_t</span> data = sq-&gt;data[sq-&gt;front];</span><br><span class="line"></span><br><span class="line">	sq-&gt;front = (sq-&gt;front+<span class="number">1</span>)%SIZE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispalySqueue</span><span class="params">(squeue *sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == sq)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> temp = sq-&gt;front;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(temp != sq-&gt;rear)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sq-&gt;data[temp]);</span><br><span class="line">	</span><br><span class="line">		temp = (temp+<span class="number">1</span>)%SIZE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<br>
<br>
<br>

<h3 id="链表队列"><a href="#链表队列" class="headerlink" title="链表队列"></a>链表队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">data_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;linklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	linklist *front; <span class="comment">//指向对头元素的前一个位置</span></span><br><span class="line">	linklist *rear; <span class="comment">//指向队尾元素的位置</span></span><br><span class="line">&#125;lqueue;</span><br><span class="line"></span><br><span class="line"><span class="function">lqueue *<span class="title">createLqueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	lqueue *lq = (lqueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lqueue));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	lq-&gt;front = (linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist)); <span class="comment">//返回头结点的地址</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq-&gt;front)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	lq-&gt;rear = lq-&gt;front;</span><br><span class="line"></span><br><span class="line">	lq-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> lq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lqueue_is_empty</span><span class="params">(lqueue *lq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (lq-&gt;front == lq-&gt;rear)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lqueue_length</span><span class="params">(lqueue *lq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	linklist *p = lq-&gt;front-&gt;next; <span class="comment">//p指向第一个有效结点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		num++;</span><br><span class="line"></span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lqueue_in</span><span class="params">(lqueue *lq, <span class="keyword">data_t</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	linklist *<span class="keyword">new</span> = (linklist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == <span class="keyword">new</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span>-&gt;data = data;</span><br><span class="line">	<span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	lq-&gt;rear-&gt;next = <span class="keyword">new</span>; </span><br><span class="line"></span><br><span class="line">	lq-&gt;rear = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">data_t</span> <span class="title">lqueue_out</span><span class="params">(lqueue *lq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lqueue_is_empty(lq))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	linklist *p = lq-&gt;front-&gt;next; <span class="comment">//指向对头元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">data_t</span> data = p-&gt;data;</span><br><span class="line"></span><br><span class="line">	lq-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(lq-&gt;front-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">		lq-&gt;front == lq-&gt;rear;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayLqueue</span><span class="params">(lqueue *lq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == lq)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	linklist *p = lq-&gt;front-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line"></span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>栈，队列</tag>
      </tags>
  </entry>
  <entry>
    <title>day27.5-静态库，动态库</title>
    <url>/2023/04/05/day27-5-%E9%9D%99%E6%80%81%E5%BA%93%EF%BC%8C%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<h1 id="day27-5-静态库，动态库"><a href="#day27-5-静态库，动态库" class="headerlink" title="day27.5-静态库，动态库"></a><font color="green">day27.5-静态库，动态库</font></h1><hr>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>c语言程序编译的步骤（源文件到可执行文件的编译）：</p>
<blockquote>
<p>预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接</p>
</blockquote>
<a id="more"></a>

<p>预处理：是使用预编译器cpp进行处理.c源文件和.h头文件，最终生成一个.i的文件。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line">或</span><br><span class="line">cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure>
<p>编译：是将<code>预处理</code>完的文件进行一系列的词法分析、语法分析、语义分析及优化，最后生成 .s 汇编代码文件。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>
<p>汇编：将汇编代码转变成机器可以执行的指令， 每一条汇编代码几乎都对应着一条机器指令。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o 或者 as hello.s -o hello.o</span><br></pre></td></tr></table></figure>

<p>链接：链接的作用就是我们这篇文章的重点，就是将我们编译出来的<code>目标文件</code>和我们代码所用到的<code>库文件</code>一起打包成一个<code>可执行文件</code>的过程。例如hello.c中的打印函数printf，这个函数不是凭空出现的，在链接的过程中就要连同对应库文件一起打包，最终可执行文件才能正常运行。</p>
<p><img src="/2023/04/05/day27-5-%E9%9D%99%E6%80%81%E5%BA%93%EF%BC%8C%E5%8A%A8%E6%80%81%E5%BA%93/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg" alt="编译"></p>
<br>
<br>

<hr>
<h2 id="二、静态库与动态库概念"><a href="#二、静态库与动态库概念" class="headerlink" title="二、静态库与动态库概念"></a>二、静态库与动态库概念</h2><h3 id="2-1-C头文件的编译"><a href="#2-1-C头文件的编译" class="headerlink" title="2.1 C头文件的编译"></a>2.1 C头文件的编译</h3><p>对于&lt;&gt;文件，gcc会在系统预设包含文件目录(如/usr/include)中搜寻相应的文件</p>
<blockquote>
<p> cpp-v：查看默认搜索头文件路径<br>对于””文件，gcc会首先当前目录中搜寻头文件，如没有则需要在编译选项中使用<code>-I 头文件所在目录</code> 到指定的目录下寻找头文件</p>
</blockquote>
<h3 id="2-2-库的概念"><a href="#2-2-库的概念" class="headerlink" title="2.2 库的概念"></a>2.2 库的概念</h3><ul>
<li><p>库函数：由某些组织或机构提供的，应用程序员可以直接调用。如Printf等</p>
</li>
<li><p>库：若干个函数的可执行代码，打包为库文件，提供了系统调用和c库的基本函数。</p>
</li>
<li><p>静态库：把需要的.c文件做出一个.a库文件，gcc编译时直接编译进可执行文件中。就只需要链接这个库文件。会让可执行文件变大。而且如果库文件更新了，可执行文件就需要重新编译</p>
</li>
<li><p>动态库：把需要的.c文件做出一个.so库文件，动态库中的代码是可执行文件在运行中加载执行的，gcc编译时不会编译进可执行的文件中。而是留好了记号，库文件更新了，可执行文件不用重新编译。</p>
</li>
</ul>
<br>
<br>

<hr>
<h2 id="三、静态库和动态库的使用"><a href="#三、静态库和动态库的使用" class="headerlink" title="三、静态库和动态库的使用"></a>三、静态库和动态库的使用</h2><h3 id="3-1-静态库"><a href="#3-1-静态库" class="headerlink" title="3.1 静态库"></a>3.1 静态库</h3><ul>
<li><p>生成静态库：</p>
<blockquote>
<ol>
<li>把库函数所属的.c文件编译成.o文件</li>
<li>用ar命令归档，生成文件libmyc.a。<code>ar -rc &lt;生成的档案文件名&gt; &lt;.o文件名列表&gt;</code>(一般取名是  <code>lib+名字+.a</code>)</li>
</ol>
</blockquote>
</li>
<li><p>使用静态库<br>假设头文件在includes目录中，生成的libmymath.a库在libs中</p>
<blockquote>
<ol>
<li>编译头文件：<code>gcc -c -I ./includes</code></li>
<li>链接静态库：<code>gcc -o main.o -L ./libs -lmymath</code> (链接库的名字时只需要<code>-l+名字</code>，不用加前面的lib)</li>
</ol>
</blockquote>
</li>
<li><p>用makefile实现</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ALL := main                          <span class="comment"># := 是递归赋值，即使变量已经被赋值了还能赋值</span></span><br><span class="line">CC := gcc</span><br><span class="line">CFLAGS := -Wall -g -I ./includes/    <span class="comment">#wall：显示所有警告信息 -g：编译时生成调试信息 “-I ./includes/”表示将当前目录下的“includes”文件夹添加到头文件搜索路径中</span></span><br><span class="line">LDFLAGS := -L ./libs -lmamath        <span class="comment">#-L ./libs -lymamath”。其中，“-L ./libs”表示将当前目录下的“libs”文件夹添加到链接库搜索路径中，“-lymamath”表示链接名为“libymamath.so”的库文件。</span></span><br><span class="line">SRC := $(wildcard *.c)               <span class="comment">#用“wildcard”函获取当前目录下的所有.c文件</span></span><br><span class="line">OBJ := $(patsubst %.c, %.o , $(SRC)) <span class="comment">#用“patsubst”函数将变量SRC中的每个文件名中的“.c”替换为“.o”</span></span><br><span class="line">$(ALL) : $(OBJ)</span><br><span class="line">    $(CC) -o <span class="variable">$@</span> $^ $(LDFLAGS)        <span class="comment">#$@”表示规则的目标文件，“$^”表示规则的所有依赖文件。</span></span><br><span class="line">%.o : %.c</span><br><span class="line">    $(CC) -c $&lt; $(CFLAGS)            <span class="comment">#编译所有的C源文件，生成对应的目标文件,其中$&lt;表示的是第一个依赖文件，也就是当前正在被编译的c源文件</span></span><br><span class="line">clean:</span><br><span class="line">    rm main *.o</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-动态库"><a href="#3-2-动态库" class="headerlink" title="3.2 动态库"></a>3.2 动态库</h3></li>
<li><p>动态库的封装</p>
</li>
</ul>
<blockquote>
<p>对要封装的.c文件（假设是mymath.c）使用指令：<code>gcc -o libmymath.so -shared -fPIC mymath.c</code></p>
</blockquote>
<ul>
<li>动态库的使用</li>
</ul>
<blockquote>
<p>编译：和静态库差不多，编译头文件：<code>gcc -c -I ./includes</code><br>再编译动态库：<code>gcc -o main.o -L ./libs -lmymath</code>(记得去掉打头的lib和结尾的.so)<br>运行：先把编译的库的目录加入到环境变量中（设库目录是./libs）：<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./libs</code>(将./libs追加到环境变量的后面)。再启动执行文件</p>
</blockquote>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>c，封装</tag>
      </tags>
  </entry>
  <entry>
    <title>day26-图</title>
    <url>/2023/04/01/day26-%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="day26-图"><a href="#day26-图" class="headerlink" title="day26-图"></a><font color="green">day26-图</font></h1>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>day29-网络编程简介</title>
    <url>/2023/04/10/day29-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="day29-网络编程简介"><a href="#day29-网络编程简介" class="headerlink" title="day29-网络编程简介"></a><font color="green">day29-网络编程简介</font></h1><a id="more"></a>

<h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1-共享内存"><a href="#1-共享内存" class="headerlink" title="1. 共享内存"></a>1. 共享内存</h3><h4 id="1-1-共享内存通信流程"><a href="#1-1-共享内存通信流程" class="headerlink" title="1.1 共享内存通信流程"></a>1.1 共享内存通信流程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、生成key值</span></span><br><span class="line"><span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;a&#x27;</span>);  </span><br><span class="line"><span class="comment">//2、创建共享内存</span></span><br><span class="line"><span class="keyword">int</span> shmid = shmget(key, <span class="number">512</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line"><span class="comment">//3、内存映射</span></span><br><span class="line"><span class="keyword">void</span> *buf = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//4、数据读写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5、取消映射</span></span><br><span class="line">shmdt(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6、删除共享内存</span></span><br><span class="line">shmctl(shmid, IPC_RMID， <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>



<h3 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h3><h5 id="2-1-消息队列的执行过程"><a href="#2-1-消息队列的执行过程" class="headerlink" title="2.1 消息队列的执行过程"></a>2.1 消息队列的执行过程</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建消息队列</span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line">		参数：</span><br><span class="line">            key：</span><br><span class="line">            	ftok得到的key值或者 IPC_PRIVATE(创建私有的消息队列)</span><br><span class="line">            msgflg：</span><br><span class="line">            	IPC_CREAT | <span class="number">0664</span></span><br><span class="line">		返回值：</span><br><span class="line">            成功返回消息队列id，失败返回<span class="number">-1</span>；</span><br><span class="line">    </span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>; </span><br><span class="line">		参数：</span><br><span class="line">            smqid：</span><br><span class="line">            	创建或者打开消息队列得到的id号</span><br><span class="line">            msgp：</span><br><span class="line">            	是一个结构体指针，类型为<span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> *， 表示为发送消息结构体的首地址</span></span><br><span class="line"><span class="class">            <span class="title">msgsz</span>：</span></span><br><span class="line"><span class="class">            	消息正文内容的大小</span></span><br><span class="line"><span class="class">            <span class="title">msgflg</span>：</span></span><br><span class="line"><span class="class">            	0:</span>阻塞方式发送</span><br><span class="line">                IPC_NOWAIT：以非阻塞方式发送</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">               <span class="keyword">long</span> mtype;       <span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">               <span class="keyword">char</span> mtext[<span class="number">1</span>];    <span class="comment">/* message data */</span></span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">	 例：</span><br><span class="line">         <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>   //定义消息结构体</span></span><br><span class="line"><span class="class">         &#123;</span></span><br><span class="line">             <span class="keyword">long</span> mtype;</span><br><span class="line">             <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">         &#125;MSG;</span><br><span class="line"></span><br><span class="line">         <span class="meta">#<span class="meta-keyword">define</span> LEN (sizeof(MSG)-sizeof(long))  <span class="comment">//计算消息正文内容大小</span></span></span><br><span class="line"></span><br><span class="line">		 MSG msg;  <span class="comment">//定义消息结构体变量</span></span><br><span class="line">		 <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">			msg.mtype = <span class="number">100</span>;  <span class="comment">//封装消息类型</span></span><br><span class="line">		 	fgets(msg.mtext, <span class="number">1024</span>, <span class="built_in">stdin</span>);  <span class="comment">//输入消息正文</span></span><br><span class="line">		 	msg.mtext[<span class="built_in">strlen</span>(msg.mtext)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">         	msgsnd(id, &amp;msg， LEN, <span class="number">0</span>);  <span class="comment">//发送消息</span></span><br><span class="line">         &#125;   	</span><br><span class="line"><span class="comment">//接收消息</span></span><br><span class="line">       <span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line">		参数：</span><br><span class="line">            msgtyp：接收消息的类型</span><br><span class="line">    </span><br><span class="line"><span class="comment">//删除消息队列</span></span><br><span class="line">msgctl()            </span><br><span class="line">    </span><br></pre></td></tr></table></figure>





<h3 id="3-信号灯集"><a href="#3-信号灯集" class="headerlink" title="3. 信号灯集"></a>3. 信号灯集</h3><h5 id="3-1-相关接口函数"><a href="#3-1-相关接口函数" class="headerlink" title="3.1 相关接口函数"></a>3.1 相关接口函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建信号灯集</span></span><br><span class="line"><span class="keyword">int</span> semid = semget()    </span><br><span class="line"><span class="comment">//初始化信号灯集</span></span><br><span class="line"><span class="keyword">union</span> semun un;</span><br><span class="line">un.val = <span class="number">1</span>;</span><br><span class="line">semctl(semid, <span class="number">0</span>, SETVAL, un);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//PV操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">buf.sem_num = <span class="number">0</span>;  <span class="comment">//操作的信号灯的编号</span></span><br><span class="line">buf.sem_op = <span class="number">1</span>;   <span class="comment">//设置为V操作</span></span><br><span class="line">buf.sem_flag = IPC_NOWAIT; </span><br><span class="line">semop(semid, &amp;buf, <span class="number">1</span>); <span class="comment">//对信号灯集中第一个信号量进行V操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除信号灯集</span></span><br><span class="line">semctl(semid， <span class="number">0</span>, IPC_RMID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="二、网络编程"><a href="#二、网络编程" class="headerlink" title="二、网络编程"></a>二、网络编程</h2><h3 id="1-性能指标"><a href="#1-性能指标" class="headerlink" title="1. 性能指标"></a>1. 性能指标</h3><p>计算机网络的性能指标是用来衡量网络的质量和效率的一些量化的标准。根据1和2，常用的性能指标有以下几种：</p>
<ul>
<li>速率：连接在计算机网络上的主机在数字信道上传送数据的速率，单位是b/s（比特每秒）。</li>
<li>带宽：网络通信线路传送数据的能力，表示在单位时间内网络中某信道所能通过的“最高数据率”，单位也是b/s。</li>
<li>吞吐量：单位时间内通过网络的数据量，受网络的带宽或网络的额定速率的限制，单位也是b/s。</li>
<li>时延：数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，单位是s（秒）。时延由以下几个部分组成：<ul>
<li>发送时延：从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间，取决于数据长度和发送速率。</li>
<li>传播时延：电磁波在信道中需要传播一定的距离而花费的时间，取决于电磁波传播速度和链路长度。</li>
<li>处理时延：主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。</li>
<li>排队时延：分组在路由器输入输出队列中排队等待处理所经历的时延，取决于网络中当时的通信量。</li>
</ul>
</li>
<li>时延带宽积：链路的时延带宽积又称为以比特为单位的链路长度，表示该链路上可以容纳的比特数，单位是bit。</li>
<li>往返时间RTT：往返时间表示从发送方发送数据开始，到发送方收到来自接收方的确认（接收方接收到数据之后立即发送确认），总共经历的时间，只考虑信道上的传播时延。</li>
<li>利用率：利用率指出某信道有百分之几的时间是被利用的（有数据通过），分为信道利用率和网络利用率。信道利用率并非越高越好，当某信道的利用率增大时，该信道引起的时延也就迅速增加</li>
</ul>
<p><img src="/2023/04/10/day29-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/xinneng.jpg" alt="xinneng"></p>
<h3 id="2-网络协议模型"><a href="#2-网络协议模型" class="headerlink" title="2. 网络协议模型"></a>2. 网络协议模型</h3><h5 id="OSI七层协议模型-理论化的模型"><a href="#OSI七层协议模型-理论化的模型" class="headerlink" title="OSI七层协议模型(理论化的模型)"></a>OSI七层协议模型(理论化的模型)</h5><p>*应用层：解决通过应用进程的交互来说实现特定网络应用的问题</p>
<p>表示层：信息加密、解密，数据格式转换等操作</p>
<p>会话层：建立通信节点</p>
<p>*传输层：自下而上第一个提供完成端到端服务，解决进程之间基于网络的通信问题</p>
<p>*网络层：路由寻址(ip)  ip：在网络中唯一标识一台主机，解决分组在多个网络上传输的问题</p>
<p>*数据链路层：将物理层接收到的数据，进行帧格式的打包，纠错处理。解决分组在一个网络上的传输问题</p>
<p>*物理层：屏蔽物理硬件差异，光电信号的转换。用来解决使用何种信号来传输比特的问题。</p>
<p>物、数、网、传、会、表、应</p>
<h5 id="网络设备和OSE关系"><a href="#网络设备和OSE关系" class="headerlink" title="网络设备和OSE关系"></a>网络设备和OSE关系</h5><p>路由器的最高功能层是网络层3<br>交换器的最高功能层是数据链路层2<br>集线器的最高功能层是物理层1</p>
<h5 id="TCP-IP四层协议模型"><a href="#TCP-IP四层协议模型" class="headerlink" title="TCP/IP四层协议模型"></a>TCP/IP四层协议模型</h5><p>应用层:http(超文本传输协议)、FTP（文件传输协议）、DNS（域名解析，享受无连接服务）、NFS(网络挂载协议)、SSH（远程登录协议）</p>
<p>传输层：TCP协议、UDP协议，数据包为TCP报文段或UDP用户数据报</p>
<p>网络层：IP协议，数据包为IP数据报。提供的是无连接不可靠的数据报服务。</p>
<p>物理与网络接口层：以太网协议、PPP(拨号协议)、令牌环网、ARP(ip-&gt;mac)、RARP（mac-&gt;ip)，TCP/IP协议并没有在这层规定东西是为了可以互联全世界各种不同的网络接口。数据包为比特流</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tcp协议和udp协议</span><br><span class="line">    共同点：都是传输层的通信协议</span><br><span class="line">	不同点：</span><br><span class="line">    	tcp：面向连接，保证数据安全、可靠、不失序的一种通信协议</span><br><span class="line">    		应用场景：</span><br><span class="line">    			登录相关程序、重要文件</span><br><span class="line">    	udp：无连接，是一种不安全、不可靠的一种通信协议</span><br><span class="line">    		应用场景：</span><br><span class="line">    			流媒体软件、大型的音视频传输    </span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/10/day29-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/tcpip.jpg" alt="tcpip"></p>
<h3 id="3-网络编程预备知识"><a href="#3-网络编程预备知识" class="headerlink" title="3. 网络编程预备知识"></a>3. 网络编程预备知识</h3><h5 id="2-1-IP地址"><a href="#2-1-IP地址" class="headerlink" title="2.1 IP地址"></a>2.1 IP地址</h5><p>​    IP地址在网络中唯一标识一台主机</p>
<p>​    IPV4：32bit 4字节数据</p>
<p>​            点分十进制：”1.1.1.0”</p>
<p>​            二进制：00000001 00000001 00000001 00000000</p>
<p>​    IPV6：128bit</p>
<p>​    MAC：48bit全球唯一标识</p>
<p>​        ARP： ip –&gt; MAC</p>
<p>​        RARP: MAC –&gt; ip</p>
<h5 id="2-2-PORT端口号"><a href="#2-2-PORT端口号" class="headerlink" title="2.2 PORT端口号"></a>2.2 PORT端口号</h5><p>​    一个端口号对应一个进程</p>
<p>​    端口号：2字节，是一个short类型的正整数</p>
<p>​    端口号取值范围：0 ~ 65535</p>
<p>​        0不能使用</p>
<pre><code>     1~1023：系统端口，不能使用</code></pre>
<p>​        1024~5000：一般应用程序</p>
<p>​        5001~65535:系统预留自定义端口</p>
<h5 id="2-3-套接字-–socket"><a href="#2-3-套接字-–socket" class="headerlink" title="2.3 套接字 –socket"></a>2.3 套接字 –socket</h5><p>​    进程间通信的机制之一</p>
<p>​    本质：是一个特殊的文件描述符，是一个按顺序分配的最小的非负整数</p>
<h3 id="2-4-三次握手和四次挥手"><a href="#2-4-三次握手和四次挥手" class="headerlink" title="2.4 三次握手和四次挥手"></a>2.4 三次握手和四次挥手</h3><p>TCP的三次握手和四次挥手实质就是TCP通信的连接和断开。</p>
<p>三次握手：为了对每次发送的数据量进行跟踪与协商，确保数据段的发送和接收同步，根据所接收到的数据量而确认数据发送、接收完毕后何时撤消联系，并建立虚连接。</p>
<p>四次挥手：即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。</p>
<p><img src="/2023/04/10/day29-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B/huishou.jpg" alt="huishou"></p>
<h4 id="2-4-1-三次握手"><a href="#2-4-1-三次握手" class="headerlink" title="2.4.1 三次握手"></a>2.4.1 三次握手</h4><p>TCP协议位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略。</p>
<h5 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h5><blockquote>
<p>第1次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；</p>
<p>第2次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了；</p>
<p>第3次握手：客户端再回传一个带有ACK标志的数据包，表示我知道了，握手结束。</p>
<p>其中：SYN标志位数置1，表示建立TCP连接；ACK标志表示验证字段。</p>
</blockquote>
<h5 id="三次握手详细说明"><a href="#三次握手详细说明" class="headerlink" title="三次握手详细说明"></a>三次握手详细说明</h5><ol>
<li><p>客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）；</p>
</li>
<li><p>服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接；</p>
</li>
<li><p>客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）。</p>
</li>
</ol>
<h4 id="2-4-2-四次挥手"><a href="#2-4-2-四次挥手" class="headerlink" title="2.4.2 四次挥手"></a>2.4.2 四次挥手</h4><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<h5 id="四次挥手​​​​​​​过程："><a href="#四次挥手​​​​​​​过程：" class="headerlink" title="四次挥手​​​​​​​过程："></a>四次挥手​​​​​​​过程：</h5><blockquote>
<p>第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；</p>
<p>第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；</p>
<p>第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；</p>
<p>第4次挥手：客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手。</p>
</blockquote>
<p>其中：FIN标志位数置1，表示断开TCP连接。</p>
<h5 id="四次挥手详细说明"><a href="#四次挥手详细说明" class="headerlink" title="四次挥手详细说明"></a>四次挥手详细说明</h5><ol>
<li><p>客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）；</p>
</li>
<li><p>服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y由服务端随机生成）；</p>
</li>
<li><p>服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输到A的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号。（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）；</p>
</li>
<li><p>客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h为客户端随机生成）<br>至此TCP断开的4次挥手过程完毕。</p>
</li>
</ol>
<h4 id="2-4-3-相关状态名词"><a href="#2-4-3-相关状态名词" class="headerlink" title="2.4.3 相关状态名词"></a>2.4.3 相关状态名词</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">LISTEN：等待从任何远端TCP 和端口的连接请求。</span><br><span class="line"> </span><br><span class="line">SYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。</span><br><span class="line"> </span><br><span class="line">SYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。</span><br><span class="line"> </span><br><span class="line">ESTABLISHED：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。</span><br><span class="line"> </span><br><span class="line">FIN_WAIT_1：等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。</span><br><span class="line"> </span><br><span class="line">FIN_WAIT_2：等待远端TCP 的连接终止请求。</span><br><span class="line"> </span><br><span class="line">CLOSE_WAIT：等待本地用户的连接终止请求。</span><br><span class="line"> </span><br><span class="line">CLOSING：等待远端TCP 的连接终止请求确认。</span><br><span class="line"> </span><br><span class="line">LAST_ACK：等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）</span><br><span class="line"> </span><br><span class="line">TIME_WAIT：等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认。</span><br><span class="line">TIME_WAIT 两个存在的理由：</span><br><span class="line">          1.可靠的实现tcp全双工连接的终止；</span><br><span class="line">          2.允许老的重复分节在网络中消逝。</span><br><span class="line"> </span><br><span class="line">CLOSED：不在连接状态（这是为方便描述假想的状态，实际不存在）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>day33-c++运算符重载</title>
    <url>/2023/04/21/day33-c-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="day33-c-运算符重载"><a href="#day33-c-运算符重载" class="headerlink" title="day33-c++运算符重载"></a><font color="green">day33-c++运算符重载</font></h1><!--mroe-->

<h2 id="一、什么是运算符重载"><a href="#一、什么是运算符重载" class="headerlink" title="一、什么是运算符重载"></a>一、什么是运算符重载</h2><p>运算符重载是一种特殊的函数重载，它允许我们为自定义的类或结构定义新的运算符含义，从而实现不同类型数据之间的操作。例如，我们可以重载加号运算符（+）来实现两个复数或者两个矩阵的相加。</p>
<p>运算符重载的本质是定义一个函数，并告诉c++编译器，当遇到该运算符时就调用此函数来执行相应的操作。这个函数叫做运算符重载函数，它可以是类的成员函数，也可以是类的友元函数。</p>
<h2 id="二、为什么要运算符重载"><a href="#二、为什么要运算符重载" class="headerlink" title="二、为什么要运算符重载"></a>二、为什么要运算符重载</h2><p>运算符重载的目的是为了提高代码的可读性和简洁性，让我们可以用自然的方式表达自定义类型之间的操作。例如，如果我们定义了一个分数类Fraction，我们可以通过重载加号运算符来实现两个分数对象的相加，而不需要调用一个特定的函数。</p>
<h2 id="三、运算符重载形式"><a href="#三、运算符重载形式" class="headerlink" title="三、运算符重载形式"></a>三、运算符重载形式</h2><p>运算符重载函数的一般形式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 <span class="keyword">operator</span> 运算符 (参数列表) &#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，operator是关键字，它与要重载的运算符一起构成函数名。返回值类型和参数列表根据不同的运算符和需求而定。</p>
<p>根据参数个数的不同，我们可以将运算符分为一元运算符和二元运算符。一元运算符只有一个参数，二元运算符有两个参数。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一元运算符 - 的重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>- () &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(-real, -imag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元运算符 + 的重载</span></span><br><span class="line">Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex&amp; c) &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(real + c.real, imag + c.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据定义位置的不同，我们可以将运算符分为类内重载和类外重载。</p>
<ul>
<li>类内重载：将运算符重载函数作为类的成员函数，这样可以直接访问类的私有成员。类内重载的函数通常只有一个参数，表示运算符的右操作数，左操作数默认为调用该函数的对象。</li>
<li>类外重载：将运算符重载函数作为类的友元函数或普通函数，这样需要显式地传递运算符的左右操作数。类外重载的函数通常有两个参数，分别表示运算符的左右操作数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line"><span class="comment">// 类内重载 + 运算符</span></span><br><span class="line">Point <span class="keyword">operator</span>+ (<span class="keyword">const</span> Point&amp; p) &#123;</span><br><span class="line"><span class="keyword">return</span> Point(x + p.x, y + p.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> Point <span class="keyword">operator</span>- (<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外重载 - 运算符</span></span><br><span class="line">Point <span class="keyword">operator</span>- (<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2) &#123;</span><br><span class="line"><span class="keyword">return</span> Point(p1.x - p2.x, p1.y - p2.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，当要操作类中私有成员时就用类内重载或者友员函数重载。当操作公用的成员时就能用类外普通函数重载。</p>
<h2 id="四、运算符重载的分类"><a href="#四、运算符重载的分类" class="headerlink" title="四、运算符重载的分类"></a>四、运算符重载的分类</h2><p>根据运算符操作数的个数，可以将运算符分为一元运算符和二元运算符。</p>
<ul>
<li>一元运算符：只有一个操作数，例如 +、-、*、&amp;、!、++、– 等。一元运算符可以作为前置或后置形式使用，例如 ++a 或 a++。一元运算符重载时，如果是类内重载，则不需要参数；如果是类外重载，则需要一个参数。</li>
<li>二元运算符：有两个操作数，例如 +、-、*、/、%、==、!=、&lt;、&gt; 等。二元运算符重载时，如果是类内重载，则需要一个参数；如果是类外重载，则需要两个参数。</li>
</ul>
<p>另外，还有一些特殊的运算符，例如 ()、[]、-&gt; 等，它们也可以进行重载，但必须作为类的成员函数进行类内重载。</p>
<p>自增分为前自增和后自增，这两个在语法上有一定的区别（后置++的参数要多个占位符<code>int</code>）,输入和输出重载返回值和参数有<code>ostream &amp;</code> 和 <code>istream &amp;</code>。</p>
<p><strong>当返回值是对象时需要用引用返回防止空间浪费</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point&amp; <span class="keyword">operator</span>+ (<span class="keyword">const</span> Point&amp; p) &#123;     <span class="comment">//类内实现操作符重载</span></span><br><span class="line">        Point* temp = <span class="keyword">new</span> Point(x + p.x, y + p.y);</span><br><span class="line">        <span class="keyword">return</span> *temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point&amp; <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;p1, <span class="keyword">const</span> Point &amp;p2) &#123;<span class="comment">//类外友联实现操作符重载</span></span><br><span class="line">        Point* temp = <span class="keyword">new</span> Point(p1.x + p2.x, p1.y + p2.y);</span><br><span class="line">        <span class="keyword">return</span> *temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point&amp; <span class="keyword">operator</span>++ (Point&amp; p1, <span class="keyword">int</span>)&#123; <span class="comment">//后置++</span></span><br><span class="line"></span><br><span class="line">        Point* temp = <span class="keyword">new</span> Point(p1.x++,p1.y++);</span><br><span class="line">        <span class="keyword">return</span> *temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point&amp; <span class="keyword">operator</span>++ (Point&amp; p1)&#123; <span class="comment">//前置++</span></span><br><span class="line"></span><br><span class="line">        Point* temp = <span class="keyword">new</span> Point(++p1.x,++p1.y);</span><br><span class="line">        <span class="keyword">return</span> *temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Point &amp;p) &#123; <span class="comment">//输入重载</span></span><br><span class="line">        os &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,y=&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Point &amp;p) &#123;  <span class="comment">//输出重载</span></span><br><span class="line">        is &gt;&gt; p.x &gt;&gt; p.y;</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//括号重载，不能用友员函数写</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;x +=a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y +=b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">a</span><span class="params">(<span class="number">12</span>,<span class="number">13</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cin</span>  &gt;&gt; a ;</span><br><span class="line">    <span class="function">Point <span class="title">b</span><span class="params">(<span class="number">14</span>,<span class="number">15</span>)</span></span>;</span><br><span class="line">    Point c=b+(a++);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a;</span><br><span class="line">    a(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;c:&quot;</span>&lt;&lt;c;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//14 15</span></span><br><span class="line"><span class="comment">//a:x=15,y=16</span></span><br><span class="line"><span class="comment">//c:x=28,y=30</span></span><br><span class="line"><span class="comment">//a:x=16,y=18</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>重载运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式学习-Linux基础</title>
    <url>/2023/02/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一、linux系统基础"><a href="#一、linux系统基础" class="headerlink" title="一、linux系统基础"></a><font color="green">一、linux系统基础</font></h1><h2 id="1、linux和windows"><a href="#1、linux和windows" class="headerlink" title="1、linux和windows"></a>1、linux和windows</h2><p>​    linux：开源、免费、安全性高、稳定性强、可移植性高</p>
<a id="more"></a>

<h2 id="2、linux操作系统的基本使用"><a href="#2、linux操作系统的基本使用" class="headerlink" title="2、linux操作系统的基本使用"></a>2、linux操作系统的基本使用</h2><h3 id="0-、linux的文件的系统结构"><a href="#0-、linux的文件的系统结构" class="headerlink" title="(0)、linux的文件的系统结构"></a>(0)、linux的文件的系统结构</h3><blockquote>
<ul>
<li>windows：所有文件有分盘(C,D,E,F….)，每个盘中都有子文件或者子目录，对文件存放没有要求，可以放在任意位置</li>
<li>linux：没有分盘，只有一个大的目录–根目录（’/‘），根目录下的文件夹每一个都有其固定作用</li>
<li>bin：存放二进制文件或者可执行程序</li>
<li>dev：存放设备文件</li>
<li>etc：系统相关的配置文件</li>
<li>home：用户目录，用户所有操作都在该目录下进行     /home/hqyj 可以用符号(~)表示</li>
</ul>
</blockquote>
<br>
<br>

<hr>
<h3 id="1-、基本的shell命令"><a href="#1-、基本的shell命令" class="headerlink" title="(1)、基本的shell命令"></a>(1)、基本的shell命令</h3><p>​        shell本质：命令行解释器，将用户输入的特定指令转换为系统能够识别的语言</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    绝对路径：从根目录出发所表示的一个路径</span><br><span class="line">    相对路径：相对于用户当前位置所表示的一个路径</span><br><span class="line"></span><br><span class="line">pwd:显示当前用户在文件系统中的绝对路径</span><br><span class="line">    用法：</span><br><span class="line">    	pwd + 回车</span><br><span class="line">ls:显示当前用户所在路径下的所有文件(不包含隐藏文件)</span><br><span class="line">    用法：</span><br><span class="line">    	ls + 回车</span><br><span class="line">ls -a：显示当前用户所在路径下的所有文件(包含隐藏文件)</span><br><span class="line">    <span class="string">&#x27;.&#x27;</span> == 用户当前目录</span><br><span class="line">    &#x27;..&#x27; == 当前目录的上一级目录</span><br><span class="line">    </span><br><span class="line">ls -l:显示当前用户所在路径下的所有文件的详细信息</span><br><span class="line">    - rw- rw- r--</span><br><span class="line">    第一位代表文件类型：</span><br><span class="line">    	<span class="string">&#x27;-&#x27;</span> :普通文件</span><br><span class="line">    	<span class="string">&#x27;d&#x27;</span> :目录文件</span><br><span class="line">    	<span class="string">&#x27;c&#x27;</span> :字符设备文件</span><br><span class="line">    	<span class="string">&#x27;b&#x27;</span> :块设备文件</span><br><span class="line">    	<span class="string">&#x27;p&#x27;</span> :管道文件</span><br><span class="line">    	<span class="string">&#x27;l&#x27;</span> :符号链接文件</span><br><span class="line">    	<span class="string">&#x27;s&#x27;</span> :套接字文件</span><br><span class="line">            不同操作系统下支持使用的文件类型不同</span><br><span class="line">    	</span><br><span class="line">    后<span class="number">9</span>位代表文件存取权限</span><br><span class="line">         rw-rw-r--  == <span class="number">110</span> <span class="number">110</span> <span class="number">100</span> == <span class="number">0664</span></span><br><span class="line">         权限的前<span class="number">3</span>位表示用户自己的使用权限，如果当前位上没有对应权限用<span class="string">&#x27;-&#x27;</span>表示                      </span><br><span class="line">		 权限的中间<span class="number">3</span>位代表用户组的使用权限        </span><br><span class="line">         权限的最后<span class="number">3</span>位代表其他用户的使用权限</span><br><span class="line">         r -- 具有读权限  w -- 具有写权限  x -- 具有可执行权限</span><br><span class="line">    改变文件权限的命令入下:</span><br><span class="line">         chmod [-R]  xyz  文件或目录</span><br><span class="line">         -R ： 以递归方式进行修改，比如修改某个目录下所有文件的属性。</span><br><span class="line"></span><br><span class="line">cd: 目录跳转	</span><br><span class="line">    用法：</span><br><span class="line">    	cd + 指定路径    </span><br><span class="line"></span><br><span class="line">touch:以不打开的方式创建一个文件，如果文件存在，则修改时间戳</span><br><span class="line">    用法：</span><br><span class="line">    	touch + 文件名</span><br><span class="line">    </span><br><span class="line">rm:删除指定文件</span><br><span class="line">    用法：</span><br><span class="line">    	rm + 文件名</span><br><span class="line">    </span><br><span class="line">cat：显示文件内容</span><br><span class="line">    用法：</span><br><span class="line">    	cat + 文件名</span><br><span class="line">    </span><br><span class="line">cp: 复制文件</span><br><span class="line">    用法：</span><br><span class="line">    	cp + 源文件名 + 路径名</span><br><span class="line">    	cp + 源文件名 + 目标文件名</span><br><span class="line">mv：移动文件</span><br><span class="line">    用法：</span><br><span class="line">    	mv + 源文件名 + 路径名</span><br><span class="line">    	mv + 源文件名 + 目标文件名    </span><br><span class="line"></span><br><span class="line">mkdir: 创建目录</span><br><span class="line">    用法：</span><br><span class="line">    	mkdir + 目录名</span><br><span class="line">    </span><br><span class="line">rmdir: 删除指定目录(空目录)   </span><br><span class="line">    用法：</span><br><span class="line">    	rmdir + 目录名</span><br><span class="line">    </span><br><span class="line">  	删除非空目录：rm -r 目录名</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">clear:清屏    ctrl + l快捷方式也可以清屏</span><br><span class="line">Tab: 命令补全</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h3 id="2-、vim编辑器"><a href="#2-、vim编辑器" class="headerlink" title="(2)、vim编辑器"></a>(2)、vim编辑器</h3><p>shell命令：vi 或者 vim + 文件名  </p>
<p>如果文件不存在，则会先创建再进行编辑</p>
<h4 id="vim编辑器中的三种工作模式："><a href="#vim编辑器中的三种工作模式：" class="headerlink" title="vim编辑器中的三种工作模式："></a>vim编辑器中的三种工作模式：</h4><p>​命令行模式：用户在进入编辑器后默认处于的工作模式</p>
<p>​        在命令行模式下不能直接输入数据，但是可以对文本进行复制、粘贴、剪切、撤销等操作：</p>
<p>​            在命令行模式下输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ngg: 光标跳到某一行首</span><br><span class="line"></span><br><span class="line">nyy：将光标以及光标以下的n行数据进行复制</span><br><span class="line"></span><br><span class="line">ndd：将光标以及光标以下的n行数据进行剪切或删除</span><br><span class="line"></span><br><span class="line">p：将复制或者剪切的内容粘贴到光标的下一行</span><br><span class="line"></span><br><span class="line">u：撤回到上一步操作</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>：当前行首</span><br><span class="line"></span><br><span class="line">$：当前行尾</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    编辑模式：可以对文本进行编辑操作</p>
<p>​        在命令行模式下输入：a, i, o都可以进入编辑模式</p>
<p>​        按Esc退回到命令行模式</p>
<p>​    </p>
<p>​    底行模式：对文本进行保存、退出等操作</p>
<p>​        在命令行模式下输入冒号进入底行模式</p>
<p>​            在底行模式下输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">w：保存文件</span><br><span class="line">q：退出文件</span><br><span class="line">wq：保存并且退出</span><br><span class="line">q！：强制不保存退出</span><br><span class="line">x：保存并且退出</span><br></pre></td></tr></table></figure>

<br>

<h4 id="vim文本查找和替换"><a href="#vim文本查找和替换" class="headerlink" title="vim文本查找和替换"></a>vim文本查找和替换</h4><p>在一般模式下，可以执行以下命令。</p>
<ol>
<li>查找<br>pattern  从光标开始处向文件尾搜索pattern，后按下n或N</li>
</ol>
<p>注意：</p>
<blockquote>
<p>n    在同一个方向重复上一次搜索命令<br>N    在反方向重复上一次搜索命令</p>
</blockquote>
<p>注意：<br>在/pattern之前先跳到第一行则进行全文件搜索。</p>
<ol start="2">
<li>替换<blockquote>
<p>:%s/p1/p2/g   //将文件中所有的p1均用p2替换<br>:%s/p1/p2/gc  //替换时需要确认<br>“s“ 全称：substitute替换；<br>“g“ 全称：global全局；<br>“c“ 全称：confirm，确认</p>
</blockquote>
</li>
</ol>
<h3 id="3-、gcc编译工具"><a href="#3-、gcc编译工具" class="headerlink" title="(3)、gcc编译工具"></a>(3)、gcc编译工具</h3><p>​    shell指令：</p>
<p>​        gcc + c文件名</p>
<p>​        编译成功之后会在当前目录下产生一个名为a.out的二进制可执行程序</p>
<p>​            </p>
<p>​       gcc c文件名 -o 新的二进制可执行文件名</p>
<p>​    </p>
<h3 id="4-、执行程序"><a href="#4-、执行程序" class="headerlink" title="(4)、执行程序"></a>(4)、执行程序</h3><p>​    shell命令：</p>
<p>​        ./可执行的二进制文件名</p>
<p>​        </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析</title>
    <url>/2020/04/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><font color="green">概述</font></h1><p>算法分析是关于计算机程序和资源利用的研究</p>
<h2 id><a href="#" class="headerlink" title></a><a id="more"></a></h2><h1 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a><font color="green">数学模型</font></h1><p>大多数程序得到数学模型所需步骤：</p>
<ol>
<li>确定输入模型，定义问题规模（n）</li>
<li>识别循环与递归</li>
<li>根据内循环或每部递归的操作确定成本模型</li>
<li>对于给定的输入，判断这些操作的执行频率</li>
</ol>
<hr>
<h1 id="两种常见讨论情况"><a href="#两种常见讨论情况" class="headerlink" title="两种常见讨论情况"></a><font color="green">两种常见讨论情况</font></h1><blockquote>
<p>最坏情况：T(n)定义为输入规模为 n 时的最长运行时间<br>平均情况：T(n)定义为输入规模为 n 时所有可能输入的期望值(通常是均匀分布时的情况)</p>
</blockquote>
<p>为了不被硬件因素所影响，对算法的分析采用了 <font color="red">渐进分析</font></p>
<blockquote>
<p>渐进分析：</p>
<ol>
<li>忽略依赖于机器性能的常量</li>
<li>只关注运行时间的增长</li>
</ol>
</blockquote>
<hr>
<br>
<br>

<h1 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a><font color="green">渐进符号</font></h1><h2 id="大-O-记号法：-上界"><a href="#大-O-记号法：-上界" class="headerlink" title="大$O$记号法：(上界)"></a>大$O$记号法：(上界)</h2><p>f(n) = $O$(g(n)) 表示存在适当常数 (c&gt;0 $n_0$&gt;0) 使得 0 &lt;= f(n) &lt;= c*g(n) 其中 n &gt;= $n_0$<br><strong>注：这里的=不是等于的意思，更多是指 f(n) 属于 $O$(g(n)) 集合。 即$O$(g(n))是一个函数集，集合内有 f(n)</strong></p>
<blockquote>
<p>例：$2n^2 = O(n^3)$</p>
</blockquote>
<p>宏展开：<br>&nbsp;&nbsp;&nbsp; 当等式左右两边都存在$O$( )时，这时=相当于$\epsilon$</p>
<blockquote>
<p>例：$n^2+O(n) = O(n^2)$ &gt; &nbsp;&nbsp;&nbsp;对于任意 f(n)$\epsilon O(n)$，都有对应的 h(n)$\epsilon O(n)$<br>注：不能反推</p>
</blockquote>
<h2 id="大-Omega-记号法：-下界"><a href="#大-Omega-记号法：-下界" class="headerlink" title="大 $\Omega$记号法：(下界)"></a>大 $\Omega$记号法：(下界)</h2><p>f(n) = $O$(g(n)) 表示存在适当常数 (c&gt;0 $n_0$&gt;0) 使得 0 &lt;= c*g(n) &lt;= f(n) 其中 n &gt;= $n_0$</p>
<blockquote>
<p>例：$\sqrt{n}=\Omega(\lg n)$</p>
</blockquote>
<h2 id="大-Theta-记号法："><a href="#大-Theta-记号法：" class="headerlink" title="大 $\Theta$记号法："></a>大 $\Theta$记号法：</h2><p>$\Theta(g(n)) = O(g(n)) \bigcap \Omega(g(n))$</p>
<p>理解：左右两边增长速率一样</p>
<p>用法：写个公式，去掉它的低阶项，并忽略前面的常数因子(系数)</p>
<h2 id="严格符号："><a href="#严格符号：" class="headerlink" title="严格符号："></a>严格符号：</h2><p>与渐进符号的区别在于：</p>
<ul>
<li>渐进符号表示渐进符号内的函数在经过某一点后便大于或小于原函数</li>
<li>严格符号表示严格符号内的函数是完全大于或小于原函数</li>
</ul>
<h3 id="o-记号"><a href="#o-记号" class="headerlink" title="o 记号"></a>o 记号</h3><p>f(n)完全小于 o(g(n)),与$O$对应</p>
<h3 id="omega-记号"><a href="#omega-记号" class="headerlink" title="$\omega$记号"></a>$\omega$记号</h3><p>f(n)完全大于$\omega$(g(n))，与$O$对应</p>
<hr>
<br>
<br>

<h1 id="递归式的三种解法"><a href="#递归式的三种解法" class="headerlink" title="递归式的三种解法"></a><font color="green">递归式的三种解法</font></h1><h2 id="补充知识：数学归纳法"><a href="#补充知识：数学归纳法" class="headerlink" title="补充知识：数学归纳法"></a>补充知识：数学归纳法</h2><p>用来证明一个命题在问题规模为 n 时成立</p>
<ol>
<li>证明 n=1 时成立</li>
<li>假设 n=n-1 时成立，如求出(n-1)+1 时成立</li>
<li>则命题成立</li>
</ol>
<h2 id="1-代换法"><a href="#1-代换法" class="headerlink" title="1. 代换法"></a>1. 代换法</h2><ol>
<li>先猜答案得到最高阶</li>
<li>验证这个递归式是否按照数学归纳法满足条件</li>
</ol>
<blockquote>
<p>例：T(n)=4T(n/2)+n</p>
<ol>
<li>(猜)忽略常数 n，由 T(n)=4T(n/2) 可看出当 n 减 2 倍，系数增加 4 倍。$n^2$符合这一标准,假定 T(n)=$O(n^2)$</li>
<li>(证)将递归式展开得 T(n)=$4T(n/2)+n$ &lt;= $cn^2$+n = $cn^2$-(-n)<blockquote>
<p>$O(n^2)$=$c(n)^2$</p>
</blockquote>
</li>
<li>因为要证明的是 T(n)=$O(n^2)$ 所以 T(n) &lt;= $cn^2$-(-n) 中(-n)大于等于 0</li>
</ol>
</blockquote>
<p>但这里发现了因为 n&gt;=1 所以上式不成立。是我们做错了吗，让我们想想有什么办法可以改变这个常数。<br>当我们对 $O(n^2)$ 进行展开时，我们是忽略了常数项的，因为它对 n 为无穷大时作用很小，但作用小就表明还是有一定的作用，我们试着把常数项带进来，即改进 T(n)=$O(n^2)$ 时的条件</p>
<blockquote>
<p>改进：<br>T(n) =$O(n^2)$ &lt;=$c_1n^2-c_2n$ (多了常数项)<br>T(n)=$4T(n/2)+n$ &lt;= $4(c_1(n/2)^2-c_2(n/2))+n=c_1n^2-c_2n-(c_2-1)n$<br>要使 T(n)=$O(n^2)$则要满足$(c_2-1)n$ &gt;= 0 (当$c_2$ &gt;= 1 时成立)<br>并且 T(1) &lt;=$c_1-c_2$ 成立<br>可以得出 T(n+1) &lt;= $c_1(n+1)^2-c_2(n+1)$ (当$c_1&gt;&gt;c_2$时成立)(算一下就出来了)<br>这时条件 T(1)，T(n)和 T(1)推出 T(n+1)都有了<br>最后得出 T(n) = $O(n^2)$</p>
</blockquote>
<h2 id="2-递归树法"><a href="#2-递归树法" class="headerlink" title="2. 递归树法"></a>2. 递归树法</h2><ol>
<li>将递归式按树的形式展开(不用全画出来)(并且每次递归时 n 的和都要减少而不是增大)</li>
<li>根据每层的和的规律，求出总子叶节点<ul>
<li>如果每层和一样，用每层的和乘以树的高度就行<blockquote>
<p>树要对称，高用每次递归式减少的数(每层为等差)或除以的数(每层为等比)来求<br>等差的话 h=n-k+1 (k 为每层 n 减少的数)<br>等比的话 h=$log_kn$ (k 为每层 n 除的数)</p>
</blockquote>
</li>
<li>如果树不对称或者每层和成等比排列，不用求具体值，都是有规律相加的，求其上界就行</li>
</ul>
</li>
<li>判断总子叶节点小于等于某个相近的值，便可求出其最高阶</li>
</ol>
<p>例：<br><img src="/2020/04/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/diGuiShuFa.jpg" alt="递归树"></p>
<h2 id="3-主方法"><a href="#3-主方法" class="headerlink" title="3.主方法"></a>3.主方法</h2><p>相当于套公式，且适用情况少<br>原理是递归树，可以自己去推导下,这三个主要区别是总子叶节点数的判断不同。（1 是因为每层和在增加，最后一层和占主导。2 是因为每层和一样，和乘以高。3 是因为每层和在减少，第一层和占主导）<br>限制：递归式要满足于 $T(n)=aT(n/b)+f(n)$ &nbsp;&nbsp;&nbsp;a&gt;=1,b&gt;1,f(n)渐进趋正<br>主思路：比较 f(n)和$n^{\log_ba}$</p>
<p>1.</p>
<p>若对某个常数 $\varepsilon&gt;0有$<br>$f(n)= \omicron (n^{\log_b{a-\varepsilon} })$<br>那么<br>$T(n)= \theta (n^{log_ba})$</p>
<p>2.</p>
<p>若<br>$f(n)=\theta(n^{log_ba})f(n)$<br>则<br>$T(n)=\theta(n^{log_ba}\lg n)T(n)$</p>
<p>3.</p>
<p>若对某个常数 $\varepsilon&gt;0有$<br>$f(n) = \Omega(n^{\log_b{a+\varepsilon} })f(n)$<br>且对于某个常数 c&lt;1 和所有足够大的 n 有<br>$af(\frac nb)\le cf(n)$<br>则<br>$T(n)=\theta(f(n))T(n)$</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>算法</tag>
        <tag>概念</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>day27-文件与系统IO</title>
    <url>/2023/04/01/day27-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9FIO/</url>
    <content><![CDATA[<h1 id="day27-文件与系统IO"><a href="#day27-文件与系统IO" class="headerlink" title="day27-文件与系统IO"></a><font color="green">day27-文件与系统IO</font></h1><h2 id="一、IO概念"><a href="#一、IO概念" class="headerlink" title="一、IO概念"></a>一、IO概念</h2><h3 id="1-标准IO和文件IO的区别："><a href="#1-标准IO和文件IO的区别：" class="headerlink" title="1. 标准IO和文件IO的区别："></a>1. 标准IO和文件IO的区别：</h3><blockquote>
<ol>
<li>标准IO是c库函数，文件IO是系统调用接口</li>
<li>标准IO自带缓冲区，文件IO没有缓冲</li>
<li>标准IO是文件IO的基础上封装出来的API接口</li>
</ol>
</blockquote>
<a id="more"></a>

<table>
<thead>
<tr>
<th></th>
<th>文件io</th>
<th>标准io</th>
</tr>
</thead>
<tbody><tr>
<td>缓冲</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>高低级</td>
<td>linux系统io、低级io</td>
<td>高级io</td>
</tr>
<tr>
<td>操作对象</td>
<td>文件描述符</td>
<td>流</td>
</tr>
<tr>
<td>能否打开设备文件</td>
<td>可以</td>
<td>不可以</td>
</tr>
<tr>
<td>API</td>
<td>open，close，read，write，sleek</td>
<td>fopen，fclose，fread，fwrite，fseek</td>
</tr>
</tbody></table>
<h3 id="2-缓冲区："><a href="#2-缓冲区：" class="headerlink" title="2. 缓冲区："></a>2. 缓冲区：</h3><p>&emsp;&emsp;缓冲区是内存空间的一部分，在内存中预留了一定的存储空间，用来暂时保存输入和输出等I/O操作的一些数据，这些预留的空间就叫做缓冲区。缓冲区是为了减少cpu对磁盘的读写次数，从内存（即缓冲区）中读取数据来加快运行速度</p>
<ol>
<li><p>全缓冲：当缓冲区满了或者特定的情况下才会刷新，最经典的是对磁盘文件的读写</p>
</li>
<li><p>行缓冲：当缓冲区中有了换行\n就会刷新，经典的有标准输入（stdin）输出（stdout）流</p>
</li>
<li><p>无缓冲：任何东西进入缓冲区马上被刷新走，经典的有标准错误输出流（stderr）</p>
</li>
</ol>
<p>默认：程序结束会刷新缓冲区</p>
<h3 id="3-流"><a href="#3-流" class="headerlink" title="3. 流"></a>3. 流</h3><p>&emsp;&emsp;在C语言中，将在不同的输入/输出设备之间进行传递的数据抽象为“流”。C中有三种标准流：标准输入流<code>stdin</code>，标准输出流<code>stdout</code>，标准错误流<code>stderr</code><br>&emsp;&emsp;流实际上就是一个字节序列，输入函数的字节序列被称为输入流，输出函数的字节序列称为输出流。<br>&emsp;&emsp;根据数据形式，输入输出流可以分为<code>文本流</code>（字符流）和<code>二进制流</code>。</p>
<blockquote>
<p>文本流和二进制流：</p>
<ul>
<li>文本文件：（又称ASCII文件）该文件中一个字符占用一个字节，存储单元中存放单个字符对应的ASCII 码。在文本流中输入输出的数据是字符或字符串，可以被修改；</li>
<li>二进制文件：二进制文件是存储在内存的数据的映像，也称映像文件。二进制流中输入输出是一系列二进制的0、1代码，不能以任何方式修改。</li>
</ul>
</blockquote>
<h3 id="4-文件"><a href="#4-文件" class="headerlink" title="4. 文件"></a>4. 文件</h3><p>&emsp;&emsp;C语言使用的文件系统为：<code>缓冲文件系统</code>（标准I/O）和<code>非缓冲文件系统</code>（系统I/O）。其中ANSIC标准采用“缓冲文件系统”处理文件。</p>
<p>&emsp;&emsp;文件指针：<br>在C语言中，所有文件操作必须依靠指针完成，通常用fopen（）为文件变量进行赋值。标准输入输出流，标准错误流都是文件指针类型的，可以给文件指针变量进行赋值。</p>
<blockquote>
<p>FILE *变量名</p>
</blockquote>
<h3 id="5-文件描述符"><a href="#5-文件描述符" class="headerlink" title="5. 文件描述符"></a>5. 文件描述符</h3><p>&emsp;&emsp;文件描述符：就是内核为了高效管理已被打开的文件所创的索引，是一个非负整数（通常为0-1023），所有执行I/O操作的系统调用都是通过文件描述符来实现。并规定系统刚启动时0是标准输入，1是标准输出，2是标准错误。如果打开新的文件，那么它的文件描述符会是3。<font color="blue">简单理解文件描述符就是一个数值的下标，下标的内容就是指向打开文件的指针。</font><br><br><br>&emsp;&emsp;实际上关于文件描述符，Linux内核维护了3个数据结构： </p>
<ul>
<li>进程级的文件描述符表</li>
<li>系统级的打开文件描述符表</li>
<li>文件系统的i-node表</li>
</ul>
<h4 id="5-1-进程级的文件描述表"><a href="#5-1-进程级的文件描述表" class="headerlink" title="5.1 进程级的文件描述表"></a>5.1 进程级的文件描述表</h4><p>&emsp;&emsp;一个Linux进程启动后，会在内核空间创建一个PCB控制块（PCB是进程控制块的缩写，包含了如进程的状态、程序计数器、堆栈指针、打开的文件列表、进程优先级等。主要用于进程之间切换时，对该进程的PCB进行保存和恢复状态），PCB内部有个 记录当前进程所有可用的文件描述符 的文件描述符表，除了这张表，系统还要维护另外两张表：打开文件描述表和i-node表</p>
<h4 id="5-2-系统级的打开文件描述表"><a href="#5-2-系统级的打开文件描述表" class="headerlink" title="5.2 系统级的打开文件描述表"></a>5.2 系统级的打开文件描述表</h4><ul>
<li>当前文件的偏移量</li>
<li>打开文件时的标识（open()里的falgs参数）</li>
<li>文件的访问模式（mode）</li>
<li>与信号驱动相关的设置</li>
<li>对该文件i-node对象的引用，即i-node指针</li>
</ul>
<h4 id="5-3-文件系统的i-node表"><a href="#5-3-文件系统的i-node表" class="headerlink" title="5.3 文件系统的i-node表"></a>5.3 文件系统的i-node表</h4><ul>
<li>文件类型（例如：常规文件，套接字或FIFO）和访问权限</li>
<li>一个指针，指向该文件所持有的锁链表（即对文件的锁定）</li>
<li>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳</li>
</ul>
<br>

<p>这三个表之间的关系如下图：<br><img src="/2023/04/01/day27-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9FIO/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.jpg" alt="文件描述符"></p>
<ul>
<li><p>在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的。</p>
</li>
<li><p>进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</p>
</li>
<li><p>进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况。 </p>
</li>
<li><p>*这就说明：同一个进程的不同文件描述符可以指向同一个文件；不同进程可以拥有相同的文件描述符；不同进程的同一个文件描述符可以指向不同的文件（一般也是这样，除了 0、1、2 这三个特殊的文件）；不同进程的不同文件描述符也可以指向同一个文件。**</p>
<br>
<br>

<hr>
</li>
</ul>
<h2 id="二、I-O函数"><a href="#二、I-O函数" class="headerlink" title="二、I/O函数"></a>二、I/O函数</h2><h3 id="1-更改缓冲区类型：setvbuf"><a href="#1-更改缓冲区类型：setvbuf" class="headerlink" title="1. 更改缓冲区类型：setvbuf"></a>1. 更改缓冲区类型：setvbuf</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int setvbuf(FILE *stream, char *buf, int mode, size_t size);</span><br><span class="line">功能：可以更改缓冲区类型（缓冲区可以人为指定）</span><br><span class="line">头文件：不需要特定头文件</span><br><span class="line">返回值：成功返回0，失败返回非0</span><br><span class="line">stream：流，表示要更改缓冲类型的流</span><br><span class="line">buf：缓冲区地址 填NULL就是系统默认缓冲区</span><br><span class="line">mode：要改成的缓冲区类型</span><br><span class="line">	_IONBF：无缓冲</span><br><span class="line">	_IOLBF：行缓冲</span><br><span class="line">	_IOFBF：全缓冲</span><br><span class="line">size：要更改buf的大小（单位字节）填BUFSIZ的话就是系统默认缓冲区大小</span><br></pre></td></tr></table></figure>

<p>错误perror、errno、stderr</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">errno：错误号，用于内核调用完函数后设置调用结果的编号，int型</span><br><span class="line">perror：输出对应错误号的信息</span><br><span class="line">stderr：标准出错流 -- 无缓冲，通常结合fprintf使用</span><br></pre></td></tr></table></figure>

<p>标准流：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">标准输入流：stdin -- 0</span><br><span class="line">标准输出流：stdout -- 1</span><br><span class="line">标准出错流：stderr -- 2</span><br><span class="line"></span><br><span class="line">每打开一个终端，都会默认打开这三个流</span><br></pre></td></tr></table></figure>

<h3 id="2-刷新流的缓冲区：fflush"><a href="#2-刷新流的缓冲区：fflush" class="headerlink" title="2. 刷新流的缓冲区：fflush"></a>2. 刷新流的缓冲区：fflush</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fflush(FILE *stream);</span><br><span class="line">功能：强制刷新一个流（Linux下不能刷新stdin）</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回0，失败返回EOF</span><br><span class="line">stream：要刷新的流</span><br></pre></td></tr></table></figure>

<h3 id="3-打开文件-流：open-fopen"><a href="#3-打开文件-流：open-fopen" class="headerlink" title="3. 打开文件/流：open,fopen"></a>3. 打开文件/流：open,fopen</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char* pathname,int flags,mode_t mode);</span><br><span class="line">功能：open是c标准库之外的系统调用函数。用来打开一个文件</span><br><span class="line">头文件：#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt;</span><br><span class="line">返回值：成功返回文件描述符。失败返回</span><br><span class="line">pathname：要打开的文件名（包含路径）</span><br><span class="line">flags:指定文件的打开/创建模式：</span><br><span class="line">	O_RDONLY(只读) </span><br><span class="line">	O_WRONLY(只写) </span><br><span class="line">	O_RDWR (读写)</span><br><span class="line">这些是常用的且必选一，还有其它选用的参数，中间用|结合  </span><br><span class="line">	O_CREAT：如果该文件不存在，就创建一个新的文件，并用第三的参数为其设置权限。</span><br><span class="line">    O_EXCL：如果使用O_CREAT时文件存在，则可返回错误消息。这一参数可测试文件是否存在。</span><br><span class="line">    O_NOCTTY：使用本参数时，如文件为终端，那么终端不可以作为调用open()系统调用的那个进程的控制终端</span><br><span class="line">    O_APPEND：以添加方式打开文件，所以对文件的写操作都在文件的末尾进行。</span><br><span class="line">    O_TRUNC：如文件已经存在，那么打开文件时先删除文件中原有数据。（截断式打开：如果文件有内容，先清空文件内容，再打开）</span><br><span class="line">mode：指定文件的访问权限，是由（-rw-r--r--）之类的组成的参数值（0644）</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">FILE *fopen(const char *pathname, const char *mode);</span><br><span class="line">功能：让内核打开一个文件并且标记它</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回流指针，失败返回NULL</span><br><span class="line">pathname：要打开的文件名（包含路径）</span><br><span class="line">mode：打开文件的方式（只读、只写...）</span><br><span class="line">	“r”：只读方式打开文件，文件必须存在</span><br><span class="line">	“w”：只写方式打开文件，如果文件存在则清空文件，如果文件不存在则创建文件</span><br><span class="line">	“a”：以追加方式打开文件，如果文件不存在则创建文件</span><br><span class="line">	“r+”：读写方式打开文件，文件必须存在</span><br><span class="line">	“w+”：读写方式打开文件，如果文件存在则清空文件，如果文件不存在则创建文件</span><br><span class="line">	“a+”：读写方式打开文件，如果文件不存在则创建文件，并在文件末尾写入数据</span><br><span class="line">	(注意：a+在追加时会从文件末尾另起一行再加，想要在末尾加就用fseek偏移后用fputs)</span><br><span class="line">注：如果操作二进制文件，那么打开文件时的方式可以加上b(如r+b, wb等)，但是Linux下不区分二进制流和文本流</span><br></pre></td></tr></table></figure>
<h4 id="open-和fopen-区别"><a href="#open-和fopen-区别" class="headerlink" title="open()和fopen()区别"></a>open()和fopen()区别</h4><p> <code>open()</code> 和 <code>fopen()</code> 都是用于打开文件的函数，但是它们有以下几个主要的区别：</p>
<blockquote>
<ol>
<li><strong>语法不同</strong>：<code>open()</code> 是一个系统调用，使用 C 语言的语法，而 <code>fopen()</code> 是一个标准 C 库函数，使用 C 标准库的语法。</li>
<li><strong>返回值不同</strong>：<code>open()</code> 的返回值是一个文件描述符，而 <code>fopen()</code> 的返回值是一个文件指针。</li>
<li><strong>文件模式不同</strong>：<code>open()</code> 可以打开任何类型的文件，包括设备文件和管道等，而 <code>fopen()</code> 只能打开普通文件。此外，<code>open()</code> 可以指定文件的打开模式，如只读、只写、读写等，而 <code>fopen()</code> 只能指定文件的访问模式，如只读、只写、读写等。</li>
<li><strong>缓冲不同</strong>：<code>fopen()</code> 打开文件时会创建一个缓冲区，用于提高读写效率，而 <code>open()</code> 不会创建缓冲区。</li>
<li>如果需要打开普通文件并使用标准 C 库函数进行读写操作，应该使用 <code>fopen()</code> 函数；如果需要打开设备文件、管道等非普通文件，或者需要更细粒度的文件访问控制，应该使用 <code>open()</code> 系统调用函数。</li>
</ol>
</blockquote>
<h3 id="4-关闭文件-流：close和fclose"><a href="#4-关闭文件-流：close和fclose" class="headerlink" title="4. 关闭文件/流：close和fclose"></a>4. 关闭文件/流：close和fclose</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int close(int fd)</span><br><span class="line">功能：关闭文件描述符，但不删除文件（删除用unlink()）</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：成功返回0，失败返回EOF</span><br><span class="line">fd：要关闭的文件标识符</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fclose(FILE *stream)</span><br><span class="line">功能：关闭已经打开的流,防止文件损坏</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回0，失败返回EOF</span><br><span class="line">stream：要关闭的流</span><br></pre></td></tr></table></figure>
<h4 id="close-和fclose-区别"><a href="#close-和fclose-区别" class="headerlink" title="close()和fclose()区别"></a>close()和fclose()区别</h4><blockquote>
<ol>
<li><strong>关闭文件不同</strong>：close关闭open打开的文件，fclose关闭fopen打开的文件。</li>
<li><strong>缓冲不同</strong>：close不会刷新缓冲区，fclose会刷新缓冲区</li>
</ol>
</blockquote>
<h3 id="5，文件-流偏移：lseek和fseek"><a href="#5，文件-流偏移：lseek和fseek" class="headerlink" title="5，文件/流偏移：lseek和fseek"></a>5，文件/流偏移：lseek和fseek</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">off_t lseek(int fd, off_t offset, int whence);</span><br><span class="line">功能：用于在打开的文件描述符中设置文件偏移量。文件偏移量是文件中下一个读取或写入操作的位置。</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：成功返回off_t整型(头文件是&lt;sys/types.h&gt;)新的文件偏移量，如果出错则返回-1。</span><br><span class="line">fd：文件描述符，</span><br><span class="line">offset：偏移量，</span><br><span class="line">whence：基准位置。可以取下面的值</span><br><span class="line">	- `SEEK_SET`：相对位置从文件开头开始计算。</span><br><span class="line">	- `SEEK_CUR`：相对位置从当前位置开始计算。</span><br><span class="line">	- `SEEK_END`：相对位置从文件结尾开始计算。</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fseek(FILE *stream, long offset, int whence);</span><br><span class="line">功能：用于设置文件指针的位置</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回0，失败返回非0</span><br><span class="line">stream：指向要设置位置的文件的指针</span><br><span class="line">offset：是要设置的相对位置</span><br><span class="line">whence：是指定相对位置的起始点。可以取下面的值</span><br><span class="line">	- `SEEK_SET`：相对位置从文件开头开始计算。</span><br><span class="line">	- `SEEK_CUR`：相对位置从当前位置开始计算。</span><br><span class="line">	- `SEEK_END`：相对位置从文件结尾开始计算。</span><br></pre></td></tr></table></figure>

<h4 id="lseek-和fseek-区别"><a href="#lseek-和fseek-区别" class="headerlink" title="lseek()和fseek()区别"></a>lseek()和fseek()区别</h4><blockquote>
<ol>
<li><strong>操作文件不同</strong>：lseek操作open打开的文件流，fseek操作fopen打开的文件描述符。</li>
<li><strong>缓冲不同</strong>：lseek不会刷新缓冲区，fseek会刷新缓冲区</li>
</ol>
</blockquote>
<h3 id="6-读写文件-流："><a href="#6-读写文件-流：" class="headerlink" title="6. 读写文件/流："></a>6. 读写文件/流：</h3><h3 id="6-1-按字符读：getc，fgetc"><a href="#6-1-按字符读：getc，fgetc" class="headerlink" title="6.1 按字符读：getc，fgetc"></a>6.1 按字符读：getc，fgetc</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int getc(FILE *stream);</span><br><span class="line">功能：从文件里面读取一个字符</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回读到的字符，失败返回EOF</span><br><span class="line">stream：要读的流</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fgetc(FILE *stream);</span><br><span class="line">功能：从流里面读取一个字符</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回读到的字符，失败返回EOF</span><br><span class="line">stream：要读的流</span><br></pre></td></tr></table></figure>
<p>两者功能等价，但getc()函数的参数可以是任何类型的文件指针，包括标准输入、标准输出和标准错误，或者是文件描述符。而fgetc()函数的参数必须是一个指向文件的指针。</p>
<h3 id="6-2-按字符写：putc，fputc"><a href="#6-2-按字符写：putc，fputc" class="headerlink" title="6.2 按字符写：putc，fputc"></a>6.2 按字符写：putc，fputc</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int putc(int c, FILE *stream);</span><br><span class="line">功能：往文件里面写一个字符</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回写入的字符，失败返回EOF</span><br><span class="line">c：要写的字符</span><br><span class="line">stream：要写入的流</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fputc(int c, FILE *stream);</span><br><span class="line">功能：往流里面写一个字符</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回写入的字符，失败返回EOF</span><br><span class="line">c：要写的字符</span><br><span class="line">stream：要写入的流</span><br></pre></td></tr></table></figure>
<p>两者完全等价，参数都能填文件指针或者文件描述符</p>
<h3 id="6-3-按行读：gets，fgets"><a href="#6-3-按行读：gets，fgets" class="headerlink" title="6.3 按行读：gets，fgets"></a>6.3 按行读：gets，fgets</h3><p>gets()函数可能会导致缓冲区溢出，不建议使用。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">char *fgets(char *s, int size, FILE *stream);</span><br><span class="line">功能：读取一行的内容</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回s的地址，失败返回NULL</span><br><span class="line">s：要把内容读到哪里去（缓冲区）</span><br><span class="line">size：预计要读的字节数，一般用sizeof()</span><br><span class="line">stream：从哪个流读取</span><br><span class="line"></span><br><span class="line">注：fgets是表示遇到了换行符才终止并且会把换行符存进去，如果size比一行的数据大，就读完所有内容。size如果比一行数据小，只读size-1个，追加一个&#x27;<span class="tag">\</span>0&#x27;，表示没读完。(即后面一定会加&#x27;<span class="tag">\</span>0&#x27;，在遇到文件末尾时才会&#x27;<span class="tag">\<span class="name">n</span></span>&#x27;,再加&#x27;<span class="tag">\</span>0&#x27;。在可以在&#x27;<span class="tag">\</span>0&#x27;前面是否有&#x27;<span class="tag">\<span class="name">n</span></span>&#x27;来判断一行是否读取完。)</span><br></pre></td></tr></table></figure>
<p><strong><font color="red">注意：sizeof(str)是指的str的有效长度，即整个长度-1。设char str[6],那么sizeof(str)为5。</font></strong></p>
<h3 id="6-4-按行写：puts-fputs"><a href="#6-4-按行写：puts-fputs" class="headerlink" title="6.4 按行写：puts,fputs"></a>6.4 按行写：puts,fputs</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int puts(const char *str);</span><br><span class="line">功能：将一个字符串输出到标准输出流。</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回非负数，失败返回EOF</span><br><span class="line">s：要写入的内容所在的缓冲区</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fputs(const char *s, FILE *stream);</span><br><span class="line">功能：往一个流里面写一行数据</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回非负数，失败返回EOF</span><br><span class="line">s：要写入的内容所在的缓冲区</span><br><span class="line">stream：要写入的流</span><br></pre></td></tr></table></figure>
<p>puts会在字符串输出后自动添加一个换行，fputs不会添加</p>
<h3 id="6-5-按对象读：read，fread"><a href="#6-5-按对象读：read，fread" class="headerlink" title="6.5 按对象读：read，fread"></a>6.5 按对象读：read，fread</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">size_t read(int fd, void *buf, size_t count);</span><br><span class="line">功能：从文件描述符中读取数据的系统调用</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：读取到的字节数，如果读取到文件末尾则返回0，错误返回EOF</span><br><span class="line">fd：文件描述符</span><br><span class="line">buf：要存放读出数据的缓冲区</span><br><span class="line">count：要读取的字节数</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</span><br><span class="line">功能：从流里面读取内容，内容分了组（对象）</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回实际读到的对象个数，失败返回EOF</span><br><span class="line">ptr：要把读到内容放在哪个缓冲区</span><br><span class="line">size：每个对象的字节大小</span><br><span class="line">nmemb：预计要读多少个对象</span><br><span class="line">stream：要读的流</span><br><span class="line"></span><br><span class="line">注：size * nmemb不能超过缓冲区(ptr)大小</span><br></pre></td></tr></table></figure>
<h4 id="read-和fread-区别"><a href="#read-和fread-区别" class="headerlink" title="read()和fread()区别"></a>read()和fread()区别</h4><blockquote>
<p>read函数是系统调用，直接与操作系统交互，因此它的效率比fread函数高。但是，fread函数是标准库函数，具有更好的移植性和可移植性。在读取文本文件时，fread函数会自动进行字符集转换，而read函数则不会。<br>所以如果需要高效地读取二进制文件，可以使用read函数；如果需要读取文本文件或者需要移植性更好的代码，可以使用fread函数。</p>
</blockquote>
<h3 id="6-6-按对象写：write，fwrite"><a href="#6-6-按对象写：write，fwrite" class="headerlink" title="6.6 按对象写：write，fwrite"></a>6.6 按对象写：write，fwrite</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">size_t write(int fd, const void *buf, size_t count);</span><br><span class="line">功能：将数据从指定的缓冲区写入到文件描述符中</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：成功返回写入的字节数，如果错误返回EOF</span><br><span class="line">fd：文件描述符</span><br><span class="line">buf：要写入的数据所在的缓冲区</span><br><span class="line">count：要写入的字节数</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream);</span><br><span class="line">功能：把缓冲区的内容写入到流里面</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回实际写入的对象个数，失败返回EOF</span><br><span class="line">ptr：要写入的数据所在的缓冲区</span><br><span class="line">size：每个对象的字节大小</span><br><span class="line">nmemb：预计要写入的对象个数</span><br><span class="line">stream：要写入的流</span><br></pre></td></tr></table></figure>
<h4 id="write-和fwrite-区别"><a href="#write-和fwrite-区别" class="headerlink" title="write()和fwrite()区别"></a>write()和fwrite()区别</h4><blockquote>
<ul>
<li>write 函数是系统调用函数，直接将数据写入到文件中，而 fwrite 函数是标准库函数，先将数据写入到缓冲区中，再由标准库将缓冲区中的数据写入到文件中。</li>
<li>write 函数的参数中需要指定文件描述符，而 fwrite 函数的参数中需要指定文件流。</li>
<li>write 函数的返回值是实际写入的字节数，而 fwrite 函数的返回值是实际写入的数据项个数。</li>
</ul>
</blockquote>
<h3 id="7-重定向"><a href="#7-重定向" class="headerlink" title="7. 重定向"></a>7. 重定向</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">FILE *freopen(const char *pathname, const char *mode, FILE *stream);</span><br><span class="line">功能：打开一个文件并且会产生一个流，stream所表示的流会被替代</span><br><span class="line">头文件：#include &lt;stdio.h&gt;</span><br><span class="line">返回值：成功返回流指针，失败返回NULL</span><br><span class="line">pathname：要打开的文件</span><br><span class="line">mode：打开文件的方式(&quot;w&quot;之类的)</span><br><span class="line">stream：要重定向的流</span><br></pre></td></tr></table></figure>
<p>重定向例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    fp = freopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This will be written to output.txt\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，freopen 函数将文件名为 output.txt 的文件与标准输出流 stdout 关联起来，打开方式为写入模式。然后，程序使用 printf 函数向 stdout 中写入一条消息，这条消息会被重定向写到 output.txt 文件中。最后，程序关闭文件指针 fp，结束程序。<br><strong>注意：freopen 函数只能用于重新定向标准输入输出流，不能用于其他类型的流</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>LINUX</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>day31-c++介绍</title>
    <url>/2023/04/18/day31-c++%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="day31-c-介绍"><a href="#day31-c-介绍" class="headerlink" title="day31-c++介绍"></a><font color="green">day31-c++介绍</font></h1><a id="more"></a>

<h1 id="一、c-简介"><a href="#一、c-简介" class="headerlink" title="一、c++简介"></a>一、c++简介</h1><p>C++是一种编程语言，它是在C语言的基础上发展而来的，增加了面向对象、泛型和异常处理等特性。C++是一种多范式的语言，它支持面向过程、面向对象、泛型和函数式等编程范式。C++也是一种编译型的语言，它需要通过编译器将源代码转换为可执行的机器码。</p>
<p>C++的特点有以下几点：</p>
<ul>
<li>C++是一种高效的语言，它提供了底层的访问能力，可以直接操作内存和硬件，也可以利用现代的优化技术提高性能。</li>
<li>C++是一种灵活的语言，它允许程序员根据不同的需求选择不同的编程风格和技术，也可以与其他语言进行混合编程。</li>
<li>C++是一种可移植的语言，它遵循了国际标准，可以在不同的平台和操作系统上运行，也可以利用标准模板库（STL）和第三方库扩展功能。</li>
</ul>
<p>C++的适用场景有以下几点：</p>
<ul>
<li>C++适合开发需要高性能、高可靠性、高安全性的系统软件和应用软件，例如操作系统、数据库、网络通信、图形图像、游戏等领域。</li>
<li>C++适合开发需要跨平台、跨语言的软件，例如嵌入式系统、物联网、云计算、人工智能等领域。</li>
<li>C++适合开发需要利用现有代码或库的软件，例如基于C语言或其他语言的遗留代码或开源代码等。</li>
</ul>
<p>C++的学习路线有以下几点：</p>
<ul>
<li>入门阶段：学习C++的基本语法和面向对象编程思想，掌握类、对象、继承、多态等概念，熟悉常用的标准库和第三方库，完成一些简单的项目实践。</li>
<li>进阶阶段：学习C++的高级特性和泛型编程思想，掌握模板、异常处理、智能指针等概念，深入理解STL的原理和实现，完成一些复杂的项目实践。</li>
<li>提高阶段：学习C++的最新标准和新特性，掌握lambda表达式、移动语义、并发编程等概念，关注C++的发展趋势和前沿技术，完成一些创新的项目实践。</li>
</ul>
<br>
<br>

<hr>
<h2 id="二、c-开发环境"><a href="#二、c-开发环境" class="headerlink" title="二、c++开发环境"></a>二、c++开发环境</h2><ul>
<li><p>Linux下的c++开发工具</p>
<blockquote>
<p>vim，gedit，vscode，g++</p>
</blockquote>
</li>
<li><p>windows下的c++开发工具</p>
<blockquote>
<p>devcpp，vsxode+winGW</p>
</blockquote>
</li>
<li><p>windows + linux </p>
<blockquote>
<p>用ssh在windows上远程连接Linux</p>
</blockquote>
</li>
</ul>
<br>
<br>

<hr>
<h2 id="三、c-基础知识"><a href="#三、c-基础知识" class="headerlink" title="三、c++基础知识"></a>三、c++基础知识</h2><h3 id="3-1-c-基本结构"><a href="#3-1-c-基本结构" class="headerlink" title="3.1 c++基本结构"></a>3.1 c++基本结构</h3><p>C++是一种面向对象的编程语言，它由以下几个部分组成：</p>
<ul>
<li>预处理器指令：用于引入头文件，定义宏，设置条件编译等。</li>
<li>全局变量和常量：用于在整个程序中存储和访问数据。</li>
<li>函数：用于封装一组相关的语句，实现特定的功能。</li>
<li>类：用于定义一种新的数据类型，包含数据成员和成员函数。</li>
<li>对象：用于创建类的实例，调用成员函数，访问数据成员。</li>
<li>继承：用于实现类之间的关系，使子类可以继承父类的特性和行为。</li>
<li>多态：用于实现不同类型的对象可以使用相同的接口，根据对象的实际类型执行不同的操作。</li>
<li>模板：用于实现泛型编程，使函数和类可以适用于不同类型的参数和数据。</li>
</ul>
<p>C++基本结构的示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cpp</span><br><span class="line"><span class="comment">// 预处理器指令</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // 引入输入输出流头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// 使用标准命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量和常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>; <span class="comment">// 定义一个常量</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 定义一个变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> <span class="comment">// 定义一个无参无返回值的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出一行文字</span></span><br><span class="line">count++; <span class="comment">// 变量自增</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> // 定义一个圆类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有部分</span></span><br><span class="line"><span class="keyword">double</span> radius; <span class="comment">// 数据成员，半径</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// 公有部分</span></span><br><span class="line">Circle(<span class="keyword">double</span> r) <span class="comment">// 构造函数，初始化半径</span></span><br><span class="line">&#123;</span><br><span class="line">radius = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="comment">// 成员函数，计算面积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printHello(); <span class="comment">// 调用函数</span></span><br><span class="line"><span class="function">Circle <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 创建对象，传入半径为5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The area of the circle is &quot;</span> &lt;&lt; c.getArea() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出圆的面积</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The count is &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出变量的值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示程序正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2-c-和c语法上的不同"><a href="#3-2-c-和c语法上的不同" class="headerlink" title="3.2 c++和c语法上的不同"></a>3.2 c++和c语法上的不同</h3><ol>
<li>隐式类型转换</li>
</ol>
<p>在C中，可以隐式地将一个类型的变量赋值给另一个类型的变量，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> y = x; <span class="comment">// 隐式地将int转换为double</span></span><br></pre></td></tr></table></figure>

<p>这种隐式类型转换可能会导致精度损失或数据溢出，但是C编译器不会报错，只会给出一个警告。</p>
<p>而在C++中，这种隐式类型转换是不允许的，编译器会报错，提示类型不匹配。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> y = x; <span class="comment">// 错误：不能将int转换为double</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是因为C++更加注重类型安全，要求程序员显式地进行类型转换，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x); <span class="comment">// 显式地将int转换为double</span></span><br></pre></td></tr></table></figure>

<p>这样可以避免一些潜在的错误和风险。</p>
<ol start="2">
<li>函数重载</li>
</ol>
<p>在C中，不能定义两个或多个同名但参数不同的函数，即使它们的返回值也不同。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125; <span class="comment">// 错误：重复定义了函数add</span></span><br></pre></td></tr></table></figure>

<p>这是因为C中的函数名是一个全局唯一的标识符，不能有重复。</p>
<p>而在C++中，可以定义两个或多个同名但参数不同的函数，这称为函数重载。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125; <span class="comment">// 正确：重载了函数add</span></span><br></pre></td></tr></table></figure>

<p>这是因为C++中的函数名是一个由函数名和参数列表组成的复合标识符，只要参数列表不同，就可以有相同的函数名。而且参数可以写默认值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printfln</span><span class="params">(<span class="keyword">const</span> a = <span class="string">&quot;hello&quot;</span>, <span class="keyword">int</span> b=<span class="number">4</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数重载可以提高代码的可读性和灵活性，可以根据不同的参数类型选择合适的函数实现。</p>
<p>但要注意参数类型不一致时，会发生转换，但如果有两个符合条件的函数（例如输入的参数是int和float，把float转为int可以调用函数1，把int转为float可以调用函数2），编译器就会发生错误</p>
<ol start="3">
<li>结构体变量声明</li>
</ol>
<p>在C中，定义一个结构体类型后，要声明一个该类型的变量，需要在变量名前加上关键字struct。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p</span>;</span> <span class="comment">// 声明一个结构体变量p</span></span><br></pre></td></tr></table></figure>

<p>而在C++中，定义一个结构体类型后，要声明一个该类型的变量，可以省略关键字struct。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point p; <span class="comment">// 声明一个结构体变量p</span></span><br></pre></td></tr></table></figure>

<p>这是因为C++中的结构体类型和类类型是一致的，都属于用户自定义类型，可以直接使用其名称作为变量类型。</p>
<p>省略关键字struct可以简化代码的书写和阅读。</p>
<h3 id="3-3-c-作用域"><a href="#3-3-c-作用域" class="headerlink" title="3.3 c++作用域"></a>3.3 c++作用域</h3><p>C++作用域是指变量或函数在程序中的可见范围。C++有四种作用域，范围从大到小：全局作用域、命名空间作用域和类作用域、局部作用域。</p>
<ul>
<li>全局作用域<br>全局作用域是指定义在函数外部的变量或函数，它们在程序的任何地方都可以访问。全局变量或函数的命名应该避免与其他库或模块的命名冲突，否则会导致链接错误或不可预期的行为。</li>
<li>命名空间作用域<br>命名空间作用域是指定义在命名空间内部的变量或函数，它们可以在同一个命名空间内或者使用命名空间限定符访问。命名空间是一种组织代码的方式，可以避免不同模块之间的命名冲突，也可以提高代码的可读性和可维护性。C++标准库中的所有内容都位于std命名空间中，使用时需要加上std::前缀，或者使用using声明引入。</li>
<li>类作用域<br>类作用域是指定义在类内部的变量或函数，它们可以在类内部或者使用类对象访问。类是一种封装数据和操作的抽象，可以实现面向对象编程的特性，如封装、继承和多态。类内部的变量称为数据成员，类内部的函数称为成员函数。数据成员和成员函数可以有不同的访问权限，如公有、私有和保护，这样可以控制类对象对它们的访问程度。</li>
<li>局部作用域<br>局部作用域是指定义在函数内部的变量或函数，它们只能在函数内部使用。局部变量或函数的生命周期只限于函数的执行期间，函数结束后，它们会被销毁。局部变量或函数可以隐藏同名的全局变量或函数，这样可以提高程序的模块化和封装性。</li>
</ul>
<h3 id="3-4-c-引用"><a href="#3-4-c-引用" class="headerlink" title="3.4 c++引用"></a>3.4 c++引用</h3><p>C++中的引用是一种特殊的变量，它可以用来表示另一个变量的别名。引用的作用是可以让我们通过不同的名字访问同一个内存地址，从而实现对变量的间接操作。引用的声明方式是在变量类型后面加上一个&amp;符号，然后给出引用的名字和初始化的变量。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>; <span class="comment">// 声明一个整型变量x</span></span><br><span class="line">    <span class="keyword">int</span> &amp;y = x; <span class="comment">// 声明一个整型引用y，指向x</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    change(a,b);<span class="comment">//a,b的值能被转换，a=2，b=1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用有以下几个特点：</p>
<ul>
<li>引用必须在声明时初始化，不能像指针那样先声明后赋值。</li>
<li>引用一旦初始化，就不能改变指向的对象，也就是说引用是常量指针。</li>
<li>引用没有自己的内存空间，它只是指向另一个变量的别名，所以不能对引用取地址。</li>
<li>引用可以作为函数的参数和返回值，从而实现传递和返回对象的效果。</li>
</ul>
<p>引用的优点是可以简化代码的书写，避免使用指针带来的复杂性和风险。引用的缺点是可能造成代码的可读性和可维护性降低，因为不容易区分引用和原始变量。因此，在使用引用时，应该遵循以下原则：</p>
<ul>
<li>尽量使用const引用，以防止修改指向的对象。</li>
<li>尽量避免使用多层引用，以防止产生混乱和错误。</li>
<li>尽量避免使用引用的引用，以防止出现未定义的行为。</li>
</ul>
<h3 id="3-5-内联函数"><a href="#3-5-内联函数" class="headerlink" title="3.5 内联函数"></a>3.5 内联函数</h3><p>c++中可以用宏函数提高效率，但安全性降低</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//宏函数只会进行引用，不是真正的函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max1;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">  max1 = max(a++,b); <span class="comment">//实际上是((a++)&gt;(b)?(a++):(b));</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;max1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//结果是max=8，a=9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c++中引入了inlien关键字（内联函数），用来实现类似于宏函数的效果<br>但内联函数通过空间换取的时间，相当于直接把内联函数的代码嵌如到主函数中。空间开销大，一般内联函数不能太复杂</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max1;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">7</span>,b=<span class="number">4</span>;</span><br><span class="line">  max1 = max(a++,b);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;max1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//结果是max=7，a=8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-const关键字"><a href="#3-6-const关键字" class="headerlink" title="3.6 const关键字"></a>3.6 const关键字</h3><ol>
<li>const修饰类的成员函数</li>
</ol>
<p>当我们在类的成员函数后面加上const关键字时，表示这个函数是一个常成员函数，它不会修改对象的任何数据成员。这样可以保证对象的状态不被意外改变，也可以增加代码的可读性和可维护性。</p>
<p>常成员函数的特点有：</p>
<ul>
<li>常成员函数只能访问类的const成员变量和const成员函数，不能访问非const的成员。</li>
<li>常成员函数不能修改类的任何数据成员，也不能调用非const的成员函数（因为这些操作都可能改变对象的状态）。</li>
<li>常成员函数可以被非const对象和const对象调用，但非const成员函数只能被非const对象调用。</li>
<li>常成员函数可以被重载，即可以存在同名的const和非const版本的成员函数，它们的区别在于是否有const修饰符。</li>
</ul>
<p>常成员函数的语法格式为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">返回值类型 类名::函数名(参数列表) const;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> * name, <span class="keyword">int</span> age, <span class="keyword">float</span> score );</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>; <span class="comment">//非const成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">getname</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//const成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//const成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getscore</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//const成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Student::getname</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Student::getage</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Student::getscore</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>const修饰类的成员变量</li>
</ol>
<p>当我们在类的成员变量前面加上const关键字时，表示这个变量是一个常数据成员，它只能在初始化列表中赋值，不能在其他地方修改。这样可以保证对象的数据不被意外改变，也可以增加代码的安全性和效率。</p>
<p>常数据成员的特点有：</p>
<ul>
<li>常数据成员必须在初始化列表中赋值，不能在构造函数体或其他地方赋值。</li>
<li>常数据成员只能被const成员函数访问，不能被非const的成员函数访问。</li>
<li>常数据成员可以是静态或非静态的，静态常数据成员还必须在类外初始化。</li>
</ul>
<p>常数据成员的语法格式为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">public:</span><br><span class="line">    类名(参数列表):常数据成员(初始值)&#123;...&#125;</span><br><span class="line">private:</span><br><span class="line">    const 数据类型 数据名;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">double</span> r):radius(r),area(PI*r*r)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> radius;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> area;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> radius; <span class="comment">//常数据成员</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> area; <span class="comment">//常数据成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>const修饰对象<br>首先，我们需要明确一点，const修饰的是对象本身，而不是对象的类型。也就是说，const修饰的对象仍然属于原来的类型，只不过它的状态不能被改变。例如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x_(x), y_(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; x_ = x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123; y_ = y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x_; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> y_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x_;</span><br><span class="line">    <span class="keyword">int</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// p1是一个普通的Point对象</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Point <span class="title">p2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>; <span class="comment">// p2是一个const Point对象</span></span><br><span class="line"></span><br><span class="line">p1.setX(<span class="number">10</span>); <span class="comment">// OK，可以修改p1的状态</span></span><br><span class="line">p2.setX(<span class="number">20</span>); <span class="comment">// 错误，不能修改p2的状态</span></span><br><span class="line"></span><br><span class="line">Point* pp1 = &amp;p1; <span class="comment">// OK，可以用普通指针指向普通对象</span></span><br><span class="line">Point* pp2 = &amp;p2; <span class="comment">// 错误，不能用普通指针指向const对象</span></span><br><span class="line"><span class="keyword">const</span> Point* pp3 = &amp;p1; <span class="comment">// OK，可以用const指针指向普通对象</span></span><br><span class="line"><span class="keyword">const</span> Point* pp4 = &amp;p2; <span class="comment">// OK，可以用const指针指向const对象</span></span><br><span class="line"></span><br><span class="line">pp1-&gt;setX(<span class="number">30</span>); <span class="comment">// OK，可以通过普通指针修改普通对象的状态</span></span><br><span class="line">pp2-&gt;setX(<span class="number">40</span>); <span class="comment">// 错误，不能通过普通指针修改const对象的状态</span></span><br><span class="line">pp3-&gt;setX(<span class="number">50</span>); <span class="comment">// 错误，不能通过const指针修改普通对象的状态</span></span><br><span class="line">pp4-&gt;setX(<span class="number">60</span>); <span class="comment">// 错误，不能通过const指针修改const对象的状态</span></span><br></pre></td></tr></table></figure>
从上面的例子可以看出，当我们用const修饰一个自定义对象时，有以下几个效果：</li>
</ol>
<ul>
<li>我们不能直接调用该对象的任何非const成员函数，因为这些函数可能会修改该对象的状态。</li>
<li>我们不能用普通指针或引用来指向该对象，因为这样可能会通过指针或引用来修改该对象的状态。</li>
<li>我们只能调用该对象的const成员函数，因为这些函数保证了不会修改该对象的状态。</li>
<li>我们只能用const指针或引用来指向该对象，因为这样保证了不会通过指针或引用来修改该对象的状态。</li>
</ul>
<h3 id="3-6-static关键字"><a href="#3-6-static关键字" class="headerlink" title="3.6 static关键字"></a>3.6 static关键字</h3><ol>
<li>static可以使类的成员变量和成员函数与类的对象无关，即不需要创建对象就可以访问。static修饰的成员变量和成员函数属于类本身，而不属于某个对象，因此它们只有一份，被所有对象共享。这样可以节省内存空间，也可以实现一些全局的功能。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> value) : m_value(value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s_count = &quot;</span> &lt;&lt; s_count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_count; <span class="comment">// 静态成员变量</span></span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyClass::s_count = <span class="number">0</span>; <span class="comment">// 静态成员变量初始化要在类外</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    MyClass::printCount(); <span class="comment">// 输出s_count = 0</span></span><br><span class="line">    obj1.printCount(); <span class="comment">// 输出s_count = 0</span></span><br><span class="line">    obj2.printCount(); <span class="comment">// 输出s_count = 0</span></span><br><span class="line">    MyClass::s_count = <span class="number">1</span>; <span class="comment">// 静态成员变量修改</span></span><br><span class="line">    MyClass::printCount(); <span class="comment">// 输出s_count = 1</span></span><br><span class="line">    obj1.printCount(); <span class="comment">// 输出s_count = 1</span></span><br><span class="line">    obj2.printCount(); <span class="comment">// 输出s_count = 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>static可以实现类的封装性，即隐藏类的实现细节。static修饰的成员变量和成员函数只能在类的内部或者友元函数中访问，不能在类的外部访问。这样可以保护类的数据和行为，防止被外部修改或者滥用。</li>
<li>static可以实现类的多态性，即同一个函数名可以有不同的行为。static修饰的成员函数是静态绑定的，即在编译时就确定了调用哪个函数。static修饰的成员函数不能被子类重写，也不能使用虚函数表实现动态绑定。这样可以提高程序的执行效率，也可以避免一些运行时错误。</li>
</ol>
<p>总之，static在自定义类中的作用是使类的成员变量和成员函数与对象无关、实现类的封装性和多态性。在使用static时，需要注意以下几点：</p>
<ul>
<li>static修饰的成员变量需要在类外初始化，否则会报错。</li>
<li>static修饰的成员函数不能访问非静态的成员变量和成员函数，否则会报错。</li>
<li>static修饰的成员函数不能被声明为const或者volatile，否则会报错。</li>
<li>static修饰的成员函数不能使用this指针，因为this指针指向当前对象，而静态成员函数与对象无关。</li>
</ul>
<br>
<br>

<hr>
<h2 id="四、c-编译"><a href="#四、c-编译" class="headerlink" title="四、c++编译"></a>四、c++编译</h2><p>c和c++混合编译时，先分别编译成.o文件，在放在一起编译</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>day32-c++结构体，类</title>
    <url>/2023/04/19/day32-c-%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="day32-c-结构体，类"><a href="#day32-c-结构体，类" class="headerlink" title="day32-c++结构体，类"></a><font color="green">day32-c++结构体，类</font></h1><!--mroe-->
<h1 id="一、c-引用和指针"><a href="#一、c-引用和指针" class="headerlink" title="一、c++引用和指针"></a>一、c++引用和指针</h1><p>指针和引用有以下几个主要的区别：</p>
<ul>
<li><p>指针是一个变量，存储的是一个地址，指向内存的一个存储单元；引用是原变量的一个别名，跟原来的变量实质上是同一个东西。</p>
</li>
<li><p>指针可以有多级，引用只能是一级。</p>
</li>
<li><p>指针可以在定义的时候不初始化，引用必须在定义的时候初始化。</p>
</li>
<li><p>指针可以指向NULL，引用不可以为NULL。</p>
</li>
<li><p>指针初始化之后可以再改变，引用不可以。</p>
</li>
<li><p>sizeof 的运算结果不同，指针返回指针类型的大小，引用返回原变量类型的大小。</p>
</li>
<li><p>自增运算意义不同，指针自增之后指向后面的内存，引用自增相当于原变量自增。</p>
</li>
</ul>
<p>所以，在一些场合下，比如动态内存分配、多态、链表、树等数据结构、函数参数等，指针是更合适或者必须的选择。当然，在一些场合下，比如函数返回值、常量对象等，引用是更安全或者更高效的选择。另外，在C++中还有一些智能指针（如unique_ptr, shared_ptr, weak_ptr等）和标准容器（如vector, list, map等），可以简化或者避免一些原生指针的使用。</p>
<p>下面是几个引用的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传递函数参数：引用可以用来作为函数参数，传递变量的引用而不是副本，可以避免在函数调用时产生额外的内存开销，并且可以让函数修改原始数据。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    increment(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值：引用可以用来返回函数的结果，避免了拷贝构造函数的调用，提高程序的效率</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">max</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    max(x, y) = <span class="number">30</span>; <span class="comment">// 将x赋值为30</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h1 id="二、c-结构体和类"><a href="#二、c-结构体和类" class="headerlink" title="二、c++结构体和类"></a>二、c++结构体和类</h1><p>在c语言中，结构体只能包含数据成员，不能包含函数成员。而在c++中，结构体可以包含函数成员，甚至可以包含虚函数。这样，c++中的结构体就具有了类的功能，可以实现封装、继承和多态。但是，c++中的结构体和类还是有一些区别的，主要有以下几点：</p>
<ul>
<li>结构体的默认访问权限是public，而类的默认访问权限是private。这意味着，在结构体内部定义的成员变量和成员函数，默认都是公有的，可以在结构体外部访问。而在类内部定义的成员变量和成员函数，默认都是私有的，只能在类内部访问。</li>
<li>结构体的默认继承方式是public，而类的默认继承方式是private。这意味着，在用一个结构体派生另一个结构体时，默认保持基类的访问权限不变。而在用一个类派生另一个类时，默认将基类的公有成员和保护成员变为私有成员。</li>
<li>结构体不能作为模板参数，而类可以。这意味着，在定义模板时，不能用struct关键字来指定类型参数，只能用class或typename关键字。</li>
</ul>
<p>例如，我们可以定义一个学生结构体，包含姓名、年龄、成绩等信息:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个学生结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="comment">// 数据成员</span></span><br><span class="line"><span class="built_in">string</span> name; <span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line"><span class="keyword">double</span> score; <span class="comment">// 成绩</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Student(<span class="built_in">string</span> n, <span class="keyword">int</span> a, <span class="keyword">double</span> s) &#123;</span><br><span class="line">name = n;</span><br><span class="line">age = a;</span><br><span class="line">score = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者用初始化列表:&lt;成员&gt;(数值)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">Student(<span class="built_in">string</span> n ,<span class="keyword">int</span> a,<span class="keyword">double</span> s) : name(n),age(a),score(s)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">~Student(); <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成绩：&quot;</span> &lt;&lt; score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student ::~Student()&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;析构函数&quot;</span>&lt;&lt;denl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个学生对象</span></span><br><span class="line"><span class="function">Student <span class="title">s</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line"><span class="comment">// 调用成员函数</span></span><br><span class="line">s.show();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构函数的作用是在对象销毁时释放对象分配的资源，如：</p>
<blockquote>
<ul>
<li>释放动态分配的内存：如果在对象创建时使用了new操作符分配了动态内存，则需要在析构函数中使用delete操作符释放这些内存，以避免内存泄漏。</li>
<li>关闭文件：如果在对象创建时打开了文件或其他资源，则需要在析构函数中关闭这些文件或资源，以避免资源泄漏。</li>
<li>清理对象状态：如果对象有一些状态需要清理，例如释放锁、删除文件等，也可以在析构函数中完成。<br>需要注意的是，析构函数是在对象销毁时自动调用的，无法手动调用，因此应该确保在析构函数中释放所有的资源和状态。</li>
</ul>
</blockquote>
<br>
<br>

<hr>
<h1 id="三、this指针"><a href="#三、this指针" class="headerlink" title="三、this指针"></a>三、this指针</h1><p>this指针是一个隐含的指针，它指向调用成员函数的对象。在成员函数内部，可以通过this指针来访问对象的数据成员和其他成员函数。this指针的类型是类类型的指针，例如，如果类名是Car，那么this指针的类型就是Car*。</p>
<p>this指针有以下几个作用：</p>
<ol>
<li>区分同名的数据成员和形参。例如，如果成员函数的形参和数据成员同名，可以用this指针来区分它们。如下面的代码所示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_price; <span class="comment">// 数据成员</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetPrice</span><span class="params">(<span class="keyword">int</span> m_price)</span> <span class="comment">// 成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_price = m_price; <span class="comment">// this指针指向调用该函数的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>实现链式操作。例如，如果成员函数的返回值是类类型的引用，可以用this指针来返回当前对象的引用，从而实现链式操作。如下面的代码所示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_price; <span class="comment">// 数据成员</span></span><br><span class="line">    <span class="function">Car&amp; <span class="title">SetPrice</span><span class="params">(<span class="keyword">int</span> m_price)</span> <span class="comment">// 返回类类型的引用</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_price = m_price; <span class="comment">// this指针指向调用该函数的对象</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car car;</span><br><span class="line">    car.SetPrice(<span class="number">20000</span>).SetPrice(<span class="number">30000</span>); <span class="comment">// 链式操作，先后给car对象赋值20000和30000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>作为函数的参数。例如，如果有一个友元函数或者全局函数，需要访问类的私有成员，可以用this指针作为参数传递给该函数。(和1差不多)如下面的代码所示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_price; <span class="comment">// 私有数据成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetPrice</span><span class="params">(<span class="keyword">int</span> m_price)</span> <span class="comment">// 成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_price = m_price; <span class="comment">// this指针指向调用该函数的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">ShowPrice</span><span class="params">(Car* car)</span></span>; <span class="comment">// 声明友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowPrice</span><span class="params">(Car* car)</span> <span class="comment">// 友元函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; car-&gt;m_price &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 可以访问私有数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car car;</span><br><span class="line">    car.SetPrice(<span class="number">20000</span>); <span class="comment">// 给car对象赋值20000</span></span><br><span class="line">    ShowPrice(&amp;car); <span class="comment">// 传递car对象的地址给友元函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<br>

</li>
</ol>
<hr>
<h1 id="四、分配和释放内存"><a href="#四、分配和释放内存" class="headerlink" title="四、分配和释放内存"></a>四、分配和释放内存</h1><p>C++中的new和delete操作符，以及它们和C语言中的malloc和free函数的区别。这些都是用于动态分配和释放内存的方法，但是它们有一些重要的不同点，需要我们了解和注意。</p>
<p>首先，new和delete是C++中的操作符，而malloc和free是C中的函数。这意味着new和delete可以被重载（就是自定义新的功能），而malloc和free不能。另外，new和delete可以根据对象的类型自动计算所需的内存大小，而malloc和free需要我们手动指定字节数。</p>
<p>其次，new不仅分配内存，而且会调用类的构造函数，delete会调用类的析构函数，而malloc只分配内存，不会进行初始化类成员工作，free不会调用析构函数。这意味着new和delete可以保证对象的完整性和正确性，而malloc和free可能会导致内存泄漏或未定义行为。</p>
<p>最后，new在分配内存失败时，会抛出异常，而malloc在分配内存失败时，会返回NULL。这意味着new需要使用try-catch语句来处理异常，而malloc需要使用if语句来检查返回值。另外，new可以使用定位new来指定分配内存的位置，而malloc不能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++中用于代替 malloc() 与 free();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//开辟一个int</span></span><br><span class="line"><span class="keyword">delete</span> p1;          <span class="comment">//释放       </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *ptr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">64</span>];   <span class="comment">//开辟64个char </span></span><br><span class="line"><span class="keyword">delete</span> [] ptr;              <span class="comment">//释放空间 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ps = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">delete</span> [] ps;</span><br><span class="line"></span><br><span class="line">node *ptr_node = <span class="keyword">new</span> node;   <span class="comment">//开辟一个node</span></span><br><span class="line"><span class="keyword">delete</span> ptr_node;             <span class="comment">//释放一个node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：对于基本类型释放时直接delete ptr,对于数组空间 delete [] ptr </span></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h1 id="五、特殊的成员函数"><a href="#五、特殊的成员函数" class="headerlink" title="五、特殊的成员函数"></a>五、特殊的成员函数</h1><h2 id="5-1-构造函数"><a href="#5-1-构造函数" class="headerlink" title="5.1 构造函数"></a>5.1 构造函数</h2><p>构造函数是一种特殊的成员函数，它的名字和类名相同，没有返回值，可以有参数也可以没有参数。构造函数的作用是在类的对象被创建时，对对象的数据成员进行初始化，为对象分配内存空间，并执行一些必要的操作。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;id = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student object created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个Student对象</span></span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">1001</span>, <span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 输出：Student object created.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-析构函数"><a href="#5-2-析构函数" class="headerlink" title="5.2 析构函数"></a>5.2 析构函数</h2><p>析构函数也是一种特殊的成员函数，它的名字是类名前加上一个波浪号(~)，没有返回值，也没有参数。析构函数的作用是在类的对象被销毁时，对对象的数据成员进行清理，释放对象占用的内存空间，并执行一些必要的操作。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;id = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student object created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">~Student() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Student object destroyed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个Student对象</span></span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">1001</span>, <span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 输出：Student object created.</span></span><br><span class="line"><span class="comment">// 程序结束时，s1对象被销毁</span></span><br><span class="line"><span class="comment">// 输出：Student object destroyed.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-赋值函数"><a href="#5-3-赋值函数" class="headerlink" title="5.3 赋值函数"></a>5.3 赋值函数</h2><p>首先，看一段代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    stu(<span class="keyword">int</span> id,<span class="built_in">string</span> name)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setid</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main&#123;&#125;&#123;</span><br><span class="line">    <span class="function">sut <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="string">&quot;tom&quot;</span>)</span></span>;</span><br><span class="line">    sut b = a;</span><br><span class="line">    a.setid(<span class="number">2</span>);</span><br><span class="line">    b.showid();<span class="comment">//应该是1，但结果是2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码体现了对象如果直接赋值给另一个对象，并不是数据的拷贝，而只是把b指向了和a同一个空间。想要解决这种问题，c++引入了赋值函数和拷贝函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 赋值运算符重载函数</span></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; other) &#123;</span><br><span class="line"><span class="comment">// 判断是否为自赋值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line"><span class="comment">// 释放当前对象占用的资源</span></span><br><span class="line"><span class="comment">// 根据other复制当前对象的成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回当前对象的引用</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>赋值函数是一种特殊的成员函数，它的名字是operator=，有一个返回值类型为类类型的引用，有一个参数类型为类类型的常量引用。赋值函数的作用是在类的对象之间进行赋值操作时，对对象的数据成员进行逐个赋值，并返回左操作数的引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> age) : m_age(age) &#123;</span><br><span class="line">        m_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_name, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值函数</span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123; <span class="comment">// 避免自我赋值</span></span><br><span class="line">            <span class="keyword">delete</span>[] m_name;</span><br><span class="line">            m_age = other.m_age;</span><br><span class="line">            m_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(other.m_name) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(m_name, other.m_name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name = &quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;, age = &quot;</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    p1 = p2; <span class="comment">// 调用赋值函数</span></span><br><span class="line">    p1.print(); <span class="comment">// 输出name = Jerry, age = 30</span></span><br><span class="line">    p2.print(); <span class="comment">// 输出name = Jerry, age = 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-4-拷贝函数"><a href="#5-4-拷贝函数" class="headerlink" title="5.4 拷贝函数"></a>5.4 拷贝函数</h2><p>c++中拷贝函数是一种特殊的成员函数，它用于在创建对象时复制另一个对象的数据。拷贝函数的一般形式是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类名(<span class="keyword">const</span> 类名 &amp;obj) &#123;</span><br><span class="line">  <span class="comment">// 拷贝obj的数据到当前对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拷贝函数的作用是实现深拷贝，即不仅复制对象的基本类型成员，还复制对象的指针成员所指向的内存空间。如果没有定义拷贝函数，编译器会自动生成一个默认的拷贝函数，但它只能实现浅拷贝，即只复制对象的基本类型成员和指针值，而不复制指针所指向的内存空间。这样可能会导致内存泄漏或重复释放的问题。</p>
<p>拷贝函数的使用场景有以下几种：</p>
<ul>
<li>当一个对象作为参数传递给一个函数时，会调用拷贝函数创建一个临时对象。</li>
<li>当一个对象作为返回值从一个函数返回时，会调用拷贝函数创建一个临时对象。</li>
<li>当使用初始化列表或赋值运算符初始化一个对象时，会调用拷贝函数复制另一个对象的数据。</li>
</ul>
<p>拷贝函数是c++中重要的特性之一，它可以保证对象的数据安全和完整。在编写c++程序时，应该根据需要合理地定义和使用拷贝函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">int</span> age) : m_age(age) &#123;</span><br><span class="line">        m_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_name, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝函数</span></span><br><span class="line">    Person(<span class="keyword">const</span> Person&amp; other) &#123;</span><br><span class="line">        m_age = other.m_age;</span><br><span class="line">        m_name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(other.m_name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_name, other.m_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name = &quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;, age = &quot;</span> &lt;&lt; m_age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_name;</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    Person p2 = p1; <span class="comment">// 调用拷贝函数</span></span><br><span class="line">    p1.print(); <span class="comment">// 输出name = Tom, age = 20</span></span><br><span class="line">    p2.print(); <span class="comment">// 输出name = Tom, age = 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>拷贝函数和赋值函数的区别主要有以下几点：</p>
<ul>
<li>拷贝函数用于创建新对象，赋值函数用于修改已存在的对象。</li>
<li>拷贝函数只能有一个参数，即被拷贝的对象的引用，而赋值函数可以有多个参数，但第一个参数必须是被赋值的对象的引用。</li>
<li>拷贝函数不需要返回值，而赋值函数需要返回被赋值的对象的引用，以便进行连续赋值。</li>
<li>拷贝函数不需要考虑自拷贝的情况，而赋值函数需要在函数内部判断是否为自赋值，以避免出现错误。</li>
<li>拷贝函数不需要释放当前对象占用的资源，而赋值函数需要在复制之前释放当前对象占用的资源，以防止内存泄漏。</li>
</ul>
</blockquote>
<p>如果使用默认的拷贝函数和赋值函数，则会进行浅拷贝。当类中含有指针类型的数据成员时要避免浅拷贝。如果需要进行深拷贝，则需要自定义拷贝函数和赋值函数，实现拷贝构造函数以及赋值操作时，为指针开辟新的空间。</p>
<h2 id="5-5-友员函数"><a href="#5-5-友员函数" class="headerlink" title="5.5 友员函数"></a>5.5 友员函数</h2><p>在C++中，友元（friend）是一种特殊的关系，它允许一个类的非成员函数或另一个类访问该类的私有成员和保护成员。这个关系可以在类的定义中通过friend关键字来声明。</p>
<p>友元函数是一个在类外定义的函数，它可以访问该类的私有成员和保护成员。声明一个函数为友元函数的方法是在该类的定义中使用friend关键字，后跟函数的声明。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">myFriendFunction</span><span class="params">(MyClass obj)</span></span>; <span class="comment">// 友元函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFriendFunction</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; obj.x; <span class="comment">// 可以访问MyClass类的私有成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，一个类也可以成为另一个类的友元。这个类就可以访问该类的私有成员和保护成员。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFriendClass</span>;</span> <span class="comment">// 友元类声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFriendClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj.x; <span class="comment">// 可以访问MyClass类的私有成员</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是，友元关系是单向的，不具有传递性。即如果类A是类B的友元，类C是类A的友元，那么类C不能访问类B的私有成员和保护成员。友员函数虽然可以访问类的私有和保护成员，但它并不是该类的成员函数，也不受该类的访问控制规则的约束。因此，友员函数不能使用this指针，也不能直接访问该类的成员名，而必须通过对象名、引用或指针来访问。另外，友员函数也不能被继承或多态。<strong>友元虽然可以打破类的封装性，但应该谨慎使用，因为它破坏了类的封装性原则，使代码更加复杂和难以维护。</strong></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2020/05/05/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><font color="green">简介</font></h1><p>我们关注的主要对象是重新排列数组元素的算法，其中每个元素都有一个主键，排序算法的目的就是将所有的元素的主键按照某种方式排列（通常是按照大小或是字母顺序） </p>
<a id="more"></a> 
<p>常见的十大算法：<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588689912090&di=3d31e8a2f7ab8a74d03f295e5a2c6f25&imgtype=0&src=http://img.mp.itc.cn/upload/20160925/6689ac6a8e954126aefebaf492994cfc_th.jpeg" alt="排序算法"></p>
<blockquote>
<p>稳定：指如果有相同的数，排序后本来在前面的还是在前面<br>out-place：指用了额外的空间</p>
</blockquote>
<hr>
<br>

<p>下面我们在介绍排序算法时将从这几个方向入手：</p>
<ul>
<li>算法思路</li>
<li>算法图解</li>
<li>基本代码实现</li>
<li>易踩坑点</li>
<li>优化思路</li>
</ul>
<p><strong>如未特别说明，下面的变量都是从0开始的</strong></p>
<hr>
<br>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><font color="green">冒泡排序</font></h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>从头开始遍历数据，当前者的主键(值)大于后者时，两者交换位置，直到最后一位</li>
<li>此时数据的最大值一定排在了最后一位，排好的最大值便固定，无需再排</li>
<li>重复1的操作，直到最后两个数排序完成</li>
</ol>
<p>总结：外部循环<code>数据个数-1</code>次，内部循环<code>数组长度-n-1</code>次，每次内部循环比较当前位和后一位的值的大小，判断是否交换</p>
<h2 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3438712239,3527372442&fm=26&gp=0.jpg" alt="冒泡排序"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp; <span class="comment">//帮助交换</span></span><br><span class="line">            <span class="keyword">boolean</span> falg = <span class="keyword">false</span>; <span class="comment">//检查是否已经排好</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                falg = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123; <span class="comment">//每次排序后的最大位可以忽略</span></span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        falg =<span class="keyword">true</span>;</span><br><span class="line">                        temp=arr[j+<span class="number">1</span>];</span><br><span class="line">                        arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                        arr[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!falg) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点"><a href="#易踩坑点" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>一共循环 <code>数据个数-1</code> 次 ，因为最后一次确定第二个值的同时也把最小值确定了</li>
<li>每次遍历后的最大值要忽略，所以每次内部循环时循环次数要-1次</li>
<li>因为比较是和后面的数比较，所以当后面的数到最大值即当前数到倒数第二个时就说明内部循环完，否则数组越界</li>
</ol>
<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>如果有次内循环中没有发生交换，说明已经有序</p>
<hr>
<br>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><font color="green">选择排序</font></h1><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>先把第一个数记成最小值，遍历整个数组，记录遍历时遇见的最小值</li>
<li>遍历完一次后将最小值和第一个数交换位置，下一次遍历从第二个数开始</li>
<li>重复上述操作，直到最后两个数遍历完成</li>
</ol>
<h2 id="算法图解-1"><a href="#算法图解-1" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="http://www.west.cn/cms/images/2019-01-10/q5dlczui1fw.gif" alt="选择排序"></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min;<span class="comment">//记录最小数</span></span><br><span class="line">        <span class="keyword">int</span> temp; <span class="comment">//帮助交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length;i++)&#123;</span><br><span class="line">            min = i; <span class="comment">//将最小值初始化为遍历的第一个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;arr[min])&#123; <span class="comment">//*当某数小于当前最小数(别写成i)时，将最小数的索引改成该数的索引</span></span><br><span class="line">                    min =j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行交换</span></span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-1"><a href="#易踩坑点-1" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>开始时我们是把第一个数当成最小值的，所以是从第二个数开始遍历的</li>
<li>i值的含义有两个，一个是遍历次数，一个是当前遍历最小时应所处的位置</li>
</ol>
<hr>
<br>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><font color="green">插入排序</font></h1><h2 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>遍历数组，将当前数组插入左边已排好数据中</li>
<li>插入方法：先记录当前值，遍历左边，将当前数左边的数向右移动，直到遇见比当前数小的数，此时空白部分便是要插入的地方</li>
</ol>
<h2 id="算法图解-2"><a href="#算法图解-2" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;    </span><br><span class="line">        <span class="comment">//插入法</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            temp=arr[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j];j--)&#123; <span class="comment">//别忘了j要大于0</span></span><br><span class="line">                arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-2"><a href="#易踩坑点-2" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>i是从第二个数开始的</li>
<li>为了插入而进行的遍历一定别忘了j要大于0，(因为每次都是j和j+1比较)如果当前值正好是最小值，则数组会越界</li>
<li>这里j的含义是当前值最后插入的位置的左边</li>
</ol>
<hr>
<br>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><font color="green">希尔排序</font></h1><h2 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>先将数据分成间隔为h的许多小组，先让小组进行排序(插入排序法)</li>
<li>在把间隔缩短（小组变少，每个组中数变多）再进行插入排序</li>
<li>重复上述步骤，直到最后间隔为1时排序(即整个数据排序)</li>
</ol>
<blockquote>
<p>注：h也称为增量序列，对于最优增量序列目前还没有结论，主要的增量序列有Shell 增量序列，Hibbard 增量序列，Knuth 增量序列</p>
</blockquote>
<h2 id="算法图解-3"><a href="#算法图解-3" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" alt="希尔排序"></p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = arr.length; <span class="comment">//总数</span></span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">1</span>;<span class="comment">//增量序列</span></span><br><span class="line">        <span class="keyword">while</span>(h&lt;N/<span class="number">3</span>) h= h*<span class="number">3</span>+<span class="number">1</span>; <span class="comment">//Knuth 增量序列计算得来的h</span></span><br><span class="line">        <span class="comment">//插入法</span></span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;N;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i]; <span class="comment">//因为arr[i]的值可能会变，保存插入值</span></span><br><span class="line">                <span class="keyword">for</span>(;j-h&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j-h];j=j-h)&#123;</span><br><span class="line">                    arr[j] = arr[j-h];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            h=h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-3"><a href="#易踩坑点-3" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>和插入排序一样，i是从h而不是0开始的(h代表的是第一个小组的第二个数)</li>
<li>这里j的含义是当前数再小组中该插入的位置(和插入排序j的含义不同)，所以不是要 j&gt;=0而是要 j-h&gt;=0 (因为每次都是j和j-h比较)</li>
<li>这里是从h开始遍历到结束，效果是先让每个小组的第二个数和前面比较后再让每个小组的第三个数和前面比较，如此循环</li>
</ol>
<h2 id="优化思路-1"><a href="#优化思路-1" class="headerlink" title="优化思路"></a>优化思路</h2><p>增量序列的不同会影响排序算法效率</p>
<hr>
<br>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><font color="green">归并排序</font></h1><h2 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>将数组分成两部分</li>
<li>左部分和右部分分别排序，直到左部分或右部分只有一个数时返回</li>
<li>将两部分合并起来</li>
</ol>
<p>合并方法：</p>
<ul>
<li>传入需要合并的部分的开头，中间和结尾数，将该部分数组放入辅助数组对应位置中</li>
<li>左部分开头和右部分开头创建指针分别遍历：</li>
<li>当左边遍历完时，将右边的数传入原数组</li>
<li>当右边遍历完时，将左边的数传入原数组</li>
<li>当左边小于右边时，将左边的数传入原数组</li>
<li>当右边小于左边时，将右边的数传入原数组</li>
</ul>
<h2 id="算法图解-4"><a href="#算法图解-4" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=4070550482,2402998767&fm=26&gp=0.jpg" alt="归并算法"></p>
<p>合并步骤：</p>
<p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1120323612,2379483011&fm=15&gp=0.jpg" alt="归并算法2"></p>
<h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux; <span class="comment">//归并时所用的辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并两个有序子数据：先将要归并的数据保存到辅助数组中，用两个指针指向辅助数组的前面和中间+1分成两数组</span></span><br><span class="line">    <span class="comment">//两数组依次比较，将较小的数放进原数组对应位置，然后较小数所在的数组指针上移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并子数组，先将数据存入辅助数组中，用两指针二分辅助数组并遍历</span></span><br><span class="line">    <span class="comment">//mid为左边数组的最右边，即最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//辅助指针</span></span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将要归并的数据保存到辅助数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;=hi;k++)&#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;=hi;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;mid) a[k] = aux[j++];<span class="comment">//左边数组遍历完时，直接加右边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;hi) a[k] = aux[i++];<span class="comment">//右边数组遍历完时，直接加左边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aux[i]&gt;aux[j]) a[k] = aux [j++]; <span class="comment">//当右边的比左边的小时，加右边</span></span><br><span class="line">            <span class="keyword">else</span> a[k] = aux [i++]; <span class="comment">//当左边的比右边的小时，加左边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自顶向下的归并排序,将数组不断地二分直到直到只有一个数，再向上合并返回</span></span><br><span class="line">    <span class="comment">//将数组分成左右两部分，每个部分进行排序，排完后再合并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        mergeSort1(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo ,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span>; <span class="comment">//如果最前面和最后面一样说明已经分成最小单位</span></span><br><span class="line">        <span class="keyword">int</span> mid = (hi-lo)/<span class="number">2</span>+lo;</span><br><span class="line">        mergeSort1(a,lo,mid);</span><br><span class="line">        mergeSort1(a,mid+<span class="number">1</span>,hi);</span><br><span class="line">        <span class="keyword">if</span>(a[mid+<span class="number">1</span>]&gt;=a[mid]) <span class="keyword">return</span>; <span class="comment">//优化，如果排好序的右边最小值已经大于左边最大值，说明已经有序</span></span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-4"><a href="#易踩坑点-4" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>合并时传入的 mid (中间值)含义是左部分的最后一个数，算 mid 时记得要加 lo，写右边排序时记得传入的是 mid+1</li>
<li>合并中，将数据存入辅助数组是记得要&lt;=最后一位数而不是&lt;</li>
<li>判断是否左部分或右部分只含有一个数(传入的最左边的索引<code>lo</code> &gt;= 最右边的索引<code>hi</code>)</li>
</ol>
<h2 id="优化思路-2"><a href="#优化思路-2" class="headerlink" title="优化思路"></a>优化思路</h2><p>左右两边排好了之后，如果这时左部分的最大值&lt;=右部分的最小值的，说明已经有序，不用再合并</p>
<h3 id="自下向顶的归并"><a href="#自下向顶的归并" class="headerlink" title="自下向顶的归并"></a>自下向顶的归并</h3><p>除了上面的自顶向下的归并方法，还存在自下向顶的归并的方法：</p>
<ul>
<li><p>每个子数组长度为1开始，2个一组归并，再4个一组归并，直到整个归并</p>
<p>图解：<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E8%87%AA%E4%B8%8B%E5%90%91%E9%A1%B6.jpg" alt="自顶向下"></p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i*=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//因为归并是两个归并，所以每次指针k要移动2个子数组长度</span></span><br><span class="line">            <span class="comment">//可以把一个子数组的i个 数看成一个整体，k的循环就要小于a.length - i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.length - i; k=k+i*<span class="number">2</span>)&#123;</span><br><span class="line">                merge(a,k,k+i-<span class="number">1</span>,Math.min(k+i*<span class="number">2</span>-<span class="number">1</span>,a.length-<span class="number">1</span>)); <span class="comment">//有可能最后一组数不够，要判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>易踩坑点：</p>
<ol>
<li>因为k的作用是指向两个子数组合并的开头，如果最后的个数连一个子数组都没达到的话，那在合并时传入的中间值k+i-1就会发生数组出界问题，所以 k&lt;a.length-i</li>
<li>如果最后只剩一个不全数组，则放到下一轮，如果最后剩一个好的左部分和一个不全的右部分，两者可以合并，但要注意此时传入的最右边的值就不是 k+i*2-1 而是 a.length-1</li>
</ol>
<hr>
<br>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><font color="green">快速排序</font></h1><h2 id="算法思路-5"><a href="#算法思路-5" class="headerlink" title="算法思路"></a>算法思路</h2><p>和归并排序有异曲同工之妙，都采用分治法，但不同点是归并是先分别排序后归并，快速是分开时先排序再分别排序</p>
<ol>
<li>确定一位中间值(一般取第一个数),遍历数组，小于等于中间值的放左边，大于等于中间值的放右边</li>
<li>对中间值左边的数组排序</li>
<li>对中间值右边的数组排序</li>
</ol>
<p>上面 1 的具体步骤：</p>
<ol>
<li>将左边第一个数设为中间值</li>
<li>左边第二个和最右边分别设置两指针向中间遍历，直到左边的指针大于等于右边的指针</li>
<li>当左边遍历时遇见大于中间值的数停下，当右边遍历时遇见小于中间值的数停下</li>
<li>当两指针停下后交换两指针所值的数</li>
<li>遍历完后j所指的一定是小于等于中间值的，将j所在的数与第一个数交换，返回j(中间值所在位置)</li>
</ol>
<h2 id="算法图解-5"><a href="#算法图解-5" class="headerlink" title="算法图解"></a>算法图解</h2><p>整体思路：</p>
<p><img src="https://img-blog.csdnimg.cn/20200318212047646.png" alt="快速排序"></p>
<p>左右排序：</p>
<p>i和j最后一次交换时<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F2.jpg" alt="快速排序2"></p>
<p>i和j最后一次没有交换时<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F3.jpg" alt="快速排序3"></p>
<h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将数组有序二分并返回切分元素位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建两个辅助指针和切分元素</span></span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = hi+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i,j指针向中间遍历，直到遇见不符合的数或边界停下，两者都停下时将两数进行交换</span></span><br><span class="line">        <span class="comment">//当遍历完时i的位置可能会比j大(最后两个数发生交换时，i，j同时移动)可能相等(最后两个数没发生交换时，i，j其中一个移动)</span></span><br><span class="line">        <span class="comment">//遍历完时j的位置一定在小于等于切分元素的数的索引上，将这两个数交换，j所指的便是切分元素索引</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[++i] &lt; v) <span class="keyword">if</span>(i==hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (a[--j] &gt; v) ;<span class="comment">//这里本来还有个判断j是否跑到了最左边(当切分元素是该数据中最小值时)，但因为v在最左边，j一定会停在lo上</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        a[lo] = a[j];</span><br><span class="line">        a[j] = v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        quick(a , <span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span>;  <span class="comment">//可以在某个情况后改成插入排序</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        quick(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        quick(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="易踩坑点-5"><a href="#易踩坑点-5" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>数组切分时创建并初始化 i 与 j 是让 i ，j 等于第一个数和最后一个数的后一位，并且先加减再操作。如果是让 i ，j 等于第二个数和最后一个数并且先操作在加减时会很麻烦，不仅要在内循环中写i++，j–，在arr[i]和arr[j]交换后也要写i++，j– <strong>最好是先移动指针再操作</strong></li>
<li>返回中间值后，中间值是不再参与排序的</li>
<li>小心i和j出界的问题，当i到最右边或j到左边时，也要停止指针移动(j比较特殊，因为j到最左边时一定是等于v的，不可能越界)</li>
</ol>
<h2 id="优化思路-3"><a href="#优化思路-3" class="headerlink" title="优化思路"></a>优化思路</h2><p>防止特殊情况，可以先把数据打乱再排</p>
<h3 id="三切分法："><a href="#三切分法：" class="headerlink" title="三切分法："></a>三切分法：</h3><p>思路：</p>
<ul>
<li>对于有大量的重复数而言，可以使用三分切法，将数据分成大于v，等于，小于iv三部分，v代表中间值<ul>
<li>三个辅助指针i,lt,gt，i来遍历数组，直到大于gt(等于gt时还要再判断一次)</li>
<li>如果i遇见小的数，和lt交换并两者++，如果遇见大的数，和gt交换，gt–，i不动(因为无法保证gt所在的值，lt一定为v)</li>
<li>最后lt，gt都在中间段的最左边和最右边</li>
</ul>
</li>
</ul>
<p>图示：<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B8%89%E5%90%91%E5%88%87%E5%88%86.jpg" alt="快速排序三向切分"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">quick3way</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        quick(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick3way</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi&lt;=lo) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lt = lo;</span><br><span class="line">        <span class="keyword">int</span> gt = hi;</span><br><span class="line">        <span class="keyword">int</span> i  = lo+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v  = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=gt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;v) exchange(a,i++,lt++); <span class="comment">//lt一定为v，交换后i为v，可以移动</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;v) exchange(a,i,gt--); <span class="comment">//无法确定gt处的值，交换后不能动i</span></span><br><span class="line">            <span class="keyword">else</span> i++; <span class="comment">//i处等于v</span></span><br><span class="line">            &#125;</span><br><span class="line">        quick3way(a,lo,lt-<span class="number">1</span>);</span><br><span class="line">        quick3way(a,gt+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[x];</span><br><span class="line">        a[x] = a[y];</span><br><span class="line">        a[y] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>易踩坑点：</p>
<ol>
<li>因为lt是一定等于v的并且在等于v数组的最左边，所以和i所在值交换后两者可以一起++，但由于不知道gt所在的值，所以和i所在值交换后只能让gt–，i不动</li>
<li>记得当i=gt时还要再判断一次</li>
</ol>
<hr>
<br>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><font color="green">计数排序</font></h1><h2 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h2><ol>
<li>找到数组中最大的值</li>
<li>创建一个长度为最大值+1的数组，遍历原数组把数放在值相同的辅助数组下(如遍历到5，则让辅助数组temp[5]++)</li>
<li>遍历辅助数组，将不等于0的索引依次返回给原数组</li>
</ol>
<h2 id="算法图解-6"><a href="#算法图解-6" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="计数排序"></p>
<h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">counting</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = findMax(a);</span><br><span class="line">        counting(a,max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">counting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//用作a的指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:a)&#123;</span><br><span class="line">            temp[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                a[k++] = i;</span><br><span class="line">                temp[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;max) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="易踩坑点-6"><a href="#易踩坑点-6" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>数组计数是从0开始的，记得创建数组时长度为 max+1 这样数组的最后一位才是max</li>
<li>当取出一个数后，该数上的计数(即 temp[ i ] )要-1</li>
<li>注意当前给的代码中因为是用的<code>temp[i]--</code>所以不稳定，可以改成一个从0开始小于temp[i]的循环</li>
</ol>
<hr>
<br>

<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><font color="green">桶排序</font></h1><h2 id="算法思路-6"><a href="#算法思路-6" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>找到数组最大值</li>
<li>根据最大值创建n个桶，每个桶中存放一定范围的数</li>
<li>将每个桶中的数据排序</li>
<li>遍历桶，返回桶中的数</li>
</ol>
<p><strong>因为这个算法本身比较麻烦且用得不多，就不再演示了</strong></p>
<hr>
<br>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><font color="green">基数排序</font></h1><h2 id="算法思路-7"><a href="#算法思路-7" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>找到数据中 位数最高的数（即最大数有多少位）</li>
<li>创建一个二维数组，第一维 0~9 代表某位上可能出现的数，第二维用来存某位相同的数（如12，42都放在arr[2][n]中）</li>
<li>从个位数开始，遍历数组，将个位上相同的数存入相同一维的二维数组中（这里需要一个辅助一维数组来记录二维数组的一维上有多少存储的数）</li>
<li>遍历二维数组，依次返回给原数组</li>
<li>再从十位开始，重复上述操作，如果没十位则补0.循环最高位数次</li>
</ol>
<blockquote>
<p>二维数组可以这样理解：一共有0<del>9的桶，某位上值和桶的索引一样时放进桶中，从下到上放入桶中。一维数组也是0</del>9，每个位置的值就代表桶中有多少存入的值以及下一个该存入该桶的数的位置</p>
</blockquote>
<h2 id="算法图解-7"><a href="#算法图解-7" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="基数排序"></p>
<h2 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> high = findHigh(a);</span><br><span class="line">        radix(a,high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][a.length]; <span class="comment">//放数据的桶，一共要有10个桶(0~9),桶中最多存a中所有的数</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>; <span class="comment">//用于计算某位上的数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一共循环的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=high;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] bucketContent = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//记录每个桶有多少数已经下一个数应该存放在桶的哪里</span></span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>; <span class="comment">//用于将桶中数据返回给数组时对数组的指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算某位上的数进行分组,放入桶里</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : a) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (value / m) % <span class="number">10</span>; <span class="comment">//如果该数没有更高位，temp就为0</span></span><br><span class="line">                bucket[temp][bucketContent[temp]] = value;<span class="comment">//bucketContent[temp]可以表示该存入该桶的数的位置</span></span><br><span class="line">                bucketContent[temp]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将桶中数据返回数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;bucket.length;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bucketContent[k]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bucketContent[k];j++)&#123;</span><br><span class="line">                        a[n++] = bucket[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m=m*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findHigh</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;max)&#123;</span><br><span class="line">                max = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String temp = Integer.toString(max);</span><br><span class="line">        <span class="keyword">return</span> temp.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-7"><a href="#易踩坑点-7" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>每循环完一次后辅助一维数组要清0，即要放入循环中</li>
<li>用m计算位时，没有该位的运算结果就为0</li>
<li>每次记得m*10</li>
</ol>
<hr>
<br>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><font color="green">堆排序</font></h1><p><del>还没学到二叉树呢，以后补</del></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法，排序算法，基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day30-网络编程连接</title>
    <url>/2023/04/11/day30-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="day29-网络编程简介"><a href="#day29-网络编程简介" class="headerlink" title="day29-网络编程简介"></a><font color="green">day29-网络编程简介</font></h1><a id="more"></a>
<h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1-1-网络协议模型："><a href="#1-1-网络协议模型：" class="headerlink" title="1.1 网络协议模型："></a>1.1 网络协议模型：</h3><p>​OSI七层协议模型：</p>
<blockquote>
<p>​应用层<br>​表示层<br>​会话层<br>​传输层<br>​网络层<br>​数据链路层<br>​物理层</p>
</blockquote>
<p>​TCP/IP四层协议模型：</p>
<blockquote>
<p>应用层：<br>​传输层：TCP、UDP<br>​网络层：IP<br>​物理与网络接口层    </p>
</blockquote>
<h3 id="1-2-ip，端口-套接字"><a href="#1-2-ip，端口-套接字" class="headerlink" title="1.2 ip，端口,套接字"></a>1.2 ip，端口,套接字</h3><p>IP：</p>
<blockquote>
<p>IP：在网络中唯一标识一台主机<br>​IPV4: 4字节  32bit<br>点分十进制：  “192.168.1.45”<br>二进制形式：11000000 10101000 00000001 00101101</p>
</blockquote>
<p>端口：</p>
<blockquote>
<p>PORT：端口号 unsigned short<br>1-1023：系统端口<br>1024-5000：一般应用程序接口<br>5001-65535：系统预留用户自定义接口</p>
</blockquote>
<p>​套接字：</p>
<blockquote>
<p>本质：是一种特殊的文件描述符<br>TCP通信流程：<br>服务器：<br>socket() –&gt; bind() –&gt; listen() –&gt; accept() –&gt; read()/write() –&gt; close()<br>客户端：<br>socket() –&gt; connect() –&gt; read()/write() –&gt; close()</p>
</blockquote>
<br>
<br>

<hr>
<h2 id="二、网络编程相关接口函数"><a href="#二、网络编程相关接口函数" class="headerlink" title="二、网络编程相关接口函数"></a>二、网络编程相关接口函数</h2><h3 id="2-1创建套接字-–-socket"><a href="#2-1创建套接字-–-socket" class="headerlink" title="2.1创建套接字 – socket"></a>2.1创建套接字 – socket</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line"></span><br><span class="line">功能：socket函数用于创建一个套接字（socket）</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：成功返回套接字的文件描述符.失败，将返回-1，并设置errno变量表示错误类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    domain：指定套接字的协议族（protocol family），常见的协议族包括AF_INET（IPv4协议）、AF_INET6（IPv6协议）和AF_UNIX（本地协议）等。</span><br><span class="line">    type：指定套接字的类型（socket type），常见的套接字类型包括SOCK_STREAM（面向连接的流套接字）和SOCK_DGRAM（无连接的数据报套接字）等。</span><br><span class="line">    protocol：指定套接字所使用的协议（protocol），常见的协议包括IPPROTO_TCP（TCP协议）、IPPROTO_UDP（UDP协议）和IPPROTO_SCTP（SCTP协议）等。默认选项填0。</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="2-2绑定本机IP地址和端口号"><a href="#2-2绑定本机IP地址和端口号" class="headerlink" title="2.2绑定本机IP地址和端口号"></a>2.2绑定本机IP地址和端口号</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line"></span><br><span class="line">功能：将一个套接字（socket）绑定到一个本地地址（IP地址和端口号）</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt;         </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;netinet/ip.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">sockfd：通过socket创建得到的套接字</span><br><span class="line">addr：服务器地址结构的首地址，结构体是sockaddr_in</span><br><span class="line">addrlen：地址结构的大小  </span><br><span class="line">返回值：</span><br><span class="line">成功返回0，失败返回-1</span><br><span class="line">       	</span><br><span class="line">       	   	</span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">sa_family_t    sin_family; /* 一般使用AF_INET（IPv4协议族）或AF_INET6（IPv6协议族） */</span><br><span class="line">in_port_t      sin_port;   /* 表示端口号，以网络字节序表示 */</span><br><span class="line">struct in_addr sin_addr;   /* internet address */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct in_addr &#123;</span><br><span class="line">uint32_t       s_addr;     /* IPv4地址，网络字节序 */</span><br><span class="line">&#125;;</span><br><span class="line">     </span><br><span class="line">相关函数：</span><br><span class="line">inet_addr(&quot;192.168.1.23&quot;);  //将点分十进制IP转换为整数形式（字节序）</span><br><span class="line">char *inet_ntoa(struct in_addr address); //将整数形式的地址转换为点分十进制</span><br><span class="line">    		</span><br><span class="line">sin_addr.s_addr = htons(INADDR_ANY); //任意本地IP地址</span><br><span class="line">       </span><br><span class="line">sockaddr_in.sin_port = htons(6666); //用于将16位的主机字节序（little-endian）的整数转换为网络字节序（big-endian）的整数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-3设置监听套接字-–-listen"><a href="#2-3设置监听套接字-–-listen" class="headerlink" title="2.3设置监听套接字 – listen"></a>2.3设置监听套接字 – listen</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">用于将一个套接字转换为被动套接字，用于服务器端的网络编程。被动套接字可以接收来自客户端的连接请求。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">成功，将返回0。</span><br><span class="line">失败，将返回-1，并设置errno变量表示错误类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：需要转换为被动套接字的套接字的文件描述符。</span><br><span class="line">    backlog：表示请求连接队列的最大长度，也就是可以同时接收的连接请求数量的上限。该参数的取值一般为5到128之间。</span><br></pre></td></tr></table></figure>



<h3 id="2-4等待客户端连接-–-accept"><a href="#2-4等待客户端连接-–-accept" class="headerlink" title="2.4等待客户端连接 – accept"></a>2.4等待客户端连接 – accept</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">accept函数用于从监听套接字中接收来自客户端的连接请求，创建一个新的套接字，并将其绑定到客户端的地址。该新的套接字可以用于与客户端进行通信。</span><br><span class="line"></span><br><span class="line">头文件：    </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">如果accept函数调用成功，将返回一个非负整数，表示新创建的套接字的文件描述符。该文件描述符可以用于后续的套接字操作（如send、recv等）。</span><br><span class="line">如果accept函数调用失败，将返回-1，并设置errno变量表示错误类型。  </span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：需要接受连接请求的监听套接字的文件描述符（file descriptor）。</span><br><span class="line"></span><br><span class="line">    addr：指向客户端地址的指针，是一个sockaddr结构体类型指针。在accept函数返回时，客户端的地址信息将被填充到该结构体中。记得要强转。</span><br><span class="line">    int connfd = accept(sockfd, (struct sockaddr *)&amp;caddr, &amp;c_len);</span><br><span class="line"></span><br><span class="line">    addrlen：指向addr结构体的大小的指针。在accept函数返回时，该指针将被设置为客户端地址结构体的大小。sizeof(caddr);</span><br><span class="line"></span><br><span class="line">accept(sockfd, NULL, NULL);//意思是接受监听套接字上的连接请求，但不获取客户端的地址信息。</span><br></pre></td></tr></table></figure>
<h3 id="2-5向服务器发起连接-–-connect"><a href="#2-5向服务器发起连接-–-connect" class="headerlink" title="2.5向服务器发起连接 – connect"></a>2.5向服务器发起连接 – connect</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line"></span><br><span class="line">功能：将套接字连接到远程主机的地址。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">如果connect函数调用成功，将返回0。</span><br><span class="line">如果connect函数调用失败，将返回-1，并设置errno变量表示错误类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：需要连接到远程主机的套接字的文件描述符。</span><br><span class="line">    addr：指向远程主机地址的指针，是一个sockaddr结构体类型指针。该结构体包含了远程主机的IP地址和端口号等信息。</span><br><span class="line">    addrlen：指定addr结构体的大小。</span><br></pre></td></tr></table></figure>

<h3 id="2-6发送接收数据-–-send、recv"><a href="#2-6发送接收数据-–-send、recv" class="headerlink" title="2.6发送接收数据 – send、recv"></a>2.6发送接收数据 – send、recv</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">功能：用于向已连接的套接字发送/接收数据。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">成功将返回实际发送/接收的字节数。</span><br><span class="line">失败将返回-1，并设置errno变量表示错误类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：需要发送/接收数据的套接字的文件描述符。</span><br><span class="line">    buf：指向待发送/接收数据的缓冲区的指针。</span><br><span class="line">    len：待发送/接收数据的字节数。</span><br><span class="line">    flags：用于控制数据发送/接收的方式的标志位，一般设置为0即可。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1.在发送数据时，可以通过设置flags参数的值来控制数据发送的方式，例如设置为MSG_DONTWAIT将数据设置为非阻塞模式。一般情况下，flags的取值应该为0。</span><br><span class="line">2. 在发送数据时，应该确保buf指向的缓冲区中的数据已经准备好。如果缓冲区中的数据还没有完全准备好，可以使用select或poll等函数进行等待，以避免因缓冲区未就绪而导致的发送失败。</span><br></pre></td></tr></table></figure>

<p><strong><font color="red">在进行TCP协议传输的时候，要注意数据流传输的特点，recv和send不一定是一一对应的（一般情况下是一一对应），也就是说并不是send一次，就一定recv一次就接收完，有可能send一次，recv多次才接收完，也可能send多次，一次recv就接收完了。这和网络束调有关。</font></strong></p>
<p>示例代码：</p>
<p>客户端向服务端发送图片：</p>
<ul>
<li><p>服务端：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、绑定本机IP地址和端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET; <span class="comment">//ipv4</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">6666</span>); <span class="comment">//把主机字节序转换为网络字节序再赋值</span></span><br><span class="line">    <span class="comment">//saddr.sin_addr.s_addr = inet_addr(&quot;192.168.12.15&quot;);//将点分十进制转换为整形再赋值</span></span><br><span class="line">    saddr.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);  <span class="comment">//计算数据结构的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bind success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、设置监听套接字</span></span><br><span class="line">    ret = listen(sockfd, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;caddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(caddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c_len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wait for a new client...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(sockfd, (struct sockaddr *)&amp;caddr, &amp;c_len);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;link success! ip -- %s port -- %d\n&quot;</span>, inet_ntoa(caddr.sin_addr), ntohs(caddr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.jpg&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open 1.jpg&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>( (ret = read(connfd, buf, <span class="number">64</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(fd, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(connfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket success!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、向服务器发起连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.12.15&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = connect(sockfd, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;link success!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.jpg&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open 1.jpg&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((ret = read(fd, buf, <span class="number">64</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(sockfd, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

</li>
</ul>
<br>
<br>

<hr>
<h2 id="三、服务器模型"><a href="#三、服务器模型" class="headerlink" title="三、服务器模型"></a>三、服务器模型</h2><h3 id="3-1-循环服务器"><a href="#3-1-循环服务器" class="headerlink" title="3.1 循环服务器"></a>3.1 循环服务器</h3><blockquote>
<ol>
<li>服务器端从连接请求队列中提取请求，建立连接并返回新的已经连接套接字；</li>
<li>服务器端通过已经连接的套接字循环接受数据，处理并发送给客户端直到客户端关闭；</li>
<li>服务器关闭已连接套接字，返回步骤（1）处理下一个客户端；<br>-———————————————————————–</li>
<li>服务器端采用循环嵌套来实现：外层循环依次提取客户端的请求队列并建立TCP连接，内层循环接受处理连接客户端的所有数据，直到客户端关闭；</li>
<li>如果当前客户端没有处理结束，其他客户端必须一直等待；</li>
</ol>
</blockquote>
<h3 id="3-2-并发服务器"><a href="#3-2-并发服务器" class="headerlink" title="3.2 并发服务器"></a>3.2 并发服务器</h3><blockquote>
<ol>
<li>服务器端父进程从连接请求队列中提取请求，建立连接并返回新的已创建套接字；</li>
<li>服务器端父进程创建子进程为客户端服务，客户端关闭连接时，子进程结束；</li>
<li>服务器端父进程关闭已连接套接字，返回步骤（1）；<br>-———————————————————————</li>
<li>服务器端父进程一旦接收到客户端的连接请求，便建立好连接并创建新的子进程。这意味着每个客广端在服务器端有一个专门的子进程为其服务。</li>
<li>服务器端的多个子进程同时运行 （宏观上），处理多个容户端。</li>
<li>服务器端的父进程不具体处理每个客户端的数据请求。</li>
</ol>
</blockquote>
<h4 id="3-2-1多进程并发服务器"><a href="#3-2-1多进程并发服务器" class="headerlink" title="3.2.1多进程并发服务器"></a>3.2.1多进程并发服务器</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">socket(...)</span><br><span class="line">bind(...)</span><br><span class="line">listen(...)</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    accept(...)</span><br><span class="line">    if(fork(...)==0)</span><br><span class="line">    &#123;</span><br><span class="line">        process(...);</span><br><span class="line">        close(...);</span><br><span class="line">        exit(...);</span><br><span class="line">    &#125;</span><br><span class="line">    close(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_handler</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> connfd;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、绑定本机IP地址和端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET; <span class="comment">//ipv4</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">6666</span>); <span class="comment">//把主机字节序转换为网络字节序再赋值</span></span><br><span class="line">    <span class="comment">//saddr.sin_addr.s_addr = inet_addr(&quot;192.168.12.15&quot;);//将点分十进制转换为整形再赋值</span></span><br><span class="line">    saddr.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);  <span class="comment">//计算数据结构的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bind success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、设置监听套接字</span></span><br><span class="line">    ret = listen(sockfd, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;caddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(caddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c_len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    signal(<span class="number">17</span>, wait_handler);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait for a new client...\n&quot;</span>);</span><br><span class="line">        connfd = accept(sockfd, (struct sockaddr *)&amp;caddr, &amp;c_len);</span><br><span class="line">        <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;link success! ip -- %s port -- %d\n&quot;</span>, inet_ntoa(caddr.sin_addr), ntohs(caddr.sin_port));</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//close(sockfd);</span></span><br><span class="line">            <span class="comment">//5、接收数据</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">                ret = read(connfd, buf, <span class="number">64</span>);</span><br><span class="line">                <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client leave!\n&quot;</span>);</span><br><span class="line">                    close(connfd);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recv %dbytes: %s\n&quot;</span>, ret, buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//close(connfd);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2多线程并发服务器"><a href="#3-2-2多线程并发服务器" class="headerlink" title="3.2.2多线程并发服务器"></a>3.2.2多线程并发服务器</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">socket(...)</span><br><span class="line">bind(...)</span><br><span class="line">listen(...)</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    accept(...)</span><br><span class="line">    if(pthread_create(...)== 0)</span><br><span class="line">    &#123;</span><br><span class="line">        process(...);</span><br><span class="line">        close(...);</span><br><span class="line">        exit(...);</span><br><span class="line">    &#125;</span><br><span class="line">    close(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">c_info</span>;</span></span><br><span class="line">&#125;C;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    C c1;</span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、绑定本机IP地址和端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET; <span class="comment">//ipv4</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">6666</span>); <span class="comment">//把主机字节序转换为网络字节序再赋值</span></span><br><span class="line">    <span class="comment">//saddr.sin_addr.s_addr = inet_addr(&quot;192.168.12.15&quot;);//将点分十进制转换为整形再赋值</span></span><br><span class="line">    saddr.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);  <span class="comment">//计算数据结构的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bind success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、设置监听套接字</span></span><br><span class="line">    ret = listen(sockfd, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen success!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;caddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(caddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c_len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait for a new client...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> connfd = accept(sockfd, (struct sockaddr *)&amp;caddr, &amp;c_len);</span><br><span class="line">        <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c1.c_fd = connfd;</span><br><span class="line">        c1.c_info = caddr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;link success! ip -- %s port -- %d\n&quot;</span>, inet_ntoa(caddr.sin_addr), ntohs(caddr.sin_port));</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(pthread_create(&amp;thread, <span class="literal">NULL</span>, func, &amp;c1) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pthread_detach(thread);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//int connfd = *(int *)arg;</span></span><br><span class="line">    C c2 = *(C *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、接收数据</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">        ret = read(c2.c_fd, buf, <span class="number">64</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client leave!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv %dbytes: %s  ip -- %s\n&quot;</span>, ret, buf, inet_ntoa(c2.c_info.sin_addr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(c2.c_fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="四、udp通信"><a href="#四、udp通信" class="headerlink" title="四、udp通信"></a>四、udp通信</h2><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>UDP（User Datagram Protocol，用户数据报协议）是一种无连接的、不可靠的网络传输协议。与TCP协议不同，UDP不会建立连接、不会保证数据传输的可靠性和完整性，也不会进行数据重传和流量控制等操作。UDP仅仅提供了最基本的数据传输服务，而且传输速度快，传输效率高，因此常用于实时性要求较高的网络通信，比如音视频通信、在线游戏等。</p>
<blockquote>
<p>UDP通信的基本流程如下：</p>
<ol>
<li><p>服务器和客户端都需要创建UDP套接字，并指定通信协议和端口号。</p>
</li>
<li><p>客户端向服务器发送数据包，数据包中包含了目标地址和端口号、数据等信息。在UDP协议中，发送数据包不需要建立连接，因此可以直接发送。</p>
</li>
<li><p>服务器接收到客户端发送的数据包后，解析数据包中的目标地址和端口号，并根据这些信息将响应数据包发送回客户端。</p>
</li>
<li><p>客户端接收到服务器发送的响应数据包后，解析数据包中的数据并进行相应的处理。</p>
</li>
</ol>
</blockquote>
<h3 id="4-2-相关函数"><a href="#4-2-相关函数" class="headerlink" title="4.2 相关函数"></a>4.2 相关函数</h3><ul>
<li><p>sendto</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">sendto函数用于通过指定的socket向目标地址发送数据，支持发送UDP数据报和raw IP数据包。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">sendto函数返回发送的字节数，如果返回值为-1则表示发送失败，可通过errno变量获取错误码。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：表示需要发送数据的socket文件描述符；</span><br><span class="line">    buf：表示待发送的数据缓冲区；</span><br><span class="line">    len：表示待发送的数据长度；</span><br><span class="line">    flags：表示发送数据的可选项，例如是否启用MSG_DONTWAIT标志来设置非阻塞模式；</span><br><span class="line">    dest_addr：表示目标地址信息；</span><br><span class="line">    addrlen：表示目标地址信息的长度，通常为sizeof(struct sockaddr)。</span><br></pre></td></tr></table></figure>
</li>
<li><p>recvfrom</p>
</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">recvfrom函数用于从指定的socket接收数据，并将发送者的地址信息存储在src_addr中，支持接收UDP数据报和raw IP数据包。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">recvfrom函数返回接收到的字节数，如果返回值为-1则表示接收失败，可通过errno变量获取错误码。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：表示需要接收数据的socket文件描述符；</span><br><span class="line">    buf：表示接收数据的缓冲区；</span><br><span class="line">    len：表示缓冲区的长度；</span><br><span class="line">    flags：表示接收数据的可选项，例如是否启用MSG_DONTWAIT标志来设置非阻塞模式；</span><br><span class="line">    src_addr：表示发送者的地址信息；</span><br><span class="line">    addrlen：表示发送者地址信息的长度，应当初始化为sizeof(struct sockaddr)。</span><br><span class="line"></span><br><span class="line">注意：src_addr和addrlen应当事先分配好内存，并在调用recvfrom函数时作为参数传入</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<p>服务器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、绑定本机IP地址和端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、接收数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;caddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(caddr));</span><br><span class="line">    <span class="keyword">int</span> c_len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">        ret = recvfrom(sockfd, buf, <span class="number">64</span>, <span class="number">0</span>, (struct sockaddr *)&amp;caddr, &amp;c_len);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;recvform&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip:%s -- recv %dbytes: %s&quot;</span>,inet_ntoa(caddr.sin_addr), ret, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码有两个注意点：</p>
<ol>
<li>当需要取地址时(&amp;),不能直接写<del>&amp;sizeof(caddr)</del>,要先用一个变量接收sizeof(caddr),再对变量进行取地址。</li>
<li>注意换行符，因为终端输出是行缓冲，所以没有换行符的话很容易导致无法打印。</li>
</ol>
</blockquote>
<p>客服端：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//1、创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、发送数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.12.15&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fgets(buf, <span class="number">64</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>设置非阻塞相关函数 – fcntl</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int fcntl(int fd, int cmd, ... /* arg */ );</span><br><span class="line"></span><br><span class="line">功能</span><br><span class="line">fcntl函数是一个通用的文件控制函数，其功能非常广泛。该函数可以执行的命令包括：</span><br><span class="line"></span><br><span class="line">    1. F_DUPFD： 复制文件描述符</span><br><span class="line">当应用程序需要使用多个文件描述符来操作同一个文件时，可以使用F_DUPFD命令来复制文件描述符。该命令需要一个整数参数arg，表示要创建的新文件描述符的最小值。该函数将返回一个新的文件描述符，该文件描述符是不小于arg的最小整数。</span><br><span class="line">    2. F_GETFD： 获取文件描述符标志</span><br><span class="line">应用程序可以使用F_GETFD命令获取一个文件描述符的标志。该命令不需要arg参数，而是返回一个整数值，表示该文件描述符的标志。</span><br><span class="line">    3. F_SETFD： 设置文件描述符标志</span><br><span class="line">应用程序可以使用F_SETFD命令来设置一个文件描述符的标志。该命令需要一个整数参数arg，表示要设置的标志。该函数将返回0表示成功，-1表示失败。</span><br><span class="line">    4. F_GETFL： 获取文件状态标志</span><br><span class="line">应用程序可以使用F_GETFL命令获取一个文件的状态标志。该命令不需要arg参数，而是返回一个整数值，表示该文件的状态标志。</span><br><span class="line">    5. F_SETFL： 设置文件状态标志</span><br><span class="line">应用程序可以使用F_SETFL命令来设置一个文件的状态标志。该命令需要一个整数参数arg，表示要设置的状态标志。该函数将返回0表示成功，-1表示失败。</span><br><span class="line">    6. F_GETLK： 获取文件锁定信息</span><br><span class="line">应用程序可以使用F_GETLK命令获取一个文件的锁定信息。该命令需要一个指向flock结构体的指针arg。该结构体包含锁定类型、锁定起始位置和锁定长度等信息。如果文件未被锁定，则返回一个flock结构体，其中l_type字段被设置为F_UNLCK。如果文件已被锁定，则返回一个指定锁定信息的flock结构体。</span><br><span class="line">    7. F_SETLK： 设置文件锁定信息（非阻塞）</span><br><span class="line">应用程序可以使用F_SETLK命令来设置一个文件的锁定信息，该命令是非阻塞的，如果文件已经被其他进程锁定，该命令将立即返回EACCES错误。该命令需要一个指向flock结构体的指针arg，该结构体包含要设置的锁定类型、锁定起始位置和锁定定长等信息</span><br><span class="line">    8. F_SETLKW： 设置文件锁定信息（阻塞）</span><br><span class="line">应用程序可以使用F_SETLKW命令来设置一个文件的锁定信息，该命令是阻塞的，如果文件已经被其他进程锁定，则该命令将一直阻塞，直到获取锁为止。该命令需要一个指向flock结构体的指针arg，该结构体包含要设置的锁定类型、锁定起始位置和锁定定长等信息。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">参数：</span><br><span class="line">fd：文件描述符</span><br><span class="line">cmd：</span><br><span class="line">    F_GETFL:获取文件属性状态</span><br><span class="line">    F_SETFL:设置文件属性状态</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    根据参数cmd的不同返回不同的值</span><br><span class="line">    cmd -- F_GETFL:返回获取的文件属性状态</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">1、获取文件描述符对应属性状态</span><br><span class="line">    int flag = fcntl(fd, F_GETFL, 0);</span><br><span class="line">2、将flag添加设置非阻塞方式</span><br><span class="line">    flag = flag | O_NONBLOCK;</span><br><span class="line">3、将新的状态属性设置到文件描述符中</span><br><span class="line">    fcntl(fd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flock结构体定义如下：</span><br><span class="line">struct flock &#123;</span><br><span class="line">    short l_type;   /* 锁定类型，可以是F_RDLCK或F_WRLCK或F_UNLCK */</span><br><span class="line">    short l_whence; /* 锁定起始位置，可以是SEEK_SET、SEEK_CUR或SEEK_END */</span><br><span class="line">    off_t l_start;  /* 锁定起始位置相对于l_whence的偏移量 */</span><br><span class="line">    off_t l_len;    /* 锁定定长，如果为0，则锁定到文件结束 */</span><br><span class="line">    pid_t l_pid;    /* 加锁进程的PID，仅用于F_GETLK命令 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<br>
<br>

<hr>
<h2 id="五、IO多路复用"><a href="#五、IO多路复用" class="headerlink" title="五、IO多路复用"></a>五、IO多路复用</h2><h3 id="5-1-IP多路复用基本概念"><a href="#5-1-IP多路复用基本概念" class="headerlink" title="5.1 IP多路复用基本概念"></a>5.1 IP多路复用基本概念</h3><p>IO多路复用是一种高效的IO处理模式，它可以让一个线程或进程同时监控多个文件描述符（通常是socket）的状态，从而实现并发的IO操作。IO多路复用的作用是提高系统的资源利用率，减少不必要的阻塞和上下文切换，提高程序的性能和响应速度。</p>
<p>为什么需要IO多路复用呢？我们先来看看常见的IO模型有哪些：</p>
<ul>
<li>阻塞IO：当我们调用read或write函数时，如果没有数据可读或可写，那么程序就会被阻塞，直到数据到达或发送完成。这种模式下，每个文件描述符都需要一个线程或进程来处理，如果有大量的文件描述符，那么就会消耗大量的内存和CPU资源，而且大部分时间都在等待数据，效率很低。</li>
<li>非阻塞IO：当我们调用read或write函数时，如果没有数据可读或可写，那么程序就会立即返回一个错误码，表示操作不能进行。这种模式下，我们需要不断地轮询文件描述符的状态，来判断是否可以进行IO操作。这种模式虽然避免了阻塞，但是也浪费了大量的CPU资源在无效的轮询上，而且轮询的频率很难控制。</li>
<li>信号驱动IO：当我们调用sigaction函数时，可以让内核在文件描述符可读或可写时发送一个信号给我们，然后我们在信号处理函数中进行IO操作。这种模式下，我们不需要轮询文件描述符的状态，而是由内核主动通知我们。但是信号驱动IO也有一些缺点，比如信号处理函数的执行环境受到限制，不能进行一些可能阻塞的操作；信号可能丢失或合并；信号处理函数可能被中断等。</li>
<li>异步IO：当我们调用aio_read或aio_write函数时，可以让内核在文件描述符可读或可写时自动完成数据的拷贝，并在完成后通知我们。这种模式下，我们不需要关心文件描述符的状态，也不需要自己进行数据的拷贝，完全交给内核来处理。但是异步IO在Linux上并不完善，很多系统调用并不支持异步IO。</li>
</ul>
<p>从上面可以看出，每种IO模型都有各自的优缺点，没有一种是完美的。那么有没有一种模式可以兼顾效率和简洁呢？答案就是IO多路复用。</p>
<p>IO多路复用的基本概念是，通过一个函数（如select，poll，epoll等）来监控多个文件描述符的状态，当有一个或多个文件描述符可读或可写时，函数返回，告诉我们哪些文件描述符可以进行IO操作。这样，我们就可以在一个线程或进程中处理多个文件描述符的IO事件，而不需要为每个文件描述符创建一个线程或进程，也不需要轮询或等待信号。</p>
<p>IO多路复用的作用是，提高系统的资源利用率，减少不必要的阻塞和上下文切换，提高程序的性能和响应速度。IO多路复用适合于以下场景：</p>
<ul>
<li>文件描述符数量较多，但每个文件描述符的IO操作并不频繁，大部分时间都处于空闲状态。</li>
<li>文件描述符的IO操作都是非阻塞的，不会导致线程或进程挂起。</li>
<li>文件描述符的类型不同，可能是socket，也可能是文件，管道等。</li>
<li>需要同时处理多种类型的事件，比如读写事件，错误事件，超时事件等。</li>
</ul>
<p>IO多路复用常用在网络编程中，比如实现高并发的服务器程序。通过IO多路复用，服务器可以在一个线程或进程中同时监听和处理多个客户端的连接请求和数据交互。这样可以节省系统资源，提高服务器的吞吐量和并发能力。</p>
<blockquote>
<p>流程：</p>
<ol>
<li>创建表</li>
<li>向表中添加需要监测的文件描述符</li>
<li>循环监测表<br>(1)遍历表，判断是否有文件描述符有响应<br>(2)如果有响应，需要判断是哪一个文件描述符响应，然后实现对应IO操作</li>
</ol>
</blockquote>
<h3 id="5-2-IO多路复用的相关函数"><a href="#5-2-IO多路复用的相关函数" class="headerlink" title="5.2 IO多路复用的相关函数"></a>5.2 IO多路复用的相关函数</h3><h4 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int select (int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict exceptfds, struct timeval *restrict timeout);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">select函数可以指定一个超时时间，在这个时间内，如果指定的文件描述符集合中有任何一个文件描述符发生了可读，可写或异常事件，select函数就会返回，并告知哪些文件描述符已经就绪。如果在超时时间内没有任何事件发生，select函数就会返回0。如果发生了错误，select函数就会返回-1，并设置errno变量。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">select函数返回的是就绪的文件描述符的个数，如果超时则返回0，如果出错则返回-1。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">    nfds：指定要监视的文件描述符的范围，一般是最大的文件描述符加1。</span><br><span class="line"></span><br><span class="line">    readfds：指向一个fd_set类型的指针，表示要监视的可读文件描述符集合。如果为NULL，则表示不关心任何文件的可读事件。</span><br><span class="line"></span><br><span class="line">    writefds：指向一个fd_set类型的指针，表示要监视的可写文件描述符集合。如果为NULL，则表示不关心任何文件的可写事件。</span><br><span class="line"></span><br><span class="line">    exceptfds：指向一个fd_set类型的指针，表示要监视的异常文件描述符集合。如果为NULL，则表示不关心任何文件的异常事件。</span><br><span class="line"></span><br><span class="line">    timeout：指向一个timeval结构体的指针，表示select函数的超时时间。如果为NULL，则表示无限等待。如果为0，则表示不等待，立即返回。如果为非零值，则表示等待指定的秒数和微秒数。</span><br><span class="line"></span><br><span class="line">fd_set类型和timeval结构体：</span><br><span class="line"></span><br><span class="line">fd_set类型是一个位图类型，每一位对应一个文件描述符。可以使用以下几个宏来操作fd_set类型：</span><br><span class="line"></span><br><span class="line">    void FD_ZERO(fd_set *set)：清空一个fd_set类型变量的所有位。</span><br><span class="line"></span><br><span class="line">    void FD_SET(int fd, fd_set *set)：将一个文件描述符fd加入到一个fd_set类型变量中。</span><br><span class="line"></span><br><span class="line">    void FD_CLR(int fd, fd_set *set)：将一个文件描述符fd从一个fd_set类型变量中移除。</span><br><span class="line"></span><br><span class="line">    int FD_ISSET(int fd, fd_set *set)：检查一个文件描述符fd是否在一个fd_set类型变量中。判断指定的文件描述符是否有响应，结果为真--有响应</span><br><span class="line"></span><br><span class="line">timeval结构体定义如下：</span><br><span class="line"></span><br><span class="line">struct timeval &#123;</span><br><span class="line">  long tv_sec;  /* 秒 */</span><br><span class="line">  long tv_usec; /* 微秒 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>select机制流程：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1、定义监测表,清空表</span><br><span class="line">   	fd_set rfds;</span><br><span class="line">	FD_ZERO(&amp;rfds);</span><br><span class="line">2、向表中添加要监测的文件描述符0、3</span><br><span class="line">    FD_SET(0, &amp;rfds);</span><br><span class="line">	FD_SET(3, &amp;rfds);</span><br><span class="line">	int maxfd = 3+1;</span><br><span class="line">3、循环监测表</span><br><span class="line">    int i = 0;</span><br><span class="line">4、创建监测表的替代（检测表每次响应之后会变，所以每次都要更新）</span><br><span class="line">    fd_set rfds_tmp = rfds;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        rfds = rfds_tmp;</span><br><span class="line">        select(maxfd, &amp;rfds, NULL, NULL, NULL);</span><br><span class="line">        for(i = 0; i &lt; maxfd; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(FD_ISSET(i, &amp;rfds))</span><br><span class="line">            &#123;</span><br><span class="line">                if(i == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                   //实现对应IO操作 </span><br><span class="line">                &#125;</span><br><span class="line">                else if(i == 3)</span><br><span class="line">                &#123;</span><br><span class="line">                    //实现对应IO操作</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">poll函数用于监视一组文件描述符，以确定它们中是否有文件描述符准备好读取、写入或出现异常情况。该函数允许应用程序在一个地方等待多个事件，而不需要阻塞或使用轮询方式查询。在调用poll函数后，内核将扫描文件描述符集合，确定哪些文件描述符已经准备好读取、写入或出现异常情况，然后将事件报告给应用程序。移植性好。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">poll函数返回事件数量，即就绪的文件描述符数量。如果在超时时间内没有任何事件发生，poll函数将返回0。如果发生错误，则返回-1，并设置errno变量来指示错误类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    -fds参数是一个指向pollfd结构体数组的指针，poll函数是在内核中实现的，因此应用程序无法直接控制poll函数的执行方式。应用程序需要为每个要监视的文件描述符创建一个pollfd结构体，并将其放入一个pollfd数组中。，该结构体定义如下：</span><br><span class="line"></span><br><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd;        /* 文件描述符 */</span><br><span class="line">    short events;  /* 需要监视的事件，可以是POLLIN、POLLOUT、POLLERR等 */</span><br><span class="line">    short revents; /* 实际发生的事件，由内核填充 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">其中，fd字段表示需要监视的文件描述符，events字段表示需要监视的事件，可以是POLLIN（可读事件）、POLLOUT（可写事件）、POLLERR（错误事件）等，revents字段表示实际发生的事件，由内核填充。</span><br><span class="line"></span><br><span class="line">    -nfds参数是fds数组中的文件描述符数量。</span><br><span class="line">    -timeout参数指定等待时间，以毫秒为单位。如果timeout为-1，则表示永远等待，直到事件发生。如果timeout为0，则表示不等待，仅对fds数组中的文件描述符进行一次扫描。如果timeout大于0，则表示等待timeout毫秒后，如果还没有事件发生，则返回。</span><br></pre></td></tr></table></figure>
<p>poll流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建表：</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfds</span>[100];</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    pfds[i].fd = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加要监测的文件描述符</span></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">pfds[++pos].fd = <span class="number">0</span>;</span><br><span class="line">pfds[pos].events = POLLIN;</span><br><span class="line">pfds[++pos].fd = <span class="number">3</span>;</span><br><span class="line">pfds[pos].events = POLLIN;	</span><br><span class="line">		</span><br><span class="line"><span class="comment">//循环进行poll检测：</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ret = poll();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= pos; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pfds[i].revents &amp; POLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pfds[i].fd == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//对应IO操作                            </span></span><br><span class="line">            &#125;                        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码（poll实现并发服务器）<br><img src="/2023/04/11/day30-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%BF%9E%E6%8E%A5/poll.jpg" alt="poll"></p>
<h4 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h4><p>epoll函数是一种高效的I/O多路复用技术，Linux特有。用于监视多个文件描述符的可读可写状态。与select和poll函数相比，epoll函数的优势在于：</p>
<ul>
<li>支持较大规模的文件描述符集合，可以监视成千上万个文件描述符；</li>
<li>采用内核回调机制，避免了轮询和阻塞等方式的低效问题；</li>
<li>支持多种事件触发方式，包括边沿触发和水平触发等；</li>
<li>可以通过epoll_ctl函数动态地添加、删除和修改文件描述符。</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">-epoll_create函数用于创建一个新的epoll实例，并返回一个代表该实例的文件描述符。这个文件描述符用于控制和访问该epoll实例，可以使用epoll_ctl函数向该实例中添加或删除文件描述符。</span><br><span class="line">-epoll_ctl函数用于向epoll实例中添加、修改或删除文件描述符，并指定需要监视的事件类型。这个函数可以动态地添加、删除和修改文件描述符，以便动态地调整事件的监视方式。</span><br><span class="line">-epoll_wait函数用于等待文件描述符的I/O事件，一旦有数据可读或可写，就会触发相应的回调函数进行处理。该函数将一直阻塞，直到有文件描述符的I/O事件发生或等待超时。函数返回发生事件的文件描述符数量，并将事件信息保存在events参数指定的结构体数组中。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">epoll_create函数返回一个新的epoll实例的文件描述符。这个文件描述符就是用于控制和访问该epoll实例的句柄，也就是所谓的“用于控制监测表的句柄”。如果发生错误，则返回-1，并设置errno变量来指示错误类型。</span><br><span class="line">epoll_ctl和epoll_wait函数的返回值与select和poll函数类似，表示事件数量或执行结果。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">epoll_create的参数：</span><br><span class="line">    -size表示需要监视的文件描述符数量，该参数实际上是epoll实例的内部事件表大小，可以设置为任意值。</span><br><span class="line">int epoll_ctl的参数：</span><br><span class="line">    epfd：句柄</span><br><span class="line">    op：控制选项</span><br><span class="line">		EPOLL_CTL_ADD   添加</span><br><span class="line">        EPOLL_CTL_MOD   修改</span><br><span class="line">        EPOLL_CTL_DEL   删除</span><br><span class="line">    fd：要控制的文件描述符的值</span><br><span class="line">    event:监测表中某一个元素的地址，也就是要控制的文件描述符在epoll_event数组中的位置的地址</span><br><span class="line">epoll_wait的参数：</span><br><span class="line">    epfd：句柄</span><br><span class="line">    events：监测表的首地址</span><br><span class="line">    maxevents：监测文件描述符的个数</span><br><span class="line">    timeout：设置超时的时间</span><br></pre></td></tr></table></figure>

<p>epoll流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epfds</span>[100];</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    epfds[i].data.fd = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">epfds[++pos].data.fd = <span class="number">0</span>;</span><br><span class="line">epfds[pos].events = EPOLLIN;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, <span class="number">0</span>, &amp;epfds[pos]);</span><br><span class="line">epfds[++pos].data.fd = <span class="number">3</span>;</span><br><span class="line">epfds[pos].events = EPOLLIN;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, <span class="number">3</span>, &amp;epfds[pos]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = epoll_wait(epfd, epfds, pos + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ret; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (epfds[i].events &amp; EPOLLIN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (epfds[i].data.fd == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 对应IO操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="六、设置套接字属性"><a href="#六、设置套接字属性" class="headerlink" title="六、设置套接字属性"></a>六、设置套接字属性</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);</span><br><span class="line">int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">功能：获取/设置套接字选项的值。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt;         </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">如果函数调用成功，返回值为0；如果函数调用失败，返回值为-1。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sockfd：套接字</span><br><span class="line">    level：</span><br><span class="line">        SOL_SOCKET: 通用套接字层</span><br><span class="line">      	IPPROTO_IP： IP层</span><br><span class="line">      	IPPROTO_TCP： TCP层</span><br><span class="line">    optname:</span><br><span class="line">      			套接字属性设置对应的功能选项，一般填对应宏</span><br><span class="line">    optval：</span><br><span class="line">      			获取套接字属性对应的值的地址</span><br><span class="line">    optlen：</span><br><span class="line">      			optval值的长度/地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置属性表：level<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;SOL_SOCKET</p>
<table>
<thead>
<tr>
<th align="center">参数optname</th>
<th align="center">宏的作用</th>
<th align="center">对应参数optval的类型</th>
<th align="center">可能会填的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SO_BROADCAST</td>
<td align="center">允许发送广播数据</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_DEBUG</td>
<td align="center">循序调试</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_DONTROUTE</td>
<td align="center">不查找路由</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_ERROR</td>
<td align="center">获的套接字错误</td>
<td align="center">int</td>
<td align="center">一个整型变量，用于存储套接字上最后一次操作的错误状态。</td>
</tr>
<tr>
<td align="center">SO_KEEPALIVE</td>
<td align="center">保持连接</td>
<td align="center">int</td>
<td align="center">一个整型变量，用于存储保持连接选项的值（0表示不支持，1表示支持）。</td>
</tr>
<tr>
<td align="center">SO_LINGER</td>
<td align="center">延迟关闭连接</td>
<td align="center">struct linger</td>
<td align="center">一个 struct linger 类型的结构体变量，用于存储延迟关闭选项的值。</td>
</tr>
<tr>
<td align="center">SO_OOBINLINE</td>
<td align="center">带外数据放入正常数据流</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_RCVBUF</td>
<td align="center">接收缓冲区大小</td>
<td align="center">int</td>
<td align="center">一个整型变量，用于存储接收缓冲区的大小。</td>
</tr>
<tr>
<td align="center">SO_SNDBUF</td>
<td align="center">发送缓冲区大小</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_RCVLOWAT</td>
<td align="center">接收缓冲区下限</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_SNDWAIT</td>
<td align="center">发送缓冲区下限</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_RCVTIMEO</td>
<td align="center">接收超时</td>
<td align="center">struct timeval</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_SNDTIMEO</td>
<td align="center">发送超时</td>
<td align="center">struct timeval</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_REUSEADDR</td>
<td align="center">允许重用本机地址和端口</td>
<td align="center">int</td>
<td align="center">一个整型变量，用于存储地址重用选项的值（0表示不支持，1表示支持）。</td>
</tr>
<tr>
<td align="center">SO_TYPE</td>
<td align="center">获得套接字类型</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SO_BSDCOMPAT</td>
<td align="center">与BSD系统兼容</td>
<td align="center">int</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">组播广播对应optname ：</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<pre><code>                        IPPROTO_IP
------------------------------------------------------
IP_ADD_MEMBERSHIP    加入到组播组中               struct ip_mreq 
IP_MULTICAST_IF      允许开启组播报文的接口       struct ip_mreq    </code></pre>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//允许重用本机地址和端口</span></span><br><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> opt_len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">if</span>(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, opt_len) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时检测</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">mt</span> = &#123;</span><span class="number">5</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(mt);</span><br><span class="line">    ret = setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &amp;mt, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取缓冲区大小</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">int</span> val_len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">if</span>(getsockopt(connfd, SOL_SOCKET, SO_RCVBUF, &amp;size, &amp;val_len) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;getsockopt&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv_buf = %d\n&quot;</span>, size);</span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="七、域套接字"><a href="#七、域套接字" class="headerlink" title="七、域套接字"></a>七、域套接字</h2><p>​和tcp基本相同:</p>
<p>​        服务器：</p>
<p>​            socket () –&gt;  bind() –&gt; listen() –&gt; accept() –&gt; read()/write() –&gt; close()</p>
<p>​        客户端：</p>
<p>​            socket () –&gt;  connect() –&gt; read()/write() –&gt; close()</p>
<p>有两处改动：</p>
<ol>
<li>socket<blockquote>
<p>tcp:socket(AF_UNIX, SOCK_STREAM, 0);<br>udp:socket(AF_UNIX, SOCK_DGRAM, 0);</p>
</blockquote>
</li>
<li>AF_UNIX对应的地址结构:struct sockaddr_un<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">   <span class="keyword">sa_family_t</span> sun_family;        <span class="comment">//AF_UNIX</span></span><br><span class="line">   <span class="keyword">char</span>        sun_path[<span class="number">108</span>];     <span class="comment">//套接字文件的名称(包含路径)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建套接字</span></span><br><span class="line"><span class="keyword">int</span> sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket success!\n&quot;</span>);</span><br><span class="line"><span class="comment">//2、绑定本机IP地址和端口号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">saddr</span>;</span></span><br><span class="line">saddr.sun_family = AF_UNIX;</span><br><span class="line"><span class="built_in">strcpy</span>(saddr.sun_path, <span class="string">&quot;mysocket&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);  <span class="comment">//计算数据结构的长度</span></span><br><span class="line"><span class="keyword">int</span> ret = bind(sockfd, (struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind success!\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="八、广播和组播"><a href="#八、广播和组播" class="headerlink" title="八、广播和组播"></a>八、广播和组播</h2><h3 id="8-1-IP分类"><a href="#8-1-IP分类" class="headerlink" title="8.1 IP分类"></a>8.1 IP分类</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">A类：美国高校、国内大型公司</span><br><span class="line">   取值范围： 0.0.0.0 ~ 127.255.255.255</span><br><span class="line">   以0开头</span><br><span class="line"></span><br><span class="line">   网络号：第一个字节为网络号</span><br><span class="line">   主机号：后三个字节为主机号   </span><br><span class="line">    广播IP：主机号全为1</span><br><span class="line">B类:私有IP</span><br><span class="line">	以10开头</span><br><span class="line">    取值范围：128.0.0.0 ~ 191.255.255.255</span><br><span class="line">    网络号：前两个字节</span><br><span class="line">    主机号：后两个字节</span><br><span class="line"></span><br><span class="line">C类：私有IP</span><br><span class="line">    以110开头</span><br><span class="line">    取值范围：192.0.0.0 ~ 223.255.255.255</span><br><span class="line">    网络号：前三个字节</span><br><span class="line">    主机号：后一个字节</span><br><span class="line">    </span><br><span class="line">D类：组播</span><br><span class="line">	以1110开头</span><br><span class="line">    	224.0.0.0 ~ 239.255.255.255</span><br><span class="line">    </span><br><span class="line">    	239.10.0.1 -- 组播IP</span><br></pre></td></tr></table></figure>
<h3 id="8-2-广播"><a href="#8-2-广播" class="headerlink" title="8.2 广播"></a>8.2 广播</h3><p>​发送方 向当前IP的广播地址发送数据，广播地址将接收的数据转发给当前网络号下的所有主机    </p>
<p>服务器流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建套接字</span></span><br><span class="line">socket();</span><br><span class="line"><span class="comment">//2、绑定IP地址和端口号 （绑定广播IP）</span></span><br><span class="line">bind();<span class="comment">//192.168.12.255</span></span><br><span class="line"><span class="comment">//3、收发数据</span></span><br><span class="line">sendto()/recvfrom();</span><br><span class="line"><span class="comment">//4、关闭套接字</span></span><br><span class="line">close();</span><br></pre></td></tr></table></figure>

<p>客户端流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建套接字</span></span><br><span class="line">socket();</span><br><span class="line"><span class="comment">//2、设置套接字属性，使其允许发送广播数据</span></span><br><span class="line">setsockopt();   <span class="comment">//SO_BROADCAST</span></span><br><span class="line"><span class="comment">//3、发送数据 -- 向广播地址发送</span></span><br><span class="line">sendto();</span><br><span class="line"><span class="comment">//4、关闭套接字</span></span><br><span class="line">close();</span><br></pre></td></tr></table></figure>

<h3 id="8-3-组播"><a href="#8-3-组播" class="headerlink" title="8.3 组播"></a>8.3 组播</h3><p>​先将接收方的ip加入到指定的组播组中去，发送方向组播组中发送数据，组播ip负责将接收的内容转发给当前组播组中的所有ip</p>
<p>服务器流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建套接字</span></span><br><span class="line">socket();</span><br><span class="line"><span class="comment">//2、设置套接字属性，将当前IP加入到组播组中去</span></span><br><span class="line">setsockopt();  <span class="comment">//IP_ADD_MEMBERSHIP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、绑定IP地址和端口号 （绑定组播IP）</span></span><br><span class="line">bind();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、接收数据</span></span><br><span class="line">recvfrom();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭套接字</span></span><br><span class="line">close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span>  &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span>   <span class="comment">/* IP multicast address of group */</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span>   <span class="comment">/* local IP address of interface */</span></span><br><span class="line">&#125;;</span><br><span class="line">用法：</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">my_group</span>;</span></span><br><span class="line">	my_group.imr_multiaddr.s_addr = inet_addr(<span class="string">&quot;239.10.0.1&quot;</span>); <span class="comment">//组播ip</span></span><br><span class="line">    my_group.imr_interface.s_addr = inet_addr(<span class="string">&quot;192.168.12.15&quot;</span>);  <span class="comment">//当地ip</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建套接字</span></span><br><span class="line">socket();</span><br><span class="line"><span class="comment">//2、设置套接字属性，允许发送组播数据</span></span><br><span class="line">setsockopt();  <span class="comment">//IP_MULTICAST_IF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、发送数据</span></span><br><span class="line">sendto();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭套接字</span></span><br><span class="line">close();</span><br></pre></td></tr></table></figure>

<p>组播示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将本机ip加入到组播组中去</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">my_group</span>;</span></span><br><span class="line">    my_group.imr_multiaddr.s_addr = inet_addr(<span class="string">&quot;239.10.0.1&quot;</span>);</span><br><span class="line">    my_group.imr_interface.s_addr = inet_addr(<span class="string">&quot;192.168.12.15&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(my_group);</span><br><span class="line">    setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;my_group, len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    <span class="comment">//saddr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line">    saddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;239.10.0.1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> s_len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd,(struct sockaddr *)&amp;saddr, s_len);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;caddr, <span class="number">0</span> , <span class="keyword">sizeof</span>(caddr));</span><br><span class="line">    <span class="keyword">int</span> c_len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">64</span>);</span><br><span class="line">        recvfrom(sockfd, buf, <span class="number">64</span>, <span class="number">0</span>, (struct sockaddr*)&amp;caddr, &amp;c_len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip -- %s:%s&quot;</span>, inet_ntoa(caddr.sin_addr), buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h2 id="九、sqlite3数据库"><a href="#九、sqlite3数据库" class="headerlink" title="九、sqlite3数据库"></a>九、sqlite3数据库</h2><p>下载sqlite3:</p>
<blockquote>
<p>sudo apt-get install sqlite3</p>
<p>sudo apt-get install libsqlite3-dev</p>
</blockquote>
<h3 id="9-1-sqlite3基础命令"><a href="#9-1-sqlite3基础命令" class="headerlink" title="9.1 sqlite3基础命令"></a>9.1 sqlite3基础命令</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">.help:帮助手册，查看所有命令</span><br><span class="line">.quit:退出</span><br><span class="line">.exit:退出</span><br><span class="line">.tables:查看表名</span><br><span class="line">.schema:查看表</span><br></pre></td></tr></table></figure>

<h3 id="9-2-sql语句"><a href="#9-2-sql语句" class="headerlink" title="9.2 sql语句"></a>9.2 sql语句</h3><p>(1)创建表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">create table &lt;table_name&gt; (info1 type1，info2 type2.....);</span><br></pre></td></tr></table></figure>

<p>(2)删除表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">drop table &lt;table_name&gt;;</span><br></pre></td></tr></table></figure>

<p>(3)插入表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">insert into &lt;table_name&gt; values(information1， information2...);</span><br></pre></td></tr></table></figure>

<p>(4)查询表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询所有数据</span></span><br><span class="line">select * from &lt;table_name&gt;;</span><br><span class="line"><span class="comment">//查询指定信息</span></span><br><span class="line">select * from &lt;table_name&gt; where info=information;</span><br><span class="line">select * from &lt;table_name&gt; where info=information <span class="keyword">and</span> info=information;</span><br></pre></td></tr></table></figure>

<p>(5)删除表中的指定信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> from &lt;table_name&gt; where info=information;</span><br></pre></td></tr></table></figure>

<p>(6)修改表中指定信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">update &lt;table_name&gt; <span class="built_in">set</span> info=new_information where info=old_information;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-sqlite3相关接口函数"><a href="#9-3-sqlite3相关接口函数" class="headerlink" title="9.3 sqlite3相关接口函数"></a>9.3 sqlite3相关接口函数</h3><p>使用了sqlite3相关函数后编译时要加库<code>-lsqlite3</code></p>
<p>(1)创建或者打开数据库文件 – sqlite3_open</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int   sqlite3_open(char  *path,   sqlite3 **db)；</span><br><span class="line"></span><br><span class="line">功能：打开数据库</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    	成功返回0，失败返回错误码</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    	path：数据库文件名(包含路径)</span><br><span class="line">    	db：控制数据库文件的句柄的地址</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">char *sqlite3_errmsg(sqlite3 *db) -- 打印错误信息</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    	错误信息</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    	db：句柄</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2)关闭数据库文件 – sqlite3_close()</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int   sqlite3_close(sqlite3 *db);</span><br><span class="line"></span><br><span class="line">功能：关闭数据库</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功返回0，失败返回错误码</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    db：句柄</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(3) 执行sql语句 – sqlite3_exec()</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">typedef  int (*sqlite3_callback)(void *, int, char **, char **);</span><br><span class="line"></span><br><span class="line">int   sqlite3_exec(sqlite3 *db, const  char  *sql,  sqlite3_callback callback, void *arg,  char **errmsg);</span><br><span class="line"></span><br><span class="line">功能：在c中执行数据库命令，并用callback回调函数接收返回值</span><br><span class="line">头文件：#include &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功返回0，失败返回错误码</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">	db：句柄</span><br><span class="line">    sql：sql语句的首地址(也就是存放sql指令的字符串的首地址)</span><br><span class="line">    callback:回调函数，主要处理sql返回的信息</span><br><span class="line">    arg：用于给回调函数传参数</span><br><span class="line">    errmsg：错误信息的首地址</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">/*******************************************************************************/</span><br><span class="line"></span><br><span class="line">typedef  int (*sqlite3_callback)(void *para, int f_num, char **f_value, char **f_name);</span><br><span class="line"></span><br><span class="line">功能：每找到一条记录自动执行一次回调函数，没找到就不会执行</span><br><span class="line">返回值：成功返回0，失败返回-1</span><br><span class="line">para：传递给回调函数的参数，也就是上面的arg</span><br><span class="line">f_num：记录中包含的字段数目</span><br><span class="line">f_value：包含每个字段值的指针数组</span><br><span class="line">f_name：包含每个字段名称的指针数组</span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>day28-进程线程</title>
    <url>/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="day28-进程线程"><a href="#day28-进程线程" class="headerlink" title="day28-进程线程"></a><font color="green">day28-进程线程</font></h1><p>下面当我问你LINUX下的c语言中的函数是，你要从函数原型，功能，头文件，返回值，参数这几个方面讲解，并给出示例代码和使用函数的注意事项，明白了吗</p>
<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1. 进程和线程"></a>1. 进程和线程</h3><ul>
<li>程序：是一些二进制、数据的有序集合，没有被加载到内存。没有“生命”</li>
<li>进程：程序执行一次的过程。程序执行时资源分配的总称。Linux 是一个多道程序设计系统，因此系统中存在彼此相互独立的进程同时运行。</li>
<li>页表：<br>&emsp;&emsp;在 Linux 中，每个进程都有自己的页表，用于映射虚拟地址到物理地址。页表是由一系列页表项（PTE）组成的数据结构，每个页表项对应着虚拟地址空间中的一个页面（通常是4KB），并描述了该页面的物理地址、访问权限等信息。<br>&emsp;&emsp;Linux 中的页表采用了多级页表的结构，即每个页表项可以指向下一级的页表，最终指向物理页面。<br>&emsp;&emsp;Linux 中的页表是按需分配的，即当进程需要访问某个虚拟地址时，如果该地址对应的页表项不存在，则会触发缺页异常，内核会根据需要分配新的物理页面，并更新页表项，使得虚拟地址能够正确映射到物理地址。</li>
<li>线程：线程是进程中的执行单元，它与进程共享同一个地址空间，因此线程之间可以直接共享数据。线程相对于进程来说更加轻量级。多个线程可以共享一个进程的以下资源(可执行的指令,静态数据,进程中打开的文件描述符,信号处理函数,当前工作目录用户ID,用户组ID)<a id="more"></a>
<h3 id="2-守护进程"><a href="#2-守护进程" class="headerlink" title="2. 守护进程"></a>2. 守护进程</h3></li>
</ul>
<p>&emsp;&emsp;守护进程：在某些用户空间中，即使用户退出登录，仍然会有一些后台进程在运行，不会被用户或终端影响，这些进程被称为<code>守护进程</code>。<br>&emsp;&emsp;Linux 中有一种特殊的守护进程被称为<code>计划守护进程</code>，计划守护进程可以每分钟醒来一次检查是否有工作要做，做完会继续回到睡眠状态等待下一次唤醒。</p>
<h3 id="3-父进程与子进程"><a href="#3-父进程与子进程" class="headerlink" title="3. 父进程与子进程"></a>3. 父进程与子进程</h3><p>&emsp;&emsp;在 Linux 系统中，进程通过非常简单的方式来创建，<code>fork</code>系统调用会创建一个源进程的拷贝(副本)。调用<code>fork</code>函数的进程被称为<code>父进程</code>，使用 fork 函数创建出来的进程被称为 <code>子进程</code>。父进程和子进程都有自己的内存映像。<strong>如果在子进程创建出来后</strong>，父进程修改了一些变量等，那么子进程是看不到这些变化的，也就是<code>fork</code>后，父进程和子进程相互独立。</p>
<p>&emsp;&emsp;虽然父进程和子进程保持相互独立，但是它们却能够共享相同的文件，如果在 fork 之前，父进程已经打开了某个文件，那么 fork 后，父进程和子进程仍然共享这个打开的文件。对共享文件的修改会对父进程和子进程同时可见。</p>
<p>&emsp;&emsp;那么该如何区分父进程和子进程呢？子进程只是父进程的拷贝，所以它们几乎所有的情况都一样，包括内存映像、变量、寄存器等。区分的关键在于fork函数调用后的返回值，如果fork后返回一个非零值，这个非零值即是子进程的<code>进程标识符</code>(pid)，而会给子进程返回一个零值,<font color="blue">即在程序中,<code>pid==0</code>的代码为子进程的代码，而<code>pid &gt; 0</code>的代码为父进程的代码</font>。父进程在 fork 后会得到子进程的 PID，这个 PID 即能代表这个子进程的唯一标识符也就是 PID。如果子进程想要知道自己的 PID，可以调用<code>getpid</code>方法。父进程可以生成多个子进程，子进程也能生成自己的子进程。</p>
<h3 id="4-Linux进程间的通信"><a href="#4-Linux进程间的通信" class="headerlink" title="4. Linux进程间的通信"></a>4. Linux进程间的通信</h3><p>Linux进程间的通信（IPC）大致可以分为6种</p>
<ol>
<li>信号 signal</li>
<li>无名管道 pipe</li>
<li>共享内存 shared memory</li>
<li>先入先出队列（也叫有名管道） fifo</li>
<li>消息队列 message queue</li>
<li>套接字 socket</li>
<li>信号量 semaphore</li>
</ol>
<blockquote>
<p>有两个东西可以标识一个IPC结构：标识符(ID)和键(key)。</p>
<p>ID是IPC结构的内部名。内部即在进程内部使用，这样的标识方法是不能支持进程间通信的。</p>
<p>key就是IPC结构的外部名。当多个进程，针对同一个key调用get函数(msgget等)，这些进程得到的ID其实是标识了同一个IPC结构。多个进程间就可以通过这个IPC结构通信。</p>
</blockquote>
<br>

<h4 id="4-1-信号-signal"><a href="#4-1-信号-signal" class="headerlink" title="4.1 信号 signal"></a>4.1 信号 signal</h4><h5 id="4-1-1-信号的基本概念"><a href="#4-1-1-信号的基本概念" class="headerlink" title="4.1.1 信号的基本概念"></a>4.1.1 信号的基本概念</h5><p>&emsp;&emsp;信号是在软件层次对中断机制的一种模拟，是一种异步通信方式。信号可以直接进行用户空间进程和内核之间的交互，内核也能利用它来通知用户空间进程发生了哪些系统事件。</p>
<h5 id="4-1-2-信号的处理流程"><a href="#4-1-2-信号的处理流程" class="headerlink" title="4.1.2 信号的处理流程"></a>4.1.2 信号的处理流程</h5><p>&emsp;&emsp;操作系统给进程发送信号，本质上是给进程的task_struct（是 Linux 内核中的一个通过双向链表来组织的结构体，它代表了一个进程或线程）中写入数据，修改相应的task_struct字段(里面有进程 ID、进程状态、进程优先级、进程的父进程、进程的子进程等等)，然后进程在合适的时间(内核态发回用户态时)去处理所接受的信号。<br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt="信号处理"></p>
<p>例子说明：</p>
<blockquote>
<ol>
<li>假设用户启动一个交互式的前台进程，然后输入ctrl+c结束它，系统通过键盘产生一个硬件中断。</li>
<li>cpu暂停用户空间的代码，cpu从用户态切换至内核态处理中断</li>
<li>系统驱动程序将ctlr+c解释为一个SIGINT信号，并将其记在该进程的task_struct中的信号位上；</li>
<li>当某时刻进程从内核态返回用户态继续执行之前，检查task_struct中的信号域，SIGINT信号的默认处理动作为终止进程，所以直接终止进程而不再返回到它的用户空间代码。</li>
</ol>
</blockquote>
<h5 id="4-1-3-常用的信号-前面是它的编号"><a href="#4-1-3-常用的信号-前面是它的编号" class="headerlink" title="4.1.3 常用的信号(前面是它的编号)"></a>4.1.3 常用的信号(前面是它的编号)</h5><p>Linux 中可以通过<code>kill -l</code>查看信号表</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.  SIGHUP：   本信号在用户终端结束时发出，通常是在终端的控制进程结束时，通知同一会话期内的各个作业，这时他们与控制终端不在关联。比如，登录Linux时，系统会自动分配给登录用户一个控制终端，在这个终端运行的所有程序，包括前台和后台进程组，一般都属于同一个会话。当用户退出时，所有进程组都将收到该信号，这个信号的默认操作是终止进程。此外对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</span><br><span class="line">2.  SIGINT：   程序终止信号。当用户按下CRTL+C时通知前台进程组终止进程。</span><br><span class="line">3.  SIGQUIT：  Ctrl+<span class="tag">\<span class="name">控</span></span>制，进程收到该信号退出时会产生core文件，类似于程序错误信号。</span><br><span class="line">4.  SIGILL：   执行了非法指令。通常是因为可执行文件本身出现错误，或者数据段、堆栈溢出时也有可能产生这个信号。</span><br><span class="line">5.  SIGTRAP：  由断点指令或其他陷进指令产生，由调试器使用。</span><br><span class="line">6.  SIGABRT：  调用abort函数产生，将会使程序非正常结束。</span><br><span class="line">7.  SIGBUS：   非法地址。包括内存地址对齐出错。比如访问一个4个字长的整数，但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法地址的非法访问触发。</span><br><span class="line">8.  SIGFPE：   发生致命的算术运算错误。</span><br><span class="line">9.  SIGKILL：  用来立即结束程序的运行。不能被捕捉、阻塞或忽略，只能执行默认动作。</span><br><span class="line">10. SIGUSR1：  留给用户使用，用户可自定义。</span><br><span class="line">11. SIGSEGV：  访问未分配给用户的内存区。或操作没有权限的区域。</span><br><span class="line">12. SIGUSR2：  留给用户使用，用户可自定义。</span><br><span class="line">13. SIGPIPE：  管道破裂信号。当对一个读进程已经运行结束的管道执行写操作时产生。</span><br><span class="line">14. SIGALRM：  时钟定时信号。由alarm函数设定的时间终止时产生。</span><br><span class="line">15. SIGTERM：  程序结束信号。shell使用kill产生该信号，当结束不了该进程，尝试使用SIGKILL信号。</span><br><span class="line">16. SIGSTKFLT：堆栈错误。</span><br><span class="line">17. SIGCHLD：  子进程结束，父进程会收到。如果子进程结束时父进程不等待或不处理该信号，子进程会变成僵尸进程。</span><br><span class="line">18. SIGCONT：  让一个停止的进程继续执行。</span><br><span class="line">19. SIGSTOP：  停止进程执行。不能被捕捉、阻塞或忽略，只能执行默认动作。</span><br><span class="line">20. SIGTSTP：  停止终端交互运行，可以被忽略。按下Ctrl+z发出这个信号。</span><br><span class="line">21. SIGTTIN：  当后台进程需要从终端接收数据时，所有进程会收到该信号，暂停执行。</span><br><span class="line">22. SIGTTOU：  与SIGTTIN类似，在后台的进程向终端输出数据时产生。</span><br><span class="line">23. SIGURG：   套接字上出现紧急情况时产生。向当前正在运行的进程发出些信号，报告有紧急数据到达，如网络带外数据到达。</span><br><span class="line">24. SIGXCPU：  超过CPU时间资源限制时产生的信号。</span><br><span class="line">25. SIGXFSZ：  当进程企图扩大文件以至于超过文件大小资源限制时产生。</span><br><span class="line">26. SIGVTALRM：虚拟使用信号。计算的是进程占用CPU调用的时间。</span><br><span class="line">27. SIGPROF：  包括进程使用CPU的时间以及系统调用的时间。</span><br><span class="line">28. SIGWINCH： 窗口大小改变时。</span><br><span class="line">29. SIGIO：    文件描述符准备就绪，表示可以进行输入输出操作。</span><br><span class="line">30. SIGPWR：   电源失效信号，即关机。</span><br><span class="line">31. SIGSYS：   非法的系统调用。</span><br></pre></td></tr></table></figure>

<h5 id="4-1-4-信号的处理"><a href="#4-1-4-信号的处理" class="headerlink" title="4.1.4 信号的处理"></a>4.1.4 信号的处理</h5><p>信号的3种状态：</p>
<blockquote>
<p>未决：进程接收到信号，但是还没有处理它。这个信号会被添加到进程的信号掩码中，等待进程处理。<br>阻塞：进程可以选择阻塞某些信号，这样当这些信号发送时，进程不会接收到它们。阻塞信号可以通过 sigprocmask() 函数设置。<br>处理：当进程接收到一个信号时，它需要处理这个信号。处理信号的方式可以是执行一个信号处理函数，或者使用默认的信号处理方式。可以使用 signal() 函数或 sigaction() 函数来设置信号处理函数。</p>
</blockquote>
<p>信号的5种默认处理动作</p>
<blockquote>
<p>Term    终止进程<br>Ign    当前进程忽略此信号<br>Core    终止进程，并生成一个Core文件<br>Stop    暂停当前进程<br>Cont    继续执行当前被暂停的进程</p>
</blockquote>
<h5 id="4-1-5-信号集"><a href="#4-1-5-信号集" class="headerlink" title="4.1.5 信号集"></a>4.1.5 信号集</h5><p>信号集：顾名思义，就是信号的集合。在linux中，它的类型是<code>sigset_t</code>,大小是64bits。（Linux中一个只有64个信号）。在头文件<code>signal.h</code>提供了五个处理信号集的函数。</p>
<br>

<h4 id="4-2-无名管道-pipe"><a href="#4-2-无名管道-pipe" class="headerlink" title="4.2 无名管道 pipe"></a>4.2 无名管道 pipe</h4><h5 id="4-2-1-pipe的基本概念"><a href="#4-2-1-pipe的基本概念" class="headerlink" title="4.2.1 pipe的基本概念"></a>4.2.1 pipe的基本概念</h5><p>&emsp;&emsp;管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
<ol>
<li><p>其本质是一个伪文件(实为内核缓冲区)</p>
</li>
<li><p>由两个文件描述符引用，一个表示读端，一个表示写端。</p>
</li>
<li><p>规定数据从管道的写端流入管道，从读端流出。</p>
</li>
</ol>
<p>管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。</p>
<p>管道的局限性：<br>① 数据自己读不能自己写。<br>② 数据一旦被读走，便不在管道中存在，不可反复读取。<br>③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。<br>④ 只能在有公共祖先的进程间使用管道。<br>常见的通信方式有，单工通信、半双工通信、全双工通信。</p>
<h5 id="4-2-2-pipe的创建"><a href="#4-2-2-pipe的创建" class="headerlink" title="4.2.2 pipe的创建"></a>4.2.2 pipe的创建</h5><p>&emsp;&emsp;管道两端可分别用描述符fd[0] 以及fd[1]来描述。需要注意的是，管道两端的任务是固定的，一端只能用于读，由描述符fd[0]表示，称其为管道读端，另一端只能用于写，由描述符fd[1]来表示，称其为管道写端。如果试图从管道写端读数据，或者向管道读端写数据都将导致出错。</p>
<p>&emsp;&emsp;管道是一种文件，因此对文件操作的I/O函数都可以用于管道，如read，write等。</p>
<h5 id="4-2-3-pipe的读写"><a href="#4-2-3-pipe的读写" class="headerlink" title="4.2.3 pipe的读写"></a>4.2.3 pipe的读写</h5><p>&emsp;&emsp;如果某个进程要读取管道中的数据，那么该进程应当关闭fd[1]，向管道写数据的进程应当关闭fd[0]。因为管道只能用于具有亲缘关系的进程间的通信，在进行通信时，他们共享文件描述符。在使用前，应及时地关闭不需要的管道的另一端，以避免意外错误的发生。</p>
<p>&emsp;&emsp;进程在管道的读端读数据时，如果管道的写端不存在，则读进程认为已经读到了数据的末尾，读函数返回读出的字节数为0；管道的写端如果存在，且请求读取的字节数大于PIPE_BUF，则返回管道中现有的所有数据；如果请求的字节数不大于PIPE_BUF，则返回管道中现有的所有数据（此时，管道中数据量小于请求的数据量），或者返回请求的字节数（此时，管道中数据量大于等于请求的数据量）。</p>
<h5 id="4-2-4-pipe的实现细节"><a href="#4-2-4-pipe的实现细节" class="headerlink" title="4.2.4 pipe的实现细节"></a>4.2.4 pipe的实现细节</h5><p>在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。如下图<br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/pipe.jpg" alt="pipe"></p>
<h4 id="4-3-共享内存-shared-memory"><a href="#4-3-共享内存-shared-memory" class="headerlink" title="4.3 共享内存 shared memory"></a>4.3 共享内存 shared memory</h4><h5 id="4-3-1-共享内存概念"><a href="#4-3-1-共享内存概念" class="headerlink" title="4.3.1 共享内存概念"></a>4.3.1 共享内存概念</h5><p>&emsp;&emsp;实现进程间通信最简单也是最直接的方法就是共享内存——为参与通信的多个进程在内存中开辟一个共享区。由于进程可以直接对共享内存进行读写操作，因此这种通信方式效率特别高，但其弱点是，它没有互斥机制，需要信号量之类的手段来配合。</p>
<h5 id="4-3-2-共享内存方法"><a href="#4-3-2-共享内存方法" class="headerlink" title="4.3.2 共享内存方法"></a>4.3.2 共享内存方法</h5><blockquote>
<p>为了实现共享内存，就需要做两件事：</p>
<ol>
<li>在内存划出一块区域来作为共享区；</li>
<li>把这个区域映射到参与通信的各个进程空间。</li>
</ol>
</blockquote>
<p>&emsp;&emsp;在Linux中，共享内存有两种方式：System V IPC和POSIX IPC。</p>
<p>&emsp;&emsp;System V IPC：System V IPC是一种传统的IPC机制，它提供了三种IPC方式：消息队列、共享内存和信号量。其中，共享内存是一种最快的IPC方式，因为它直接将内存映射到进程的地址空间中，避免了数据的拷贝和内核态和用户态之间的切换。共享内存的使用需要调用一系列的函数，包括shmget()、shmat()、shmdt()和shmctl()等。</p>
<p>&emsp;&emsp;POSIX IPC：POSIX IPC是一种比System V IPC更加灵活和可移植的IPC机制，它提供了两种IPC方式：消息队列和共享内存。与System V IPC不同的是，POSIX IPC使用命名对象来标识IPC资源，这些对象存储在文件系统中，可以在进程间共享。POSIX共享内存的使用需要调用一系列的函数，包括shm_open()、shm_unlink()、mmap()和munmap()等。</p>
<h5 id="4-3-3-文件映射"><a href="#4-3-3-文件映射" class="headerlink" title="4.3.3 文件映射"></a>4.3.3 文件映射</h5><h6 id="4-3-3-1-mmap的基本概念"><a href="#4-3-3-1-mmap的基本概念" class="headerlink" title="4.3.3.1 mmap的基本概念"></a>4.3.3.1 mmap的基本概念</h6><p>&emsp;&emsp;通常在内存划出一个区域的方法是，在内存中打开一个文件，若通过系统调用<code>mmap()</code>把这个文件所占用的内存空间映射到参与通信的各个进程地址空间，则这些进程就都可以看到这个共享区域，进而实现进程间的通信。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面（脏页面是指已经被修改但还没有被写回到磁盘的页面）到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。<br>&emsp;&emsp;总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。而且这个映射的过程是动态的，即请求多少映射多少。所以mmap适用与大型文件的操作。<br>&emsp;&emsp;mmap()原型如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br><span class="line"></span><br><span class="line">功能：将一个文件或者其它对象映射到进程的地址空间中，从而让进程可以像访问内存一样访问这些对象。</span><br><span class="line">返回值：返回映射区域的起始地址。如果调用失败，则返回MAP_FAILED宏。</span><br><span class="line">addr：指定映射的起始地址，通常设置为0，表示让系统自动选择一个合适的地址。</span><br><span class="line">length：指定映射区域的长度，单位是字节。</span><br><span class="line">prot：指定映射区域的保护方式，可以是以下值的按位或：</span><br><span class="line">    PROT_EXEC：可执行</span><br><span class="line">    PROT_READ：可读</span><br><span class="line">    PROT_WRITE：可写</span><br><span class="line">    PROT_NONE：不可访问</span><br><span class="line">flags：指定映射区域的标志，可以是以下值的按位或：</span><br><span class="line">    MAP_SHARED：共享映射</span><br><span class="line">    MAP_PRIVATE：私有映射</span><br><span class="line">    MAP_ANONYMOUS：匿名映射</span><br><span class="line">fd：指定要映射的文件描述符，如果是匿名映射，则设置为-1。</span><br><span class="line">offset：指定映射区域在文件中的偏移量，通常设置为0。。</span><br></pre></td></tr></table></figure>
<h6 id="4-3-3-2-mmap的文件映射过程"><a href="#4-3-3-2-mmap的文件映射过程" class="headerlink" title="4.3.3.2 mmap的文件映射过程"></a>4.3.3.2 mmap的文件映射过程</h6><p><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/mmap.jpg" alt="mmap"><br>mmap本身其实是一个很简单的操作，在进程页表中添加一个页表项，该页表项是物理内存的地址。调用mmap的时候，内核会在该进程的地址空间的映射区域查找一块满足需求的空间用于映射该文件，然后生成该虚拟地址的页表项，改页表项此时的有效位（标志是否已经在物理内存中）为0，页表项的内容是文件的磁盘地址，此时mmap的任务已经完成。第一次访问该块内存的时候，因为页表项的有效位还是0，就会发生缺页中断，然后CPU会使用该页表项的内容也就是磁盘的文件地址，讲该地址指向的内容加载到物理内存，并需改页表项的内容为该物理地址，有效位置为1。 </p>
<p>简而言之，就是在进程对应的虚存段添加一个段，也就是创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。在创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，引发缺页异常（缺页指的是当进程需要访问的页面不在物理内存中时，就会发生缺页中断，此时操作系统会将该页面从磁盘中读取到内存中，以满足进程的需求。），内核进行请页。</p>
<p><font color="blue">再简单点，就是在进程的虚拟地址的合适位置添加一个vm_area_struct结构体。而进程的页表用于映射虚拟地址到物理地址，所以会给添加的结构体添加一个页表项即物理内存的地址。通过这个进程中映射的地址就能访问到共享的物理地址了</font><br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/mmap2.jpg" alt="mmap"></p>
<h5 id="4-3-4-共享内存的映射"><a href="#4-3-4-共享内存的映射" class="headerlink" title="4.3.4 共享内存的映射"></a>4.3.4 共享内存的映射</h5><p>&emsp;&emsp;共享内存通信方式与上面的mmap()方式极为相似，但因为建立一个文件的目的仅是为了通信，于是这种文件没有永久保存的意义，因此IPC并没有使用正规的文件系统，而是在系统初始化时在磁盘交换区建立了一个专门用来实现共享内存的特殊临时文件系统shm，当系统断电后，其中的文件会全部自行销毁。（不是人为的，mapp创造的内存空间随着进程的消亡而消亡，而共享内存的是在断电后才消失）</p>
<h5 id="4-3-5-共享内存的结构"><a href="#4-3-5-共享内存的结构" class="headerlink" title="4.3.5 共享内存的结构"></a>4.3.5 共享内存的结构</h5><p>在 Linux 中，kern_ipc_perm 结构体用于跟踪进程间通信（IPC）对象的权限。IPC 对象包括消息队列、信号量和共享内存段等。<br>(这里只展示了有关共享内存的结构体，IPC还有很多其它的结构体，shmid_kernel，ipc_id_ary，ipc_ids是共享内存中独有的，而kern_ipc_perm也能用于其它IPC中)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="keyword">key_t</span> key;          <span class="comment">/* 键值 */</span></span><br><span class="line">    <span class="keyword">uid_t</span> uid;          <span class="comment">/* 拥有者的用户 ID */</span></span><br><span class="line">    <span class="keyword">gid_t</span> gid;          <span class="comment">/* 拥有者的组 ID */</span></span><br><span class="line">    <span class="keyword">uid_t</span> cuid;         <span class="comment">/* 创建者的用户 ID */</span></span><br><span class="line">    <span class="keyword">gid_t</span> cgid;         <span class="comment">/* 创建者的组 ID */</span></span><br><span class="line">    <span class="keyword">mode_t</span> mode;        <span class="comment">/* 访问权限 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> seq; <span class="comment">/* 序列号 */</span></span><br><span class="line">    <span class="keyword">key_serial_t</span> sem_perm_seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>共享内存段的内核数据结构shmid_kernel如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> /* <span class="title">private</span> <span class="title">to</span> <span class="title">the</span> <span class="title">kernel</span> */</span></span><br><span class="line"><span class="class">&#123;</span>	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span>	<span class="title">shm_perm</span>;</span>        <span class="comment">//描述进程间通信许可的结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *		<span class="title">shm_file</span>;</span>            <span class="comment">//指向共享内存文件的指针</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		shm_nattch;            <span class="comment">//挂接到本段共享内存的进程数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		shm_segsz;            <span class="comment">//段大小</span></span><br><span class="line">	<span class="keyword">time_t</span>			shm_atim;            <span class="comment">//最后挂接时间</span></span><br><span class="line">	<span class="keyword">time_t</span>			shm_dtim;            <span class="comment">//最后解除挂接时间</span></span><br><span class="line">	<span class="keyword">time_t</span>			shm_ctim;            <span class="comment">//最后变化时间</span></span><br><span class="line">	<span class="keyword">pid_t</span>			shm_cprid;            <span class="comment">//创建进程的PID</span></span><br><span class="line">	<span class="keyword">pid_t</span>			shm_lprid;            <span class="comment">//最后使用进程的PID</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span>	*<span class="title">mlock_user</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了便于管理，内核把共享内存区的所有描述结构shmid_kernel都存放在结构ipc_id_ary中的一个数组中。结构ipc_id_ary的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">p</span>[0];</span>            <span class="comment">//存放段描述结构的数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样，为了描述一个共享内存区的概貌，内核使用了数据结构ipc_ids。该结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> in_use;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> seq;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> seq_max;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">rw_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">ipcs_idr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span> *<span class="title">entries</span>;</span>        <span class="comment">//指向struct ipc_id_ary的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由多个共享段组成的共享区的结构如下所示：<br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/%E5%85%B1%E4%BA%AB%E5%8C%BA%E7%BB%93%E6%9E%84.jpg" alt="共享区结构"><br>IPC内核中有许多的结构体：</p>
<p>在共享内存中，ipc_ids结构体维护了所有共享内存的ID，ipc_id_ary结构体维护了共享内存的索引，kern_ipc_perm结构体维护了共享内存的权限信息，shmid_kernel结构体维护了共享内存的管理信息。这些结构体相互配合，实现了IPC机制的管理和控制。</p>
<p>它们之间的关系如下所示：</p>
<p>ipc_ids中存储了所有IPC对象的ID，每个ID对应一个ipc_id_ary中的元素。</p>
<p>ipc_id_ary中存储了所有IPC对象的ID，每个ID对应一个kern_ipc_perm结构体。</p>
<p>kern_ipc_perm结构体中包含了一个指向共享内存的指针，这个指针指向一个shmid_kernel结构体。</p>
<h4 id="4-4-先入先出队列（也叫有名管道）-fifo"><a href="#4-4-先入先出队列（也叫有名管道）-fifo" class="headerlink" title="4.4 先入先出队列（也叫有名管道） fifo"></a>4.4 先入先出队列（也叫有名管道） fifo</h4><p>&emsp;&emsp;FIFO和Pipe都可以用于进程间通信，但它们的实现方式略有不同。Pipe是一种匿名管道，它只存在于内存中，而FIFO是一种特殊的文件类型，它存在于文件系统中。因此，FIFO可以用于不同进程甚至不同计算机之间的通信，而Pipe只能用于具有亲缘关系的进程之间的通信。</p>
<p>&emsp;&emsp;FIFO主要用于缓冲速度不匹配的通信。例如生产者（数据产生者）可能在短时间内生成大量数据，导致消费者（数据使用方）无法立即处理完，那么就需要用到队列。生产者可以突然生成大量数据存到队列中，然后就去休息，消费者再有条不紊地将数据一条条取出解析。通常会结合DMA操作。</p>
<p>&emsp;&emsp;FIFO为一种特殊的文件类型，它在文件系统中有对应的路径。当一个进程以读(r)的方式打开该文件，而另一个进程以写(w)的方式打开该文件，那么内核就会在这两个进程之间建立管道，所以FIFO实际上也由内核管理，不与硬盘打交道。之所以叫FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序。FIFO只是借用了文件系统(file system,命名管道是一种特殊类型的文件，因为Linux中所有事物都是文件，它在文件系统中以文件名的形式存在。)来为管道命名。写模式的进程向FIFO文件中写入，而读模式的进程从FIFO文件中读出。当删除FIFO文件时，管道连接也随之消失。FIFO的好处在于我们可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接</p>
<h5 id="4-4-1-fifo的实现方式"><a href="#4-4-1-fifo的实现方式" class="headerlink" title="4.4.1 fifo的实现方式"></a>4.4.1 fifo的实现方式</h5><p>fifo 是用户空间的实现，而 kfifo 是内核空间的实现。</p>
<p>kfifo是linux内核的对队列功能的实现。在内核中，它被称为无锁环形队列。</p>
<p>所谓无锁，就是当只有一个生产者和只有一个消费者时，操作fifo不需要加锁。这是因为kfifo出队和入队时，不会改动到相同的变量。</p>
<p>kfifo使用了in和out两个变量分别作为入队和出队的索引：<br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/kfifo.jpg" alt="kfifo"></p>
<ul>
<li>入队n个数据时，in变量就+n</li>
<li>出队k个数据时，out变量就+k</li>
<li>out不允许大于in（out等于in时表示fifo为空）</li>
<li>in不允许比out大超过fifo空间（比如上图，in最多比out多8，此时表示fifo已满）<br>如果in和out大于fifo空间了，比如上图中的8，会减去8后重新开始吗？</li>
</ul>
<p>不，这两个索引会一直往前加，不轻易回头，为出入队操作省下了几个指令周期。</p>
<p>那入队和出队的数据从哪里开始存储/读取呢，我们第一时间会想到，把 in/out 用“%”对fifo大小取余就行了，是吧？</p>
<p>不，取余这种耗费资源的运算，内核开发者怎会轻易采用呢，kfifo的办法是，把 <code>in/out &amp; fifo-&gt;mask</code>。这个mask等于fifo的空间大小减一（其要求fifo的空间必须是2的次方大小）。这个“与”操作可比取余操作快得多了。</p>
<p>由此，kfifo就实现了“无锁”“环形”队列。</p>
<p>了解了上述原理，我们就能意识到，这个无锁只是针对“单生产者-单消费者”而言的。“多生产者”时，则需要对入队操作进行加锁；同样的，“多消费者”时需要对出队操作进行加锁。</p>
<h4 id="4-5-消息队列-Message"><a href="#4-5-消息队列-Message" class="headerlink" title="4.5 消息队列 Message"></a>4.5 消息队列 Message</h4><h5 id="4-5-1-消息队列概念"><a href="#4-5-1-消息队列概念" class="headerlink" title="4.5.1 消息队列概念"></a>4.5.1 消息队列概念</h5><p>消息队列是消息的链接表 ,存放在内核中并由消息队列标识符标识。我们将称消息队列为“队列”，其标识符为“队列 I D”。我们并不一定要以先进先出次序取消息，也可以按消息的类型字段取消息。消息队列的优点是能够实现异步通信。缺点是消息的大小受到限制。<br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/mes.jpg" alt="mes"></p>
<h4 id="4-7-信号量-semaphore"><a href="#4-7-信号量-semaphore" class="headerlink" title="4.7 信号量 semaphore"></a>4.7 信号量 semaphore</h4><h5 id="4-7-1-信号量概述"><a href="#4-7-1-信号量概述" class="headerlink" title="4.7.1 信号量概述"></a>4.7.1 信号量概述</h5><p>信号量与其他进程间通信方式不大相同，它主要提供对进程间共享资源访问控制机制。相当于内存中的标志，进程可以根据它判定是否能够访问某些共享资源（临界区，类似于互斥锁），同时，进程也可以修改该标志。除了用于访问控制外，还可用于进程同步。信号量有以下两种类型：</p>
<ul>
<li>二值信号量：最简单的信号量形式，信号量的值只能取0或1，类似于互斥锁。<br>注：二值信号量能够实现互斥锁的功能，但两者的关注内容不同。信号量强调共享资源，只要共享资源可用，其他进程同样可以修改信号量的值；互斥锁更强调进程，占用资源的进程使用完资源后，必须由进程本身来解锁。</li>
<li>计算信号量：信号量的值可以取任意非负值（当然受内核本身的约束）。</li>
</ul>
<h5 id="4-7-2-Linux信号量"><a href="#4-7-2-Linux信号量" class="headerlink" title="4.7.2 Linux信号量"></a>4.7.2 Linux信号量</h5><p>linux对信号量的支持状况与消息队列一样，在red had 8.0发行版本中支持的是系统V的信号量。因此，本文将主要介绍系统V信号量及其相应API。在没有声明的情况下，以下讨论中指的都是系统V信号量。</p>
<p>注意：通常所说的系统V信号量指的是计数信号量集。</p>
<h5 id="4-7-2-信号量和内核"><a href="#4-7-2-信号量和内核" class="headerlink" title="4.7.2 信号量和内核"></a>4.7.2 信号量和内核</h5><ol>
<li><p>系统V信号量是随内核持续的，只有在内核重起或者显示删除一个信号量集时，该信号量集才会真正被删除。因此系统中记录信号量的数据结构（struct ipc_ids sem_ids）位于内核中，系统中的所有信号量都可以在结构sem_ids中找到访问入口。</p>
</li>
<li><p>下图说明了内核与信号量是怎样建立起联系的：<br><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/xinhaodeng.jpg" alt="sem"></p>
</li>
</ol>
<p>其中：structipc_ids sem_ids是内核中记录信号量的全局数据结构；描述一个具体的信号量及其相关信息。</p>
<p>其中，struct sem结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">  <span class="keyword">int</span> semval; <span class="comment">// current value    </span></span><br><span class="line">  <span class="keyword">int</span> sempid; <span class="comment">// pid of last operation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上图可以看出，全局数据结构struct ipc_ids sem_ids可以访问到struct ipc_id ipcid的一个成员：struct kern_ipc_perm；而每个struct kern_ipc_perm能够与具体的信号量集对应起来是因为在该结构中，有一个key_t类型成员key，而key则唯一确定一个信号量集struct sem_array；同时，结构struct sem_array的最后一个成员sem_nsems确定了该信号量在信号量集中的顺序，这样内核就能够记录每个信号量的信息了。</p>
<p>kern_ipc_perm结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内核中全局数据结构sem_ids能够访问到该结构；</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span>  <span class="comment">// IPC 命名空间</span></span><br><span class="line">    <span class="keyword">uid_t</span> uid;  <span class="comment">// 拥有者的用户 ID</span></span><br><span class="line">    <span class="keyword">gid_t</span> gid;  <span class="comment">// 拥有者的组 ID</span></span><br><span class="line">    <span class="keyword">uid_t</span> cuid;  <span class="comment">// 创建者的用户 ID</span></span><br><span class="line">    <span class="keyword">gid_t</span> cgid;  <span class="comment">// 创建者的组 ID</span></span><br><span class="line">    <span class="keyword">mode_t</span> mode;  <span class="comment">// 访问权限</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> locked:<span class="number">1</span>;  <span class="comment">// 锁定标志</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> deleted:<span class="number">1</span>;  <span class="comment">// 删除标志</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;  <span class="comment">// IPC 对象的 ID</span></span><br><span class="line">    <span class="keyword">key_t</span> key;  <span class="comment">// IPC 对象的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>  <span class="comment">// RCU 头</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*系统中的每个信号量集对应一个sem_array 结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">sem_perm</span>;</span>  <span class="comment">// 信号量的内核 IPC 权限</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span>  <span class="comment">// 指向信号量集合的第一个信号量的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sem_nsems;  <span class="comment">// 信号量集合中信号量的数量</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_otime;  <span class="comment">// 最后一次 semop 操作的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> sem_ctime;  <span class="comment">// 最后一次修改 sem_array 的时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">sem_pending</span>;</span>  <span class="comment">// 指向等待信号量的进程队列的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> **<span class="title">sem_pending_last</span>;</span>  <span class="comment">// 指向等待信号量的进程队列的最后一个 sem_queue 结构体的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">undo</span>;</span>  <span class="comment">// 指向撤销操作链表的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *sem_unused;  <span class="comment">// 未使用的信号量的数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，sem_queue结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 系统中每个因为信号量而睡眠的进程，都对应一个sem_queue结构*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> * <span class="title">next</span>;</span> <span class="comment">/* next entry in the queue */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> ** <span class="title">prev</span>;</span> <span class="comment">/* previous entry in the queue, *(q-&gt;prev) == q */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">sleeper</span>;</span> <span class="comment">/* this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> * <span class="title">undo</span>;</span> <span class="comment">/* undo structure */</span></span><br><span class="line">    <span class="keyword">int</span> pid; <span class="comment">/* process id of requesting process */</span></span><br><span class="line">    <span class="keyword">int</span> status; <span class="comment">/* completion status of operation */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> * <span class="title">sma</span>;</span> <span class="comment">/* semaphore array for operations */</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">/* internal sem id */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> * <span class="title">sops</span>;</span> <span class="comment">/* array of pending operations */</span></span><br><span class="line">    <span class="keyword">int</span> nsops; <span class="comment">/* number of operations */</span></span><br><span class="line">    <span class="keyword">int</span> alter; <span class="comment">/* operation will alter semaphore */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-7-3-操作信号量"><a href="#4-7-3-操作信号量" class="headerlink" title="4.7.3 操作信号量"></a>4.7.3 操作信号量</h5><p>对信号量的操作无非有下面三种类型：</p>
<ol>
<li><p>打开或创建信号量 与消息队列的创建及打开基本相同，不再详述。</p>
</li>
<li><p>信号量值操作 linux可以增加或减小信号量的值，相应于对共享资源的释放和占有。具体参见后面的semop系统调用。</p>
</li>
<li><p>获得或设置信号量属性： 系统中的每一个信号量集都对应一个struct sem_array结构，该结构记录了信号量集的各种信息，存在于系统空间。为了设置、获得该信号量集的各种信息及属性，在用户空间有一个重要的联合结构与之对应，即union semun。</p>
</li>
</ol>
<p><img src="/2023/04/01/day28-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/sem.jpg" alt="sem"></p>
<p>联合semun数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span> val;                  <span class="comment">// 用于SETVAL操作，表示信号量的初始值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>     <span class="comment">// 用于IPC_STAT和IPC_SET操作，指向一个semid_ds结构体，用于获取和设置信号量集的属性</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;    <span class="comment">// 用于GETALL和SETALL操作，指向一个无符号短整型数组，用于获取和设置信号量集中每个信号量的值</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> defined(__linux__)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span>    <span class="comment">// 用于IPC_INFO操作，指向一个seminfo结构体，用于获取信号量实现的一些限制</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">semid_ds数据结构在&lt;sys/sem.h&gt;头文件中定义如下：</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span> <span class="comment">// 信号量集合的权限结构体，包含了拥有者、创建者的用户和组ID，以及权限信息</span></span><br><span class="line">    <span class="keyword">time_t</span>          sem_otime; <span class="comment">// 上次semop操作的时间，如果没有操作则为0</span></span><br><span class="line">    <span class="keyword">time_t</span>          sem_ctime; <span class="comment">// 上次semctl操作更改信号量集合的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   sem_nsems; <span class="comment">// 信号量集合中信号量的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">ipc_perm结构体在&lt;sys/ipc.h&gt;头文件中定义如下:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="keyword">key_t</span>  __key;     <span class="comment">// 外部键，用于获取IPC对象的键值</span></span><br><span class="line">    <span class="keyword">uid_t</span>  uid;       <span class="comment">// 拥有者（用户）的用户ID</span></span><br><span class="line">    <span class="keyword">gid_t</span>  gid;       <span class="comment">// 拥有者（用户）的组ID</span></span><br><span class="line">    <span class="keyword">uid_t</span>  cuid;      <span class="comment">// 创建者（用户）的用户ID</span></span><br><span class="line">    <span class="keyword">gid_t</span>  cgid;      <span class="comment">// 创建者（用户）的组ID</span></span><br><span class="line">    <span class="keyword">mode_t</span> mode;      <span class="comment">// 读写权限标志，包括用户、组和其他用户的读写权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果在包含&lt;sys/sem.h&gt;头文件之前定义了_GNU_SOURCE特性测试宏，那么seminfo结构体将在&lt;sys/sem.h&gt;头文件中定义。_GNU_SOURCE是一个预处理器宏，用于启用GNU扩展功能。</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> semmap;     <span class="comment">// 系统范围内映射的信号量集数的上限</span></span><br><span class="line">    <span class="keyword">int</span> semmni;     <span class="comment">// 系统范围内信号量标识符数（信号量集）的上限</span></span><br><span class="line">    <span class="keyword">int</span> semmns;     <span class="comment">// 系统范围内信号量数的上限</span></span><br><span class="line">    <span class="keyword">int</span> semmnu;     <span class="comment">// 系统范围内未使用信号量数的上限</span></span><br><span class="line">    <span class="keyword">int</span> semmsl;     <span class="comment">// 单个信号量集中信号量数的上限</span></span><br><span class="line">    <span class="keyword">int</span> semopm;     <span class="comment">// 单个`semop`操作中可以执行的最大操作数</span></span><br><span class="line">    <span class="keyword">int</span> semume;     <span class="comment">// 单个进程可持有的信号量撤销结构（undo structure）的最大数量</span></span><br><span class="line">    <span class="keyword">int</span> semusz;     <span class="comment">// 系统范围内的信号量撤销结构总大小的上限</span></span><br><span class="line">    <span class="keyword">int</span> semvmx;     <span class="comment">// 单个信号量的最大值</span></span><br><span class="line">    <span class="keyword">int</span> semaem;     <span class="comment">// 系统范围内的调整值（adjust）的最大值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//semmsl、semmns、semopm和semmni这些设置可以通过/proc/sys/kernel/sem进行修改；请参阅proc(5)文档了解详细信息。</span></span><br></pre></td></tr></table></figure>

<h3 id="5-Linux线程的同步和互斥"><a href="#5-Linux线程的同步和互斥" class="headerlink" title="5. Linux线程的同步和互斥"></a>5. Linux线程的同步和互斥</h3><h4 id="5-1-线程同步"><a href="#5-1-线程同步" class="headerlink" title="5.1 线程同步"></a>5.1 线程同步</h4><p>同步是指多个线程按照约定的顺序相互配合完成一件事情，例如一个线程需要等待另一个线程的结果才能继续执行。<br>Linux线程的同步和进程的差不多，都是用的信号量来进行p/v操作。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">信号量操作：</span><br><span class="line"></span><br><span class="line">​			创建信号量 -- sem_init()</span><br><span class="line"></span><br><span class="line">​			P操作 -- 申请资源 -- sem_wait()</span><br><span class="line"></span><br><span class="line">​					if（资源）</span><br><span class="line"></span><br><span class="line">​					&#123;</span><br><span class="line"></span><br><span class="line">​							执行代码;</span><br><span class="line"></span><br><span class="line">​							信号量值-1；</span><br><span class="line"></span><br><span class="line">​					&#125;</span><br><span class="line"></span><br><span class="line">​					else</span><br><span class="line"></span><br><span class="line">​					&#123;</span><br><span class="line"></span><br><span class="line">​							阻塞；  //直到有资源才会继续执行</span><br><span class="line"></span><br><span class="line">​					&#125;</span><br><span class="line"></span><br><span class="line">​			V操作 -- 释放资源 -- sem_post()</span><br><span class="line"></span><br><span class="line">​					信号量值+1；</span><br><span class="line"></span><br><span class="line">​					如果有阻塞需要资源代码，则会唤醒让其继续执行</span><br></pre></td></tr></table></figure>

<p>但也有不同：</p>
<ul>
<li>posix的信号量常用于线程，system v的信号量常用于进程的同步。</li>
<li>posix的信号量是个非负整数，system v的信号量是一个或多个信号量的集合，对应一个信号量结构体。</li>
<li>posix的信号量是基于内存的，放在共享内存中，由名字来标识。system v的信号量是基于内核的，放在内核里面。</li>
</ul>
<h4 id="5-2-线程互斥锁"><a href="#5-2-线程互斥锁" class="headerlink" title="5.2 线程互斥锁"></a>5.2 线程互斥锁</h4><p>互斥主要用来保护临界资源，任何时刻最多只有一个线程能访问该资源，必须先获得互斥锁才能访问临界资源，访问完后要释放互斥锁。多个线程访问只有一个互斥锁的资源时会进行争抢，所以无法知道哪个线程会抢到该资源</p>
<p>线程的同步和互斥都是为了保证数据的一致性和正确性，但同步更强调线程之间的逻辑关系，而互斥更强调线程之间的排他性。</p>
<br>
<br>

<hr>
<h2 id="二、相关函数使用"><a href="#二、相关函数使用" class="headerlink" title="二、相关函数使用"></a>二、相关函数使用</h2><h3 id="2-1-进程"><a href="#2-1-进程" class="headerlink" title="2.1 进程"></a>2.1 进程</h3><h4 id="2-1-1-进程的创建"><a href="#2-1-1-进程的创建" class="headerlink" title="2.1.1 进程的创建"></a>2.1.1 进程的创建</h4><h5 id="子进程创建fork"><a href="#子进程创建fork" class="headerlink" title="子进程创建fork"></a>子进程创建fork</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pid_t fork(void);</span><br><span class="line">功能：创建一个子进程出来，并和父进程并发执行</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：如果调用成功，fork()函数将返回两次。在父进程中，它返回子进程的进程ID，而在子进程中，它返回0。如果调用失败，则返回一个负值，表示错误类型。(可以用pid是否等于0来分别编写子进程函数(==0)和父进程函数(&gt;0))</span><br><span class="line"></span><br><span class="line">注：父进程和子进程空间完全独立</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child process, x = %d\n&quot;</span>, ++x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the parent process, x = %d\n&quot;</span>, --x);</span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 父进程等待子进程执行完毕</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上示例代码创建了一个新的进程，它的执行结果取决于操作系统调度进程的顺序。在该示例代码中，父进程和子进程分别执行不同的代码段，从而改变变量x的值。父进程调用wait()函数等待子进程执行完毕，以便正确处理进程的退出状态。</span></span><br></pre></td></tr></table></figure>

<h5 id="实时拷贝vfork："><a href="#实时拷贝vfork：" class="headerlink" title="实时拷贝vfork："></a>实时拷贝vfork：</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pid_t vfork(void);</span><br><span class="line">功能：创建一个子进程出来,创建的新进程与父进程共享同一个地址空间，因此在子进程中修改变量或调用函数可能会影响到父进程的数据。</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：返回0给子进程，返回子进程的id(&gt;0)给父进程，-1出错</span><br><span class="line"></span><br><span class="line">注：一定是子进程先运行，并且子进程不结束exit()或者不调用exec函数簇，父进程不会运行（正确运行）</span><br></pre></td></tr></table></figure>
<h5 id="进程替换exec族："><a href="#进程替换exec族：" class="headerlink" title="进程替换exec族："></a>进程替换exec族：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int execl(const char *path, const char *arg0, ..., const char *argn, (char *) NULL);</span><br><span class="line">int execlp(const char *file, const char *arg0, ..., const char *argn, (char *) NULL);</span><br><span class="line">int execle(const char *path, const char *arg0, ..., const char *argn, (char *) NULL, char *const envp[]);</span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line">int execve(const char *path, char *const argv[], char *const envp[]);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">exec()函数族用于在当前进程中执行一个新的程序，替换当前进程的镜像。这些函数的不同之处在于它们的参数形式和处理方式不同。换句话说，就是在调用进程内部执行一个可执行文件。进程 ID 并未改变。exec 只是用另一个新程序替换了当前进程的正文、数据、堆和栈段（进程替换）。</span><br><span class="line">execl()函数将程序名和参数逐个列举出来，每个参数都是一个独立的字符串，以NULL指针结束。</span><br><span class="line">execlp()函数与execl()函数相似，但是它还允许通过PATH环境变量查找可执行文件。</span><br><span class="line">execle()函数与execl()函数类似，但是它还允许指定环境变量。</span><br><span class="line">execv()函数和execl()函数类似，但是它接受一个字符串数组作为参数列表。</span><br><span class="line">execvp()函数和execlp()函数类似，但是它接受一个字符串数组作为参数列表。</span><br><span class="line">execve()函数和execle()函数类似，但是它接受一个字符串数组作为参数列表，并允许指定环境变量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">返回值：如果调用成功，exec()函数将不会返回。如果调用失败，则返回-1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">path：要执行的程序的路径名。</span><br><span class="line">file：要执行的程序的文件名，如果没有指定路径，则使用PATH环境变量查找可执行文件。</span><br><span class="line">arg0 ~ argn：要传递给新程序的参数列表。</span><br><span class="line">argv：一个字符串数组，包含要传递给新程序的参数列表。</span><br><span class="line">envp：一个字符串数组，包含要传递给新程序的环境变量列表，**以NULL指针结束**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：argn和envp数组要用NULL来表示结束，否则会出错</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *envp[] = &#123;<span class="string">&quot;USER=chatgpt&quot;</span>, <span class="string">&quot;PATH=/bin&quot;</span>, <span class="literal">NULL</span>&#125;; <span class="comment">//</span></span><br><span class="line">  execle(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>, envp);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这行代码不会执行，除非 execle() 失败。\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个程序将使用 execle() 函数执行 /bin/ls 程序，并使用 ls -l 作为命令行参数。它还将设置两个新的环境变量 USER 和 PATH。如果 execle() 函数成功，则它不会返回，而是执行 /bin/ls 程序，如果失败则会返回-1。</span></span><br></pre></td></tr></table></figure>
<br>

<h4 id="2-1-2-进程的退出"><a href="#2-1-2-进程的退出" class="headerlink" title="2.1.2 进程的退出"></a>2.1.2 进程的退出</h4><h5 id="进程退出exit"><a href="#进程退出exit" class="headerlink" title="进程退出exit"></a>进程退出exit</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">void exit(int status);</span><br><span class="line">功能：终止程序的执行，并返回给操作系统一个退出状态。</span><br><span class="line">头文件：#include &lt;stdlib.h&gt;</span><br><span class="line">返回值：无返回值，程序将终止执行。</span><br><span class="line">参数：</span><br><span class="line">    status：可选参数，用于指定程序的退出状态。</span><br></pre></td></tr></table></figure>
<h5 id="exit"><a href="#exit" class="headerlink" title="_exit"></a>_exit</h5><p>_exit() 函数也用于终止程序的执行，但它不会执行任何清理工作，例如关闭文件描述符或刷新流缓冲区等操作。不刷新缓冲区的话，可能会导致输出的内容不及时或不完整。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void _exit(int status);</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-进程的等待wait"><a href="#2-1-2-进程的等待wait" class="headerlink" title="2.1.2 进程的等待wait"></a>2.1.2 进程的等待wait</h4><h5 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pid_t wait(int *status);</span><br><span class="line">功能：调用该函数进程阻塞，直到任一一个子进程结束或者是该进程接收到了一个信号为止，如果该进程没有子进程或者其子进程已经结束，wait函数会立即返回。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt;、#include &lt;sys/wait.h&gt;</span><br><span class="line">返回值：如果成功，则返回子进程的进程 ID，否则返回-1。</span><br><span class="line">参数：</span><br><span class="line">    status：可选参数，用于获取子进程的退出状态。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建子进程失败。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是子进程，进程 ID 为 %d。\n&quot;</span>, getpid());</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程结束。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是父进程，进程 ID 为 %d。\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = wait(&amp;status);</span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;等待子进程结束失败。\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;子进程 %d 结束，退出状态为 %d。\n&quot;</span>, child_pid, status);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个程序创建了一个子进程，并在子进程中等待 3 秒钟后退出，并返回状态码 42。在父进程中，我们使用 wait() 函数等待子进程的结束，并获取其退出状态。如果 wait() 函数成功，则返回子进程的进程 ID，并将子进程的退出状态存储在 status 参数中。在本例中，父进程将打印子进程的进程 ID 和退出状态。如果等待子进程结束失败，则程序将返回非零值</span></span><br></pre></td></tr></table></figure>

<h5 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid, int *status, int options);</span><br><span class="line">功能：waitpid() 函数与 wait() 函数类似，也用于等待一个子进程的结束，并获取该子进程的退出状态。但 waitpid() 函数提供了更多的控制选项，例如可以等待特定进程的结束，可以在不阻塞的情况下查询进程状态等。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt;、#include &lt;sys/wait.h&gt;</span><br><span class="line">返回值：如果成功，则返回子进程的进程 ID，否则返回-1。</span><br><span class="line">参数：</span><br><span class="line">    pid：要等待的进程 ID，如果为-1，则表示等待任何子进程的结束。</span><br><span class="line">    status：可选参数，用于获取子进程的退出状态。</span><br><span class="line">    options：等待选项，可以是 0（阻塞模式）或 WNOHANG（非阻塞模式）。</span><br><span class="line"></span><br><span class="line">注：非阻塞模式下父进程可能会在子进程结束前就执行过了waitpid导致接收不到子进程的退出状态。</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-守护进程"><a href="#2-1-3-守护进程" class="headerlink" title="2.1.3 守护进程"></a>2.1.3 守护进程</h4><h5 id="守护进程的定义"><a href="#守护进程的定义" class="headerlink" title="守护进程的定义"></a>守护进程的定义</h5><ol>
<li><p>守护进程是脱离于终端并且在后台运行的进程</p>
</li>
<li><p>守护进程脱离终端是为了避免在执行过程中的信息在任何终端上显示，并且不被任何终端产生的终端信息所打断</p>
</li>
<li><p>守护进程通常在系统引导装入时启动</p>
</li>
</ol>
<h5 id="守护进程的作用"><a href="#守护进程的作用" class="headerlink" title="守护进程的作用"></a>守护进程的作用</h5><ol>
<li><p>守护进程是一个生存周期较长的进程，通常独立于控制终端并且周期性的执行某种任务或者等待处理某些待发生的事件</p>
</li>
<li><p>大多数服务都是通过守护进程实现的</p>
</li>
<li><p>关闭终端，相应的进程都会被关闭，而守护进程却能够突破这种限制</p>
</li>
</ol>
<h5 id="守护进程的创建过程："><a href="#守护进程的创建过程：" class="headerlink" title="守护进程的创建过程："></a>守护进程的创建过程：</h5><blockquote>
<ol>
<li>创建子进程，父进程退出。这样可以使子进程成为孤儿进程，从而被init进程收养，避免成为僵尸进程。</li>
<li>在子进程中创建新会话。这样可以使子进程摆脱原来的会话，进程组，控制终端的影响，成为新会话的首进程和组长进程。</li>
<li>改变当前工作目录为根目录。这样可以使子进程不依赖于原来的工作目录，避免影响文件系统的卸载和挂载。</li>
<li>重设文件权限掩码。这样可以使子进程拥有更大的文件操作权限，避免受到原来的权限掩码的限制。</li>
<li>关闭不需要的文件描述符。这样可以使子进程释放无用的资源，避免占用系统资源和引起安全问题。</li>
</ol>
</blockquote>
<h5 id="查看系统中的守护进程"><a href="#查看系统中的守护进程" class="headerlink" title="查看系统中的守护进程"></a>查看系统中的守护进程</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ps -axj</span><br><span class="line"></span><br><span class="line">PPID：父进程ID</span><br><span class="line">PID： 进程ID</span><br><span class="line">PGID：进程组ID</span><br><span class="line">SID:  会话期ID</span><br><span class="line">TTY:  终端ID</span><br><span class="line">TPGID:终端进程组ID</span><br><span class="line">STAT: 状态</span><br><span class="line">UID:  用户</span><br><span class="line">TIME: 运行时间</span><br></pre></td></tr></table></figure>
<h5 id="守护进程的创建的代码实现："><a href="#守护进程的创建的代码实现：" class="headerlink" title="守护进程的创建的代码实现："></a>守护进程的创建的代码实现：</h5><p>需要用到的函数</p>
<ul>
<li><p>setsid函数</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">pid_t setsid(void);</span><br><span class="line"></span><br><span class="line">功能：用于创建一个新的会话，该会话成为当前进程的会话，同时将当前进程设置为该会话的首进程，该函数还将当前进程的进程组ID设置为其进程ID。这意味着当前进程将成为一个新的进程组和会话的首进程，不再属于原来的进程组或会话。</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：函数成功调用返回新会话的ID号，如果出错则返回-1。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>getdtablesize函数</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int getdtablesize(void);</span><br><span class="line"></span><br><span class="line">功能：getdtablesize()函数用于获取当前进程可以打开的最大文件描述符数量，但由于该函数已经过时，不再被建议使用。取而代之的是使用getrlimit()函数来获取最大文件描述符数量。</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：函数成功调用返回当前进程可以打开的最大文件描述符数量，如果出错则返回-1。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>getrlimit函数</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int getrlimit(int resource, struct rlimit *rlim);</span><br><span class="line">int setrlimit(int resource, const struct rlimit *rlim);</span><br><span class="line"></span><br><span class="line">功能：   getrlimit()函数用于获取指定资源的当前软限制和硬限制值。</span><br><span class="line">        setrlimit()函数则用于设置指定资源的软限制和硬限制值。</span><br><span class="line">头文件：#include &lt;sys/time.h&gt;  #include &lt;sys/resource.h&gt;</span><br><span class="line">返回值：getrlimit()函数成功调用返回0，失败返回-1；</span><br><span class="line">        setrlimit()函数成功调用返回0，失败返回-1。</span><br><span class="line">参数：getrlimit()函数有两个参数，分别是资源类型和rlim结构体的指针，其中rlim结构体用来存储获取到的软限制和硬限制值。资源类型可以是以下常量之一：</span><br><span class="line">    RLIMIT_CPU：CPU时间限制。</span><br><span class="line">    RLIMIT_FSIZE：文件大小限制。</span><br><span class="line">    RLIMIT_DATA：数据段大小限制。</span><br><span class="line">    RLIMIT_STACK：栈大小限制。</span><br><span class="line">    RLIMIT_CORE：核心转储文件大小限制。</span><br><span class="line">    RLIMIT_RSS：驻留内存集大小限制。</span><br><span class="line">    RLIMIT_NOFILE：打开的文件数量限制。</span><br><span class="line">    RLIMIT_AS：虚拟内存总量限制。</span><br><span class="line">    RLIMIT_NPROC：进程数量限制。</span><br><span class="line">    RLIMIT_MEMLOCK：内存锁定大小限制。</span><br><span class="line">    RLIMIT_LOCKS：文件锁数量限制。</span><br><span class="line">    RLIMIT_SIGPENDING：挂起的信号数量限制。</span><br><span class="line">    RLIMIT_MSGQUEUE：POSIX消息队列的大小限制。</span><br><span class="line">    RLIMIT_NICE：优先级限制。</span><br><span class="line">    RLIMIT_RTPRIO：实时优先级限制。</span><br><span class="line">    RLIMIT_RTTIME：实时时间限制。</span><br><span class="line">setrlimit()函数有两个参数，分别是资源类型和rlim结构体的指针，其中rlim结构体用来存储新的软限制和硬限制值。</span><br><span class="line"></span><br><span class="line">rlimt结构体定义如下：</span><br><span class="line">struct rlimit &#123;</span><br><span class="line">    rlim_t rlim_cur;  // 软限制值</span><br><span class="line">    rlim_t rlim_max;  // 硬限制值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">rlim_t是一个无符号整型类型</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>umask函数</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">mode_t umask(mode_t cmask);</span><br><span class="line"></span><br><span class="line">功能：用来设置当前进程的文件创建屏蔽字。文件创建屏蔽字是一种文件权限掩码，用来掩盖掉新建的文件的某些权限。文件创建屏蔽字是一个由9个常量按位或构成的mode_t类型的值，对应9种访问权限。在文件创建时，系统会将umask值和用户创建一个新文件或目录时指定一个文件权限值按位取反后进行按位与操作，以得到最终权限值。文件创建屏蔽字可以分为硬限制和软限制。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;sys/stat.h&gt;</span><br><span class="line">返回值：函数成功调用返回原文件创建屏蔽字的值，如果出错则返回-1。</span><br></pre></td></tr></table></figure>
</li>
<li><p>chdir函数</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int chdir(const char *path);</span><br><span class="line"></span><br><span class="line">功能：用来改变当前进程的工作目录，即将当前工作目录更改为path指定的目录。</span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line">返回值：函数成功调用返回0，失败返回-1。</span><br><span class="line">参数：path，表示要改变的工作目录路径。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建子进程失败</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程继续执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 脱离终端</span></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符,gettablesize()用于获取当前进程的文件描述符数量上限,循环关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int fdtablesize = getdtablesize();</span></span><br><span class="line">    <span class="comment">//for(fd = 0;fd&lt;fdtablesize;fd++) close(fd);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = getrlimit(RLIMIT_NOFILE, &amp;rlim);</span><br><span class="line">    <span class="keyword">for</span>(fd=<span class="number">0</span>;fd &lt; ret:fd++) close(fd);</span><br><span class="line">    <span class="comment">// 设置文件权限掩码，umask(0)不屏蔽任何权限</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变工作目录 通常是把&quot;/&quot;或&quot;/tmp&quot;作为守护进程的当前目录</span></span><br><span class="line">    chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理信号</span></span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    signal(SIGHUP, handle_signal);</span><br><span class="line">    signal(SIGTERM, handle_signal);</span><br><span class="line">    signal(SIGINT, handle_signal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动守护进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 守护进程的主要工作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-2-线程"><a href="#2-2-线程" class="headerlink" title="2.2 线程"></a>2.2 线程</h3><h4 id="2-2-1-线程的创建"><a href="#2-2-1-线程的创建" class="headerlink" title="2.2.1 线程的创建"></a>2.2.1 线程的创建</h4><h5 id="进程创建pthread-create"><a href="#进程创建pthread-create" class="headerlink" title="进程创建pthread_create"></a>进程创建pthread_create</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</span><br><span class="line"></span><br><span class="line">功能：用于创建一个新的线程，并执行指定的函数。线程创建后立即执行指定的函数，如果指定的函数执行完毕后没有调用pthread_exit函数或返回值为NULL，则线程将自动调用pthread_exit函数并返回NULL。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;pthread.h&gt;</span><br><span class="line">返回值：函数成功调用返回0，失败返回错误码。</span><br><span class="line">参数：</span><br><span class="line">    thread：指向线程ID的指针，用于存储新线程的ID。</span><br><span class="line">    attr：指向线程属性结构体的指针，用于指定新线程的属性，如果为NULL则使用默认属性。</span><br><span class="line">    start_routine：指向线程函数的指针，表示新线程要执行的函数。</span><br><span class="line">    arg：指向void类型的指针，表示传递给线程函数的参数。</span><br><span class="line"></span><br><span class="line">注意：用了pthred函数后编译时要在后面链接一个phread库。-lpthread</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-线程的等待pthread-join"><a href="#2-2-2-线程的等待pthread-join" class="headerlink" title="2.2.2 线程的等待pthread_join"></a>2.2.2 线程的等待pthread_join</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pthread_join(pthread_t thread, void **retval);</span><br><span class="line"></span><br><span class="line">功能：用于等待指定的线程结束，并获取线程的返回值。如果指定的线程已经结束，则该函数会立即返回；否则该函数会阻塞当前线程，直到指定的线程结束为止。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;pthread.h&gt;</span><br><span class="line">返回值：函数成功调用返回0，失败返回错误码。</span><br><span class="line">参数：</span><br><span class="line">    thread：要等待的线程ID。</span><br><span class="line">    retval：指向指针的指针，用于存储线程的返回值。</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-线程的取消pthread-cancel"><a href="#2-2-3-线程的取消pthread-cancel" class="headerlink" title="2.2.3 线程的取消pthread_cancel"></a>2.2.3 线程的取消pthread_cancel</h4><blockquote>
<p>线程有取消类型：</p>
<p>是否允许取消，pthread_setcancelstate()，参数可选值：</p>
<blockquote>
<p>PTHREAD_CANCEL_ENABLE 这是默认值，该线程可以响应取消请求。<br>PTHREAD_CANCEL_DISABLE 无法响应取消请求</p>
</blockquote>
<p>设置取消类型，pthread_setcanceltype()，参数可选值：</p>
<blockquote>
<p>PTHREAD_CANCEL_ASYNCHRONOUS，异步方式，当发出取消请求后，线程可能会在任何点被杀死。<br>PTHREAD_CANCEL_DEFERRED，延迟方式，线程只会在特定的取消点（cancellation points，调用某个函数前）被杀死。</p>
</blockquote>
</blockquote>
<blockquote>
<p>在Linux系统中，以下是一些常见的取消点：</p>
<blockquote>
<ul>
<li>I/O操作，如read、write、open等</li>
<li>等待信号，如sigsuspend、sigwait等</li>
<li>等待锁，如pthreadmutexlock、pthreadmutextimedlock等</li>
<li>等待条件变量，如pthreadcondwait、pthreadcondtimedwait等</li>
<li>睡眠，如sleep、nanosleep等</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pthread_cancel(pthread_t thread);</span><br><span class="line"></span><br><span class="line">功能：pthread_cancel函数用于请求取消指定的线程。线程在接收到取消请求后，可以选择立即取消或者继续执行直到响应取消请求为止。线程可以通过设置线程取消状态来控制是否接收取消请求。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;pthread.h&gt;</span><br><span class="line">返回值：函数成功调用返回0，失败返回错误码。</span><br><span class="line">参数：</span><br><span class="line">    thread：要取消的线程ID。</span><br><span class="line"></span><br><span class="line">注意：pthread_cancel只是像线程发送了一个取消请求，如果线程的退出</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running.\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);  <span class="comment">// 线程执行10秒</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is exiting.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread_id, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to create new thread.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;New thread created successfully.\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);  <span class="comment">// 稍微等待一下</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_cancel(thread_id) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Failed to cancel thread.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Thread is canceled.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_join(thread_id, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个程序中创建了一个线程并让线程运行10秒，主线程运行2秒后调pthread_cancel取消线程，并pthread_join等待阻塞,但因为sleep是一个取消点，线程会被取消返回，所以整个进程在大概2秒后结束。如果 pthread_join 在 pthread_cancel之前或者没有取消点，整个进程则会运行大概10秒后结束。</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-线程的退出pthread-exit"><a href="#2-2-4-线程的退出pthread-exit" class="headerlink" title="2.2.4 线程的退出pthread_exit"></a>2.2.4 线程的退出pthread_exit</h4><ul>
<li>需要回收的pthread_exit和自然退出<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">void pthread_exit(void *retval);</span><br><span class="line"></span><br><span class="line">功能:pthread_exit()函数用于结束当前线程的执行，并返回一个指定的返回值。如果没有调用pthread_exit()函数，线程将在函数返回时自动退出。</span><br><span class="line"></span><br><span class="line">头文件: #include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">返回值:pthread_exit()函数没有返回值，它只是用于结束当前线程的执行。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    void *retval：即线程返回值的指针（记得要是void）。retval参数可以用来指定当前线程的返回值，这个返回值可以被其他线程调用pthread_join()函数获取。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">    1. pthread_exit函数和return语句的区别是，pthread_exit函数只会终止当前线程，不会影响进程中其他线程的执行，而return语句会终止整个进程。此外，pthread_exit函数可以自动调用线程清理程序和析构函数</span><br><span class="line">    2. pthread_exit函数和pthread_cancel函数的区别是，pthread_exit函数是线程主动退出的方式，它可以指定一个返回值给其他线程；pthread_cancel函数是线程被动退出的方式，它是由其他线程发送一个取消请求给目标线程，然后目标线程在取消点检查并终止执行。被取消的线程可以选择忽略取消或者控制如何被取消。</span><br><span class="line">    3. pthread_detach函数可以使线程与主线程分离，不需要等待或回收，而pthread_exit函数可以使线程退出，但需要其他线程调用pthread_join函数来等待或回收（自然退出也是）。另外，pthread_detach函数是在线程运行过程中调用的，pthread_exit函数是在线程结束时调用的。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>示例代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *value_ptr = (<span class="keyword">int</span> *) arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread function started with value %d\n&quot;</span>, *value_ptr);</span><br><span class="line">    *value_ptr += <span class="number">1</span>;</span><br><span class="line">    pthread_exit(value_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">int</span> *return_value_ptr;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_func, &amp;value);</span><br><span class="line">    pthread_join(thread, (<span class="keyword">void</span> **) &amp;return_value_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread returned value %d\n&quot;</span>, *return_value_ptr);</span><br><span class="line">    <span class="built_in">free</span>(return_value_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//在这个例子中，我们使用 pthread_create 创建了一个新线程，并传递了一个指向整数值 value 的指针。线程函数 thread_func 接受这个值，将其加 1，然后使用指向更新后值的指针调用 pthread_exit。在主线程中，我们调用 pthread_join 等待子线程终止并检索其返回值。然后我们打印出返回值并释放其分配的内存。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自动回收的pthread_detach</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pthread_detach(pthread_t thread);</span><br><span class="line"></span><br><span class="line">功能：主线程中使用，用于将指定的线程标记为可被回收资源的状态，从而让线程在终止时能够自动释放占用的资源，无需其他线程调用pthread_join来等待其退出。</span><br><span class="line">头文件：#include &lt;pthread.h&gt;</span><br><span class="line">返回值：函数返回值为0表示成功，返回其他值表示失败。</span><br><span class="line">函数参数：</span><br><span class="line">  thread: 要被标记为可被回收状态的线程的线程ID。</span><br><span class="line"></span><br><span class="line">注意：只能对还未被其他线程使用pthread_join函数等待的线程进行pthread_detach操作。</span><br></pre></td></tr></table></figure>
<br>

<h3 id="2-3-进程间通信"><a href="#2-3-进程间通信" class="headerlink" title="2.3 进程间通信"></a>2.3 进程间通信</h3><h4 id="2-3-1-无名管道pipe"><a href="#2-3-1-无名管道pipe" class="headerlink" title="2.3.1 无名管道pipe"></a>2.3.1 无名管道pipe</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pipe(int pipefd[2]);</span><br><span class="line"></span><br><span class="line">功能:用于创建一个管道，它返回两个文件描述符，一个用于读取管道中的数据，一个用于写入数据到管道中。</span><br><span class="line">头文件:在使用pipe函数时需要包含头文件&lt;unistd.h&gt;，该头文件中包含了pipe函数的声明。</span><br><span class="line">返回值:pipe函数成功执行时返回0，失败时返回-1。</span><br><span class="line">参数:</span><br><span class="line">    fd:该数组用于存储创建的管道的读取和写入文件描述符。fd[0]用于读取管道中的数据，fd[1]用于向管道中写入数据。</span><br><span class="line"></span><br><span class="line">注意：pipe有读写特性</span><br><span class="line">读特性</span><br><span class="line">	写端存在：</span><br><span class="line">        管道中有数据：返回读到的字节数</span><br><span class="line">        管道中无数据：阻塞</span><br><span class="line">    写端不存在：</span><br><span class="line">       	管道中有数据：返回读到的字节数</span><br><span class="line">        管道中无数据：返回0</span><br><span class="line">写特性</span><br><span class="line">    读端存在：</span><br><span class="line">        空间足够：返回写入的字节数</span><br><span class="line">        空间不足：阻塞</span><br><span class="line">    读端不存在：    </span><br><span class="line">        无论是否有空间：管道破裂</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="keyword">char</span>* msg = <span class="string">&quot;Hello, parent process!&quot;</span>;</span><br><span class="line">        write(pipefd[<span class="number">1</span>], msg, <span class="built_in">strlen</span>(msg) + <span class="number">1</span>); <span class="comment">// 写入管道</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="keyword">ssize_t</span> num = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 读取管道数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received message from child process: %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个子进程，并在父子进程间创建一个管道，子进程写管道，父进程读管道</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-有名管道fifo"><a href="#2-3-2-有名管道fifo" class="headerlink" title="2.3.2 有名管道fifo"></a>2.3.2 有名管道fifo</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">功能：mkfifo函数用于创建一个FIFO文件，FIFO文件是一种特殊的文件，可以实现进程间通信。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt;  #include &lt;sys/stat.h&gt;</span><br><span class="line">返回值：函数返回值为0表示成功，返回其他值表示失败。</span><br><span class="line">参数：</span><br><span class="line">    pathname: FIFO文件的路径和名称。</span><br><span class="line">    mode: FIFO文件的权限。</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* fifo_name = <span class="string">&quot;./myfifo&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建FIFO文件</span></span><br><span class="line">    <span class="keyword">if</span> (mkfifo(fifo_name, <span class="number">0666</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkfifo error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="comment">// 打开FIFO文件</span></span><br><span class="line">        <span class="keyword">if</span> ((fd = open(fifo_name, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从FIFO读取数据</span></span><br><span class="line">        <span class="keyword">if</span> (read(fd, buf, <span class="keyword">sizeof</span>(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received message from parent: %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">        close(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 打开FIFO文件</span></span><br><span class="line">        <span class="keyword">if</span> ((fd = open(fifo_name, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向FIFO写入数据</span></span><br><span class="line">        <span class="keyword">char</span>* message = <span class="string">&quot;Hello, child process!&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (write(fd, message, <span class="built_in">strlen</span>(message)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭FIFO文件</span></span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除FIFO文件</span></span><br><span class="line">    <span class="keyword">if</span> (unlink(fifo_name) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;unlink error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这个示例代码中，使用mkfifo函数创建一个名为&quot;myfifo&quot;的FIFO文件，然后创建子进程。在父进程中，使用open函数打开FIFO文件，并使用write函数向其中写入一条消息。在子进程中，使用open函数打开FIFO文件，并使用read函数从其中读取一条消息。在最后，使用unlink函数删除FIFO文件。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-共享内存"><a href="#2-3-3-共享内存" class="headerlink" title="2.3.3 共享内存"></a>2.3.3 共享内存</h4><h5 id="生成键值-ftok"><a href="#生成键值-ftok" class="headerlink" title="生成键值 ftok"></a>生成键值 ftok</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">key_t ftok(const char *pathname, int proj_id);</span><br><span class="line"></span><br><span class="line">功能：ftok函数用于生成一个唯一的键值，这个键值通常用于创建或获取共享内存、消息队列等系统对象。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt;  #include &lt;sys/ipc.h&gt;</span><br><span class="line">返回值：函数返回值为一个非零整数，如果生成键值失败则返回-1。</span><br><span class="line">函数参数：</span><br><span class="line">    pathname: 已存在的文件路径和名称，用于生成键值。可以填&quot;.&quot;表示当前目录</span><br><span class="line">    proj_id: 项目ID，用于进一步生成键值。可以填0~255。</span><br><span class="line">注意事项：</span><br><span class="line">    1. ftok函数根据文件路径和名称以及项目ID生成一个唯一的键值，这个键值通常用于创建或获取共享内存、消息队列等系统对象。</span><br><span class="line">    2. 为了保证生成的键值唯一，需要选择一个具有唯一性的文件路径和名称以及项目ID。</span><br><span class="line">    3. 在使用ftok函数生成键值时，需要注意文件路径和名称的正确性以及是否具有可读可写的权限。</span><br></pre></td></tr></table></figure>

<h5 id="创建共享内存shmget"><a href="#创建共享内存shmget" class="headerlink" title="创建共享内存shmget"></a>创建共享内存shmget</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line"></span><br><span class="line">功能：shmget函数用于创建或获取一个共享内存段。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt;</span><br><span class="line">返回值：函数返回值为共享内存段的标识符，如果创建或获取共享内存段失败则返回-1。</span><br><span class="line">函数参数：</span><br><span class="line">    key: 共享内存段的键值。</span><br><span class="line">    size: 共享内存段的大小。</span><br><span class="line">    shmflg: 共享内存段的标志位，用于指定共享内存的权限和创建方式等。中间用 | 来连接。</span><br><span class="line">        - IPC_CREAT：如果共享内存段不存在，则创建它。</span><br><span class="line">        - IPC_EXCL：如果同时指定了 IPC_CREAT 和 IPC_EXCL，并且共享内存段已经存在，则返回错误。</span><br><span class="line">        - SHM_HUGETLB：使用大页面分配共享内存段。</span><br><span class="line">        - SHM_NORESERVE：不为共享内存段保留交换空间。</span><br><span class="line">        - 0664：共享内存的权限（也可以是其它的数）</span><br></pre></td></tr></table></figure>

<h5 id="映射共享内存shmat"><a href="#映射共享内存shmat" class="headerlink" title="映射共享内存shmat"></a>映射共享内存shmat</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line"></span><br><span class="line">功能：shmat函数用于将共享内存段映射到当前进程的地址空间，并返回共享内存段的起始地址。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt;  #include &lt;sys/shm.h&gt;</span><br><span class="line">返回值：函数返回值为共享内存段的起始地址，如果映射失败则返回-1。</span><br><span class="line">函数参数：</span><br><span class="line">    shmid: 共享内存段的标识符。</span><br><span class="line">    shmaddr: 映射共享内存段的首地址，通常设置为NULL。</span><br><span class="line">    shmflg: 映射共享内存段的标志位，用于指定映射的方式和权限等。一般填0，为读写</span><br></pre></td></tr></table></figure>

<h5 id="解除共享内存的映射shmdt"><a href="#解除共享内存的映射shmdt" class="headerlink" title="解除共享内存的映射shmdt"></a>解除共享内存的映射shmdt</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int shmdt(const void *shmaddr);</span><br><span class="line"></span><br><span class="line">功能：shmdt函数用于解除共享内存段和当前进程地址空间的映射。</span><br><span class="line">头文件：#include &lt;sys/shm.h&gt;</span><br><span class="line">返回值：函数成功时返回 0，失败时返回 -1。</span><br><span class="line">函数参数：</span><br><span class="line">    shmaddr：指向共享内存区域的指针。通常，该指针是由 shmat() 函数返回的共享内存区域地址。</span><br><span class="line">注意事项：</span><br><span class="line">    1. 在调用 shmdt 函数分离共享内存区域后，程序不应该再使用该指针访问共享内存，因为这样会导致未定义的行为。</span><br><span class="line">    2. 如果当前进程是最后一个附加到该共享内存区域的进程，那么该共享内存区域会被系统自动删除。</span><br></pre></td></tr></table></figure>

<h5 id="控制共享内存shmctl"><a href="#控制共享内存shmctl" class="headerlink" title="控制共享内存shmctl"></a>控制共享内存shmctl</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span><br><span class="line"></span><br><span class="line">功能：shmctl 函数用于对共享内存区域进行控制操作，包括获取共享内存区域的状态信息、修改共享内存区域的权限和删除共享内存区域等操作。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：函数成功时返回 0，失败时返回 -1。</span><br><span class="line"></span><br><span class="line">函数参数：</span><br><span class="line"></span><br><span class="line">    shmid：共享内存区域的标识符，由 shmget 函数返回。</span><br><span class="line">    cmd：控制操作命令。常见的操作命令包括：</span><br><span class="line">        IPC_STAT：获取共享内存区域的状态信息，将共享内存的相关信息保存到 buf 结构体中。</span><br><span class="line">        IPC_SET：修改共享内存区域的状态信息，使用 buf 结构体中的信息更新共享内存的相关属性。</span><br><span class="line">        IPC_RMID：删除共享内存区域。</span><br><span class="line">    buf：指向 shmid_ds 结构体的指针，用于存储共享内存区域的状态信息或更新共享内存的相关属性。如果 cmd 参数为 IPC_STAT 或 IPC_SET，则需要传入一个有效的 shmid_ds 结构体指针。</span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">    1. 在使用 shmctl 函数删除共享内存区域时，应该确保没有任何进程正在使用该共享内存，否则删除操作会失败。</span><br><span class="line">    2. 如果 shmctl 函数的 cmd 参数为 IPC_RMID，则系统会立即删除共享内存区域，而不管当前是否有进程正在使用该共享内存。</span><br></pre></td></tr></table></figure>

<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">char</span> *shm, *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个唯一的 key</span></span><br><span class="line">    <span class="keyword">if</span> ((key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;R&#x27;</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建共享内存段</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHM_SIZE, <span class="number">0644</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将共享内存段连接到当前进程的地址空间</span></span><br><span class="line">    <span class="keyword">if</span> ((shm = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="keyword">char</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向共享内存段写入数据</span></span><br><span class="line">    s = shm;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">        *s++ = c;</span><br><span class="line">    &#125;</span><br><span class="line">    *s = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从共享内存段读取数据并输出</span></span><br><span class="line">    <span class="keyword">for</span> (s = shm; *s != <span class="string">&#x27;\0&#x27;</span>; s++) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(*s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将共享内存段从当前进程的地址空间分离</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(shm) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmdt&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除共享内存段</span></span><br><span class="line">    <span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码中首先使用 ftok 函数生成一个唯一的 key，然后使用 shmget 函数创建一个大小为 SHM_SIZE 的共享内存段，并将其连接到当前进程的地址空间中。接着，向共享内存段写入数据，从共享内存段读取数据并输出。最后，将共享内存段从当前进程的地址空间分离，并使用 shmctl 函数删除共享内存段。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-进程间异步通信-信号"><a href="#2-3-4-进程间异步通信-信号" class="headerlink" title="2.3.4 进程间异步通信-信号"></a>2.3.4 进程间异步通信-信号</h4><h5 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h5><ul>
<li><p>kill</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int kill(pid_t pid, int sig);</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;sys/types.h&gt;  #include &lt;signal.h&gt;</span><br><span class="line">返回值：函数返回值为 0 表示成功，返回 -1 表示失败。</span><br><span class="line">参数：</span><br><span class="line">        pid：指定进程或进程组的进程 ID，可以取以下几个值：</span><br><span class="line">                &gt;0：发送信号给进程 ID 为 pid 的进程。</span><br><span class="line">                0：发送信号给当前进程所在进程组中的所有进程。</span><br><span class="line">                -1：发送信号给所有有权限发送信号的进程。</span><br><span class="line">                &lt;-1：发送信号给进程组 ID 为 -pid 的进程组中的所有进程。</span><br><span class="line">        sig：指定要发送的信号的编号或者名字，可以是以下几个值：</span><br><span class="line">                SIGKILL：无条件终止进程。</span><br><span class="line">                SIGTERM：向进程发送终止信号，请求进程自己终止。</span><br><span class="line">                SIGINT：中断信号，通常是通过键盘发送给进程的。</span><br><span class="line">                其他信号编号，可以参考上面信号部分的笔记</span><br><span class="line">注意事项：</span><br><span class="line">1. 只有具有特权的进程才能向其他进程发送信号。</span><br><span class="line">2. SIGKILL和SIGSTOP信号不能被进程捕获或忽略，一旦进程接收到该信号，它会立即终止。</span><br><span class="line">3. SIGTERM 信号可以被进程捕获或忽略，进程可以在收到该信号后进行清理工作后再终止。</span><br><span class="line">4. 如果向进程组发送信号，则该信号会被所有在该进程组中的进程接收到。</span><br></pre></td></tr></table></figure>
</li>
<li><p>raise</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int raise(int sig);</span><br><span class="line"></span><br><span class="line">功能：raise()函数用于发送一个信号给调用进程或者线程。这个函数可以用来模拟信号的接收，以便测试信号处理函数。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：成功时，返回0；失败时，返回非0值。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    sig：要发送的信号。信号可以是SIGTERM、SIGABRT等，具体取决于您想要发送的信号类型。</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">1. 当一个进程或线程收到一个信号时，它将暂停当前的工作，并根据信号的类型来执行相应的处理函数。因此，在使用raise()函数时要注意不要产生死锁或者循环依赖。</span><br><span class="line">2. 在多线程环境下，raise()函数可能发送信号给同一进程中的任意线程，而不是特定的调用线程。所以，在多线程环境下使用raise()函数时，要特别注意。</span><br><span class="line">3. 该函数仅将信号发送到调用它的进程或线程。主要用于测试或模拟信号处理。</span><br></pre></td></tr></table></figure>
<h5 id="信号的等待"><a href="#信号的等待" class="headerlink" title="信号的等待"></a>信号的等待</h5></li>
<li><p>定时器alarm</p>
</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line"></span><br><span class="line">功能：alarm()函数用于设置一个实时闹钟，当闹钟到期时，会向当前进程发送SIGALRM信号。如果在闹钟到期之前再次调用alarm()，则先前设置的闹钟会被新的设置覆盖。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：如果之前已经设置了闹钟，则返回剩余的秒数，否则返回0。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">    unsigned int seconds：从当前时间开始，经过的秒数。设置为0表示取消先前设置的闹钟。</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">1. 在使用alarm()函数之前，请确保已经正确注册了信号处理函数（如SIGALRM信号），以便在信号发送后可以正确处理。</span><br><span class="line">2. alarm()函数不是线程安全的，因此在多线程环境下使用时要小心。在多线程环境下，建议使用timer_create()和timer_settime()等函数来设置定时器。</span><br><span class="line">3. alarm()函数设置的闹钟是进程级别的，而非线程级别的。因此，所有线程共享同一个闹钟。</span><br><span class="line">4. 一个进程只允许一个闹钟，如果在上一个闹钟还没结束时调用了另一个闹钟，则新闹钟的返回值是前一个闹钟还剩下的时间</span><br></pre></td></tr></table></figure>

<ul>
<li>进程暂停pause</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pause(void);</span><br><span class="line"></span><br><span class="line">功能：pause()函数用于使调用进程暂停，直到收到一个信号。当收到信号后，该函数会返回，并且进程会继续执行。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：pause()函数在成功接收信号后返回-1，并设置errno为EINTR。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">1. pause()函数通常与信号处理函数一起使用，当需要让进程等待信号时，可以使用pause()函数。</span><br><span class="line">2. 如果进程在调用pause()之前就已经收到信号，那么pause()函数可能会导致进程永久阻塞。</span><br><span class="line">3. 在多线程环境下使用pause()函数时要小心，因为它会影响整个进程。在多线程环境下，可以考虑使用条件变量、信号量等其他同步原语。</span><br></pre></td></tr></table></figure>

<h5 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line"></span><br><span class="line">功能：signal()函数用于设置信号处理函数。当进程接收到指定类型的信号时，它将执行给定的信号处理函数。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：成功时，返回先前的信号处理函数指针；失败时，返回SIG_ERR。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">int signum：要设置处理函数的信号。例如，SIGINT、SIGTERM等。</span><br><span class="line">sighandler_t handler：用于处理指定信号的函数指针。可以是用户定义的处理函数，也可以是SIG_IGN（忽略信号）或SIG_DFL（使用默认操作）。</span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">1. 信号处理函数应尽量简短且不阻塞，写在信号产生之前，因为它会中断正常的程序执行。此外，请确保信号处理函数是可重入的，因为它可能在任何时间被调用。</span><br><span class="line">2. signal()函数在不同的系统和库实现中可能具有不同的行为。在某些情况下，建议使用sigaction()函数代替signal()函数，以获得更可靠和可移植的行为。</span><br></pre></td></tr></table></figure>

<h5 id="信号的示例代码"><a href="#信号的示例代码" class="headerlink" title="信号的示例代码"></a>信号的示例代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGALRM信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigalrm_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子进程: 收到SIGALRM信号，发送SIGUSR1信号给父进程\n&quot;</span>);</span><br><span class="line">    kill(getppid(), SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGUSR1信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigusr1_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;父进程: 收到SIGUSR1信号\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;创建子进程失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">if</span> (signal(SIGALRM, sigalrm_handler) == SIG_ERR) &#123;</span><br><span class="line">            perror(<span class="string">&quot;子进程: 注册SIGALRM信号处理函数失败&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程: 设置3秒后触发闹钟\n&quot;</span>);</span><br><span class="line">        alarm(<span class="number">3</span>);</span><br><span class="line">        pause();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">if</span> (signal(SIGUSR1, sigusr1_handler) == SIG_ERR) &#123;</span><br><span class="line">            perror(<span class="string">&quot;父进程: 注册SIGUSR1信号处理函数失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程: 等待SIGUSR1信号\n&quot;</span>);</span><br><span class="line">        pause();</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程: 子进程已退出\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这个示例中，我们首先创建了一个子进程。子进程设置了一个3秒后触发的闹钟，并注册了一个处理SIGALRM信号的信号处理函数。然后子进程调用pause()函数等待信号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父进程注册了一个处理SIGUSR1信号的信号处理函数，并调用pause()函数等待信号。当子进程的闹钟触发后，它会接收到SIGALRM信号并调用信号处理函数，这个函数会向父进程发送SIGUSR1信号。父进程接收到SIGUSR1信号后，执行信号处理函数并继续执行。最后，父进程等待子进程退出并打印一条消息</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-5-进程间同步和互斥"><a href="#2-3-5-进程间同步和互斥" class="headerlink" title="2.3.5 进程间同步和互斥"></a>2.3.5 进程间同步和互斥</h4><h5 id="生成键值-ftok-1"><a href="#生成键值-ftok-1" class="headerlink" title="生成键值 ftok"></a>生成键值 ftok</h5><p>和共享内存相似，生成信号量前要先生成一个键值：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">key_t ftok(const char *pathname, int proj_id);</span><br><span class="line"></span><br><span class="line">功能：ftok函数用于生成一个唯一的键值，这个键值通常用于创建或获取共享内存、消息队列等系统对象。</span><br><span class="line">头文件：#include &lt;sys/types.h&gt;  #include &lt;sys/ipc.h&gt;</span><br><span class="line">返回值：函数返回值为一个非零整数，如果生成键值失败则返回-1。</span><br><span class="line">函数参数：</span><br><span class="line">    pathname: 已存在的文件路径和名称，用于生成键值。可以填&quot;.&quot;表示当前目录</span><br><span class="line">    proj_id: 项目ID，用于进一步生成键值。可以填0~255</span><br><span class="line">注意事项：</span><br><span class="line">    1. ftok函数根据文件路径和名称以及项目ID生成一个唯一的键值，这个键值通常用于创建或获取共享内存、消息队列等系统对象。</span><br><span class="line">    2. 为了保证生成的键值唯一，需要选择一个具有唯一性的文件路径和名称以及项目ID。</span><br><span class="line">    3. 在使用ftok函数生成键值时，需要注意文件路径和名称的正确性以及是否具有可读可写的权限。</span><br></pre></td></tr></table></figure>

<h5 id="创建信号量集semget"><a href="#创建信号量集semget" class="headerlink" title="创建信号量集semget"></a>创建信号量集semget</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int semget(key_t key, int nsems, int semflg);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line"></span><br><span class="line">semget 函数用于获取一个信号量集的标识符。如果指定的键值 key 对应的信号量集已经存在，则返回该信号量集的标识符；否则，根据指定的键值 key 和信号量集的数量 nsems 创建一个新的信号量集，并返回其标识符。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line"></span><br><span class="line">如果成功，semget 函数返回一个非负整数，即信号量集的标识符；否则，返回 -1 并设置 errno 变量以指示错误。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line"></span><br><span class="line">        - key_t key：一个键值，用于标识信号量集。可以使用 ftok 函数生成一个键值。</span><br><span class="line">        - int nsems：信号量集中信号量的数量。</span><br><span class="line">        - int semflg：标志位，用于指定信号量集的访问权限和行为。可以使用 IPC_CREAT 标志位创建一个新的信号量集。</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line"></span><br><span class="line">1. semget 函数是一个系统调用，它可以用于在进程间共享信号量集。如果多个进程使用相同的键值调用 semget 函数，则它们将共享同一个信号量集。</span><br><span class="line">2. semget 函数返回的标识符可以用于后续的信号量操作，如 semop 函数。</span><br><span class="line">3. 如果您使用 IPC_CREAT 标志位创建一个新的信号量集，则需要使用 semctl 函数来初始化信号量集中的每个信号量。</span><br></pre></td></tr></table></figure>

<h5 id="操作信号量集semop"><a href="#操作信号量集semop" class="headerlink" title="操作信号量集semop"></a>操作信号量集semop</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int semop(int semid, struct sembuf *sops, size_t nsops);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line"></span><br><span class="line">semop 函数用于对一个信号量集进行操作。它可以对一个或多个信号量进行 P 操作或 V 操作，也可以对一个或多个信号量进行 Z 操作。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">如果成功，semop 函数返回 0；否则，返回 -1 并设置 errno 变量以指示错误。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">        - int semid：信号量集的标识符，即 semget 函数返回的值。</span><br><span class="line">        - struct sembuf *sops：指向一个 sembuf 结构体数组的指针，每个 sembuf 结构体描述了一个信号量操作。</span><br><span class="line">        - size_t nsops：sembuf 结构体数组的长度。</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line">1. semop 函数是一个系统调用，它可以用于在进程间共享信号量集。</span><br><span class="line">2. semop 函数可以对一个或多个信号量进行操作，每个操作由一个 sembuf 结构体描述。</span><br><span class="line">3. semop 函数可以对信号量进行 P 操作、V 操作或 Z 操作。</span><br><span class="line">4. 如果您使用了 SEM_UNDO 标志位，则在进程退出时会自动撤销信号量操作。</span><br><span class="line">5. 如果您使用了 IPC_NOWAIT 标志位，则 semop 函数会立即返回，而不是等待信号量变为 0。</span><br></pre></td></tr></table></figure>

<p>sembuf 结构体定义如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">struct sembuf &#123;</span><br><span class="line">    unsigned short sem_num;  // 信号量在信号量集中的编号</span><br><span class="line">    short sem_op;            // 信号量操作，可以是 P、V 或 Z</span><br><span class="line">    short sem_flg;           // 操作标志，可以是 IPC_NOWAIT 或 SEM_UNDO</span><br><span class="line">&#125;;</span><br><span class="line">sem_op 可以是以下值之一：</span><br><span class="line">        - sem_op &gt; 0：V 操作，即释放一个信号量。</span><br><span class="line">        - sem_op &lt; 0：P 操作，即获取一个信号量。</span><br><span class="line">        - sem_op = 0：Z 操作，即等待一个信号量变为 0。</span><br><span class="line"></span><br><span class="line">sem_flg 可以是以下值之一：</span><br><span class="line">        - 0：默认值，表示在操作完成之前等待信号量变为 0。</span><br><span class="line">        - IPC_NOWAIT：表示不等待信号量变为 0，立即返回。</span><br><span class="line">        - SEM_UNDO：表示在进程退出时自动撤销信号量操作。</span><br></pre></td></tr></table></figure>

<h5 id="改变信号量集semctl"><a href="#改变信号量集semctl" class="headerlink" title="改变信号量集semctl"></a>改变信号量集semctl</h5><ul>
<li>semun结构体<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">union semun &#123; </span><br><span class="line">    int val; //用于SETVAL命令 </span><br><span class="line">    struct semid_ds *buf; //用于IPC_STAT和IPC_SET命令 </span><br><span class="line">    unsigned short *array; //用于GETALL和SETALL命令 </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    结构体semun的val是用于设置或获取信号量集的值的整数，它是用于SETVAL命令的参数，表示要设置的信号量的值。例如，如果要将第0个信号量的值设置为1，可以这样写：</span><br><span class="line">    union semun arg; arg.val = 1; semctl(semid, 0, SETVAL, arg);</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int semctl(int semid, int semnum, int cmd, ...);</span><br><span class="line"></span><br><span class="line">函数功能:</span><br><span class="line">semctl 函数允许我们控制信号量，包括获取或设置信号量的值、初始化信号量、删除信号量等。</span><br><span class="line"></span><br><span class="line">头文件:#include &lt;sys/sem.h&gt;</span><br><span class="line"></span><br><span class="line">返回值:</span><br><span class="line">semctl 函数的返回值取决于 cmd 参数的值，具体如下：</span><br><span class="line">        当 cmd 为 IPC_STAT 时，返回值为 0，表示成功。</span><br><span class="line">        当 cmd 为 IPC_SET 时，返回值为 0，表示成功。</span><br><span class="line">        当 cmd 为 IPC_RMID 时，返回值为 0，表示成功。</span><br><span class="line">        其他情况下，返回值为信号量集合的值或者 -1，表示出错。</span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">semid：信号量集合的 ID，由 semget 函数返回。</span><br><span class="line">semnum：信号量在集合中的编号，从 0 开始。</span><br><span class="line">cmd：要执行的操作</span><br><span class="line">        IPC_STAT：获取信号量集的状态信息，包括信号量集的 ID、拥有者的 ID、访问权限、信号量集中的信号量数量等。需要传入一个指向 semid_ds 结构体的指针，用于保存信号量集的状态信息。</span><br><span class="line">        IPC_SET：设置信号量集的状态信息，例如设置信号量集的访问权限、设置信号量集中信号量的数量等。需要传入一个指向 semid_ds 结构体的指针，用于设置信号量集的状态信息。</span><br><span class="line">        IPC_RMID：删除信号量集。不需要传入参数，可以传入一个 NULL 指针。</span><br><span class="line">        GETVAL：获取指定信号量的当前值。不需要传入参数，可以传入一个 NULL 指针。</span><br><span class="line">        SETVAL：设置指定信号量的值。需要传入一个 int 类型的参数，表示要设置的信号量的值。</span><br><span class="line">        GETALL：获取信号量集中所有信号量的值。需要传入一个指向 unsigned short 类型数组的指针，用于保存所有信号量的当前值。</span><br><span class="line">        SETALL：设置信号量集中所有信号量的值。需要传入一个指向 unsigned short 类型数组的指针，用于设置所有信号量的值。</span><br><span class="line">        GETPID：获取上一次操作该信号量的进程 ID。不需要传入参数，可以传入一个 NULL 指针。</span><br><span class="line">        GETNCNT：获取正在等待信号量的进程数。不需要传入参数，可以传入一个 NULL 指针。</span><br><span class="line">        GETZCNT：获取等待信号量变为 0 的进程数。不需要传入参数，可以传入一个 NULL 指针。</span><br><span class="line">...：根据 cmd 的值不同，后面的参数也不同。</span><br><span class="line"></span><br><span class="line">注意事项</span><br><span class="line">semctl 函数可以对一个信号量集合进行多种操作，包括获取或设置信号量的值、初始化信号量、删除信号量等。</span><br><span class="line">semctl 函数的第三个参数 cmd 决定了要执行的操作，具体操作请参考 semctl 的手册。</span><br><span class="line">semctl 函数的第四个参数是一个可选参数，根据 cmd 的值不同，后面的参数也不同。具体参数请参考 semctl 的手册。</span><br><span class="line">semctl 函数是一个比较底层的函数，如果不是很熟悉信号量的使用，建议使用更高级别的函数，如 semop。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> semun &#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_sem</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> initval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> semun arg;</span><br><span class="line">    arg.val = initval;</span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, semnum, SETVAL, arg) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_sem</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span> = &#123;</span>semnum, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;buf, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semop&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放信号量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_sem</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span> = &#123;</span>semnum, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (semop(semid, &amp;buf, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semop&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> semid, retval;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">union</span> semun arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的信号量集合</span></span><br><span class="line">    key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((semid = semget(key, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化信号量集合中的第一个信号量</span></span><br><span class="line">    init_sem(semid, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待信号量，相当于 P 操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Waiting for semaphore...\n&quot;</span>);</span><br><span class="line">    wait_sem(semid, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Semaphore acquired.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放信号量，相当于 V 操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Releasing semaphore...\n&quot;</span>);</span><br><span class="line">    signal_sem(semid, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取信号量的值</span></span><br><span class="line">    retval = semctl(semid, <span class="number">0</span>, GETVAL, arg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The value of the semaphore is %d\n&quot;</span>, retval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除信号量集合</span></span><br><span class="line">    <span class="keyword">if</span> (semctl(semid, <span class="number">0</span>, IPC_RMID, arg) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;semctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这个示例代码中，我们首先使用 ftok 函数创建一个用于标识信号量集合的 key。然后使用 semget 函数创建一个新的信号量集合，并使用 init_sem 函数初始化了信号量集合中的第一个信号量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来，我们使用 wait_sem 函数等待信号量，这里的信号量初值为 1，因此程序不会一直阻塞在这里。等待信号量之后，我们使用 signal_sem 函数释放信号量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接着，我们使用 semctl 函数获取信号量的值，并打印出来。最后，我们使用 semctl 函数删除信号量集合</span></span><br></pre></td></tr></table></figure>
<h4 id="2-3-6-消息队列"><a href="#2-3-6-消息队列" class="headerlink" title="2.3.6 消息队列"></a>2.3.6 消息队列</h4><h5 id="创建键值ftok"><a href="#创建键值ftok" class="headerlink" title="创建键值ftok"></a>创建键值ftok</h5><h5 id="消息队列创建msgget"><a href="#消息队列创建msgget" class="headerlink" title="消息队列创建msgget"></a>消息队列创建msgget</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int msgget(key_t key, int msgflg);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    1. 如果给定的键值 key 对应的消息队列已经存在，则返回其标识符。</span><br><span class="line">    2. 如果给定的键值 key 对应的消息队列不存在，则根据给定的标志 msgflg 创建一个新的消息队列，并返回其标识符。</span><br><span class="line">头文件：</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/ipc.h&gt;</span><br><span class="line">    #include &lt;sys/msg.h&gt;</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回一个非负整数，表示消息队列的标识符。</span><br><span class="line">    失败：返回 -1，并设置 errno 错误码以指示错误的类型。</span><br><span class="line">参数：</span><br><span class="line">    -key：用于标识消息队列的键值。</span><br><span class="line">    -msgflg：用于指定消息队列的访问权限和创建方式的标志。</span><br><span class="line">            -IPC_CREAT：如果消息队列不存在，则创建一个新的消息队列，并返回其标识符。如果消息队列已经存在，则返回其标识符。</span><br><span class="line">            -IPC_EXCL：如果消息队列已经存在，则返回错误（EEXIST）。</span><br><span class="line">            -IPC_PRIVATE：创建一个新的消息队列，并将其关联到一个新的私有键值上。这种方式只能由当前进程及其子进程访问。</span><br><span class="line">注意：</span><br><span class="line">1. 在使用消息队列之前，必须先定义一个消息结构体，以便可以将消息传递到队列中。</span><br><span class="line">2. 在使用完消息队列后，应该使用 msgctl 函数删除它。可以通过设置 IPC_RMID 标志来删除消息队列。</span><br><span class="line"></span><br><span class="line">消息结构体：</span><br><span class="line">struct msgbuf &#123;</span><br><span class="line">    long mtype;</span><br><span class="line">    char mtext[MSG_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mtype的值可以用来区分不同的消息内容或不同的消息来源，也可以用来实现消息的优先级或过滤。</span><br></pre></td></tr></table></figure>
<h5 id="消息队列的发送msgsnd"><a href="#消息队列的发送msgsnd" class="headerlink" title="消息队列的发送msgsnd"></a>消息队列的发送msgsnd</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">    将一个消息发送到指定的消息队列中。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/ipc.h&gt;</span><br><span class="line">    #include &lt;sys/msg.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：返回 0。</span><br><span class="line">    失败：返回 -1，并设置 errno 错误码以指示错误的类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    -msqid：要发送消息的消息队列标识符。</span><br><span class="line">    -msgp：指向一个消息结构体的指针，用于指定要发送的消息。消息结构体必须包含一个 long 类型的成员 mtype，表示消息类型。在发送消息之前，需要设置该成员的值。</span><br><span class="line">    -msgsz：要发送的消息的大小，以字节为单位。一般可以为(sizeof(MSG)-sizeof(long))即除 mtype 以外的消息部分的大小。</span><br><span class="line">    -msgflg：用于指定发送消息的行为的标志。0代表默认。它是一些位掩码，可以使用按位或运算符将它们组合在一起。常用的标志包括：</span><br><span class="line">        -IPC_NOWAIT：如果消息队列已满，则不等待并立即返回错误（EAGAIN）。</span><br><span class="line">        -MSG_NOERROR：如果消息的大小超过消息队列中定义的最大消息大小，则将消息截断并发送其截断后的部分，而不返回错误（但是，截断后的消息可能无法使用 msgrcv 函数完全接收）。</span><br></pre></td></tr></table></figure>

<h5 id="消息队列的接收msgrcv"><a href="#消息队列的接收msgrcv" class="headerlink" title="消息队列的接收msgrcv"></a>消息队列的接收msgrcv</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">功能：从指定的消息队列中接收一个消息，并将其存储到指定的消息结构体中。</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">    #include &lt;sys/types.h&gt;</span><br><span class="line">    #include &lt;sys/ipc.h&gt;</span><br><span class="line">    #include &lt;sys/msg.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">    成功：返回接收到的消息的大小（以字节为单位）。</span><br><span class="line">    失败：返回 -1，并设置 errno 错误码以指示错误的类型。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    -msqid：要接收消息的消息队列标识符。</span><br><span class="line">    -msgp：指向一个消息结构体的指针，用于存储接收到的消息。消息结构体必须包含一个 long 类型的成员 mtype，表示消息类型。在接收消息之前，需要设置该成员的值。</span><br><span class="line">    -msgsz：存储接收到的消息的缓冲区大小，以字节为单位。一般可以为(sizeof(MSG)-sizeof(long))</span><br><span class="line">    -msgtyp：要接收的消息类型。如果设置为 0，则接收队列中的第一条消息。一般要和要发送消息的结构体中的mtype中的值一样（有点像协议，两边约定同一个端口，即mtype的值）</span><br><span class="line">    -msgflg：用于指定接收消息的行为的标志。0表示默认。它是一些位掩码，可以使用按位或运算符将它们组合在一起。常用的标志包括：</span><br><span class="line">        -IPC_NOWAIT：如果消息队列中没有符合条件的消息，则立即返回错误（ENOMSG）。</span><br><span class="line">        -MSG_EXCEPT：用于指定接收队列中第一个不等于 msgtyp 的消息。如果没有这样的消息，则返回错误（ENOMSG）。</span><br><span class="line">        -MSG_NOERROR：如果消息的大小超过存储接收到的消息的缓冲区的大小，则将消息截断并接收其截断后的部分，而不返回错误。</span><br></pre></td></tr></table></figure>

<h5 id="内存空间中值的设定memset"><a href="#内存空间中值的设定memset" class="headerlink" title="内存空间中值的设定memset"></a>内存空间中值的设定memset</h5><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">void *memset(void *s, int c, size_t n);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">将一段内存空间的前 n 个字节设置为指定的值。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">返回指向目标内存空间的指针 s。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    s：指向要填充的内存空间的指针。</span><br><span class="line">    c：要设置的值，以 int 类型表示，但实际上只使用一个字节。通常使用无符号字符（unsigned char）类型的值，例如 &#x27;<span class="tag">\</span>0&#x27; 或 0xFF。</span><br><span class="line">    n：要设置的字节数。</span><br></pre></td></tr></table></figure>
<h5 id="消息队列的示例代码"><a href="#消息队列的示例代码" class="headerlink" title="消息队列的示例代码"></a>消息队列的示例代码</h5><p>这里实现的是同一目录下的两个进程之间相互发送和接受信息，注意里面的key值要一样</p>
<p>A文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;MSG;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN (sizeof(MSG)-sizeof(long)) <span class="comment">//发送消息的大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPEA 100  <span class="comment">//A向B发送消息的类型，msgtyp</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPEB 200  <span class="comment">//B向A发送消息的类型，msgtyp</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">//创建键值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(key, IPC_CREAT|<span class="number">0666</span>); <span class="comment">//创建消息队列</span></span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        msg.mtype = TYPEA;  <span class="comment">//设置消息类型</span></span><br><span class="line">        fgets(msg.mtext, <span class="number">1024</span>, <span class="built_in">stdin</span>); </span><br><span class="line">        ret = msgsnd(msgid, &amp;msg, LEN, <span class="number">0</span>); <span class="comment">//发送消息类型为TYPEA，大小为LEN的消息</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg)); <span class="comment">//将消息中的值清空</span></span><br><span class="line">        ret = msgrcv(msgid, &amp;msg, LEN, TYPEB, <span class="number">0</span>); <span class="comment">//接收消息类型为TYPEB，大小为LEN的消息</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv:%s\n&quot;</span>, msg.mtext);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>B文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">1024</span>];</span><br><span class="line">&#125;MSG;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN (sizeof(MSG)-sizeof(long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPEA 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPEB 200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> msgid = msgget(key, IPC_CREAT|<span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(msgid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        ret = msgrcv(msgid, &amp;msg, LEN, TYPEA, <span class="number">0</span>);<span class="comment">//接收消息类型为TYPEA，大小为LEN的消息</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv:%s\n&quot;</span>, msg.mtext);</span><br><span class="line"></span><br><span class="line">        msg.mtype = TYPEB;</span><br><span class="line">        fgets(msg.mtext, <span class="number">1024</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        ret = msgsnd(msgid, &amp;msg, LEN, <span class="number">0</span>);<span class="comment">//发送消息类型为TYPEB，大小为LEN的消息</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-4-线程间同步和互斥"><a href="#2-4-线程间同步和互斥" class="headerlink" title="2.4 线程间同步和互斥"></a>2.4 线程间同步和互斥</h3><h4 id="2-4-1-同步"><a href="#2-4-1-同步" class="headerlink" title="2.4.1 同步"></a>2.4.1 同步</h4><ul>
<li><p>初始化信号量sem_init</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">sem_init() 函数用于初始化一个 POSIX 信号量（Semaphore），该信号量用于线程间或进程间同步和互斥访问共享资源。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">若调用成功则返回 0，否则返回 -1 并设置 errno 错误码。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">        sem：指向要初始化的信号量的指针。</span><br><span class="line">        pshared：指定信号量是线程共享还是进程共享，如果是线程共享，则 pshared 值为 0，否则为非零值。对于不同的进程，只有当它们都指定同一个 pshared 值时，它们才能够共享同一个信号量。</span><br><span class="line">        value：指定信号量的初值。如果初值为 0，则所有试图使用该信号量进行 wait 操作的线程或进程将会被阻塞。</span><br></pre></td></tr></table></figure>
</li>
<li><p>等待信号量sem_wait</p>
</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int sem_wait(sem_t *sem);</span><br><span class="line"></span><br><span class="line">功能：</span><br><span class="line">sem_wait() 函数用于对指定的 POSIX 信号量进行 wait 操作，即尝试从信号量中取走一个资源，如果当前没有资源，则阻塞等待直到有资源可用。</span><br><span class="line">头文件：#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">若调用成功则返回 0，否则返回 -1 并设置 errno 错误码。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">sem：指向要进行 wait 操作的 POSIX 信号量的指针。</span><br></pre></td></tr></table></figure>
<p>示例代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">sem_t</span> empty, full, mutex;</span><br><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        item = rand() % <span class="number">100</span>; <span class="comment">// 生产一个随机数</span></span><br><span class="line">        sem_wait(&amp;empty); <span class="comment">// 等待缓冲区非满</span></span><br><span class="line">        sem_wait(&amp;mutex); <span class="comment">// 互斥访问缓冲区</span></span><br><span class="line">        buffer[in] = item; <span class="comment">// 将 item 放入缓冲区</span></span><br><span class="line">        in = (in + <span class="number">1</span>) % BUFFER_SIZE; <span class="comment">// 更新 in 指针</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者生产了 %d\n&quot;</span>, item);</span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// 释放缓冲区</span></span><br><span class="line">        sem_post(&amp;full); <span class="comment">// 增加缓冲区中的项目数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;full); <span class="comment">// 等待缓冲区非空</span></span><br><span class="line">        sem_wait(&amp;mutex); <span class="comment">// 互斥访问缓冲区</span></span><br><span class="line">        item = buffer[out]; <span class="comment">// 从缓冲区中取出一个项目</span></span><br><span class="line">        out = (out + <span class="number">1</span>) % BUFFER_SIZE; <span class="comment">// 更新 out 指针</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者消费了 %d\n&quot;</span>, item);</span><br><span class="line">        sem_post(&amp;mutex); <span class="comment">// 释放缓冲区</span></span><br><span class="line">        sem_post(&amp;empty); <span class="comment">// 增加缓冲区中的空闲位置数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    sem_init(&amp;empty, <span class="number">0</span>, BUFFER_SIZE); <span class="comment">// 初始化 empty 为 BUFFER_SIZE</span></span><br><span class="line">    sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 初始化 full 为 0</span></span><br><span class="line">    sem_init(&amp;mutex, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 初始化 mutex 为 1</span></span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    sem_destroy(&amp;empty);</span><br><span class="line">    sem_destroy(&amp;full);</span><br><span class="line">    sem_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个生产者-消费者问题的解决方案，使用了信号量来实现线程之间的同步和互斥。其中，sem_init() 用于初始化信号量，sem_wait() 用于等待信号量的值变为非零，sem_post() 用于增加信号量的值。在生产者线程中，当缓冲区非满时，生产者将一个项目放入缓冲区，并增加缓冲区中的项目数；在消费者线程中，当缓冲区非空时，消费者从缓冲区中取出一个项目，并增加缓冲区中的空闲位置数。同时，为了保证线程之间的互斥访问，使用了一个互斥信号量 mutex。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-互斥锁"><a href="#2-4-2-互斥锁" class="headerlink" title="2.4.2 互斥锁"></a>2.4.2 互斥锁</h4><ul>
<li>创建互斥锁pthread_mutex_init</li>
</ul>
<p>设函数中有pthread_mutex_t mutex;</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);</span><br><span class="line"></span><br><span class="line">功能：pthread_mutex_init() 函数用于初始化一个互斥锁</span><br><span class="line">头文件：#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">若调用成功则返回 0，否则返回一个非零错误码。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">        mutex：指向要初始化的互斥锁的指针。</span><br><span class="line">        attr：指向 pthread_mutexattr_t 类型的互斥锁属性对象的指针。如果该参数为 NULL，则使用默认属性。</span><br></pre></td></tr></table></figure>

<ul>
<li>请求互斥锁pthread_mutex_lock</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">int pthread_mutex_lock(pthread_mutex_t *mutex);</span><br><span class="line"></span><br><span class="line">功能：pthread_mutex_lock() 函数用于请求锁，如果当前锁已被其他线程持有，则调用线程将会阻塞等待，直到锁被释放。</span><br><span class="line"></span><br><span class="line">头文件：#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">若调用成功则返回 0，否则返回一个非零错误码。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">        mutex：指向要请求的互斥锁的指针。</span><br></pre></td></tr></table></figure>

<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex); <span class="comment">// 请求锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread is running with the mutex locked.\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 模拟线程执行任务</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex); <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread has released the mutex.\n&quot;</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>); <span class="comment">// 初始化互斥锁</span></span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex); <span class="comment">// 请求锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread is running with the mutex locked.\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 模拟线程执行任务</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex); <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main thread has released the mutex.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex); <span class="comment">// 销毁互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>进程线程</tag>
      </tags>
  </entry>
</search>
