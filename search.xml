<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言基础-存储类别</title>
    <url>/2020/05/09/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB/</url>
    <content><![CDATA[<h1 id="存储类别"><a href="#存储类别" class="headerlink" title="存储类别"></a><font color="green">存储类别</font></h1><p>在理解存储类别前，先要复习一些概念和术语。</p>
<ul>
<li>对象：对于储存在内存中的数据，被储存的每个值都占用一定的物理内存。这样的一块内存成为对象(和面向对象的对象概念不同)</li>
<li>存储期：对象在内存中保留了多长的时间。</li>
<li>标识符用于访问对象，可以用<strong>作用域</strong>和<strong>链接</strong>描述标识符，表明了程序的哪些部分可以使用它。</li>
</ul>
<p>我们先介绍`作用域、链接和储存期的含义，再介绍具体的存储类别</p>
<a id="more"></a>

<h2 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h2><p>作用域描述程序中可访问标识符的区域。<br>一个C变量的作用域可以是:</p>
<ul>
<li>块作用域：花括号内的代码，if语句或循环所控制的代码</li>
<li>函数作用域：仅用于goto语句的标签。再块中定义但作用域是整个函数</li>
<li>函数原型作用域：从形参定义处到原型声明结束</li>
<li>文件作用域：定义在函数外面，从它的定义到该定义所在的文件的末尾均可见</li>
</ul>
<blockquote>
<p>注意：当一个源代码中包含一个或多个头文件时，会把所有头文件和编译器源代码文件都看成是一个包含信息的单独文件，文件作用域的实际可见范围是整个翻译单元</p>
</blockquote>
<h2 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h2><p>链接指该变量访问范围<br>C变量有3种链接属性：<strong>外部链接，内部链接或无链接</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;具有块作用域、函数作用域和函数原型作用域的变量都是无链接变量<br>&nbsp;&nbsp;&nbsp;&nbsp;文件作用域的变量可以是外部链接和内部链接，<br>&nbsp;&nbsp;&nbsp;&nbsp;内部链接变量比外部链接变量前面多了个static ，内部链接变量只能在翻译单元中使用，外部链接变量可以在多文件程序中使用</p>
<h2 id="3-存储期"><a href="#3-存储期" class="headerlink" title="3.存储期"></a>3.存储期</h2><p>作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。<br>C对象有4种存储期：</p>
<ol>
<li>静态存储期：关键字static，如果对象具有静态储存期，那么它在程序的执行期间一直存在   <font color="red">注意：文件作用域变量都具有静态存储期，但它的static表示的是其链接属性</font></li>
<li>线程存储期: _Thread_local</li>
<li>自动存储期: 通常是块作用域的变量所具有</li>
<li>动态分配存储期： 从声明处到块末尾而不是块头到末尾</li>
</ol>
<h2 id="5种存储类别"><a href="#5种存储类别" class="headerlink" title="5种存储类别"></a>5种存储类别</h2><table>
<thead>
<tr>
<th>存储类别</th>
<th>存储期</th>
<th>作用域</th>
<th>链接</th>
<th>声明方式</th>
</tr>
</thead>
<tbody><tr>
<td>自动(局部变量)</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内</td>
</tr>
<tr>
<td>寄存器</td>
<td>自动</td>
<td>块</td>
<td>无</td>
<td>块内，使用关键字<code>register</code></td>
</tr>
<tr>
<td>静态外部链接(全局变量)</td>
<td>静态</td>
<td>文件</td>
<td>外部</td>
<td>所有函数外</td>
</tr>
<tr>
<td>静态内部链接(static全局变量)</td>
<td>静态</td>
<td>文件</td>
<td>内部</td>
<td>所有函数外，翻译单元中，使用关键字<code>static</code></td>
</tr>
<tr>
<td>静态无链接(静态局部变量)</td>
<td>静态</td>
<td>块</td>
<td>无</td>
<td>块内，使用关键字<code>static</code></td>
</tr>
</tbody></table>
<ul>
<li>如果内层块种声明的变量和外层块的变量同名时，优先内层块的变量</li>
<li>寄存器变量储存在寄存器中，所以无法获取其地址</li>
<li>局部静态变量在程序的执行时间一直存在但只能在块内部使用，其值有继承性（就像Java里面的成员变量）</li>
<li>要在外部使用全局变量或在块中使用全局变量或static全局变量。也必须先声明，而且声明前面要加关键字extern</li>
<li>局部变量和静态局部变量在本文件中只能在声明后使用</li>
</ul>
<h3 id="存储类别的初始化"><a href="#存储类别的初始化" class="headerlink" title="存储类别的初始化"></a>存储类别的初始化</h3><ul>
<li>局部变量不会初始化，但其变量值是分配空间范围中的任意值</li>
<li>静态变量如未人为初始化，则自动初始化为0</li>
</ul>
<h3 id="存储类别说明符"><a href="#存储类别说明符" class="headerlink" title="存储类别说明符"></a>存储类别说明符</h3><ul>
<li>auto:声明局部变量，可忽略</li>
<li>register:声明寄存器变量</li>
<li>static:声明静态类型</li>
<li>extern:  声明时调用（全局/static全局） 变量</li>
<li>_Thread_local：声明线程存储期，可以和 static或extern一起使用</li>
</ul>
<hr>
<br>

<h2 id="存储类别与函数"><a href="#存储类别与函数" class="headerlink" title="存储类别与函数"></a>存储类别与函数</h2><p>函数也有存储类别。</p>
<ul>
<li>外部函数<blockquote>
<p>double a(int i)</p>
</blockquote>
</li>
<li>静态函数<blockquote>
<p>static double a(int i)</p>
</blockquote>
</li>
<li>内联函数<blockquote>
<p>extern double a(int i)</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>c</tag>
        <tag>基础</tag>
        <tag>存储类别</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础-递归</title>
    <url>/2020/04/28/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><font color="#7CFC00">基本概念</font></h1><p>C 语言允许函数调用它自己，这种调用的过程称为递归</p>
<a id="more"></a>

<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><blockquote>
<p>栈：一种数据结构，其特点为先进后出</p>
<blockquote>
<p>C 语言在执行代码时会从 main()开始依次将调用的函数放入栈中<br>放完后便将栈中的方法，从栈顶一个个取出并执行</p>
</blockquote>
</blockquote>
<p>如图( 计算 3! )：</p>
<p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/diguis.jpg" alt="递归原理图"></p>
<p>解释：</p>
<ol>
<li>开始执行，先将<code>main( )</code>函数放入栈底并执行</li>
<li>遇到了<code>fun(3)</code>后把 <code>mian( )</code>函数暂时放在栈中，去调用<code>fun(3)</code>函数</li>
<li>执行<code>fun(3)</code>时又发现调用了<code>fun(2)</code>，又把<code>fun(2)</code>放入栈中去掉<code>fun(1)</code></li>
<li><code>fun(1)</code>时发现没有调用了( 此时<code>fun(1)</code>在栈顶 )，便开始返回，把返回值给了<code>fun(2)</code>，<code>fun(2)</code>也继续下面的语句，返回给了<code>fun(3)</code></li>
<li>最后<code>fun(3)</code>返回给<code>main( )</code>，<code>main( )</code>继续执行下面的语句</li>
</ol>
<p>由此可以看成递归的形成至少需要两个条件：</p>
<ol>
<li>变化的参数</li>
<li>递归终止条件</li>
</ol>
<blockquote>
<p>栈溢出：内存空间是有限的，分配给 C 程序的栈空间也是有限的，如果递归没有结束条件的话就会导致无限的调用，形成栈溢出</p>
</blockquote>
<hr>
<br>
<br>

<h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a><font color="#7CFC00">尾递归</font></h1><p>最简单的递归形式就是把递归调用置于函数的末尾，即正好在 <code>return</code> 语句之前。这种形式的递归被称为 <u>尾递归</u> (如上图所示)，它相当于循环。</p>
<p><strong>如果效果和循环差不多时最好使用循环</strong></p>
<hr>
<br>
<br>

<h1 id="递归的优缺点"><a href="#递归的优缺点" class="headerlink" title="递归的优缺点"></a><font color="#7CFC00">递归的优缺点</font></h1><p>递归的语法易被人理解，但空间成本消耗太大。所以在使用递归时要特别注意，尤其是<font color="red">效率优先</font>的程序</p>
<br>

<blockquote>
<p>注：main( )函数可以调用自己，且两函数间不可以相互调用</p>
</blockquote>
<hr>
<br>
<br>

<h1 id="递归算法实战-汉诺塔问题"><a href="#递归算法实战-汉诺塔问题" class="headerlink" title="递归算法实战-汉诺塔问题"></a><font color="#7CFC00">递归算法实战-汉诺塔问题</font></h1><h2 id="问题叙述"><a href="#问题叙述" class="headerlink" title="问题叙述"></a>问题叙述</h2><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p>
<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>
<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1159565693,4014945639&fm=26&gp=0.jpg" alt="汉诺塔"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们倒着的开始，假如要移动 64 个</p>
<ol>
<li>我们要把上面的 63 个移动到 B</li>
<li>把第 64 个移动到 C</li>
<li>把 B 上的 63 个移动到 C</li>
</ol>
<p>那么就会产生问题了：怎么移动那 63 个呢<br>和上面的思路一样</p>
<ol>
<li>我们要把上面的 62 个移动到 B</li>
<li>把第 63 个移动到 C</li>
<li>把 B 上的 62 个移动到 C</li>
</ol>
<p>直到问题变为：怎么移动上面的那 1 个呢，这时我们就会了，移动了 1 个后，我们就会移动 2 个，移动 2 个后，我们就会第 3 个，依次下去，就能把 64 个都移动完了</p>
<p>所以整个过程是</p>
<ol>
<li>我们要把上面的<code>n-1</code>个移动到 B</li>
<li>把第<code>n</code>个移动到 C</li>
<li>把 B 上的<code>n-1</code>个移动到 C</li>
</ol>
<blockquote>
<p>其中移动 n-1 个盘子的操作是递归操作<br>1，3 步分别用了递归</p>
</blockquote>
<p>下面是 java 语言代码实现部分( <del>用 C 表达出来的效果不好啊，还是 java 的看着舒服</del> ，其实基本都是一样的):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        move(A.size(),A,B,C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从这开始看</span></span><br><span class="line">    <span class="comment">//盘子用数字代替，n代表需要移动的盘子数，List是盘子的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n,List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当需要移动的盘子数只有1个时，此时这个盘子就是最下面的，其它的都移动到B上(第一步)或者A(第三步)上了了</span></span><br><span class="line">        <span class="comment">// 把A的盘子直接移动到C就行了</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            C.add(A.remove(A.size()-<span class="number">1</span>)); <span class="comment">//注意这里是最下面的盘子数最大</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没到最上面时，则一直重复123步骤</span></span><br><span class="line">        move(n-<span class="number">1</span>,A,C,B); <span class="comment">//对应第一步</span></span><br><span class="line">        C.add(A.remove(A.size()-<span class="number">1</span>));  <span class="comment">//对应第二步</span></span><br><span class="line">        move(n-<span class="number">1</span>,B,A,C);  <span class="comment">//对应第三步</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<br>
<br>

<h1 id="递归总结"><a href="#递归总结" class="headerlink" title="递归总结"></a><font color="#7CFC00">递归总结</font></h1><p>要运用递归的地方都有以下的共同点</p>
<ol>
<li>拥有大量重复的步骤，或者说可将复杂的步骤转换为计算大但容易理解的重复步骤</li>
<li>拥有当达到某种条件时，可返回一个确定值，即遇见某种情况时可向前推导</li>
</ol>
<p>这样便可以将代表条件的变量设为函数参数，把步骤设为函数具体代码</p>
<hr>
<br>
<br>

<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a><font color="#7CFC00">推荐阅读</font></h1><p>知乎-<a href="https://www.zhihu.com/question/24385418">如何理解汉诺塔的递推</a><br><a href="https://leetcode-cn.com/explore/featured/card/recursion-i/">leetcode-递推</a>(有点难度)</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>c</tag>
        <tag>递归</tag>
        <tag>C语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown笔记-基础</title>
    <url>/2020/04/26/Markdown%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Markdown-概述"><a href="#Markdown-概述" class="headerlink" title="Markdown 概述"></a>Markdown 概述</h1><p>Markdown 是一种轻量级标记语言，与 2004 年创建。<br>后缀为<code>.md</code>或<code>.maekdown</code>，可导出 HTML，Word，pdf 等多种格式文档</p>
<a id="more"></a>

<hr>
<br>

<h1 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h1><h2 id="1-使用-和-标记一级和二级标题"><a href="#1-使用-和-标记一级和二级标题" class="headerlink" title="1.使用=和-标记一级和二级标题"></a>1.使用=和-标记一级和二级标题</h2><blockquote>
<p>这是一级标题<br>==========<br>这是二级标题<br>-—————–</p>
</blockquote>
<h2 id="2-使用-号标记标题"><a href="#2-使用-号标记标题" class="headerlink" title="2.使用#号标记标题"></a>2.使用#号标记标题</h2><blockquote>
<p># 一级标题<br>## 二级标题<br>### 三级标题<br>…<br>###### 六级标题</p>
</blockquote>
<p><strong>注：#后要加空格</strong></p>
<hr>
<br>
<br>

<h1 id="Markdown-段落与字体格式"><a href="#Markdown-段落与字体格式" class="headerlink" title="Markdown 段落与字体格式"></a>Markdown 段落与字体格式</h1><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>1.在段落末尾使用两个以上空格加回车为换行</p>
<p>2.在段落与段落之间留出一个空行为换段落</p>
<h2 id="字体格式"><a href="#字体格式" class="headerlink" title="字体格式"></a>字体格式</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><blockquote>
<p>*斜体文本* &gt; _斜体文本_ &gt; **粗体文本** &gt;__粗体文本__ &gt; ***粗斜体文本*** &gt;___粗斜体文本___</p>
</blockquote>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>&nbsp; 在一行内用三个以上的星号，减号，下划线，在建立一个分割线<br>&nbsp; 注意：行内不能有其他东西</p>
<blockquote>
<p>***<br> -–<br>_ _ _<br>-———–</p>
</blockquote>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a><del>删除线</del></h3><p>&nbsp; 如果要在文字上添加删除线，则在文字两端加上两个波浪线~~</p>
<blockquote>
<p>~~要删除线的文字~~</p>
</blockquote>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>&nbsp; <u>下划线</u>可以通过 HTML 的<code>&lt;u&gt;</code>标签来实现</p>
<blockquote>
<p>&lt;u&gt;带下划线的文本&lt;/u&gt;</p>
</blockquote>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>&nbsp; 在需要脚注<a href="%E6%97%A0%E8%AE%BA%E5%86%99%E4%BB%80%E4%B9%88%E8%84%9A%E6%B3%A8%E5%90%8D%EF%BC%8C%E6%9C%80%E5%90%8E%E9%83%BD%E4%BC%9A%E5%8F%98%E6%88%90%E6%95%B0%E5%AD%97%E6%8E%92%E5%88%97%E6%96%B9%E5%BC%8F">^像这样</a>的文字后写[^脚注名]，并在后面的某个地方用[^要注明的文本]: 内容 来使用脚注。<u>且无论写什么脚注名，最后都会变成数字排列方式</u></p>
<blockquote>
<p>[^脚注名]</p>
<p>[^脚注名]: 脚注内容</p>
</blockquote>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;将选中的文字用灰色背景加重（<code>像这样</code>）,就在文字的两旁加`</p>
<blockquote>
<p>`文字`</p>
</blockquote>
<h3 id="特殊符号失效"><a href="#特殊符号失效" class="headerlink" title="特殊符号失效"></a>特殊符号失效</h3><p>&nbsp; 如果想让特殊符号失效，即打出原有符号样子(如#),则在特殊符号前加反切线\</p>
<blockquote>
<p>\<br> \&lt;\u&gt;…&lt;/u&gt;</p>
</blockquote>
<hr>
<br>
<br>

<h1 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h1><p>&nbsp; Markdown 支持有序列表和无序列表（在标记后面要有空格）</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记</p>
<blockquote>
<p>* 第一项<br>* 第二项<br>* 第三项</p>
<p>+ 第一项<br>+ 第二项<br>+ 第三项</p>
<p>- 第一项<br>- 第二项<br>- 第三项</p>
</blockquote>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<br>

<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表使用数字加上<code>.</code>号来表示，如：</p>
<blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
</blockquote>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<hr>
<br>
<br>

<h1 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h1><p>Markdown 区块引用时在段落开头使用&gt;号，后面要跟个空格符号</p>
<blockquote>
<p>&gt;区块内文字,效果就是这像一行一样出现阴影</p>
<blockquote>
<p>打多个&gt;还可以还可以内嵌(如这行的&gt;&gt;)</p>
</blockquote>
</blockquote>
<ol>
<li>区块中使用列表的话，就在&gt;后面用列表语法就行<blockquote>
<p>&gt; 1. 第一项<br>&gt; 2. 第二项<br>&gt; 3. 第三项</p>
<p>&gt; + 第一项<br>&gt; + 第二项<br>&gt; + 第三项</p>
</blockquote>
</li>
</ol>
<br>

<ol start="2">
<li>列表中使用区块，则要在&gt;前添加四个空格的缩进</li>
</ol>
<blockquote>
<p>* 第一项<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;区块内容<br>* 第二项</p>
</blockquote>
<p>效果如下：</p>
<ul>
<li>第一项<blockquote>
<p>区块内容</p>
</blockquote>
</li>
<li>第二项</li>
</ul>
<hr>
<br>
<br>

<h1 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h1><ul>
<li>如果是段落上的一个函数或片段的代码可以用反引号(`)将内容包起来</li>
</ul>
<blockquote>
<p>`printf()`函数</p>
</blockquote>
<p><code>printf()</code>函数<br><br></p>
<ul>
<li>如果是代码区块，则使用 4 个空格或者一个制表符(Tab 键)</li>
</ul>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 代码内容</p>
</blockquote>
<pre><code>public static void main(String[] args)&#123;
    System.out.println(&quot;hello,world&quot;)
&#125;</code></pre>
<br>

<ul>
<li>也可以用 ``` …. ``` 来包裹一段代码，还可以在```后面指定一种语言</li>
</ul>
<blockquote>
<p>```java<br>public static void main(String[] args){<br>System.out.println(“hello,world”)<br>}<br>```</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<br>
<br>

<h1 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h1><ul>
<li>普通方式</li>
</ul>
<blockquote>
<p>[链接名称](链接地址)<br>或者&lt;链接地址&gt;</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/3b638180e42c">技术文档书写规范</a></p>
<p><a href="https://www.jianshu.com/p/3b638180e42c">https://www.jianshu.com/p/3b638180e42c</a><br><br></p>
<ul>
<li>高级链接<br>如果链接太长时，可在[连接名称]后面设置一个[标签名],则可在后面的任意位置写[标签名]: 链接<br><strong>注意：<code>[标签名]:</code> 冒号前面以及两个中括号之间[][]不要留空格</strong></li>
</ul>
<blockquote>
<p>[技术文档书写规范][1]<br>[csdn 官网][csdn]</p>
<p>[1]: <a href="https://www.jianshu.com/p/3b638180e42c">https://www.jianshu.com/p/3b638180e42c</a> &gt;[csdn]: <a href="https://www.csdn.net/">https://www.csdn.net/</a></p>
</blockquote>
<p><a href="https://www.jianshu.com/p/3b638180e42c">技术文档书写规范</a><br><a href="https://www.csdn.net/">csdn 官网</a></p>
<hr>
<br>
<br>

<h1 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><blockquote>
<p>![alt 属性文本](图片地址)</p>
<p>![alt 属性文本](图片地址 “title 属性文本”)</p>
</blockquote>
<p>alt 为图片加载出错时的代替文本<br>title 为鼠标放在图片上时所显示的文字</p>
<h2 id="图片地址的传入方法"><a href="#图片地址的传入方法" class="headerlink" title="图片地址的传入方法"></a>图片地址的传入方法</h2><ol>
<li>通过图床将图上传到网上后使用图片的链接<blockquote>
<p>![图片加载出错](<a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg">https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http%3A%2F%2Fgss0.baidu.com%2F-4o3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2F810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg</a> “这是 title 属性”)</p>
</blockquote>
</li>
</ol>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1587895752391&di=e2f0ba8e2108ab4f04b19700233f121f&imgtype=0&src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg" alt="图片加载出错" title="这是title属性"><br><br></p>
<ol start="2">
<li>将图片存入本地，通过 <a href="https://blog.csdn.net/chudelong1/article/details/90697409">绝对路径/相对路径</a> 来加载图片(相对路径是以当前的 md 文件所在目录为起点)</li>
</ol>
<blockquote>
<p>![图片出不来了](.\mdphoto\markdownlearn\0.jpg)</p>
</blockquote>
<p><img src="/2020/04/26/Markdown%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/0.jpg" alt="图片出不来了"></p>
<p>当然，当地址过长时也可以像链接那样将(…)变成变量名</p>
<blockquote>
<p>![图片加载出错][photo 1]</p>
<p>[photo 1]: <a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg">https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587895752391&amp;di=e2f0ba8e2108ab4f04b19700233f121f&amp;imgtype=0&amp;src=http%3A%2F%2Fgss0.baidu.com%2F-4o3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2F810a19d8bc3eb13537a41c57aa1ea8d3fc1f44fe.jpg</a></p>
</blockquote>
<p><strong><u>注意：如果是想将本地连接的图片通过 hexo 传到远端时，直接使用是无效的,要实现下列步骤</u></strong></p>
<ol>
<li>配置 hexo 根下的<code>_config.yml</code>里面的<code>post_asset_folder:false</code>这个选项设置为<code>true</code>。</li>
<li>git bash 安装插件：<code>npm install https://github.com/7ym0n/hexo-asset-image --save</code> , 安装之后再生成新 md 文件时同目录下会出现同名的文件夹，图片可放进那里</li>
<li>这时再使用上面的语法便能成功</li>
</ol>
<hr>
<br>
<br>

<h1 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h1><p>&nbsp; Markdown 中制作表格用<code>|</code>来分割不同的单元格，用<code>-</code>在分割表头和其它行</p>
<blockquote>
<p>|表头 1|表头 2|表头 3|<br>| :&nbsp;—&nbsp;&nbsp; &nbsp;|:&nbsp;&nbsp; —&nbsp;&nbsp;: |&nbsp;&nbsp;&nbsp;—&nbsp;&nbsp;: |<br>|左对齐|中对齐|右对齐|<br>|左对齐效果|中对齐效果|右对齐效果|</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">表头 1</th>
<th align="center">表头 2</th>
<th align="right">表头 3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">左对齐</td>
<td align="center">中对齐</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td align="left">左对齐效果</td>
<td align="center">中对齐效果</td>
<td align="right">右对齐效果</td>
</tr>
</tbody></table>
<br>
<br>

<p>还能设置表格的对齐方式(默认向左对齐)：</p>
<ul>
<li><strong><code>-:</code></strong> 设置内容和标题栏右对齐</li>
<li><strong><code>:-:</code></strong> 设置内容和标题栏中对齐</li>
<li><strong><code>:-</code></strong> 设置内容和标题栏左对齐</li>
</ul>
<p><strong>注：最右边的<code>|</code>可以省略</strong></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Markdown基础</tag>
      </tags>
  </entry>
  <entry>
    <title>day12-c指针</title>
    <url>/2023/03/08/day12-c%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="day12-c指针"><a href="#day12-c指针" class="headerlink" title="day12-c指针"></a><font color="green">day12-c指针</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、指针变量的赋值"><a href="#1、指针变量的赋值" class="headerlink" title="1、指针变量的赋值"></a>1、指针变量的赋值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> *q = p;   <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">char</span> *m = <span class="literal">NULL</span>; <span class="comment">//空指针 3</span></span><br><span class="line"><span class="keyword">int</span> *n = b; <span class="comment">// n == &amp;b[0] //4</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>


<h3 id="2、指针变量的运算"><a href="#2、指针变量的运算" class="headerlink" title="2、指针变量的运算"></a>2、指针变量的运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p+n --&gt; 向高地址位偏移n个元素的字节数</span><br><span class="line">p-n --&gt; 向低地址位偏移n个元素的字节数</span><br><span class="line">    </span><br><span class="line">指针-指针：计算两个相同类型的指针之间相差的元素个数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、指针和一维数组"><a href="#3、指针和一维数组" class="headerlink" title="3、指针和一维数组"></a>3、指针和一维数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line">*p == a[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4、指针和二维数组"><a href="#4、指针和二维数组" class="headerlink" title="4、指针和二维数组"></a>4、指针和二维数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">二维数组的数组名也表示整个二维数组的首地址。但是是一个行地址</span><br><span class="line"></span><br><span class="line">    数组指针定义的一般形式：</span><br><span class="line">    	&lt;存储类型&gt; &lt;数据类型&gt; (*数组指针名)[列数];</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	a == &amp;a[<span class="number">0</span>] </span><br><span class="line">	a+<span class="number">1</span> == &amp;a[<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line">	*(*(p+<span class="number">1</span>)+<span class="number">1</span>) --&gt; 二维数组中第二行第二个元素</span><br></pre></td></tr></table></figure>

<hr>
<br>
<br>

<h2 id="二、指针"><a href="#二、指针" class="headerlink" title="二、指针"></a>二、指针</h2><h3 id="1、指针数组"><a href="#1、指针数组" class="headerlink" title="1、指针数组"></a>1、指针数组</h3><p>​        数组指针(行指针)：本质是指针，存放地址值，指向的内容是一个一维数组的地址</p>
<p>​        指针数组：本质是数组。如果一个数组中所有元素都是地址，那么该数组称为指针数组</p>
<h3 id="2、指针数组的定义"><a href="#2、指针数组的定义" class="headerlink" title="2、指针数组的定义"></a>2、指针数组的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; *数组名[元素个数];</span><br><span class="line">	例：</span><br><span class="line">    	<span class="keyword">int</span> a, b, c;</span><br><span class="line">		<span class="keyword">int</span> *addr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;</span><br><span class="line">		addr[<span class="number">0</span>] == &amp;a;</span><br><span class="line">		addr[<span class="number">1</span>] == &amp;b;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、多级指针–二级指针-难点"><a href="#3、多级指针–二级指针-难点" class="headerlink" title="3、多级指针–二级指针(难点)"></a>3、多级指针–二级指针(<strong>难点</strong>)</h3><p>​    定义一个指针变量，有几个星号就是几级指针</p>
<p>​    二级指针的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; **指针变量名;</span><br><span class="line">例：</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">	<span class="keyword">int</span> **q = &amp;p;</span><br><span class="line">	</span><br><span class="line">	*q == p == &amp;a</span><br><span class="line">	**q == *p == *&amp;a == a == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><font color="red"><strong>注意</strong>：</font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line"><span class="keyword">int</span> *q[<span class="number">2</span>] = &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;;</span><br><span class="line"></span><br><span class="line">p:数组指针名，p+<span class="number">1</span>偏移一行数据大小</span><br><span class="line">q:指针数组名，q+<span class="number">1</span>偏移一个指针大小</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **x = p; <span class="comment">//error****</span></span><br><span class="line"><span class="keyword">int</span> **x = q;  <span class="comment">//right</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4、const指针"><a href="#4、const指针" class="headerlink" title="4、const指针"></a>4、const指针</h3><p>​    const修饰的变量为只读属性，不能直接修改该变量的值</p>
<p>​    const指针</p>
<p>​    (1)const 数据类型 *指针变量名;</p>
<p>​         数据类型 const *指针变量名;    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//right</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error  *p被修饰为只读</span></span><br></pre></td></tr></table></figure>

<p>​        const修饰是指针指向的内容，不能修改指针指向的数据，但是可以修改指针变量中的地址值</p>
<p>​    </p>
<p>​    (2)数据类型 *  const  指针变量名；   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error p被修饰为只读</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//right</span></span><br></pre></td></tr></table></figure>

<p>​    const修饰的指针变量p，不能修改指针变量的值，但是可以修改指针指向内容的值</p>
<p>（3）const 数据类型 *  const  指针变量名；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error p被修饰为只读</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error *p被修饰为只读</span></span><br></pre></td></tr></table></figure>

<p>​    const同时修饰指针变量和指针指向内容，两者都不能修改</p>
<h3 id="5、void指针"><a href="#5、void指针" class="headerlink" title="5、void指针"></a>5、void指针</h3><p>​        void – 空类型，不确定类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br><span class="line">指针p中可以存放任意类型的地址值</span><br><span class="line">*p = <span class="number">2</span>;  <span class="comment">//error  void指针在使用之前需要将void类型指针强制转换为需要的类型</span></span><br><span class="line">*(<span class="keyword">int</span> *)p = <span class="number">2</span>; <span class="comment">//right</span></span><br></pre></td></tr></table></figure>



<h3 id="6、字符指针和字符串"><a href="#6、字符指针和字符串" class="headerlink" title="6、字符指针和字符串"></a>6、字符指针和字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">50</span>] = &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">&quot;hello&quot;</span>; <span class="comment">//right</span></span><br><span class="line">如果将一个字符串赋值给一个字符指针，相当于把该字符串的首地址赋值给字符指针变量</span><br><span class="line"></span><br><span class="line">注意：如果将一个字符串常量赋值给一个指针变量，那么通过该指针不能修改字符串每一个字符的值</span><br></pre></td></tr></table></figure>


<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>若有以下定义，且0≤i＜4，则不正确的赋值语句是<u>&emsp;B&emsp;</u>.<br>int b[4][6], *p, *q[4];<br>（A）q[i] = b[i];           （B） p = b;<br>（C）p = b[i]               （D） q[i] = &amp;b[0][0];</p>
<p>解：表示b的话要用二次指针来表示二维数组的地址。这样的话*p仅代表所对应的行地址</p>
<p>​    </p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c语言</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>day11-c数组与指针</title>
    <url>/2023/03/08/day11-c%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="day11-c数组与指针"><a href="#day11-c数组与指针" class="headerlink" title="day11-c数组与指针"></a><font color="green">day11-c数组与指针</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><p>​    字符数组和字符串</p>
<p>​        字符数组：存放的数据是字符数据</p>
<p>​        字符串：由一个或者多个字符组成，在字符串的末尾有一个隐藏的空字符 – ‘\0’</p>
<p>​        char a[50] = “hello”;    </p>
<a id="more"></a>

<h3 id="2-字符串函数："><a href="#2-字符串函数：" class="headerlink" title="2.字符串函数："></a>2.字符串函数：</h3><blockquote>
<p>字符串长度函数 – strlen()<br>字符串连接函数– strcat()<br>字符串拷贝函数 – strcpy()<br>字符串比较函数– strcmp()</p>
</blockquote>
<p><strong>注：<code>int a[10]=&#123;0&#125;</code>相当于把数组a中的所有元素给赋值成’\0’，但是<font color="red">int a[arr]={0}</font>则错误，因为在数组长度为变量时不能同时进行赋值</strong><br><strong>同时也不能把字符串常量赋值给一个字符数组，因为字符数组本身也是个常量 <font color="red">char s[10];s=”abcdefg”</font>是错误的。</strong></p>
<br>
<br>

<hr>
<h2 id="二、指针"><a href="#二、指针" class="headerlink" title="二、指针"></a>二、指针</h2><h3 id="1、指针相关运算符"><a href="#1、指针相关运算符" class="headerlink" title="1、指针相关运算符"></a>1、指针相关运算符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&amp;:获取内容的地址</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">	&amp;a --&gt; 获取到a的地址</span><br><span class="line">    </span><br><span class="line">*：获取地址中的内容</span><br><span class="line">    *(&amp;a) == a == <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、指针变量"><a href="#2、指针变量" class="headerlink" title="2、指针变量"></a>2、指针变量</h3><p>​    指针变量就是用于存放地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; *指针变量名;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">//将a的地址存放在了一个名为p的指针变量中</span></span><br><span class="line">p == &amp;a;</span><br><span class="line">*p = *(&amp;a) == a == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="3、指针变量的赋值"><a href="#3、指针变量的赋值" class="headerlink" title="3、指针变量的赋值"></a>3、指针变量的赋值</h3><p>赋值运算符的左值和右值类型一定要相同</p>
<p>(1)将一个变量的地址赋值给一个具有相同数据类型的指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>(2)将一个已有的指针赋值给一个 具有相同数据类型的指针变量</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> *q = p;</span><br><span class="line"></span><br><span class="line">q == p == &amp;a;</span><br></pre></td></tr></table></figure>

<p>(3)将0值赋值给一个指针变量 – 空指针</p>
<p>野指针：定义一个指针，没有明确指向，不能访问野指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>(4)将一个数组的数组名赋值给一个具有相同数据类型的指针变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a; <span class="comment">// a == &amp;a[0]</span></span><br></pre></td></tr></table></figure>

<p>(5)把一个复合形式的表达式的值赋给一个具有相同数据类型的指针变量</p>
<h3 id="4、指针的运算"><a href="#4、指针的运算" class="headerlink" title="4、指针的运算"></a>4、指针的运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;  <span class="comment">// &amp;a == 0x2000</span></span><br><span class="line">p+n --&gt; p向高地址位偏移n个元素大小的字节数  <span class="comment">//元素指，该指针指向的内容</span></span><br><span class="line">p-n --&gt; p向低地址位偏移n个元素大小的字节数</span><br><span class="line"></span><br><span class="line">p+n == p+n*<span class="keyword">sizeof</span>(元素类型)  <span class="comment">//在该例中元素类型为int</span></span><br><span class="line">    </span><br><span class="line">注意：指针运算中没有 指针 + 指针、指针 * 指针、 指针 / 指针，因为没有任何实际意义 </span><br><span class="line">    但是有指针 - 指针</span><br><span class="line">    </span><br><span class="line">    指针-指针表示相同类型的两个指针之间相差多少个元素,结果的正负，仅代表地址高低</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">	<span class="keyword">int</span> *q = &amp;b;</span><br><span class="line">	q - p ==  (q-p)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="5、指针和一维数组"><a href="#5、指针和一维数组" class="headerlink" title="5、指针和一维数组"></a>5、指针和一维数组</h3><p>将一个一维数组的数组名赋值给一个具有相同数据类型的指针变量, 我们就可以通过该指针访问数组中所有元素</p>
<blockquote>
<p><strong>注：数组名不能递增递减</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line">*p == a[<span class="number">0</span>];</span><br><span class="line">*(p+<span class="number">1</span>) == a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p++; <span class="comment">// p = p+1; right</span></span><br><span class="line">a++; <span class="comment">// a = a+1; error  数组名不能递增递减</span></span><br><span class="line"></span><br><span class="line">数组a中的第三个元素的表达方式:</span><br><span class="line">	a[<span class="number">2</span>]、 *(p+<span class="number">2</span>)、 *(&amp;a[<span class="number">2</span>])、p[<span class="number">2</span>]、 *(a+<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h3 id="6、指针和二维数组-–-行指针（数组指针）"><a href="#6、指针和二维数组-–-行指针（数组指针）" class="headerlink" title="6、指针和二维数组 – 行指针（数组指针）"></a>6、指针和二维数组 – 行指针（数组指针）</h3><p>​    本质：数组指针是一个指针，存放的内容是地址，指针指向的内容是一个一维数组</p>
<p>​    二维数组的数组名是一个行指针，指向二维数组的首地址，行指针+n相当于地址偏移n行元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//行指针的定义一般形式</span></span><br><span class="line">&lt;存储类型&gt; &lt;数据类型&gt; (*指针变量名)[列数];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line"></span><br><span class="line">*(*(p+<span class="number">1</span>)+<span class="number">2</span>) == 第二行第三个元素</span><br><span class="line">*(*(p+<span class="number">0</span>)+<span class="number">1</span>) == 第一行第二个元素</span><br></pre></td></tr></table></figure>

<br>
<br>

<hr>
<h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">258</span>;                                                      </span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)&amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(++p));</span><br><span class="line">  &#125;</span><br><span class="line">  ````</span><br><span class="line">程序运行结果是  &lt;u&gt;2,1&lt;/u&gt;  </span><br><span class="line"></span><br><span class="line">解：<span class="number">258</span>的<span class="number">16</span>进制为<span class="number">102</span>，按照<span class="keyword">int</span>的存储方式为 <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span>，p指针先到<span class="number">02</span>，因为转移到<span class="keyword">char</span>后+<span class="number">1</span>为前进一个字符，则p指针跳到了<span class="number">01.</span>  </span><br><span class="line"></span><br><span class="line">### <span class="number">2.</span> </span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *arr[<span class="number">3</span>]=&#123;a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>]&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<p>程序运行结果是  <u>8</u></p>
<p>解：arr数组里的都是指针，sizeof指向第一个元素即指针，所以大小为8，不是a[0][3]中的12.</p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>&emsp;若有以下说明和语句，int c[4][5],(*p)[5];p=c;能正确引用c数组元素的是<u> D</u>.<br>(A) p+1      (B) *(p+3)     　(C) *(p+1)+3   (D) *(p[0]+2) </p>
<p>解：b错误原因是p+3仅代表地址，加个*只能表示p[3].</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>c</tag>
        <tag>指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>day13-c指针，函数</title>
    <url>/2023/03/08/day13-c%E6%8C%87%E9%92%88%EF%BC%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="day13-c指针，函数"><a href="#day13-c指针，函数" class="headerlink" title="day13-c指针，函数"></a><font color="green">day13-c指针，函数</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、指针数组"><a href="#1、指针数组" class="headerlink" title="1、指针数组"></a>1、指针数组</h3><p>​    本质：数组</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;存储类型&gt; &lt;数据类型&gt;*指针数组名[元素个数];</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">50</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> b[<span class="number">50</span>] = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">50</span>] = <span class="string">&quot;qwe&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> *p[<span class="number">3</span>] = &#123;a, b, c&#125;;</span><br><span class="line">	p[<span class="number">0</span>] == a;</span><br><span class="line">	p[<span class="number">2</span>] == b;</span><br><span class="line">	p[<span class="number">3</span>] <span class="comment">//error</span></span><br><span class="line">    *(p[<span class="number">0</span>]) == <span class="string">&#x27;h&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">char</span> **q = p = &amp;a;</span><br><span class="line">	q+<span class="number">1</span> = p+<span class="number">1</span> = &amp;b;</span><br><span class="line">	*q = *p = *(&amp;a) == a;</span><br><span class="line">	**q = *a = <span class="string">&#x27;h&#x27;</span>     </span><br><span class="line">        </span><br><span class="line">    p == &amp;p[<span class="number">0</span>];    </span><br><span class="line">        </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> *p[<span class="number">2</span>] = &#123;a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;;</span><br><span class="line">	*(p[<span class="number">0</span>]) == **p == p[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、二级指针"><a href="#2、二级指针" class="headerlink" title="2、二级指针"></a>2、二级指针</h3><p>​     将一级指针的地址称为二级指针</p>
<p>​        int a = 2;</p>
<p>​        int *p = &a;</p>
<p>​        int **q = &p;  //q就是定义的一个二级指针，地址中存放一级指针的值</p>
<h3 id="3、const指针"><a href="#3、const指针" class="headerlink" title="3、const指针"></a>3、const指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//right</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;a;</span><br><span class="line">p = &amp;b; <span class="comment">//error</span></span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<h3 id="4、void指针"><a href="#4、void指针" class="headerlink" title="4、void指针"></a>4、void指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> b = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line"><span class="keyword">void</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br><span class="line">p+<span class="number">1</span> <span class="comment">// error  void类型指针在使用时需要类型强转</span></span><br><span class="line">(<span class="keyword">int</span> *)p+<span class="number">1</span> <span class="comment">// 偏移4字节</span></span><br><span class="line">(<span class="keyword">char</span> *)p+<span class="number">1</span> <span class="comment">// 偏移1字节</span></span><br><span class="line"></span><br><span class="line">注意：<span class="keyword">void</span>类型的指针不能使用递增递减运算符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、字符指针和字符串"><a href="#5、字符指针和字符串" class="headerlink" title="5、字符指针和字符串"></a>5、字符指针和字符串</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">6</span>] = <span class="string">&quot;haha&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="string">&quot;hello&quot;</span>; <span class="comment">//将字符串hello的首地址赋值给指针变量p</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *p); <span class="comment">//right</span></span><br><span class="line">*p = <span class="string">&#x27;z&#x27;</span>; <span class="comment">//error hello是一个字符串常量，不能修改里面的字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;asd&quot;</span>); <span class="comment">//error</span></span><br><span class="line"><span class="built_in">strcpy</span>(a, <span class="string">&quot;asd&quot;</span>); <span class="comment">//right	</span></span><br></pre></td></tr></table></figure>



<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><p>概念：函数是一个实现特定功能的代码模块，函数有返回值，也可能没有</p>
<p>​            返回值：函数的结果</p>
<h3 id="1、函数的封装-定义"><a href="#1、函数的封装-定义" class="headerlink" title="1、函数的封装(定义)"></a>1、函数的封装(定义)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">	&lt;数据类型&gt; 函数名(形式参数)</span><br><span class="line">	&#123;</span><br><span class="line">    	功能代码模块;  <span class="comment">//语句块</span></span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">return</span> 表达式; </span><br><span class="line">	&#125;</span><br><span class="line">	数据类型：跟函数返回值的类型一致，如果一个函数没有返回值，则填<span class="keyword">void</span></span><br><span class="line">    函数名：遵循标识符标识符的命名规范，函数命名一般和功能相关。函数名也代表函数的起始地址</span><br><span class="line">    形式参数：形式参数决定了，函数调用时需要传入的实参的个数、类型、顺序，多个形式参数之间用逗号隔开。</span><br><span class="line">    如果函数不需要形式参数，可以省略不写，或者填<span class="keyword">void</span></span><br><span class="line">    <span class="keyword">return</span>：函数结束的标志，后面的表达式的值为函数的结果。如果没有返回值，可以选择不填或者只填<span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h3 id="2、函数的调用"><a href="#2、函数的调用" class="headerlink" title="2、函数的调用"></a>2、函数的调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    函数名(实际参数);</span><br><span class="line">	实际参数必须跟形式参数的个数、类型、顺序一致。如果没有形式参数，那么实际参数可以省略</span><br></pre></td></tr></table></figure>

<h3 id="3、函数的声明"><a href="#3、函数的声明" class="headerlink" title="3、函数的声明"></a>3、函数的声明</h3><p>​    在使用函数之前需要对函数进行函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">声明的一般形式：</span><br><span class="line">   &lt;数据类型&gt; 函数名(形式参数); 	</span><br><span class="line"></span><br><span class="line">	函数的声明中变量名是可以省略的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在add.h中声明了#include &lt;stdio.h&gt;后，在其他要用到#include &lt;stdio.h&gt;的函数中可以直接声明#include”add.h”就行。</p>
</blockquote>
<h3 id="4、头文件一般格式"><a href="#4、头文件一般格式" class="headerlink" title="4、头文件一般格式"></a>4、头文件一般格式</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ADD_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ADD_H__</span></span><br><span class="line"></span><br><span class="line">头文件声明</span><br><span class="line"></span><br><span class="line">函数声明</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、函数的传参"><a href="#5、函数的传参" class="headerlink" title="5、函数的传参"></a>5、函数的传参</h3><p>(1)赋值传递</p>
<p>&emsp;&emsp;在调用函数时，将普通变量的值直接赋值给形参。因为形式参数和实际参数在内存中存储的地址不同，所以        在函数中无论怎样改变形式参数的值，对实际参数是没有任何影响的</p>
<p>(2)地址传递</p>
<p>&emsp;&emsp;在调用函数时，将普通变量的地址直接赋值给形参。可以通过修改形式参数，间接修改实参的值</p>
<p>(3)全局变量</p>
<p>&emsp;&emsp;因为全局变量的作用域在整个文件中有效，所有在当前文件的任何一个函数中都可以当作参数使用</p>
<h3 id="6、数组传参"><a href="#6、数组传参" class="headerlink" title="6、数组传参"></a>6、数组传参</h3><p>&emsp;&emsp;数组传参需要传入指定数组的首地址，如果该数组是一个整型数组，那么在传入数组首地址的同时，还需要传入数组元素的个数</p>
<hr>
   <br>
   <br>

<h2 id="7、易错点"><a href="#7、易错点" class="headerlink" title="7、易错点"></a>7、易错点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">3</span>]=a; <span class="comment">//error</span></span><br><span class="line"><span class="keyword">int</span> *p=a;<span class="comment">//error</span></span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]);<span class="comment">//error一定为8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row=a[<span class="number">1</span>]-a[<span class="number">0</span>];   <span class="comment">//二维数组列数计算，用下一行的地址减去第一行的地址。即使二维数组只有一列也行</span></span><br><span class="line"><span class="keyword">int</span> line=<span class="keyword">sizeof</span>(a)/(row*<span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));​   <span class="comment">//二维数组行数计算</span></span><br></pre></td></tr></table></figure>

<h3 id="指针数组与数组指针的区别"><a href="#指针数组与数组指针的区别" class="headerlink" title="指针数组与数组指针的区别"></a>指针数组与数组指针的区别</h3><p>例：<br>int a[2][3]={1,2,3,4,5,6};<br>int (*p)[3]=a;<br>int *p[2]={a[0],a[1]};</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">指针数组</th>
<th align="center">数组指针</th>
</tr>
</thead>
<tbody><tr>
<td align="center">本质</td>
<td align="center">元素是指针的数组</td>
<td align="center">指向数组的行指针</td>
</tr>
<tr>
<td align="center">形式</td>
<td align="center">int *p[3]={a[0],a[1]};</td>
<td align="center">int (*p)[3]=a;</td>
</tr>
<tr>
<td align="center">p+1</td>
<td align="center">=&amp;p[1]=&amp;a[1]=&amp;&amp;a[1][0]</td>
<td align="center">=&amp;p[1]=&amp;a[1]=&amp;&amp;a[1][0]</td>
</tr>
<tr>
<td align="center">sizeof(p)</td>
<td align="center">整个数组的大小</td>
<td align="center">一定为8(即指针的大小)</td>
</tr>
<tr>
<td align="center">*(p+1)<strong>值一样但形式不一样</strong></td>
<td align="center">p[1]=a[1]=&amp;a[1][0]</td>
<td align="center">=a[1]=&amp;a[1][0]</td>
</tr>
<tr>
<td align="center">sizeof(*p)</td>
<td align="center">一定为8(即指针的大小)</td>
<td align="center">一列的大小</td>
</tr>
<tr>
<td align="center">二级指针x</td>
<td align="center">有二级指针 int **x=p</td>
<td align="center">没有二级指针，<font color="red">不能 int **x=p</font></td>
</tr>
<tr>
<td align="center">**p</td>
<td align="center">=**x=*p[0]=*a[0]=a[0][0]</td>
<td align="center">=*a[0]=a[0][0]</td>
</tr>
</tbody></table>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c语言</tag>
        <tag>指针</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>day14-c函数</title>
    <url>/2023/03/10/day14-c%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="day14-c函数"><a href="#day14-c函数" class="headerlink" title="day14-c函数"></a><font color="green">day14-c函数</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><h3 id="1、函数定义"><a href="#1、函数定义" class="headerlink" title="1、函数定义"></a>1、函数定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; 函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    功能代码;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> 表达式;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">函数名：也代表函数的首地址</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="2、函数调用"><a href="#2、函数调用" class="headerlink" title="2、函数调用"></a>2、函数调用</h3><p>​    函数名(实际参数);</p>
<p>​    实际参数必须和形参的个数、类型、顺序一致</p>
<h3 id="3、函数声明"><a href="#3、函数声明" class="headerlink" title="3、函数声明"></a>3、函数声明</h3><p>​    &lt;数据类型&gt; 函数名(形式参数);</p>
<h3 id="4、函数的传参"><a href="#4、函数的传参" class="headerlink" title="4、函数的传参"></a>4、函数的传参</h3><p>​    (1)赋值传递</p>
<p>​    (2)地址传递：将数据的地址赋值给形参进行初始化</p>
<p>​    (3)全局变量传参</p>
<h3 id="5、数组传参"><a href="#5、数组传参" class="headerlink" title="5、数组传参"></a>5、数组传参</h3><p>​    (1)整型数组：要传入数组的首地址，还要传入数组的元素个数</p>
<p>​    (2)字符数组：只需要传入数组首地址</p>
<p>练习：定义一个函数，计算二维整型数组的所有元素的和</p>
<h2 id="二、函数和指针"><a href="#二、函数和指针" class="headerlink" title="二、函数和指针"></a>二、函数和指针</h2><h3 id="1、指针函数"><a href="#1、指针函数" class="headerlink" title="1、指针函数"></a>1、指针函数</h3><p>​        如果一个函数的返回值是一个地址值，那么该函数就称为指针函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; *函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    功能代码;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> 地址值; <span class="comment">//合法安全的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2、函数指针"><a href="#2、函数指针" class="headerlink" title="2、函数指针"></a>2、函数指针</h3><p>​    本质：指针，指向一个函数的首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义：</span><br><span class="line">    &lt;数据类型&gt; (*函数指针名)(形式参数);</span><br><span class="line">	数据类型：跟指向的函数的返回值一致</span><br><span class="line">    形式参数：跟指向函数的形参一致</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span> x, <span class="keyword">int</span> y); <span class="comment">//定义了一个函数指针，指向的函数--&gt;返回值为int，参数是两个int类型数据</span></span><br><span class="line">p = add; <span class="comment">//将函数add的首地址赋值给函数指针变量p</span></span><br><span class="line"></span><br><span class="line">调用函数方法：</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//通过函数名+实参 调用函数</span></span><br><span class="line">	(*p)(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//通过访问函数指针内容+实参 调用函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>















<p>​            </p>
<p>​                </p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c语言</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>day15-c函数，结构体</title>
    <url>/2023/03/12/day15-c%E5%87%BD%E6%95%B0%EF%BC%8C%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="day15-c函数，结构体"><a href="#day15-c函数，结构体" class="headerlink" title=" day15-c函数，结构体"></a><font color="green"> day15-c函数，结构体</font></h1><h2 id="一、复习"><a href="#一、复习" class="headerlink" title="一、复习"></a>一、复习</h2><hr>
<h3 id="1、指针函数："><a href="#1、指针函数：" class="headerlink" title="1、指针函数："></a>1、指针函数：</h3><p>​    本质：是一个函数，指针函数的返回值是一个地址</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt;* 函数名(形式参数)</span><br><span class="line">&#123;</span><br><span class="line">    代码模块;</span><br><span class="line">    <span class="keyword">return</span> 地址量; <span class="comment">//合法地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、函数指针："><a href="#2、函数指针：" class="headerlink" title="2、函数指针："></a>2、函数指针：</h3><p>​    本质：是一个指针，指向一个函数的首地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义的一般形式：</span><br><span class="line">    &lt;数据类型&gt; (*函数指针变量名)(参数列表);</span><br><span class="line"></span><br><span class="line">	例：</span><br><span class="line">        <span class="keyword">int</span> (*p)(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">	数据类型：跟指针指向的函数的数据类型一致</span><br><span class="line">	参数列表：跟指针指向的函数的参数列表一致</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">p = add;  <span class="comment">//将函数add的首地址赋值给函数指针变量p</span></span><br><span class="line">(*p)(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//调用add函数传入实参为2和3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><h3 id="1、函数指针数组"><a href="#1、函数指针数组" class="headerlink" title="1、函数指针数组"></a>1、函数指针数组</h3><p>​    本质：是一个数组, 存放的全部都是函数指针类型的数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">定义的一般形式：</span><br><span class="line">    &lt;数据类型&gt; (*函数指针数组名[元素个数])(参数列表);</span><br><span class="line">	例：</span><br><span class="line">    	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">		<span class="keyword">int</span> (*arr[<span class="number">2</span>])(<span class="keyword">int</span> x, <span class="keyword">int</span> y) = &#123;add, sub&#125;;</span><br><span class="line">        <span class="comment">//定义了一个名为arr的函数指针数组，数组中最多可以存放两个 int(* )(int, int)类型的数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、递归函数"><a href="#2、递归函数" class="headerlink" title="2、递归函数"></a>2、递归函数</h3><p>​    练习：计算一个正整数的阶乘，用函数封装功能</p>
<p>​    概念：在一个函数中直接或者间接调用函数本身</p>
<p>​    </p>
<p>​    递归函数的特点：</p>
<p>​            1：递推公式</p>
<p>​            2：设置有退出条件</p>
<p>​    优点：能够让代码整体更加简洁</p>
<p>​    缺点：需要消耗大量系统资源</p>
<p>​                必须要设置退出条件</p>
<h2 id="三、结构体"><a href="#三、结构体" class="headerlink" title="三、结构体"></a>三、结构体</h2><p>​    跟数组一样，是用户自定义的一种数据类型</p>
<p>​    结构体中可以存放多个不同数据类型的数据</p>
<h3 id="1、结构体的定义"><a href="#1、结构体的定义" class="headerlink" title="1、结构体的定义"></a>1、结构体的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> 结构体名</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">       数据类型 成员名<span class="number">1</span>;</span><br><span class="line">       数据类型 成员名<span class="number">2</span>;        	</span><br><span class="line">       数据类型 成员名<span class="number">3</span>; </span><br><span class="line">        ......</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">	例：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stu</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">char</span> name[<span class="number">50</span>]; </span><br><span class="line">            <span class="keyword">int</span>	age;</span><br><span class="line">            <span class="keyword">char</span> sex;</span><br><span class="line">            <span class="keyword">double</span> height;</span><br><span class="line">            <span class="keyword">char</span> address[<span class="number">50</span>];</span><br><span class="line">            <span class="keyword">char</span> hobby[<span class="number">50</span>];</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2、结构体变量"><a href="#2、结构体变量" class="headerlink" title="2、结构体变量"></a>2、结构体变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> 结构体名 结构体变量名;</span></span><br><span class="line">	例：</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu2</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、访问结构体成员"><a href="#3、访问结构体成员" class="headerlink" title="3、访问结构体成员"></a>3、访问结构体成员</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">    结构体变量名.成员名;  </span><br><span class="line">	stu1.age = <span class="number">18</span>;  <span class="comment">//访问1号学生stu1中的年龄，赋值为18；	</span></span><br></pre></td></tr></table></figure>

<h3 id="4、结构体变量的初始化"><a href="#4、结构体变量的初始化" class="headerlink" title="4、结构体变量的初始化"></a>4、结构体变量的初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 结构体变量名 = &#123;</span>依次给每一个成员赋值&#125;;  <span class="comment">//成员之间用逗号隔开</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu2</span> = &#123;</span><span class="string">&quot;张三&quot;</span>, <span class="number">19</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">182.1</span>, <span class="string">&quot;成都&quot;</span>, <span class="string">&quot;sing and dance&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="5、结构体指针"><a href="#5、结构体指针" class="headerlink" title="5、结构体指针"></a>5、结构体指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">stu1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">p</span> = &amp;<span class="title">stu1</span>;</span></span><br><span class="line">(*p).name       <span class="comment">//stu1中的name成员</span></span><br><span class="line">p-&gt;name == (*p).name</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>c语言</tag>
        <tag>函数</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2020/05/05/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><font color="green">简介</font></h1><p>我们关注的主要对象是重新排列数组元素的算法，其中每个元素都有一个主键，排序算法的目的就是将所有的元素的主键按照某种方式排列（通常是按照大小或是字母顺序） </p>
<a id="more"></a> 
<p>常见的十大算法：<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588689912090&di=3d31e8a2f7ab8a74d03f295e5a2c6f25&imgtype=0&src=http://img.mp.itc.cn/upload/20160925/6689ac6a8e954126aefebaf492994cfc_th.jpeg" alt="排序算法"></p>
<blockquote>
<p>稳定：指如果有相同的数，排序后本来在前面的还是在前面<br>out-place：指用了额外的空间</p>
</blockquote>
<hr>
<br>

<p>下面我们在介绍排序算法时将从这几个方向入手：</p>
<ul>
<li>算法思路</li>
<li>算法图解</li>
<li>基本代码实现</li>
<li>易踩坑点</li>
<li>优化思路</li>
</ul>
<p><strong>如未特别说明，下面的变量都是从0开始的</strong></p>
<hr>
<br>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><font color="green">冒泡排序</font></h1><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>从头开始遍历数据，当前者的主键(值)大于后者时，两者交换位置，直到最后一位</li>
<li>此时数据的最大值一定排在了最后一位，排好的最大值便固定，无需再排</li>
<li>重复1的操作，直到最后两个数排序完成</li>
</ol>
<p>总结：外部循环<code>数据个数-1</code>次，内部循环<code>数组长度-n-1</code>次，每次内部循环比较当前位和后一位的值的大小，判断是否交换</p>
<h2 id="算法图解"><a href="#算法图解" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3438712239,3527372442&fm=26&gp=0.jpg" alt="冒泡排序"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp; <span class="comment">//帮助交换</span></span><br><span class="line">            <span class="keyword">boolean</span> falg = <span class="keyword">false</span>; <span class="comment">//检查是否已经排好</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                falg = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123; <span class="comment">//每次排序后的最大位可以忽略</span></span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                        falg =<span class="keyword">true</span>;</span><br><span class="line">                        temp=arr[j+<span class="number">1</span>];</span><br><span class="line">                        arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                        arr[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!falg) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点"><a href="#易踩坑点" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>一共循环 <code>数据个数-1</code> 次 ，因为最后一次确定第二个值的同时也把最小值确定了</li>
<li>每次遍历后的最大值要忽略，所以每次内部循环时循环次数要-1次</li>
<li>因为比较是和后面的数比较，所以当后面的数到最大值即当前数到倒数第二个时就说明内部循环完，否则数组越界</li>
</ol>
<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>如果有次内循环中没有发生交换，说明已经有序</p>
<hr>
<br>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><font color="green">选择排序</font></h1><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>先把第一个数记成最小值，遍历整个数组，记录遍历时遇见的最小值</li>
<li>遍历完一次后将最小值和第一个数交换位置，下一次遍历从第二个数开始</li>
<li>重复上述操作，直到最后两个数遍历完成</li>
</ol>
<h2 id="算法图解-1"><a href="#算法图解-1" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="http://www.west.cn/cms/images/2019-01-10/q5dlczui1fw.gif" alt="选择排序"></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min;<span class="comment">//记录最小数</span></span><br><span class="line">        <span class="keyword">int</span> temp; <span class="comment">//帮助交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length;i++)&#123;</span><br><span class="line">            min = i; <span class="comment">//将最小值初始化为遍历的第一个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;arr[min])&#123; <span class="comment">//*当某数小于当前最小数(别写成i)时，将最小数的索引改成该数的索引</span></span><br><span class="line">                    min =j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行交换</span></span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-1"><a href="#易踩坑点-1" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>开始时我们是把第一个数当成最小值的，所以是从第二个数开始遍历的</li>
<li>i值的含义有两个，一个是遍历次数，一个是当前遍历最小时应所处的位置</li>
</ol>
<hr>
<br>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><font color="green">插入排序</font></h1><h2 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>遍历数组，将当前数组插入左边已排好数据中</li>
<li>插入方法：先记录当前值，遍历左边，将当前数左边的数向右移动，直到遇见比当前数小的数，此时空白部分便是要插入的地方</li>
</ol>
<h2 id="算法图解-2"><a href="#算法图解-2" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;    </span><br><span class="line">        <span class="comment">//插入法</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            temp=arr[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j];j--)&#123; <span class="comment">//别忘了j要大于0</span></span><br><span class="line">                arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-2"><a href="#易踩坑点-2" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>i是从第二个数开始的</li>
<li>为了插入而进行的遍历一定别忘了j要大于0，(因为每次都是j和j+1比较)如果当前值正好是最小值，则数组会越界</li>
<li>这里j的含义是当前值最后插入的位置的左边</li>
</ol>
<hr>
<br>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><font color="green">希尔排序</font></h1><h2 id="算法思路-3"><a href="#算法思路-3" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>先将数据分成间隔为h的许多小组，先让小组进行排序(插入排序法)</li>
<li>在把间隔缩短（小组变少，每个组中数变多）再进行插入排序</li>
<li>重复上述步骤，直到最后间隔为1时排序(即整个数据排序)</li>
</ol>
<blockquote>
<p>注：h也称为增量序列，对于最优增量序列目前还没有结论，主要的增量序列有Shell 增量序列，Hibbard 增量序列，Knuth 增量序列</p>
</blockquote>
<h2 id="算法图解-3"><a href="#算法图解-3" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" alt="希尔排序"></p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = arr.length; <span class="comment">//总数</span></span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">1</span>;<span class="comment">//增量序列</span></span><br><span class="line">        <span class="keyword">while</span>(h&lt;N/<span class="number">3</span>) h= h*<span class="number">3</span>+<span class="number">1</span>; <span class="comment">//Knuth 增量序列计算得来的h</span></span><br><span class="line">        <span class="comment">//插入法</span></span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;N;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i]; <span class="comment">//因为arr[i]的值可能会变，保存插入值</span></span><br><span class="line">                <span class="keyword">for</span>(;j-h&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j-h];j=j-h)&#123;</span><br><span class="line">                    arr[j] = arr[j-h];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            h=h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-3"><a href="#易踩坑点-3" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>和插入排序一样，i是从h而不是0开始的(h代表的是第一个小组的第二个数)</li>
<li>这里j的含义是当前数再小组中该插入的位置(和插入排序j的含义不同)，所以不是要 j&gt;=0而是要 j-h&gt;=0 (因为每次都是j和j-h比较)</li>
<li>这里是从h开始遍历到结束，效果是先让每个小组的第二个数和前面比较后再让每个小组的第三个数和前面比较，如此循环</li>
</ol>
<h2 id="优化思路-1"><a href="#优化思路-1" class="headerlink" title="优化思路"></a>优化思路</h2><p>增量序列的不同会影响排序算法效率</p>
<hr>
<br>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><font color="green">归并排序</font></h1><h2 id="算法思路-4"><a href="#算法思路-4" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>将数组分成两部分</li>
<li>左部分和右部分分别排序，直到左部分或右部分只有一个数时返回</li>
<li>将两部分合并起来</li>
</ol>
<p>合并方法：</p>
<ul>
<li>传入需要合并的部分的开头，中间和结尾数，将该部分数组放入辅助数组对应位置中</li>
<li>左部分开头和右部分开头创建指针分别遍历：</li>
<li>当左边遍历完时，将右边的数传入原数组</li>
<li>当右边遍历完时，将左边的数传入原数组</li>
<li>当左边小于右边时，将左边的数传入原数组</li>
<li>当右边小于左边时，将右边的数传入原数组</li>
</ul>
<h2 id="算法图解-4"><a href="#算法图解-4" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=4070550482,2402998767&fm=26&gp=0.jpg" alt="归并算法"></p>
<p>合并步骤：</p>
<p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1120323612,2379483011&fm=15&gp=0.jpg" alt="归并算法2"></p>
<h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux; <span class="comment">//归并时所用的辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并两个有序子数据：先将要归并的数据保存到辅助数组中，用两个指针指向辅助数组的前面和中间+1分成两数组</span></span><br><span class="line">    <span class="comment">//两数组依次比较，将较小的数放进原数组对应位置，然后较小数所在的数组指针上移</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并子数组，先将数据存入辅助数组中，用两指针二分辅助数组并遍历</span></span><br><span class="line">    <span class="comment">//mid为左边数组的最右边，即最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//辅助指针</span></span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将要归并的数据保存到辅助数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;=hi;k++)&#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;=hi;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;mid) a[k] = aux[j++];<span class="comment">//左边数组遍历完时，直接加右边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;hi) a[k] = aux[i++];<span class="comment">//右边数组遍历完时，直接加左边</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aux[i]&gt;aux[j]) a[k] = aux [j++]; <span class="comment">//当右边的比左边的小时，加右边</span></span><br><span class="line">            <span class="keyword">else</span> a[k] = aux [i++]; <span class="comment">//当左边的比右边的小时，加左边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自顶向下的归并排序,将数组不断地二分直到直到只有一个数，再向上合并返回</span></span><br><span class="line">    <span class="comment">//将数组分成左右两部分，每个部分进行排序，排完后再合并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        mergeSort1(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo ,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span>; <span class="comment">//如果最前面和最后面一样说明已经分成最小单位</span></span><br><span class="line">        <span class="keyword">int</span> mid = (hi-lo)/<span class="number">2</span>+lo;</span><br><span class="line">        mergeSort1(a,lo,mid);</span><br><span class="line">        mergeSort1(a,mid+<span class="number">1</span>,hi);</span><br><span class="line">        <span class="keyword">if</span>(a[mid+<span class="number">1</span>]&gt;=a[mid]) <span class="keyword">return</span>; <span class="comment">//优化，如果排好序的右边最小值已经大于左边最大值，说明已经有序</span></span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-4"><a href="#易踩坑点-4" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>合并时传入的 mid (中间值)含义是左部分的最后一个数，算 mid 时记得要加 lo，写右边排序时记得传入的是 mid+1</li>
<li>合并中，将数据存入辅助数组是记得要&lt;=最后一位数而不是&lt;</li>
<li>判断是否左部分或右部分只含有一个数(传入的最左边的索引<code>lo</code> &gt;= 最右边的索引<code>hi</code>)</li>
</ol>
<h2 id="优化思路-2"><a href="#优化思路-2" class="headerlink" title="优化思路"></a>优化思路</h2><p>左右两边排好了之后，如果这时左部分的最大值&lt;=右部分的最小值的，说明已经有序，不用再合并</p>
<h3 id="自下向顶的归并"><a href="#自下向顶的归并" class="headerlink" title="自下向顶的归并"></a>自下向顶的归并</h3><p>除了上面的自顶向下的归并方法，还存在自下向顶的归并的方法：</p>
<ul>
<li><p>每个子数组长度为1开始，2个一组归并，再4个一组归并，直到整个归并</p>
<p>图解：<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E8%87%AA%E4%B8%8B%E5%90%91%E9%A1%B6.jpg" alt="自顶向下"></p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i*=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//因为归并是两个归并，所以每次指针k要移动2个子数组长度</span></span><br><span class="line">            <span class="comment">//可以把一个子数组的i个 数看成一个整体，k的循环就要小于a.length - i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.length - i; k=k+i*<span class="number">2</span>)&#123;</span><br><span class="line">                merge(a,k,k+i-<span class="number">1</span>,Math.min(k+i*<span class="number">2</span>-<span class="number">1</span>,a.length-<span class="number">1</span>)); <span class="comment">//有可能最后一组数不够，要判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>易踩坑点：</p>
<ol>
<li>因为k的作用是指向两个子数组合并的开头，如果最后的个数连一个子数组都没达到的话，那在合并时传入的中间值k+i-1就会发生数组出界问题，所以 k&lt;a.length-i</li>
<li>如果最后只剩一个不全数组，则放到下一轮，如果最后剩一个好的左部分和一个不全的右部分，两者可以合并，但要注意此时传入的最右边的值就不是 k+i*2-1 而是 a.length-1</li>
</ol>
<hr>
<br>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><font color="green">快速排序</font></h1><h2 id="算法思路-5"><a href="#算法思路-5" class="headerlink" title="算法思路"></a>算法思路</h2><p>和归并排序有异曲同工之妙，都采用分治法，但不同点是归并是先分别排序后归并，快速是分开时先排序再分别排序</p>
<ol>
<li>确定一位中间值(一般取第一个数),遍历数组，小于等于中间值的放左边，大于等于中间值的放右边</li>
<li>对中间值左边的数组排序</li>
<li>对中间值右边的数组排序</li>
</ol>
<p>上面 1 的具体步骤：</p>
<ol>
<li>将左边第一个数设为中间值</li>
<li>左边第二个和最右边分别设置两指针向中间遍历，直到左边的指针大于等于右边的指针</li>
<li>当左边遍历时遇见大于中间值的数停下，当右边遍历时遇见小于中间值的数停下</li>
<li>当两指针停下后交换两指针所值的数</li>
<li>遍历完后j所指的一定是小于等于中间值的，将j所在的数与第一个数交换，返回j(中间值所在位置)</li>
</ol>
<h2 id="算法图解-5"><a href="#算法图解-5" class="headerlink" title="算法图解"></a>算法图解</h2><p>整体思路：</p>
<p><img src="https://img-blog.csdnimg.cn/20200318212047646.png" alt="快速排序"></p>
<p>左右排序：</p>
<p>i和j最后一次交换时<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F2.jpg" alt="快速排序2"></p>
<p>i和j最后一次没有交换时<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F3.jpg" alt="快速排序3"></p>
<h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将数组有序二分并返回切分元素位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建两个辅助指针和切分元素</span></span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = hi+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i,j指针向中间遍历，直到遇见不符合的数或边界停下，两者都停下时将两数进行交换</span></span><br><span class="line">        <span class="comment">//当遍历完时i的位置可能会比j大(最后两个数发生交换时，i，j同时移动)可能相等(最后两个数没发生交换时，i，j其中一个移动)</span></span><br><span class="line">        <span class="comment">//遍历完时j的位置一定在小于等于切分元素的数的索引上，将这两个数交换，j所指的便是切分元素索引</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[++i] &lt; v) <span class="keyword">if</span>(i==hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (a[--j] &gt; v) ;<span class="comment">//这里本来还有个判断j是否跑到了最左边(当切分元素是该数据中最小值时)，但因为v在最左边，j一定会停在lo上</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        a[lo] = a[j];</span><br><span class="line">        a[j] = v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        quick(a , <span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span>;  <span class="comment">//可以在某个情况后改成插入排序</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        quick(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        quick(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="易踩坑点-5"><a href="#易踩坑点-5" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>数组切分时创建并初始化 i 与 j 是让 i ，j 等于第一个数和最后一个数的后一位，并且先加减再操作。如果是让 i ，j 等于第二个数和最后一个数并且先操作在加减时会很麻烦，不仅要在内循环中写i++，j–，在arr[i]和arr[j]交换后也要写i++，j– <strong>最好是先移动指针再操作</strong></li>
<li>返回中间值后，中间值是不再参与排序的</li>
<li>小心i和j出界的问题，当i到最右边或j到左边时，也要停止指针移动(j比较特殊，因为j到最左边时一定是等于v的，不可能越界)</li>
</ol>
<h2 id="优化思路-3"><a href="#优化思路-3" class="headerlink" title="优化思路"></a>优化思路</h2><p>防止特殊情况，可以先把数据打乱再排</p>
<h3 id="三切分法："><a href="#三切分法：" class="headerlink" title="三切分法："></a>三切分法：</h3><p>思路：</p>
<ul>
<li>对于有大量的重复数而言，可以使用三分切法，将数据分成大于v，等于，小于iv三部分，v代表中间值<ul>
<li>三个辅助指针i,lt,gt，i来遍历数组，直到大于gt(等于gt时还要再判断一次)</li>
<li>如果i遇见小的数，和lt交换并两者++，如果遇见大的数，和gt交换，gt–，i不动(因为无法保证gt所在的值，lt一定为v)</li>
<li>最后lt，gt都在中间段的最左边和最右边</li>
</ul>
</li>
</ul>
<p>图示：<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%B8%89%E5%90%91%E5%88%87%E5%88%86.jpg" alt="快速排序三向切分"></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">quick3way</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        quick(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick3way</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi&lt;=lo) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lt = lo;</span><br><span class="line">        <span class="keyword">int</span> gt = hi;</span><br><span class="line">        <span class="keyword">int</span> i  = lo+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v  = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=gt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;v) exchange(a,i++,lt++); <span class="comment">//lt一定为v，交换后i为v，可以移动</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;v) exchange(a,i,gt--); <span class="comment">//无法确定gt处的值，交换后不能动i</span></span><br><span class="line">            <span class="keyword">else</span> i++; <span class="comment">//i处等于v</span></span><br><span class="line">            &#125;</span><br><span class="line">        quick3way(a,lo,lt-<span class="number">1</span>);</span><br><span class="line">        quick3way(a,gt+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[x];</span><br><span class="line">        a[x] = a[y];</span><br><span class="line">        a[y] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>易踩坑点：</p>
<ol>
<li>因为lt是一定等于v的并且在等于v数组的最左边，所以和i所在值交换后两者可以一起++，但由于不知道gt所在的值，所以和i所在值交换后只能让gt–，i不动</li>
<li>记得当i=gt时还要再判断一次</li>
</ol>
<hr>
<br>

<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><font color="green">计数排序</font></h1><h2 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h2><ol>
<li>找到数组中最大的值</li>
<li>创建一个长度为最大值+1的数组，遍历原数组把数放在值相同的辅助数组下(如遍历到5，则让辅助数组temp[5]++)</li>
<li>遍历辅助数组，将不等于0的索引依次返回给原数组</li>
</ol>
<h2 id="算法图解-6"><a href="#算法图解-6" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" alt="计数排序"></p>
<h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">counting</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = findMax(a);</span><br><span class="line">        counting(a,max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">counting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//用作a的指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:a)&#123;</span><br><span class="line">            temp[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(temp[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                a[k++] = i;</span><br><span class="line">                temp[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;max) max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="易踩坑点-6"><a href="#易踩坑点-6" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>数组计数是从0开始的，记得创建数组时长度为 max+1 这样数组的最后一位才是max</li>
<li>当取出一个数后，该数上的计数(即 temp[ i ] )要-1</li>
<li>注意当前给的代码中因为是用的<code>temp[i]--</code>所以不稳定，可以改成一个从0开始小于temp[i]的循环</li>
</ol>
<hr>
<br>

<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><font color="green">桶排序</font></h1><h2 id="算法思路-6"><a href="#算法思路-6" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>找到数组最大值</li>
<li>根据最大值创建n个桶，每个桶中存放一定范围的数</li>
<li>将每个桶中的数据排序</li>
<li>遍历桶，返回桶中的数</li>
</ol>
<p><strong>因为这个算法本身比较麻烦且用得不多，就不再演示了</strong></p>
<hr>
<br>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><font color="green">基数排序</font></h1><h2 id="算法思路-7"><a href="#算法思路-7" class="headerlink" title="算法思路"></a>算法思路</h2><ol>
<li>找到数据中 位数最高的数（即最大数有多少位）</li>
<li>创建一个二维数组，第一维 0~9 代表某位上可能出现的数，第二维用来存某位相同的数（如12，42都放在arr[2][n]中）</li>
<li>从个位数开始，遍历数组，将个位上相同的数存入相同一维的二维数组中（这里需要一个辅助一维数组来记录二维数组的一维上有多少存储的数）</li>
<li>遍历二维数组，依次返回给原数组</li>
<li>再从十位开始，重复上述操作，如果没十位则补0.循环最高位数次</li>
</ol>
<blockquote>
<p>二维数组可以这样理解：一共有0<del>9的桶，某位上值和桶的索引一样时放进桶中，从下到上放入桶中。一维数组也是0</del>9，每个位置的值就代表桶中有多少存入的值以及下一个该存入该桶的数的位置</p>
</blockquote>
<h2 id="算法图解-7"><a href="#算法图解-7" class="headerlink" title="算法图解"></a>算法图解</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="基数排序"></p>
<h2 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> high = findHigh(a);</span><br><span class="line">        radix(a,high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][a.length]; <span class="comment">//放数据的桶，一共要有10个桶(0~9),桶中最多存a中所有的数</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>; <span class="comment">//用于计算某位上的数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一共循环的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=high;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] bucketContent = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//记录每个桶有多少数已经下一个数应该存放在桶的哪里</span></span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>; <span class="comment">//用于将桶中数据返回给数组时对数组的指针</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算某位上的数进行分组,放入桶里</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : a) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (value / m) % <span class="number">10</span>; <span class="comment">//如果该数没有更高位，temp就为0</span></span><br><span class="line">                bucket[temp][bucketContent[temp]] = value;<span class="comment">//bucketContent[temp]可以表示该存入该桶的数的位置</span></span><br><span class="line">                bucketContent[temp]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将桶中数据返回数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;bucket.length;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bucketContent[k]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bucketContent[k];j++)&#123;</span><br><span class="line">                        a[n++] = bucket[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m=m*<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findHigh</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;max)&#123;</span><br><span class="line">                max = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String temp = Integer.toString(max);</span><br><span class="line">        <span class="keyword">return</span> temp.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="易踩坑点-7"><a href="#易踩坑点-7" class="headerlink" title="易踩坑点"></a>易踩坑点</h2><ol>
<li>每循环完一次后辅助一维数组要清0，即要放入循环中</li>
<li>用m计算位时，没有该位的运算结果就为0</li>
<li>每次记得m*10</li>
</ol>
<hr>
<br>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><font color="green">堆排序</font></h1><p><del>还没学到二叉树呢，以后补</del></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法，排序算法，基础</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式学习-Linux基础</title>
    <url>/2023/02/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一、linux系统基础"><a href="#一、linux系统基础" class="headerlink" title="一、linux系统基础"></a><font color="green">一、linux系统基础</font></h1><h2 id="1、linux和windows"><a href="#1、linux和windows" class="headerlink" title="1、linux和windows"></a>1、linux和windows</h2><p>​    linux：开源、免费、安全性高、稳定性强、可移植性高</p>
<a id="more"></a>

<h2 id="2、linux操作系统的基本使用"><a href="#2、linux操作系统的基本使用" class="headerlink" title="2、linux操作系统的基本使用"></a>2、linux操作系统的基本使用</h2><h3 id="0-、linux的文件的系统结构"><a href="#0-、linux的文件的系统结构" class="headerlink" title="(0)、linux的文件的系统结构"></a>(0)、linux的文件的系统结构</h3><blockquote>
<ul>
<li>windows：所有文件有分盘(C,D,E,F….)，每个盘中都有子文件或者子目录，对文件存放没有要求，可以放在任意位置</li>
<li>linux：没有分盘，只有一个大的目录–根目录（’/‘），根目录下的文件夹每一个都有其固定作用</li>
<li>bin：存放二进制文件或者可执行程序</li>
<li>dev：存放设备文件</li>
<li>etc：系统相关的配置文件</li>
<li>home：用户目录，用户所有操作都在该目录下进行     /home/hqyj 可以用符号(~)表示</li>
</ul>
</blockquote>
<br>
<br>

<hr>
<h3 id="1-、基本的shell命令"><a href="#1-、基本的shell命令" class="headerlink" title="(1)、基本的shell命令"></a>(1)、基本的shell命令</h3><p>​        shell本质：命令行解释器，将用户输入的特定指令转换为系统能够识别的语言</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    绝对路径：从根目录出发所表示的一个路径</span><br><span class="line">    相对路径：相对于用户当前位置所表示的一个路径</span><br><span class="line"></span><br><span class="line">pwd:显示当前用户在文件系统中的绝对路径</span><br><span class="line">    用法：</span><br><span class="line">    	pwd + 回车</span><br><span class="line">ls:显示当前用户所在路径下的所有文件(不包含隐藏文件)</span><br><span class="line">    用法：</span><br><span class="line">    	ls + 回车</span><br><span class="line">ls -a：显示当前用户所在路径下的所有文件(包含隐藏文件)</span><br><span class="line">    <span class="string">&#x27;.&#x27;</span> == 用户当前目录</span><br><span class="line">    &#x27;..&#x27; == 当前目录的上一级目录</span><br><span class="line">    </span><br><span class="line">ls -l:显示当前用户所在路径下的所有文件的详细信息</span><br><span class="line">    - rw- rw- r--</span><br><span class="line">    第一位代表文件类型：</span><br><span class="line">    	<span class="string">&#x27;-&#x27;</span> :普通文件</span><br><span class="line">    	<span class="string">&#x27;d&#x27;</span> :目录文件</span><br><span class="line">    	<span class="string">&#x27;c&#x27;</span> :字符设备文件</span><br><span class="line">    	<span class="string">&#x27;b&#x27;</span> :块设备文件</span><br><span class="line">    	<span class="string">&#x27;p&#x27;</span> :管道文件</span><br><span class="line">    	<span class="string">&#x27;l&#x27;</span> :符号链接文件</span><br><span class="line">    	<span class="string">&#x27;s&#x27;</span> :套接字文件</span><br><span class="line">            不同操作系统下支持使用的文件类型不同</span><br><span class="line">    	</span><br><span class="line">    后<span class="number">9</span>位代表文件存取权限</span><br><span class="line">         rw-rw-r--  == <span class="number">110</span> <span class="number">110</span> <span class="number">100</span> == <span class="number">0664</span></span><br><span class="line">         权限的前<span class="number">3</span>位表示用户自己的使用权限，如果当前位上没有对应权限用<span class="string">&#x27;-&#x27;</span>表示                      </span><br><span class="line">		 权限的中间<span class="number">3</span>位代表用户组的使用权限        </span><br><span class="line">         权限的最后<span class="number">3</span>位代表其他用户的使用权限</span><br><span class="line">         r -- 具有读权限  w -- 具有写权限  x -- 具有可执行权限</span><br><span class="line">    改变文件权限的命令入下:</span><br><span class="line">         chmod [-R]  xyz  文件或目录</span><br><span class="line">         -R ： 以递归方式进行修改，比如修改某个目录下所有文件的属性。</span><br><span class="line"></span><br><span class="line">cd: 目录跳转	</span><br><span class="line">    用法：</span><br><span class="line">    	cd + 指定路径    </span><br><span class="line"></span><br><span class="line">touch:以不打开的方式创建一个文件，如果文件存在，则修改时间戳</span><br><span class="line">    用法：</span><br><span class="line">    	touch + 文件名</span><br><span class="line">    </span><br><span class="line">rm:删除指定文件</span><br><span class="line">    用法：</span><br><span class="line">    	rm + 文件名</span><br><span class="line">    </span><br><span class="line">cat：显示文件内容</span><br><span class="line">    用法：</span><br><span class="line">    	cat + 文件名</span><br><span class="line">    </span><br><span class="line">cp: 复制文件</span><br><span class="line">    用法：</span><br><span class="line">    	cp + 源文件名 + 路径名</span><br><span class="line">    	cp + 源文件名 + 目标文件名</span><br><span class="line">mv：移动文件</span><br><span class="line">    用法：</span><br><span class="line">    	mv + 源文件名 + 路径名</span><br><span class="line">    	mv + 源文件名 + 目标文件名    </span><br><span class="line"></span><br><span class="line">mkdir: 创建目录</span><br><span class="line">    用法：</span><br><span class="line">    	mkdir + 目录名</span><br><span class="line">    </span><br><span class="line">rmdir: 删除指定目录(空目录)   </span><br><span class="line">    用法：</span><br><span class="line">    	rmdir + 目录名</span><br><span class="line">    </span><br><span class="line">  	删除非空目录：rm -r 目录名</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">clear:清屏    ctrl + l快捷方式也可以清屏</span><br><span class="line">Tab: 命令补全</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br>
<br>

<hr>
<h3 id="2-、vim编辑器"><a href="#2-、vim编辑器" class="headerlink" title="(2)、vim编辑器"></a>(2)、vim编辑器</h3><p>shell命令：vi 或者 vim + 文件名  </p>
<p>如果文件不存在，则会先创建再进行编辑</p>
<h4 id="vim编辑器中的三种工作模式："><a href="#vim编辑器中的三种工作模式：" class="headerlink" title="vim编辑器中的三种工作模式："></a>vim编辑器中的三种工作模式：</h4><p>​命令行模式：用户在进入编辑器后默认处于的工作模式</p>
<p>​        在命令行模式下不能直接输入数据，但是可以对文本进行复制、粘贴、剪切、撤销等操作：</p>
<p>​            在命令行模式下输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ngg: 光标跳到某一行首</span><br><span class="line"></span><br><span class="line">nyy：将光标以及光标以下的n行数据进行复制</span><br><span class="line"></span><br><span class="line">ndd：将光标以及光标以下的n行数据进行剪切或删除</span><br><span class="line"></span><br><span class="line">p：将复制或者剪切的内容粘贴到光标的下一行</span><br><span class="line"></span><br><span class="line">u：撤回到上一步操作</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>：当前行首</span><br><span class="line"></span><br><span class="line">$：当前行尾</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    编辑模式：可以对文本进行编辑操作</p>
<p>​        在命令行模式下输入：a, i, o都可以进入编辑模式</p>
<p>​        按Esc退回到命令行模式</p>
<p>​    </p>
<p>​    底行模式：对文本进行保存、退出等操作</p>
<p>​        在命令行模式下输入冒号进入底行模式</p>
<p>​            在底行模式下输入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">w：保存文件</span><br><span class="line">q：退出文件</span><br><span class="line">wq：保存并且退出</span><br><span class="line">q！：强制不保存退出</span><br><span class="line">x：保存并且退出</span><br></pre></td></tr></table></figure>

<br>

<h4 id="vim文本查找和替换"><a href="#vim文本查找和替换" class="headerlink" title="vim文本查找和替换"></a>vim文本查找和替换</h4><p>在一般模式下，可以执行以下命令。</p>
<ol>
<li>查找<br>pattern  从光标开始处向文件尾搜索pattern，后按下n或N</li>
</ol>
<p>注意：</p>
<blockquote>
<p>n    在同一个方向重复上一次搜索命令<br>N    在反方向重复上一次搜索命令</p>
</blockquote>
<p>注意：<br>在/pattern之前先跳到第一行则进行全文件搜索。</p>
<ol start="2">
<li>替换<blockquote>
<p>:%s/p1/p2/g   //将文件中所有的p1均用p2替换<br>:%s/p1/p2/gc  //替换时需要确认<br>“s“ 全称：substitute替换；<br>“g“ 全称：global全局；<br>“c“ 全称：confirm，确认</p>
</blockquote>
</li>
</ol>
<h3 id="3-、gcc编译工具"><a href="#3-、gcc编译工具" class="headerlink" title="(3)、gcc编译工具"></a>(3)、gcc编译工具</h3><p>​    shell指令：</p>
<p>​        gcc + c文件名</p>
<p>​        编译成功之后会在当前目录下产生一个名为a.out的二进制可执行程序</p>
<p>​            </p>
<p>​       gcc c文件名 -o 新的二进制可执行文件名</p>
<p>​    </p>
<h3 id="4-、执行程序"><a href="#4-、执行程序" class="headerlink" title="(4)、执行程序"></a>(4)、执行程序</h3><p>​    shell命令：</p>
<p>​        ./可执行的二进制文件名</p>
<p>​        </p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析</title>
    <url>/2020/04/27/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><font color="green">概述</font></h1><p>算法分析是关于计算机程序和资源利用的研究</p>
<h2 id><a href="#" class="headerlink" title></a><a id="more"></a></h2><h1 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a><font color="green">数学模型</font></h1><p>大多数程序得到数学模型所需步骤：</p>
<ol>
<li>确定输入模型，定义问题规模（n）</li>
<li>识别循环与递归</li>
<li>根据内循环或每部递归的操作确定成本模型</li>
<li>对于给定的输入，判断这些操作的执行频率</li>
</ol>
<hr>
<h1 id="两种常见讨论情况"><a href="#两种常见讨论情况" class="headerlink" title="两种常见讨论情况"></a><font color="green">两种常见讨论情况</font></h1><blockquote>
<p>最坏情况：T(n)定义为输入规模为 n 时的最长运行时间<br>平均情况：T(n)定义为输入规模为 n 时所有可能输入的期望值(通常是均匀分布时的情况)</p>
</blockquote>
<p>为了不被硬件因素所影响，对算法的分析采用了 <font color="red">渐进分析</font></p>
<blockquote>
<p>渐进分析：</p>
<ol>
<li>忽略依赖于机器性能的常量</li>
<li>只关注运行时间的增长</li>
</ol>
</blockquote>
<hr>
<br>
<br>

<h1 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a><font color="green">渐进符号</font></h1><h2 id="大-O-记号法：-上界"><a href="#大-O-记号法：-上界" class="headerlink" title="大$O$记号法：(上界)"></a>大$O$记号法：(上界)</h2><p>f(n) = $O$(g(n)) 表示存在适当常数 (c&gt;0 $n_0$&gt;0) 使得 0 &lt;= f(n) &lt;= c*g(n) 其中 n &gt;= $n_0$<br><strong>注：这里的=不是等于的意思，更多是指 f(n) 属于 $O$(g(n)) 集合。 即$O$(g(n))是一个函数集，集合内有 f(n)</strong></p>
<blockquote>
<p>例：$2n^2 = O(n^3)$</p>
</blockquote>
<p>宏展开：<br>&nbsp;&nbsp;&nbsp; 当等式左右两边都存在$O$( )时，这时=相当于$\epsilon$</p>
<blockquote>
<p>例：$n^2+O(n) = O(n^2)$ &gt; &nbsp;&nbsp;&nbsp;对于任意 f(n)$\epsilon O(n)$，都有对应的 h(n)$\epsilon O(n)$<br>注：不能反推</p>
</blockquote>
<h2 id="大-Omega-记号法：-下界"><a href="#大-Omega-记号法：-下界" class="headerlink" title="大 $\Omega$记号法：(下界)"></a>大 $\Omega$记号法：(下界)</h2><p>f(n) = $O$(g(n)) 表示存在适当常数 (c&gt;0 $n_0$&gt;0) 使得 0 &lt;= c*g(n) &lt;= f(n) 其中 n &gt;= $n_0$</p>
<blockquote>
<p>例：$\sqrt{n}=\Omega(\lg n)$</p>
</blockquote>
<h2 id="大-Theta-记号法："><a href="#大-Theta-记号法：" class="headerlink" title="大 $\Theta$记号法："></a>大 $\Theta$记号法：</h2><p>$\Theta(g(n)) = O(g(n)) \bigcap \Omega(g(n))$</p>
<p>理解：左右两边增长速率一样</p>
<p>用法：写个公式，去掉它的低阶项，并忽略前面的常数因子(系数)</p>
<h2 id="严格符号："><a href="#严格符号：" class="headerlink" title="严格符号："></a>严格符号：</h2><p>与渐进符号的区别在于：</p>
<ul>
<li>渐进符号表示渐进符号内的函数在经过某一点后便大于或小于原函数</li>
<li>严格符号表示严格符号内的函数是完全大于或小于原函数</li>
</ul>
<h3 id="o-记号"><a href="#o-记号" class="headerlink" title="o 记号"></a>o 记号</h3><p>f(n)完全小于 o(g(n)),与$O$对应</p>
<h3 id="omega-记号"><a href="#omega-记号" class="headerlink" title="$\omega$记号"></a>$\omega$记号</h3><p>f(n)完全大于$\omega$(g(n))，与$O$对应</p>
<hr>
<br>
<br>

<h1 id="递归式的三种解法"><a href="#递归式的三种解法" class="headerlink" title="递归式的三种解法"></a><font color="green">递归式的三种解法</font></h1><h2 id="补充知识：数学归纳法"><a href="#补充知识：数学归纳法" class="headerlink" title="补充知识：数学归纳法"></a>补充知识：数学归纳法</h2><p>用来证明一个命题在问题规模为 n 时成立</p>
<ol>
<li>证明 n=1 时成立</li>
<li>假设 n=n-1 时成立，如求出(n-1)+1 时成立</li>
<li>则命题成立</li>
</ol>
<h2 id="1-代换法"><a href="#1-代换法" class="headerlink" title="1. 代换法"></a>1. 代换法</h2><ol>
<li>先猜答案得到最高阶</li>
<li>验证这个递归式是否按照数学归纳法满足条件</li>
</ol>
<blockquote>
<p>例：T(n)=4T(n/2)+n</p>
<ol>
<li>(猜)忽略常数 n，由 T(n)=4T(n/2) 可看出当 n 减 2 倍，系数增加 4 倍。$n^2$符合这一标准,假定 T(n)=$O(n^2)$</li>
<li>(证)将递归式展开得 T(n)=$4T(n/2)+n$ &lt;= $cn^2$+n = $cn^2$-(-n)<blockquote>
<p>$O(n^2)$=$c(n)^2$</p>
</blockquote>
</li>
<li>因为要证明的是 T(n)=$O(n^2)$ 所以 T(n) &lt;= $cn^2$-(-n) 中(-n)大于等于 0</li>
</ol>
</blockquote>
<p>但这里发现了因为 n&gt;=1 所以上式不成立。是我们做错了吗，让我们想想有什么办法可以改变这个常数。<br>当我们对 $O(n^2)$ 进行展开时，我们是忽略了常数项的，因为它对 n 为无穷大时作用很小，但作用小就表明还是有一定的作用，我们试着把常数项带进来，即改进 T(n)=$O(n^2)$ 时的条件</p>
<blockquote>
<p>改进：<br>T(n) =$O(n^2)$ &lt;=$c_1n^2-c_2n$ (多了常数项)<br>T(n)=$4T(n/2)+n$ &lt;= $4(c_1(n/2)^2-c_2(n/2))+n=c_1n^2-c_2n-(c_2-1)n$<br>要使 T(n)=$O(n^2)$则要满足$(c_2-1)n$ &gt;= 0 (当$c_2$ &gt;= 1 时成立)<br>并且 T(1) &lt;=$c_1-c_2$ 成立<br>可以得出 T(n+1) &lt;= $c_1(n+1)^2-c_2(n+1)$ (当$c_1&gt;&gt;c_2$时成立)(算一下就出来了)<br>这时条件 T(1)，T(n)和 T(1)推出 T(n+1)都有了<br>最后得出 T(n) = $O(n^2)$</p>
</blockquote>
<h2 id="2-递归树法"><a href="#2-递归树法" class="headerlink" title="2. 递归树法"></a>2. 递归树法</h2><ol>
<li>将递归式按树的形式展开(不用全画出来)(并且每次递归时 n 的和都要减少而不是增大)</li>
<li>根据每层的和的规律，求出总子叶节点<ul>
<li>如果每层和一样，用每层的和乘以树的高度就行<blockquote>
<p>树要对称，高用每次递归式减少的数(每层为等差)或除以的数(每层为等比)来求<br>等差的话 h=n-k+1 (k 为每层 n 减少的数)<br>等比的话 h=$log_kn$ (k 为每层 n 除的数)</p>
</blockquote>
</li>
<li>如果树不对称或者每层和成等比排列，不用求具体值，都是有规律相加的，求其上界就行</li>
</ul>
</li>
<li>判断总子叶节点小于等于某个相近的值，便可求出其最高阶</li>
</ol>
<p>例：<br><img src="https://cdn.jsdelivr.net/gh/oyama-mahiro/ImageHosting/img/diGuiShuFa.jpg" alt="递归树"></p>
<h2 id="3-主方法"><a href="#3-主方法" class="headerlink" title="3.主方法"></a>3.主方法</h2><p>相当于套公式，且适用情况少<br>原理是递归树，可以自己去推导下,这三个主要区别是总子叶节点数的判断不同。（1 是因为每层和在增加，最后一层和占主导。2 是因为每层和一样，和乘以高。3 是因为每层和在减少，第一层和占主导）<br>限制：递归式要满足于 $T(n)=aT(n/b)+f(n)$ &nbsp;&nbsp;&nbsp;a&gt;=1,b&gt;1,f(n)渐进趋正<br>主思路：比较 f(n)和$n^{\log_ba}$</p>
<p>1.</p>
<p>若对某个常数 $\varepsilon&gt;0有$<br>$f(n)= \omicron (n^{\log_b{a-\varepsilon} })$<br>那么<br>$T(n)= \theta (n^{log_ba})$</p>
<p>2.</p>
<p>若<br>$f(n)=\theta(n^{log_ba})f(n)$<br>则<br>$T(n)=\theta(n^{log_ba}\lg n)T(n)$</p>
<p>3.</p>
<p>若对某个常数 $\varepsilon&gt;0有$<br>$f(n) = \Omega(n^{\log_b{a+\varepsilon} })f(n)$<br>且对于某个常数 c&lt;1 和所有足够大的 n 有<br>$af(\frac nb)\le cf(n)$<br>则<br>$T(n)=\theta(f(n))T(n)$</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>算法</tag>
        <tag>概念</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
</search>
